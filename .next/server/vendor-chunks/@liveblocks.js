"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@liveblocks";
exports.ids = ["vendor-chunks/@liveblocks"];
exports.modules = {

/***/ "(ssr)/./node_modules/@liveblocks/core/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   DefaultMap: () => (/* binding */ DefaultMap),\n/* harmony export */   DerivedSignal: () => (/* binding */ DerivedSignal),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   LiveblocksError: () => (/* binding */ LiveblocksError),\n/* harmony export */   MutableSignal: () => (/* binding */ MutableSignal),\n/* harmony export */   NotificationsApiError: () => (/* binding */ NotificationsApiError),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   Permission: () => (/* binding */ Permission),\n/* harmony export */   Promise_withResolvers: () => (/* binding */ Promise_withResolvers),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   Signal: () => (/* binding */ Signal),\n/* harmony export */   SortedList: () => (/* binding */ SortedList),\n/* harmony export */   TextEditorType: () => (/* binding */ TextEditorType),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   autoRetry: () => (/* binding */ autoRetry),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   compactObject: () => (/* binding */ compactObject),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToInboxNotificationData: () => (/* binding */ convertToInboxNotificationData),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   createCommentAttachmentId: () => (/* binding */ createCommentAttachmentId),\n/* harmony export */   createCommentId: () => (/* binding */ createCommentId),\n/* harmony export */   createInboxNotificationId: () => (/* binding */ createInboxNotificationId),\n/* harmony export */   createThreadId: () => (/* binding */ createThreadId),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   entries: () => (/* binding */ entries),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   generateCommentUrl: () => (/* binding */ generateCommentUrl),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   html: () => (/* binding */ html),\n/* harmony export */   htmlSafe: () => (/* binding */ htmlSafe),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isCommentBodyLink: () => (/* binding */ isCommentBodyLink),\n/* harmony export */   isCommentBodyMention: () => (/* binding */ isCommentBodyMention),\n/* harmony export */   isCommentBodyText: () => (/* binding */ isCommentBodyText),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isNotificationChannelEnabled: () => (/* binding */ isNotificationChannelEnabled),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   isStartsWithOperator: () => (/* binding */ isStartsWithOperator),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   mapValues: () => (/* binding */ mapValues),\n/* harmony export */   memoizeOnSuccess: () => (/* binding */ memoizeOnSuccess),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   objectToQuery: () => (/* binding */ objectToQuery),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   resolveUsersInCommentBody: () => (/* binding */ resolveUsersInCommentBody),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stableStringify: () => (/* binding */ stableStringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toAbsoluteUrl: () => (/* binding */ toAbsoluteUrl),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   urljoin: () => (/* binding */ urljoin),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"2.19.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/guards.ts\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction isStartsWithOperator(blob) {\n  return isPlainObject(blob) && typeof blob.startsWith === \"string\";\n}\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction keys(obj) {\n  return Object.keys(obj);\n}\nfunction values(obj) {\n  return Object.values(obj);\n}\nfunction mapValues(obj, mapFn) {\n  const result = {};\n  for (const pair of Object.entries(obj)) {\n    const key = pair[0];\n    if (key === \"__proto__\") {\n      continue;\n    }\n    const value = pair[1];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n// src/lib/autoRetry.ts\nvar HttpError = class _HttpError extends Error {\n  response;\n  details;\n  constructor(message, response, details) {\n    super(message);\n    this.name = \"HttpError\";\n    this.response = response;\n    this.details = details;\n  }\n  static async fromResponse(response) {\n    let bodyAsText;\n    try {\n      bodyAsText = await response.text();\n    } catch {\n    }\n    const bodyAsJson = bodyAsText ? tryParseJson(bodyAsText) : void 0;\n    let bodyAsJsonObject;\n    if (isPlainObject(bodyAsJson)) {\n      bodyAsJsonObject = bodyAsJson;\n    }\n    let message = \"\";\n    message ||= typeof bodyAsJsonObject?.message === \"string\" ? bodyAsJsonObject.message : \"\";\n    message ||= typeof bodyAsJsonObject?.error === \"string\" ? bodyAsJsonObject.error : \"\";\n    if (bodyAsJson === void 0) {\n      message ||= bodyAsText || \"\";\n    }\n    message ||= response.statusText;\n    let path;\n    try {\n      path = new URL(response.url).pathname;\n    } catch {\n    }\n    message += path !== void 0 ? ` (got status ${response.status} from ${path})` : ` (got status ${response.status})`;\n    const details = bodyAsJsonObject;\n    return new _HttpError(message, response, details);\n  }\n  /**\n   * Convenience accessor for response.status.\n   */\n  get status() {\n    return this.response.status;\n  }\n};\nvar DONT_RETRY_4XX = (x) => x instanceof HttpError && x.status >= 400 && x.status < 500;\nasync function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n  let attempt = 0;\n  while (true) {\n    attempt++;\n    try {\n      return await promiseFn();\n    } catch (err) {\n      if (shouldStopRetrying(err)) {\n        throw err;\n      }\n      if (attempt >= maxTries) {\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n    warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _observers = /* @__PURE__ */ new Set();\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    const unsub = subscribe((event) => {\n      unsub();\n      return callback(event);\n    });\n    return unsub;\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notify(event) {\n    let called = false;\n    for (const callback of _observers) {\n      callback(event);\n      called = true;\n    }\n    return called;\n  }\n  function count() {\n    return _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify,\n    subscribe,\n    subscribeOnce,\n    count,\n    waitUntil,\n    [Symbol.dispose]: () => {\n      _observers.clear();\n    },\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\nfunction makeBufferableEventSource() {\n  const eventSource2 = makeEventSource();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      eventSource2.notify(event);\n    }\n    _buffer = null;\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n      return false;\n    } else {\n      return eventSource2.notify(event);\n    }\n  }\n  return {\n    ...eventSource2,\n    notify: notifyOrBuffer,\n    pause,\n    unpause,\n    [Symbol.dispose]: () => {\n      eventSource2[Symbol.dispose]();\n      if (_buffer !== null) {\n        _buffer.length = 0;\n      }\n    }\n  };\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/lib/signals.ts\nvar kSinks = Symbol(\"kSinks\");\nvar kTrigger = Symbol(\"kTrigger\");\nvar signalsToTrigger = null;\nvar trackedReads = null;\nfunction batch(callback) {\n  if (signalsToTrigger !== null) {\n    callback();\n    return;\n  }\n  signalsToTrigger = /* @__PURE__ */ new Set();\n  try {\n    callback();\n  } finally {\n    for (const signal of signalsToTrigger) {\n      signal[kTrigger]();\n    }\n    signalsToTrigger = null;\n  }\n}\nfunction enqueueTrigger(signal) {\n  if (!signalsToTrigger) raise(\"Expected to be in an active batch\");\n  signalsToTrigger.add(signal);\n}\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar AbstractSignal = class {\n  /** @internal */\n  equals;\n  #eventSource;\n  /** @internal */\n  [kSinks];\n  constructor(equals) {\n    this.equals = equals ?? Object.is;\n    this.#eventSource = makeEventSource();\n    this[kSinks] = /* @__PURE__ */ new Set();\n    this.get = this.get.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.subscribeOnce = this.subscribeOnce.bind(this);\n  }\n  [Symbol.dispose]() {\n    this.#eventSource[Symbol.dispose]();\n    this.#eventSource = \"(disposed)\";\n    this.equals = \"(disposed)\";\n  }\n  get hasWatchers() {\n    if (this.#eventSource.count() > 0) return true;\n    for (const sink of this[kSinks]) {\n      if (sink.hasWatchers) {\n        return true;\n      }\n    }\n    return false;\n  }\n  [kTrigger]() {\n    this.#eventSource.notify();\n    for (const sink of this[kSinks]) {\n      enqueueTrigger(sink);\n    }\n  }\n  subscribe(callback) {\n    if (this.#eventSource.count() === 0) {\n      this.get();\n    }\n    return this.#eventSource.subscribe(callback);\n  }\n  subscribeOnce(callback) {\n    const unsub = this.subscribe(() => {\n      unsub();\n      return callback();\n    });\n    return unsub;\n  }\n  waitUntil() {\n    throw new Error(\"waitUntil not supported on Signals\");\n  }\n  markSinksDirty() {\n    for (const sink of this[kSinks]) {\n      sink.markDirty();\n    }\n  }\n  addSink(sink) {\n    this[kSinks].add(sink);\n  }\n  removeSink(sink) {\n    this[kSinks].delete(sink);\n  }\n  asReadonly() {\n    return this;\n  }\n};\nvar Signal = class extends AbstractSignal {\n  #value;\n  constructor(value, equals) {\n    super(equals);\n    this.#value = freeze(value);\n  }\n  [Symbol.dispose]() {\n    super[Symbol.dispose]();\n    this.#value = \"(disposed)\";\n  }\n  get() {\n    trackedReads?.add(this);\n    return this.#value;\n  }\n  set(newValue) {\n    batch(() => {\n      if (typeof newValue === \"function\") {\n        newValue = newValue(this.#value);\n      }\n      if (!this.equals(this.#value, newValue)) {\n        this.#value = freeze(newValue);\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n};\nvar PatchableSignal = class extends Signal {\n  constructor(data) {\n    super(freeze(compactObject(data)));\n  }\n  set() {\n    throw new Error(\"Don't call .set() directly, use .patch()\");\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    super.set((old) => merge(old, patch));\n  }\n};\nvar INITIAL = Symbol();\nvar DerivedSignal = class _DerivedSignal extends AbstractSignal {\n  #prevValue;\n  #dirty;\n  // When true, the value in #value may not be up-to-date and needs re-checking\n  #sources;\n  #deps;\n  #transform;\n  // prettier-ignore\n  static from(...args) {\n    const last = args.pop();\n    if (typeof last !== \"function\")\n      raise(\"Invalid .from() call, last argument expected to be a function\");\n    if (typeof args[args.length - 1] === \"function\") {\n      const equals = last;\n      const transform = args.pop();\n      return new _DerivedSignal(args, transform, equals);\n    } else {\n      const transform = last;\n      return new _DerivedSignal(args, transform);\n    }\n  }\n  constructor(deps, transform, equals) {\n    super(equals);\n    this.#dirty = true;\n    this.#prevValue = INITIAL;\n    this.#deps = deps;\n    this.#sources = /* @__PURE__ */ new Set();\n    this.#transform = transform;\n  }\n  [Symbol.dispose]() {\n    for (const src of this.#sources) {\n      src.removeSink(this);\n    }\n    this.#prevValue = \"(disposed)\";\n    this.#sources = \"(disposed)\";\n    this.#deps = \"(disposed)\";\n    this.#transform = \"(disposed)\";\n  }\n  get isDirty() {\n    return this.#dirty;\n  }\n  #recompute() {\n    const oldTrackedReads = trackedReads;\n    let derived;\n    trackedReads = /* @__PURE__ */ new Set();\n    try {\n      derived = this.#transform(...this.#deps.map((p) => p.get()));\n    } finally {\n      const oldSources = this.#sources;\n      this.#sources = /* @__PURE__ */ new Set();\n      for (const sig of trackedReads) {\n        this.#sources.add(sig);\n        oldSources.delete(sig);\n      }\n      for (const oldSource of oldSources) {\n        oldSource.removeSink(this);\n      }\n      for (const newSource of this.#sources) {\n        newSource.addSink(this);\n      }\n      trackedReads = oldTrackedReads;\n    }\n    this.#dirty = false;\n    if (!this.equals(this.#prevValue, derived)) {\n      this.#prevValue = derived;\n      return true;\n    }\n    return false;\n  }\n  markDirty() {\n    if (!this.#dirty) {\n      this.#dirty = true;\n      this.markSinksDirty();\n    }\n  }\n  get() {\n    if (this.#dirty) {\n      this.#recompute();\n    }\n    trackedReads?.add(this);\n    return this.#prevValue;\n  }\n  /**\n   * Called by the Signal system if one or more of the dependent signals have\n   * changed. In the case of a DerivedSignal, we'll only want to re-evaluate\n   * the actual value if it's being watched, or any of their sinks are being\n   * watched actively.\n   */\n  [kTrigger]() {\n    if (!this.hasWatchers) {\n      return;\n    }\n    const updated = this.#recompute();\n    if (updated) {\n      super[kTrigger]();\n    }\n  }\n};\nvar MutableSignal = class extends AbstractSignal {\n  #state;\n  constructor(initialState) {\n    super();\n    this.#state = initialState;\n  }\n  [Symbol.dispose]() {\n    super[Symbol.dispose]();\n    this.#state = \"(disposed)\";\n  }\n  get() {\n    trackedReads?.add(this);\n    return this.#state;\n  }\n  /**\n   * Invokes a callback function that is allowed to mutate the given state\n   * value. Do not change the value outside of the callback.\n   *\n   * If the callback explicitly returns `false`, it's assumed that the state\n   * was not changed.\n   */\n  mutate(callback) {\n    batch(() => {\n      const result = callback ? callback(this.#state) : true;\n      if (result !== null && typeof result === \"object\" && \"then\" in result) {\n        raise(\"MutableSignal.mutate() does not support async callbacks\");\n      }\n      if (result !== false) {\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n};\n\n// src/lib/stringify.ts\nfunction replacer(_key, value) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value) ? Object.keys(value).sort().reduce((sorted, key) => {\n    sorted[key] = value[key];\n    return sorted;\n  }, {}) : value;\n}\nfunction stableStringify(value) {\n  return JSON.stringify(value, replacer);\n}\nfunction stringifyOrLog(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (err) {\n    console.error(`Could not stringify: ${err.message}`);\n    console.error(value);\n    throw err;\n  }\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  input;\n  resolve;\n  reject;\n  promise;\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  #queue = [];\n  #callback;\n  #size;\n  #delay;\n  #delayTimeoutId;\n  error = false;\n  constructor(callback, options) {\n    this.#callback = callback;\n    this.#size = options.size ?? DEFAULT_SIZE;\n    this.#delay = options.delay;\n  }\n  #clearDelayTimeout() {\n    if (this.#delayTimeoutId !== void 0) {\n      clearTimeout(this.#delayTimeoutId);\n      this.#delayTimeoutId = void 0;\n    }\n  }\n  #schedule() {\n    if (this.#queue.length === this.#size) {\n      void this.#flush();\n    } else if (this.#queue.length === 1) {\n      this.#clearDelayTimeout();\n      this.#delayTimeoutId = setTimeout(() => void this.#flush(), this.#delay);\n    }\n  }\n  async #flush() {\n    if (this.#queue.length === 0) {\n      return;\n    }\n    const calls = this.#queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.#callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.#queue.find(\n      (call2) => stableStringify(call2.input) === stableStringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.#queue.push(call);\n    this.#schedule();\n    return call.promise;\n  }\n  clear() {\n    this.#queue = [];\n    this.error = false;\n    this.#clearDelayTimeout();\n  }\n};\nfunction createBatchStore(batch2) {\n  const signal = new MutableSignal(/* @__PURE__ */ new Map());\n  function getCacheKey(args) {\n    return stableStringify(args);\n  }\n  function update(cacheKey, state) {\n    signal.mutate((cache) => {\n      cache.set(cacheKey, state);\n    });\n  }\n  function invalidate(inputs) {\n    signal.mutate((cache) => {\n      if (Array.isArray(inputs)) {\n        for (const input of inputs) {\n          cache.delete(getCacheKey(input));\n        }\n      } else {\n        cache.clear();\n      }\n    });\n  }\n  async function enqueue(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      update(cacheKey, { isLoading: true });\n      const result = await batch2.get(input);\n      update(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      update(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getItemState(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey);\n  }\n  function _cacheKeys() {\n    const cache = signal.get();\n    return [...cache.keys()];\n  }\n  return {\n    subscribe: signal.subscribe,\n    enqueue,\n    getItemState,\n    invalidate,\n    batch: batch2,\n    _cacheKeys\n  };\n}\n\n// src/lib/chunk.ts\nfunction chunk(array, size) {\n  const chunks = [];\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n// src/lib/nanoid.ts\nvar nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(\n  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? \"_\" : \"-\",\n  \"\"\n);\n\n// src/lib/createIds.ts\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nvar INBOX_NOTIFICATION_ID_PREFIX = \"in\";\nfunction createOptimisticId(prefix) {\n  return `${prefix}_${nanoid()}`;\n}\nfunction createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction createCommentAttachmentId() {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\nfunction createInboxNotificationId() {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n\n// src/lib/DefaultMap.ts\nvar DefaultMap = class extends Map {\n  #defaultFn;\n  /**\n   * If the default function is not provided to the constructor, it has to be\n   * provided in each .getOrCreate() call individually.\n   */\n  constructor(defaultFn, entries2) {\n    super(entries2);\n    this.#defaultFn = defaultFn;\n  }\n  /**\n   * Gets the value at the given key, or creates it.\n   *\n   * Difference from normal Map: if the key does not exist, it will be created\n   * on the fly using the factory function, and that value will get returned\n   * instead of `undefined`.\n   */\n  getOrCreate(key, defaultFn) {\n    if (super.has(key)) {\n      return super.get(key);\n    } else {\n      const fn = defaultFn ?? this.#defaultFn ?? raise(\"DefaultMap used without a factory function\");\n      const value = fn(key);\n      this.set(key, value);\n      return value;\n    }\n  }\n};\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isPlainObject(value)) {\n      if (isStartsWithOperator(value)) {\n        keyValuePairsWithOperator.push([key, value]);\n      } else {\n        indexedKeys.push([key, value]);\n      }\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isStartsWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(({ key, operator, value }) => `${key}${operator}${quote(value)}`).join(\" \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  return typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || value === null;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${quote(nestedKey)}]`;\n  }\n  return key;\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\nfunction quote(input) {\n  const result = JSON.stringify(input);\n  if (typeof input !== \"string\") {\n    return result;\n  }\n  if (result.includes(\"'\")) {\n    return result;\n  }\n  return `'${result.slice(1, -1).replace(/\\\\\"/g, '\"')}'`;\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url2 = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url2.toString();\n}\nfunction url(strings, ...values2) {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values2[i - 1] ?? \"\") + str\n  );\n}\n\n// src/api-client.ts\nfunction createApiClient({\n  baseUrl,\n  authManager,\n  fetchPolyfill\n}) {\n  const httpClient = new HttpClient(baseUrl, fetchPolyfill);\n  async function getThreadsSince(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/threads/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        since: options.since.toISOString()\n      },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: result.data.map(convertToThreadData),\n        deleted: result.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: result.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: result.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(result.meta.requestedAt),\n      permissionHints: result.meta.permissionHints\n    };\n  }\n  async function getThreads(options) {\n    let query;\n    if (options.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    try {\n      const result = await httpClient.get(\n        url`/v2/c/rooms/${options.roomId}/threads`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\",\n          roomId: options.roomId\n        }),\n        {\n          cursor: options.cursor,\n          query,\n          limit: PAGE_SIZE\n        }\n      );\n      return {\n        threads: result.data.map(convertToThreadData),\n        inboxNotifications: result.inboxNotifications.map(\n          convertToInboxNotificationData\n        ),\n        nextCursor: result.meta.nextCursor,\n        requestedAt: new Date(result.meta.requestedAt),\n        permissionHints: result.meta.permissionHints\n      };\n    } catch (err) {\n      if (err instanceof HttpError && err.status === 404) {\n        return {\n          threads: [],\n          inboxNotifications: [],\n          nextCursor: null,\n          //\n          // HACK\n          // requestedAt needs to be a *server* timestamp here. However, on\n          // this 404 error response, there is no such timestamp. So out of\n          // pure necessity we'll fall back to a local timestamp instead (and\n          // allow for a possible 6 hour clock difference between client and\n          // server).\n          //\n          requestedAt: new Date(Date.now() - 6 * 60 * 60 * 1e3),\n          permissionHints: {}\n        };\n      }\n      throw err;\n    }\n  }\n  async function createThread(options) {\n    const commentId = options.commentId ?? createCommentId();\n    const threadId = options.threadId ?? createThreadId();\n    const thread = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        id: threadId,\n        comment: {\n          id: commentId,\n          body: options.body,\n          attachmentIds: options.attachmentIds\n        },\n        metadata: options.metadata\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function deleteThread(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function getThread(options) {\n    const response = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/thread-with-notification/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: void 0,\n        inboxNotification: void 0\n      };\n    } else {\n      throw new Error(\n        `There was an error while getting thread ${options.threadId}.`\n      );\n    }\n  }\n  async function editThreadMetadata(options) {\n    return await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.metadata\n    );\n  }\n  async function createComment(options) {\n    const commentId = options.commentId ?? createCommentId();\n    const comment = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        id: commentId,\n        body: options.body,\n        attachmentIds: options.attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment(options) {\n    const comment = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        body: options.body,\n        attachmentIds: options.attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function addReaction(options) {\n    const reaction = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      { emoji: options.emoji }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function markThreadAsResolved(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-resolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function markThreadAsUnresolved(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-unresolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function uploadAttachment(options) {\n    const roomId = options.roomId;\n    const abortSignal = options.signal;\n    const attachment = options.attachment;\n    const abortError = abortSignal ? new DOMException(\n      `Upload of attachment ${options.attachment.id} was aborted.`,\n      \"AbortError\"\n    ) : void 0;\n    if (abortSignal?.aborted) {\n      throw abortError;\n    }\n    const handleRetryError = (err) => {\n      if (abortSignal?.aborted) {\n        throw abortError;\n      }\n      if (err instanceof HttpError && err.status === 413) {\n        throw err;\n      }\n      return false;\n    };\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\n    const RETRY_ATTEMPTS = 10;\n    const RETRY_DELAYS = [\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3\n    ];\n    function splitFileIntoParts(file) {\n      const parts = [];\n      let start = 0;\n      while (start < file.size) {\n        const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n        parts.push({\n          partNumber: parts.length + 1,\n          part: file.slice(start, end)\n        });\n        start = end;\n      }\n      return parts;\n    }\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      return autoRetry(\n        async () => httpClient.putBlob(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          attachment.file,\n          { fileSize: attachment.size },\n          { signal: abortSignal }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      let uploadId;\n      const uploadedParts = [];\n      const createMultiPartUpload = await autoRetry(\n        async () => httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          void 0,\n          { signal: abortSignal },\n          { fileSize: attachment.size }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n        const parts = splitFileIntoParts(attachment.file);\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const batches = chunk(parts, 5);\n        for (const parts2 of batches) {\n          const uploadedPartsPromises = [];\n          for (const { part, partNumber } of parts2) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                async () => httpClient.putBlob(\n                  url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                  await authManager.getAuthValue({\n                    requestedScope: \"comments:read\",\n                    roomId\n                  }),\n                  part,\n                  void 0,\n                  { signal: abortSignal }\n                ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n          uploadedParts.push(...await Promise.all(uploadedPartsPromises));\n        }\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n        return httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { parts: sortedUploadedParts },\n          { signal: abortSignal }\n        );\n      } catch (error3) {\n        if (uploadId && error3?.name && (error3.name === \"AbortError\" || error3.name === \"TimeoutError\")) {\n          try {\n            await httpClient.rawDelete(\n              url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}`,\n              await authManager.getAuthValue({\n                requestedScope: \"comments:read\",\n                roomId\n              })\n            );\n          } catch (error4) {\n          }\n        }\n        throw error3;\n      }\n    }\n  }\n  const attachmentUrlsBatchStoresByRoom = new DefaultMap((roomId) => {\n    const batch2 = new Batch(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { attachmentIds }\n        );\n        return urls.map(\n          (url2) => url2 ?? new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch2);\n  });\n  function getOrCreateAttachmentUrlsStore(roomId) {\n    return attachmentUrlsBatchStoresByRoom.getOrCreate(roomId);\n  }\n  function getAttachmentUrl(options) {\n    const batch2 = getOrCreateAttachmentUrlsStore(options.roomId).batch;\n    return batch2.get(options.attachmentId);\n  }\n  async function getNotificationSettings(options) {\n    return httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/notification-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      void 0,\n      {\n        signal: options.signal\n      }\n    );\n  }\n  async function updateNotificationSettings(options) {\n    return httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/notification-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.settings\n    );\n  }\n  const markAsReadBatchesByRoom = new DefaultMap(\n    (roomId) => new Batch(\n      async (batchedInboxNotificationIds) => {\n        const inboxNotificationIds = batchedInboxNotificationIds.flat();\n        await httpClient.post(\n          url`/v2/c/rooms/${roomId}/inbox-notifications/read`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { inboxNotificationIds }\n        );\n        return inboxNotificationIds;\n      },\n      { delay: 50 }\n    )\n  );\n  async function markRoomInboxNotificationAsRead(options) {\n    const batch2 = markAsReadBatchesByRoom.getOrCreate(options.roomId);\n    return batch2.get(options.inboxNotificationId);\n  }\n  async function createTextMention(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-mentions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        userId: options.userId,\n        mentionId: options.mentionId\n      }\n    );\n  }\n  async function deleteTextMention(options) {\n    await httpClient.rawDelete(\n      url`/v2/c/rooms/${options.roomId}/text-mentions/${options.mentionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function getTextVersion(options) {\n    return httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/y-version/${options.versionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function createTextVersion(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/version`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function reportTextEditor(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        type: options.type,\n        rootKey: options.rootKey\n      }\n    );\n  }\n  async function executeContextualPrompt(options) {\n    const result = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/ai/contextual-prompt`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      }),\n      {\n        prompt: options.prompt,\n        context: {\n          beforeSelection: options.context.beforeSelection,\n          selection: options.context.selection,\n          afterSelection: options.context.afterSelection\n        },\n        previous: options.previous\n      },\n      { signal: options.signal }\n    );\n    if (!result || result.content.length === 0) {\n      throw new Error(\"No content returned from server\");\n    }\n    return result.content[0].text;\n  }\n  async function listTextVersions(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/versions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function listTextVersionsSince(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/versions/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function streamStorage(options) {\n    const result = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/storage`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      })\n    );\n    return await result.json();\n  }\n  async function sendMessages(options) {\n    return httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/send-message`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      }),\n      {\n        nonce: options.nonce,\n        messages: options.messages\n      }\n    );\n  }\n  async function getInboxNotifications(options) {\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        limit: PAGE_SIZE\n      }\n    );\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getInboxNotificationsSince(options) {\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await httpClient.get(\n      url`/v2/c/inbox-notifications/count`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds: \"all\"\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds\n      }\n    );\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications/${inboxNotificationId}`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n  async function getUserNotificationSettings(options) {\n    return httpClient.get(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      void 0,\n      { signal: options?.signal }\n    );\n  }\n  async function updateUserNotificationSettings(settings) {\n    return httpClient.post(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      settings\n    );\n  }\n  async function getUserThreads_experimental(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(\n      url`/v2/c/threads`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        query,\n        limit: PAGE_SIZE\n      }\n    );\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints\n    };\n  }\n  async function getUserThreadsSince_experimental(options) {\n    const json = await httpClient.get(\n      url`/v2/c/threads/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints\n    };\n  }\n  return {\n    // Room threads\n    getThreads,\n    getThreadsSince,\n    createThread,\n    getThread,\n    deleteThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment,\n    addReaction,\n    removeReaction,\n    markThreadAsResolved,\n    markThreadAsUnresolved,\n    markRoomInboxNotificationAsRead,\n    // Room notifications\n    getNotificationSettings,\n    updateNotificationSettings,\n    // Room text editor\n    createTextMention,\n    deleteTextMention,\n    getTextVersion,\n    createTextVersion,\n    reportTextEditor,\n    listTextVersions,\n    listTextVersionsSince,\n    // Room attachments\n    getAttachmentUrl,\n    uploadAttachment,\n    getOrCreateAttachmentUrlsStore,\n    // Room storage\n    streamStorage,\n    sendMessages,\n    // Notification\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    getUserNotificationSettings,\n    updateUserNotificationSettings,\n    // User threads\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental,\n    // AI\n    executeContextualPrompt\n  };\n}\nfunction getBearerTokenFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nvar HttpClient = class {\n  #baseUrl;\n  #fetchPolyfill;\n  constructor(baseUrl, fetchPolyfill) {\n    this.#baseUrl = baseUrl;\n    this.#fetchPolyfill = fetchPolyfill;\n  }\n  // ------------------------------------------------------------------\n  // Public methods\n  // ------------------------------------------------------------------\n  /**\n   * Constructs and makes the HTTP request, but does not handle the response.\n   *\n   * This is what .rawFetch() does:    👈 This method!\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails\n   *   6. Throw HttpError if response is an error\n   */\n  async #rawFetch(endpoint, authValue, options, params) {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"This client can only be used to make /v2/c/* requests\");\n    }\n    const url2 = urljoin(this.#baseUrl, endpoint, params);\n    return await this.#fetchPolyfill(url2, {\n      ...options,\n      headers: {\n        // These headers are default, but can be overriden by custom headers\n        \"Content-Type\": \"application/json; charset=utf-8\",\n        // Possible header overrides\n        ...options?.headers,\n        // Cannot be overriden by custom headers\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\"\n      }\n    });\n  }\n  /**\n   * Constructs, makes the HTTP request, and handles the response by parsing\n   * JSON and/or throwing an HttpError if it failed.\n   *\n   * This is what .rawFetch() does:\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:   👈 This method!\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails (🤔)\n   *   6. Throw HttpError if response is an error\n   */\n  async #fetch(endpoint, authValue, options, params) {\n    const response = await this.#rawFetch(endpoint, authValue, options, params);\n    if (!response.ok) {\n      throw await HttpError.fromResponse(response);\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  /**\n   * Makes a GET request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .get() instead.\n   */\n  async rawGet(endpoint, authValue, params, options) {\n    return await this.#rawFetch(endpoint, authValue, options, params);\n  }\n  /**\n   * Makes a POST request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .post() instead.\n   */\n  async rawPost(endpoint, authValue, body) {\n    return await this.#rawFetch(endpoint, authValue, {\n      method: \"POST\",\n      body: stringifyOrLog(body)\n    });\n  }\n  /**\n   * Makes a DELETE request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .delete() instead.\n   */\n  async rawDelete(endpoint, authValue) {\n    return await this.#rawFetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a GET request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async get(endpoint, authValue, params, options) {\n    return await this.#fetch(endpoint, authValue, options, params);\n  }\n  /**\n   * Makes a POST request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async post(endpoint, authValue, body, options, params) {\n    return await this.#fetch(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"POST\",\n        body: stringifyOrLog(body)\n      },\n      params\n    );\n  }\n  /**\n   * Makes a DELETE request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async delete(endpoint, authValue) {\n    return await this.#fetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a PUT request for a Blob body, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async putBlob(endpoint, authValue, blob, params, options) {\n    return await this.#fetch(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/octet-stream\"\n        },\n        body: blob\n      },\n      params\n    );\n  }\n};\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  #curr;\n  constructor(initialContext) {\n    this.#curr = initialContext;\n  }\n  get current() {\n    return this.#curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.#curr,\n      patch(patch) {\n        if (allowed) {\n          self.#curr = Object.assign({}, self.#curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  id;\n  // Indicates whether this state machine is still being configured, has\n  // started, or has terminated\n  #runningState;\n  #currentContext;\n  #states;\n  #currentStateOrNull;\n  #allowedTransitions;\n  #eventHub;\n  events;\n  //\n  // The cleanup stack is a stack of (optional) callback functions that will\n  // be run when exiting the current state. If a state (or state group) does\n  // not have an exit handler, then the entry for that level may be\n  // `undefined`, but there will be an explicit entry in the stack for it.\n  //\n  // This will always be true:\n  //\n  //   cleanupStack.length == currentState.split('.').length + 1\n  //\n  // Each stack level represents a different state \"group\".\n  //\n  // For example, if you are in a state named `foo.bar.qux`, then the stack\n  // will contain the exit handler for `foo.bar.qux` (at the top), then\n  // `foo.bar.*`, then `foo.*`, and finally, `*`.\n  //\n  #cleanupStack;\n  #enterFns;\n  // Used to provide better error messages\n  #knownEventTypes;\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get #initialState() {\n    const result = this.#states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.#currentStateOrNull === null) {\n      if (this.#runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.#currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.#runningState = 1 /* STARTED */;\n    this.#currentStateOrNull = this.#initialState;\n    this.#enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.#runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.#exit(null);\n    this.#runningState = 2 /* STOPPED */;\n    this.#currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.#runningState = 0 /* NOT_STARTED_YET */;\n    this.#currentStateOrNull = null;\n    this.#states = /* @__PURE__ */ new Set();\n    this.#enterFns = /* @__PURE__ */ new Map();\n    this.#cleanupStack = [];\n    this.#knownEventTypes = /* @__PURE__ */ new Set();\n    this.#allowedTransitions = /* @__PURE__ */ new Map();\n    this.#currentContext = new SafeContext(initialContext);\n    this.#eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.#eventHub.didReceiveEvent.observable,\n      willTransition: this.#eventHub.willTransition.observable,\n      didIgnoreEvent: this.#eventHub.didIgnoreEvent.observable,\n      willExitState: this.#eventHub.willExitState.observable,\n      didEnterState: this.#eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.#currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.#states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.#enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.#enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  /**\n   * Defines a promise-based state. When the state is entered, the promise is\n   * created. When the promise resolves, the machine will transition to the\n   * provided `onOK` target state. When the promise rejects, the machine will\n   * transition to the `onError` target state.\n   *\n   * Optionally, a `maxTimeout` can be set. If the timeout happens before the\n   * promise is settled, then the machine will also transition to the `onError`\n   * target state.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param promiseFn       The callback to be invoked when the state is entered.\n   * @param onOK            The state to transition to when the promise resolves.\n   * @param onError         The state to transition to when the promise\n   *                        rejects, or when the timeout happens before the\n   *                        promise has been settled.\n   * @param maxTimeout      Optional timeout in milliseconds.\n   *\n   * When the promise callback function is invoked, it's provided with an\n   * AbortSignal (2nd argument).\n   * If a state transition happens while the promise is pending (for example,\n   * an event, or a timeout happens), then an abort signal will be used to\n   * indicate this. Implementers can use this abort signal to terminate the\n   * in-flight promise, or ignore its results, etc.\n   */\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      const timeoutId = maxTimeout ? setTimeout(() => {\n        const reason = new Error(\"Timed out\");\n        this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n      }, maxTimeout) : void 0;\n      let done = false;\n      void promiseFn(this.#currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        clearTimeout(timeoutId);\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  #getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.#states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.#states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.#states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.#getStatesMatching(nameOrPattern)) {\n      let map = this.#allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.#allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.#knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param after           Number of milliseconds after which to take the\n   *                        transition. If in the mean time, another transition\n   *                        is taken, the timer will get cancelled.\n   * @param target          The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.#currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.#transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  #getTargetFn(eventName) {\n    return this.#allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  #exit(levels) {\n    this.#eventHub.willExitState.notify(this.currentState);\n    this.#currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.#cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.#cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  #enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.#currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.#enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.#cleanupStack.push(cleanupFn);\n        } else {\n          this.#cleanupStack.push(null);\n        }\n      }\n    });\n    this.#eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.#knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.#runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.#getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.#transition(event, targetFn);\n    } else {\n      this.#eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  #transition(event, target) {\n    this.#eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.#currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.#eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.#states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.#eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.#exit(up);\n    }\n    this.#currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.#currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.#enter(down);\n    }\n  }\n};\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_UPDATED\"] = 408] = \"THREAD_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    // istanbul ignore next\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeBufferableEventSource();\n  onMessage.pause();\n  const onConnectionError = makeEventSource();\n  function fireErrorEvent(message, code) {\n    return () => {\n      onConnectionError.notify({ message, code });\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onConnectionError: onConnectionError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  #machine;\n  #cleanups;\n  events;\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.#machine = machine;\n    this.events = events;\n    this.#cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.#machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.#machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.#machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.#machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.#machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.#machine.stop();\n    let cleanup;\n    while (cleanup = this.#cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.#machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.#machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nvar Permission = /* @__PURE__ */ ((Permission2) => {\n  Permission2[\"Read\"] = \"room:read\";\n  Permission2[\"Write\"] = \"room:write\";\n  Permission2[\"PresenceWrite\"] = \"room:presence:write\";\n  Permission2[\"CommentsWrite\"] = \"comments:write\";\n  Permission2[\"CommentsRead\"] = \"comments:read\";\n  return Permission2;\n})(Permission || {});\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions, onAuthenticate) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      onAuthenticate?.(parsed.parsed);\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          onAuthenticate?.(parsed.parsed);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch, endpoint, body) {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: stringifyOrLog(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${stringifyOrLog(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      // When a devtool panel sends an explicit \"connect\" message back to this\n      // live running client (in response to the \"wake-up-devtools\" message,\n      // or when the devtool panel is opened for the first time), it means that it's okay to\n      // start emitting messages.\n      // Before this explicit acknowledgement, any call to sendToPanel() will\n      // be a no-op.\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        // Sent by the devtool panel when it wants to receive the sync stream\n        // for a room\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  //                  ^^^^^^^^^^^^ TODO: Make this an interface\n  #pool;\n  #id;\n  #parent = NoParent;\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.#pool;\n  }\n  get roomId() {\n    return this.#pool ? this.#pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.#id;\n  }\n  /** @internal */\n  get parent() {\n    return this.#parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this.#parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this.#parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.#id || this.#pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.#id = id;\n    this.#pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.#pool && this.#id) {\n      this.#pool.deleteNode(this.#id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this.#parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this.#parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.#pool = void 0;\n  }\n  /** This caches the result of the last .toImmutable() call for this Live node. */\n  #cachedImmutable;\n  #cachedTreeNodeKey;\n  /** This caches the result of the last .toTreeNode() call for this Live node. */\n  #cachedTreeNode;\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this.#cachedImmutable !== void 0 || this.#cachedTreeNode !== void 0) {\n      this.#cachedImmutable = void 0;\n      this.#cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this.#cachedTreeNode === void 0 || this.#cachedTreeNodeKey !== key) {\n      this.#cachedTreeNodeKey = key;\n      this.#cachedTreeNode = this._toTreeNode(key);\n    }\n    return this.#cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this.#cachedImmutable === void 0) {\n      this.#cachedImmutable = this._toImmutable();\n    }\n    return this.#cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  #data;\n  constructor(data) {\n    super();\n    this.#data = data;\n  }\n  get data() {\n    return this.#data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this.#data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  // TODO: Naive array at first, find a better data structure. Maybe an Order statistics tree?\n  #items;\n  #implicitlyDeletedItems;\n  #unacknowledgedSets;\n  constructor(items) {\n    super();\n    this.#items = [];\n    this.#implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this.#unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this.#items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this.#items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this.#unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this.#items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this.#items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this.#items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this.#items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this.#items) {\n      item._detach();\n    }\n  }\n  #applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this.#items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this.#items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this.#implicitlyDeletedItems.add(itemWithSamePosition);\n        this.#items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this.#detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  #applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this.#detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this.#unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this.#unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this.#implicitlyDeletedItems.add(\n          this.#items[indexOfItemWithSamePosition]\n        );\n        const [prevNode] = this.#items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition, prevNode));\n      }\n      const prevIndex = this.#items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(existingItem);\n      if (newIndex !== prevIndex) {\n        delta.push(moveDelta(prevIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this.#implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this.#items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this.#items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this.#createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   */\n  #detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  #applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this.#shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  #applyInsertAck(op) {\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this.#items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this.#implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  #applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this.#items[existingItemIndex]?._parentPos;\n      const after2 = this.#items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  #applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this.#unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this.#items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this.#items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this.#detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this.#applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this.#applySetAck(op);\n      } else {\n        result = this.#applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this.#applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this.#applyInsertAck(op);\n      } else {\n        result = this.#applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this.#items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      const [previousNode] = this.#items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  #applySetChildKeyRemote(newKey, child) {\n    if (this.#implicitlyDeletedItems.has(child)) {\n      this.#implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this.#items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this.#items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  #applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this.#implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this.#implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this.#items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  #applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this.#items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this.#items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this.#items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this.#applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this.#applySetChildKeyAck(newKey, child);\n    } else {\n      return this.#applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this.#items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this.#items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length}`\n      );\n    }\n    const before2 = this.#items[index - 1] ? this.#items[index - 1]._parentPos : void 0;\n    const after2 = this.#items[index] ? this.#items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this.#items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this.#items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this.#items.length - 1 ? void 0 : this.#items[targetIndex + 1]._parentPos;\n      beforePosition = this.#items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this.#items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this.#items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this.#items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this.#items.length - 1}`\n      );\n    }\n    const item = this.#items[index];\n    item._detach();\n    const [prev] = this.#items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index, prev)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this.#items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0, item));\n        }\n      }\n      this.#items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this.#items) {\n        item._detach();\n      }\n      this.#items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length - 1}`\n      );\n    }\n    const existingItem = this.#items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this.#items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this.#unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this.#items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this.#items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this.#items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this.#items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this.#items);\n  }\n  #createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  #shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this.#items.length > index + 1 ? this.#items[index + 1]?._parentPos : void 0\n    );\n    this.#items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this.#items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this.#items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  #innerIterator;\n  constructor(items) {\n    this.#innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this.#innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index, deletedNode) {\n  return {\n    type: \"delete\",\n    index,\n    deletedItem: deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    type: \"move\",\n    index,\n    item: item instanceof LiveRegister ? item.data : item,\n    previousIndex\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  #map;\n  #unacknowledgedSet;\n  constructor(entries2) {\n    super();\n    this.#unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this.#map = new Map(mappedEntries);\n    } else {\n      this.#map = /* @__PURE__ */ new Map();\n    }\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this.#map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map.#map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.#unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.#unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.#unacknowledgedSet.delete(key);\n    }\n    const previousValue = this.#map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this.#map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this.#map.values()) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this.#map) {\n      if (value === child) {\n        this.#map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this.#map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this.#map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this.#map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.#unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this.#map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this.#map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this.#map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this.#map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this.#map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this.#map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this.#map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this.#map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this.#map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this.#map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  #map;\n  #propToLastUpdate;\n  static #buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject.#buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this.#propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this.#map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj.#map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this.#propToLastUpdate.get(key) === opId) {\n        this.#propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this.#propToLastUpdate.set(key, nn(opId));\n    } else if (this.#propToLastUpdate.get(key) === void 0) {\n    } else if (this.#propToLastUpdate.get(key) === opId) {\n      this.#propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this.#map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this.#map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this.#map) {\n        if (value === child) {\n          this.#map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const value of this.#map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this.#applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this.#applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this.#map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  #applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this.#propToLastUpdate.set(key, nn(op.opId));\n      } else if (this.#propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this.#propToLastUpdate.get(key) === op.opId) {\n        this.#propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this.#map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  #applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this.#map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this.#propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this.#map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this.#map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this.#map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this.#map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this.#map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this.#map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this.#map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this.#map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this.#map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this.#propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this.#propToLastUpdate.set(key, opId);\n      }\n      this.#map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this.#map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this.#map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this.#map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || stringifyOrLog(crdt.data) !== stringifyOrLog(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Deque.ts\nvar Deque = class {\n  #data;\n  #front;\n  #back;\n  #size;\n  constructor() {\n    this.#data = {};\n    this.#front = 0;\n    this.#back = 1;\n    this.#size = 0;\n  }\n  get length() {\n    return this.#size;\n  }\n  *[Symbol.iterator]() {\n    const size = this.#size;\n    const front = this.#front;\n    for (let i = 0; i < size; i++) {\n      yield this.#data[front + i];\n    }\n  }\n  push(value) {\n    const values2 = Array.isArray(value) ? value : [value];\n    if (this.#back > Number.MAX_SAFE_INTEGER - values2.length - 1)\n      raise(\"Deque full\");\n    for (const value2 of values2) {\n      this.#data[this.#back++ - 1] = value2;\n    }\n    this.#size += values2.length;\n  }\n  pop() {\n    if (this.#size < 1) return void 0;\n    this.#back--;\n    const value = this.#data[this.#back - 1];\n    delete this.#data[this.#back - 1];\n    this.#size--;\n    return value;\n  }\n  pushLeft(value) {\n    const values2 = Array.isArray(value) ? value : [value];\n    if (this.#front < Number.MIN_SAFE_INTEGER + values2.length)\n      raise(\"Deque full\");\n    for (let i = values2.length - 1; i >= 0; i--) {\n      this.#data[--this.#front] = values2[i];\n    }\n    this.#size += values2.length;\n  }\n  popLeft() {\n    if (this.#size < 1) return void 0;\n    const value = this.#data[this.#front];\n    delete this.#data[this.#front];\n    this.#front++;\n    this.#size--;\n    return value;\n  }\n};\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ManagedOthers.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar ManagedOthers = class {\n  // Track mutable state internally, but signal to the outside when the\n  // observable derived state changes only\n  #internal;\n  #userCache;\n  // The \"clean\" signal that is exposed to the outside world\n  signal;\n  constructor() {\n    this.#internal = new MutableSignal({\n      connections: /* @__PURE__ */ new Map(),\n      presences: /* @__PURE__ */ new Map()\n    });\n    this.signal = DerivedSignal.from(\n      this.#internal,\n      (_ignore) => compact(\n        Array.from(this.#internal.get().presences.keys()).map(\n          (connectionId) => this.getUser(Number(connectionId))\n        )\n      )\n    );\n    this.#userCache = /* @__PURE__ */ new Map();\n  }\n  // Shorthand for .signal.get()\n  get() {\n    return this.signal.get();\n  }\n  connectionIds() {\n    return this.#internal.get().connections.keys();\n  }\n  clearOthers() {\n    this.#internal.mutate((state) => {\n      state.connections.clear();\n      state.presences.clear();\n      this.#userCache.clear();\n    });\n  }\n  #_getUser(connectionId) {\n    const state = this.#internal.get();\n    const conn = state.connections.get(connectionId);\n    const presence = state.presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this.#userCache.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this.#_getUser(connectionId);\n    if (computedUser) {\n      this.#userCache.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  #invalidateUser(connectionId) {\n    this.#userCache.delete(connectionId);\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this.#internal.mutate((state) => {\n      state.connections.set(\n        connectionId,\n        freeze({\n          connectionId,\n          id: metaUserId,\n          info: metaUserInfo,\n          scopes\n        })\n      );\n      if (!state.presences.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this.#internal.mutate((state) => {\n      state.connections.delete(connectionId);\n      state.presences.delete(connectionId);\n      this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this.#internal.mutate((state) => {\n      state.presences.set(connectionId, freeze(compactObject(presence)));\n      if (!state.connections.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    this.#internal.mutate((state) => {\n      const oldPresence = state.presences.get(connectionId);\n      if (oldPresence === void 0) {\n        return false;\n      }\n      const newPresence = merge(oldPresence, patch);\n      if (oldPresence === newPresence) {\n        return false;\n      }\n      state.presences.set(connectionId, freeze(newPresence));\n      return this.#invalidateUser(connectionId);\n    });\n  }\n};\n\n// src/types/LiveblocksError.ts\nvar LiveblocksError = class _LiveblocksError extends Error {\n  context;\n  constructor(message, context, cause) {\n    super(message, { cause });\n    this.context = context;\n    this.name = \"LiveblocksError\";\n  }\n  /** Convenience accessor for error.context.roomId (if available) */\n  get roomId() {\n    return this.context.roomId;\n  }\n  /** @deprecated Prefer using `context.code` instead, to enable type narrowing */\n  get code() {\n    return this.context.code;\n  }\n  /**\n   * Creates a LiveblocksError from a generic error, by attaching Liveblocks\n   * contextual information like room ID, thread ID, etc.\n   */\n  static from(context, cause) {\n    return new _LiveblocksError(\n      defaultMessageFromContext(context),\n      context,\n      cause\n    );\n  }\n};\nfunction defaultMessageFromContext(context) {\n  switch (context.type) {\n    case \"ROOM_CONNECTION_ERROR\": {\n      switch (context.code) {\n        case 4001:\n          return \"Not allowed to connect to the room\";\n        case 4005:\n          return \"Room is already full\";\n        case 4006:\n          return \"Kicked out of the room, because the room ID changed\";\n        default:\n          return \"Could not connect to the room\";\n      }\n    }\n    case \"CREATE_THREAD_ERROR\":\n      return \"Could not create new thread\";\n    case \"DELETE_THREAD_ERROR\":\n      return \"Could not delete thread\";\n    case \"EDIT_THREAD_METADATA_ERROR\":\n      return \"Could not edit thread metadata\";\n    case \"MARK_THREAD_AS_RESOLVED_ERROR\":\n      return \"Could not mark thread as resolved\";\n    case \"MARK_THREAD_AS_UNRESOLVED_ERROR\":\n      return \"Could not mark thread as unresolved\";\n    case \"CREATE_COMMENT_ERROR\":\n      return \"Could not create new comment\";\n    case \"EDIT_COMMENT_ERROR\":\n      return \"Could not edit comment\";\n    case \"DELETE_COMMENT_ERROR\":\n      return \"Could not delete comment\";\n    case \"ADD_REACTION_ERROR\":\n      return \"Could not add reaction\";\n    case \"REMOVE_REACTION_ERROR\":\n      return \"Could not remove reaction\";\n    case \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\":\n      return \"Could not mark inbox notification as read\";\n    case \"DELETE_INBOX_NOTIFICATION_ERROR\":\n      return \"Could not delete inbox notification\";\n    case \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\":\n      return \"Could not mark all inbox notifications as read\";\n    case \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\":\n      return \"Could not delete all inbox notifications\";\n    case \"UPDATE_NOTIFICATION_SETTINGS_ERROR\":\n      return \"Could not update notification settings\";\n    case \"UPDATE_USER_NOTIFICATION_SETTINGS_ERROR\":\n      return \"Could not update user notification settings\";\n    default:\n      return assertNever(context, \"Unhandled case\");\n  }\n}\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 512;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nfunction createRoom(options, config) {\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const httpClient = config.roomHttpClient;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfoSig: new Signal(null),\n    dynamicSessionInfoSig: new Signal(null),\n    myPresence: new PatchableSignal(initialPresence),\n    others: new ManagedOthers(),\n    initialStorage,\n    idFactory: null,\n    // The Yjs provider associated to this room\n    yjsProvider: void 0,\n    yjsProviderDidChange: makeEventSource(),\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    eventHub.status.notify(newStatus);\n    notifySelfChanged();\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        eventHub.lostConnection.notify(\"lost\");\n        _hasLostConnection = true;\n        context.others.clearOthers();\n        notify({ others: [{ type: \"reset\" }] });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          eventHub.lostConnection.notify(\"failed\");\n        } else {\n          eventHub.lostConnection.notify(\"restored\");\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.get() }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    const type = \"ROOM_CONNECTION_ERROR\";\n    const err = new LiveblocksError(message, { type, code, roomId });\n    const didNotify = config.errorEventSource.notify(err);\n    if (!didNotify) {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n        );\n      }\n    }\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (true) {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.pushLeft(reverse);\n      } else {\n        addToUndoStack(reverse);\n        context.redoStack.length = 0;\n        dispatchOps(ops);\n        notify({ storageUpdates });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfoSig.get()?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource(),\n    roomWillDestroy: makeEventSource()\n  };\n  const roomId = config.roomId;\n  async function createTextMention(userId, mentionId) {\n    return httpClient.createTextMention({ roomId, userId, mentionId });\n  }\n  async function deleteTextMention(mentionId) {\n    return httpClient.deleteTextMention({ roomId, mentionId });\n  }\n  async function reportTextEditor(type, rootKey) {\n    await httpClient.reportTextEditor({ roomId, type, rootKey });\n  }\n  async function listTextVersions() {\n    return httpClient.listTextVersions({ roomId });\n  }\n  async function listTextVersionsSince(options2) {\n    return httpClient.listTextVersionsSince({\n      roomId,\n      since: options2.since,\n      signal: options2.signal\n    });\n  }\n  async function getTextVersion(versionId) {\n    return httpClient.getTextVersion({ roomId, versionId });\n  }\n  async function createTextVersion() {\n    return httpClient.createTextVersion({ roomId });\n  }\n  async function executeContextualPrompt(options2) {\n    return httpClient.executeContextualPrompt({\n      roomId,\n      ...options2\n    });\n  }\n  function* chunkOps(msg) {\n    const { ops, ...rest } = msg;\n    if (ops.length < 2) {\n      throw new Error(\"Cannot split ops into smaller chunks\");\n    }\n    const mid = Math.floor(ops.length / 2);\n    const firstHalf = ops.slice(0, mid);\n    const secondHalf = ops.slice(mid);\n    for (const halfOps of [firstHalf, secondHalf]) {\n      const half = { ops: halfOps, ...rest };\n      const text = stringifyOrLog([half]);\n      if (!isTooBigForWebSocket(text)) {\n        yield text;\n      } else {\n        yield* chunkOps(half);\n      }\n    }\n  }\n  function* chunkMessages(messages) {\n    if (messages.length < 2) {\n      if (messages[0].type === 201 /* UPDATE_STORAGE */) {\n        yield* chunkOps(messages[0]);\n        return;\n      } else {\n        throw new Error(\n          \"Cannot split into chunks smaller than the allowed message size\"\n        );\n      }\n    }\n    const mid = Math.floor(messages.length / 2);\n    const firstHalf = messages.slice(0, mid);\n    const secondHalf = messages.slice(mid);\n    for (const half of [firstHalf, secondHalf]) {\n      const text = stringifyOrLog(half);\n      if (!isTooBigForWebSocket(text)) {\n        yield text;\n      } else {\n        yield* chunkMessages(half);\n      }\n    }\n  }\n  function isTooBigForWebSocket(text) {\n    if (text.length * 4 < MAX_SOCKET_MESSAGE_SIZE) {\n      return false;\n    }\n    return new TextEncoder().encode(text).length >= MAX_SOCKET_MESSAGE_SIZE;\n  }\n  function sendMessages(messages) {\n    const strategy = config.largeMessageStrategy ?? \"default\";\n    const text = stringifyOrLog(messages);\n    if (!isTooBigForWebSocket(text)) {\n      return managedSocket.send(text);\n    }\n    switch (strategy) {\n      case \"default\": {\n        error2(\"Message is too large for websockets, not sending. Configure largeMessageStrategy option to deal with this.\");\n        return;\n      }\n      case \"split\": {\n        warn(\"Message is too large for websockets, splitting into smaller chunks\");\n        for (const chunk2 of chunkMessages(messages)) {\n          managedSocket.send(chunk2);\n        }\n        return;\n      }\n      case \"experimental-fallback-to-http\": {\n        warn(\"Message is too large for websockets, so sending over HTTP instead\");\n        const nonce = context.dynamicSessionInfoSig.get()?.nonce ?? raise(\"Session is not authorized to send message over HTTP\");\n        void httpClient.sendMessages({ roomId, nonce, messages }).then((resp) => {\n          if (!resp.ok && resp.status === 403) {\n            managedSocket.reconnect();\n          }\n        });\n        return;\n      }\n    }\n  }\n  const self = DerivedSignal.from(\n    context.staticSessionInfoSig,\n    context.dynamicSessionInfoSig,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged() {\n    const currSelf = self.get();\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      eventHub.self.notify(currSelf);\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = DerivedSignal.from(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const canWrite = self.get()?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates);\n  }\n  function _addToRealUndoStack(historyOps) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange();\n  }\n  function addToUndoStack(historyOps) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.pushLeft(historyOps);\n    } else {\n      _addToRealUndoStack(historyOps);\n    }\n  }\n  function notify(updates) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n      const others = context.others.get();\n      for (const event of othersUpdates) {\n        eventHub.others.notify({ ...event, others });\n      }\n    }\n    if (updates.presence ?? false) {\n      notifySelfChanged();\n      eventHub.myPresence.notify(context.myPresence.get());\n    }\n    if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n      const updates2 = Array.from(storageUpdates.values());\n      eventHub.storageBatch.notify(updates2);\n    }\n    notifyStorageStatus();\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfoSig.get();\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: new Deque(),\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.get()[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.pushLeft(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.pushLeft(applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: Array.from(output.reverse),\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.get()[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.pushLeft({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      if (options2?.addToHistory) {\n        addToUndoStack([{ type: \"presence\", data: oldValues }]);\n      }\n      notify({ presence: true });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message) {\n    context.dynamicSessionInfoSig.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged();\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange() {\n    eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.get(),\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const inOps = Array.from(offlineOps.values());\n    const result = applyOps(inOps, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    for (const message of messages) {\n      switch (message.type) {\n        case 101 /* USER_JOINED */: {\n          const userJoinedUpdate = onUserJoinedMessage(message);\n          if (userJoinedUpdate) {\n            updates.others.push(userJoinedUpdate);\n          }\n          break;\n        }\n        case 100 /* UPDATE_PRESENCE */: {\n          const othersPresenceUpdate = onUpdatePresenceMessage(message);\n          if (othersPresenceUpdate) {\n            updates.others.push(othersPresenceUpdate);\n          }\n          break;\n        }\n        case 103 /* BROADCASTED_EVENT */: {\n          const others = context.others.get();\n          eventHub.customEvent.notify({\n            connectionId: message.actor,\n            user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n            event: message.event\n          });\n          break;\n        }\n        case 102 /* USER_LEFT */: {\n          const event2 = onUserLeftMessage(message);\n          if (event2) {\n            updates.others.push(event2);\n          }\n          break;\n        }\n        case 300 /* UPDATE_YDOC */: {\n          eventHub.ydoc.notify(message);\n          break;\n        }\n        case 104 /* ROOM_STATE */: {\n          updates.others.push(onRoomStateMessage(message));\n          break;\n        }\n        case 200 /* INITIAL_STORAGE_STATE */: {\n          processInitialStorage(message);\n          break;\n        }\n        // Write event\n        case 201 /* UPDATE_STORAGE */: {\n          const applyResult = applyOps(message.ops, false);\n          for (const [key, value] of applyResult.updates.storageUpdates) {\n            updates.storageUpdates.set(\n              key,\n              mergeStorageUpdates(updates.storageUpdates.get(key), value)\n            );\n          }\n          break;\n        }\n        // Receiving a RejectedOps message in the client means that the server is no\n        // longer in sync with the client. Trying to synchronize the client again by\n        // rolling back particular Ops may be hard/impossible. It's fine to not try and\n        // accept the out-of-sync reality and throw an error. We look at this kind of bug\n        // as a developer-owned bug. In production, these errors are not expected to happen.\n        case 299 /* REJECT_STORAGE_OP */: {\n          errorWithTitle(\n            \"Storage mutation rejection error\",\n            message.reason\n          );\n          if (true) {\n            const traces = /* @__PURE__ */ new Set();\n            for (const opId of message.opIds) {\n              const trace = context.opStackTraces?.get(opId);\n              if (trace) {\n                traces.add(trace);\n              }\n            }\n            if (traces.size > 0) {\n              warnWithTitle(\n                \"The following function calls caused the rejected storage mutations:\",\n                `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n              );\n            }\n            throw new Error(\n              `Storage mutations rejected by server: ${message.reason}`\n            );\n          }\n          break;\n        }\n        case 400 /* THREAD_CREATED */:\n        case 407 /* THREAD_DELETED */:\n        case 401 /* THREAD_METADATA_UPDATED */:\n        case 408 /* THREAD_UPDATED */:\n        case 405 /* COMMENT_REACTION_ADDED */:\n        case 406 /* COMMENT_REACTION_REMOVED */:\n        case 402 /* COMMENT_CREATED */:\n        case 403 /* COMMENT_EDITED */:\n        case 404 /* COMMENT_DELETED */: {\n          eventHub.comments.notify(message);\n          break;\n        }\n      }\n    }\n    notify(updates);\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence™ update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid, isV2) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid,\n      v2: isV2\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message);\n    applyAndSendOps(unacknowledgedOps);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) return;\n    const items = await httpClient.streamStorage({ roomId });\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid, isV2) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid && m.v2 === isV2;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid,\n        v2: isV2\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    notify(result.updates);\n    context.redoStack.push(result.reverse);\n    onHistoryChange();\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    notify(result.updates);\n    context.undoStack.push(result.reverse);\n    onHistoryChange();\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch2(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    context.activeBatch = {\n      ops: [],\n      updates: {\n        storageUpdates: /* @__PURE__ */ new Map(),\n        presence: false,\n        others: []\n      },\n      reverseOps: new Deque()\n    };\n    try {\n      returnValue = callback();\n    } finally {\n      const currentBatch = context.activeBatch;\n      context.activeBatch = null;\n      if (currentBatch.reverseOps.length > 0) {\n        addToUndoStack(Array.from(currentBatch.reverseOps));\n      }\n      if (currentBatch.ops.length > 0) {\n        context.redoStack.length = 0;\n      }\n      if (currentBatch.ops.length > 0) {\n        dispatchOps(currentBatch.ops);\n      }\n      notify(currentBatch.updates);\n      flushNowOrSoon();\n    }\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = new Deque();\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(Array.from(historyOps));\n    }\n  }\n  const syncSourceForStorage = config.createSyncSource();\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n    syncSourceForStorage.setSyncStatus(\n      storageStatus === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n  function isPresenceReady() {\n    return self.get() !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = DerivedSignal.from(\n    context.others.signal,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable,\n    roomWillDestroy: eventHub.roomWillDestroy.observable\n  };\n  async function getThreadsSince(options2) {\n    return httpClient.getThreadsSince({\n      roomId,\n      since: options2.since,\n      signal: options2.signal\n    });\n  }\n  async function getThreads(options2) {\n    return httpClient.getThreads({\n      roomId,\n      query: options2?.query,\n      cursor: options2?.cursor\n    });\n  }\n  async function getThread(threadId) {\n    return httpClient.getThread({ roomId, threadId });\n  }\n  async function createThread(options2) {\n    return httpClient.createThread({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      metadata: options2.metadata,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function deleteThread(threadId) {\n    return httpClient.deleteThread({ roomId, threadId });\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return httpClient.editThreadMetadata({ roomId, threadId, metadata });\n  }\n  async function markThreadAsResolved(threadId) {\n    return httpClient.markThreadAsResolved({ roomId, threadId });\n  }\n  async function markThreadAsUnresolved(threadId) {\n    return httpClient.markThreadAsUnresolved({\n      roomId,\n      threadId\n    });\n  }\n  async function createComment(options2) {\n    return httpClient.createComment({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function editComment(options2) {\n    return httpClient.editComment({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function deleteComment({\n    threadId,\n    commentId\n  }) {\n    return httpClient.deleteComment({ roomId, threadId, commentId });\n  }\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    return httpClient.addReaction({ roomId, threadId, commentId, emoji });\n  }\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    return await httpClient.removeReaction({\n      roomId,\n      threadId,\n      commentId,\n      emoji\n    });\n  }\n  function prepareAttachment(file) {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file\n    };\n  }\n  async function uploadAttachment(attachment, options2 = {}) {\n    return httpClient.uploadAttachment({\n      roomId,\n      attachment,\n      signal: options2.signal\n    });\n  }\n  function getAttachmentUrl(attachmentId) {\n    return httpClient.getAttachmentUrl({ roomId, attachmentId });\n  }\n  function getNotificationSettings(options2) {\n    return httpClient.getNotificationSettings({\n      roomId,\n      signal: options2?.signal\n    });\n  }\n  function updateNotificationSettings(settings) {\n    return httpClient.updateNotificationSettings({ roomId, settings });\n  }\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await httpClient.markRoomInboxNotificationAsRead({\n      roomId,\n      inboxNotificationId\n    });\n  }\n  const syncSourceForYjs = config.createSyncSource();\n  function yjsStatusDidChange(status) {\n    return syncSourceForYjs.setSyncStatus(\n      status === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        getYjsProvider() {\n          return context.yjsProvider;\n        },\n        setYjsProvider(newProvider) {\n          context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n          context.yjsProvider = newProvider;\n          newProvider?.on(\"status\", yjsStatusDidChange);\n          context.yjsProviderDidChange.notify();\n        },\n        yjsProviderDidChange: context.yjsProviderDidChange.observable,\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // List versions of the document since the specified date\n        listTextVersionsSince,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n        // execute a contextual prompt\n        executeContextualPrompt,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.get(),\n        getOthers_forDevTools: () => others_forDevTools.get(),\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        attachmentUrlsStore: httpClient.getOrCreateAttachmentUrlsStore(roomId)\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(\n        config.roomId,\n        events,\n        config.errorEventSource\n      ),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        const { roomWillDestroy, ...eventsExceptDestroy } = eventHub;\n        for (const source of Object.values(eventsExceptDestroy)) {\n          source[Symbol.dispose]();\n        }\n        eventHub.roomWillDestroy.notify();\n        context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n        syncSourceForStorage.destroy();\n        syncSourceForYjs.destroy();\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n        roomWillDestroy[Symbol.dispose]();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch: batch2,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.get(),\n      // Presence\n      getPresence: () => context.myPresence.get(),\n      getOthers: () => context.others.get(),\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      createComment,\n      editComment,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n      // Notifications\n      getNotificationSettings,\n      updateNotificationSettings,\n      markInboxNotificationAsRead\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(roomId, events, errorEvents) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\": {\n          return errorEvents.subscribe((err) => {\n            if (err.roomId === roomId) {\n              return callback(err);\n            }\n          });\n        }\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        case \"comments\":\n          return events.comments.subscribe(\n            callback\n          );\n        // istanbul ignore next\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\" || value === \"comments\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url2 = new URL(baseUrl);\n    url2.protocol = url2.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url2.pathname = \"/v7\";\n    url2.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url2.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url2.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url2.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url2.toString());\n  };\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const currentUserId = new Signal(void 0);\n  const authManager = createAuthManager(options, (token) => {\n    const userId = token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid;\n    currentUserId.set(() => userId);\n  });\n  const fetchPolyfill = clientOptions.polyfills?.fetch || /* istanbul ignore next */\n  globalThis.fetch?.bind(globalThis);\n  const httpClient = createApiClient({\n    baseUrl,\n    fetchPolyfill,\n    authManager\n  });\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        baseUrl,\n        errorEventSource: liveblocksErrorSource,\n        largeMessageStrategy: clientOptions.largeMessageStrategy ?? (clientOptions.unstable_fallbackToHTTP ? \"experimental-fallback-to-http\" : void 0),\n        unstable_streamData: !!clientOptions.unstable_streamData,\n        roomHttpClient: httpClient,\n        createSyncSource\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    currentUserId.set(() => void 0);\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n  function invalidateResolvedUsers(userIds) {\n    usersStore.invalidate(userIds);\n  }\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n  function invalidateResolvedRoomsInfo(roomIds) {\n    roomsInfoStore.invalidate(roomIds);\n  }\n  const mentionSuggestionsCache = /* @__PURE__ */ new Map();\n  function invalidateResolvedMentionSuggestions() {\n    mentionSuggestionsCache.clear();\n  }\n  const syncStatusSources = [];\n  const syncStatusSignal = new Signal(\"synchronized\");\n  const liveblocksErrorSource = makeEventSource();\n  function getSyncStatus() {\n    const status = syncStatusSignal.get();\n    return status === \"synchronizing\" ? status : \"synchronized\";\n  }\n  function recompute() {\n    syncStatusSignal.set(\n      syncStatusSources.some((src) => src.get() === \"synchronizing\") ? \"synchronizing\" : syncStatusSources.some((src) => src.get() === \"has-local-changes\") ? \"has-local-changes\" : \"synchronized\"\n    );\n  }\n  function createSyncSource() {\n    const source = new Signal(\"synchronized\");\n    syncStatusSources.push(source);\n    const unsub = source.subscribe(() => recompute());\n    function setSyncStatus(status) {\n      source.set(status);\n    }\n    function destroy() {\n      unsub();\n      const index = syncStatusSources.findIndex((item) => item === source);\n      if (index > -1) {\n        const [ref] = syncStatusSources.splice(index, 1);\n        const wasStillPending = ref.get() !== \"synchronized\";\n        if (wasStillPending) {\n          recompute();\n        }\n      }\n    }\n    return { setSyncStatus, destroy };\n  }\n  {\n    const maybePreventClose = (e) => {\n      if (clientOptions.preventUnsavedChanges && syncStatusSignal.get() !== \"synchronized\") {\n        e.preventDefault();\n      }\n    };\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    win?.addEventListener(\"beforeunload\", maybePreventClose);\n  }\n  const client = Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      // Public inbox notifications API\n      getInboxNotifications: httpClient.getInboxNotifications,\n      getInboxNotificationsSince: httpClient.getInboxNotificationsSince,\n      getUnreadInboxNotificationsCount: httpClient.getUnreadInboxNotificationsCount,\n      markAllInboxNotificationsAsRead: httpClient.markAllInboxNotificationsAsRead,\n      markInboxNotificationAsRead: httpClient.markInboxNotificationAsRead,\n      deleteAllInboxNotifications: httpClient.deleteAllInboxNotifications,\n      deleteInboxNotification: httpClient.deleteInboxNotification,\n      // Public channel notification settings API\n      getNotificationSettings: httpClient.getUserNotificationSettings,\n      updateNotificationSettings: httpClient.updateUserNotificationSettings,\n      // Advanced resolvers APIs\n      resolvers: {\n        invalidateUsers: invalidateResolvedUsers,\n        invalidateRoomsInfo: invalidateResolvedRoomsInfo,\n        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions\n      },\n      getSyncStatus,\n      events: {\n        error: liveblocksErrorSource,\n        syncStatus: syncStatusSignal\n      },\n      // Internal\n      [kInternal]: {\n        currentUserId,\n        mentionSuggestionsCache,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        httpClient,\n        // Type-level helper only, it's effectively only an identity-function at runtime\n        as: () => client,\n        createSyncSource,\n        emitError: (context, cause) => {\n          const error3 = LiveblocksError.from(context, cause);\n          const didNotify = liveblocksErrorSource.notify(error3);\n          if (!didNotify) {\n            error2(error3.message);\n          }\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n  return client;\n}\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"paragraph\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  #strings;\n  #values;\n  constructor(strings, values2) {\n    this.#strings = strings;\n    this.#values = values2;\n  }\n  toString() {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this.#values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values2) {\n  return new HtmlSafeString(strings, values2);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  #strings;\n  #values;\n  constructor(strings, values2) {\n    this.#strings = strings;\n    this.#values = values2;\n  }\n  toString() {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this.#values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values2) {\n  return new MarkdownSafeString(strings, values2);\n}\nfunction toAbsoluteUrl(url2) {\n  if (url2.startsWith(\"http://\") || url2.startsWith(\"https://\")) {\n    return url2;\n  } else if (url2.startsWith(\"www.\")) {\n    return \"https://\" + url2;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.text ?? element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return html`${children}`;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return html`${children}`;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ? html`${element.text}` : element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ? html`${user?.name}` : element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.text ?? element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/comments/comment-url.ts\nvar PLACEHOLDER_BASE_URL = \"https://localhost:9999\";\nvar ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nfunction generateCommentUrl({\n  roomUrl,\n  commentId\n}) {\n  const isAbsolute = ABSOLUTE_URL_REGEX.test(roomUrl);\n  const urlObject = new URL(\n    roomUrl,\n    isAbsolute ? void 0 : PLACEHOLDER_BASE_URL\n  );\n  urlObject.hash = `#${commentId}`;\n  return isAbsolute ? urlObject.href : urlObject.href.replace(PLACEHOLDER_BASE_URL, \"\");\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nvar BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];\nfunction makePoller(callback, intervalMs, options) {\n  const startTime = performance.now();\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const win = typeof window !== \"undefined\" ? window : void 0;\n  const maxStaleTimeMs = options?.maxStaleTimeMs ?? Number.POSITIVE_INFINITY;\n  const context = {\n    inForeground: doc?.visibilityState !== \"hidden\",\n    lastSuccessfulPollAt: startTime,\n    count: 0,\n    backoff: 0\n  };\n  function mayPoll() {\n    return context.count > 0 && context.inForeground;\n  }\n  const fsm = new FSM({}).addState(\"@idle\").addState(\"@enabled\").addState(\"@polling\");\n  fsm.addTransitions(\"@idle\", { START: \"@enabled\" });\n  fsm.addTransitions(\"@enabled\", { STOP: \"@idle\", POLL: \"@polling\" });\n  fsm.addTimedTransition(\n    \"@enabled\",\n    () => {\n      const lastPoll = context.lastSuccessfulPollAt;\n      const nextPoll = lastPoll + intervalMs;\n      return Math.max(0, nextPoll - performance.now()) + context.backoff;\n    },\n    \"@polling\"\n  );\n  fsm.onEnterAsync(\n    \"@polling\",\n    async (_ctx, signal) => {\n      await callback(signal);\n      if (!signal.aborted) {\n        context.lastSuccessfulPollAt = performance.now();\n      }\n    },\n    // When OK\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = 0;\n        }\n      };\n    },\n    // When error\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = BACKOFF_DELAYS2.find((delay) => delay > context.backoff) ?? BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1];\n        }\n      };\n    },\n    3e4\n    // Abort the poll if the callback takes more than 30 seconds to complete\n  );\n  function startOrStop() {\n    if (mayPoll()) {\n      fsm.send({ type: \"START\" });\n    } else {\n      fsm.send({ type: \"STOP\" });\n    }\n  }\n  function inc() {\n    context.count++;\n    startOrStop();\n  }\n  function dec() {\n    context.count--;\n    if (context.count < 0) {\n      context.count = 0;\n    }\n    startOrStop();\n  }\n  function pollNowIfStale() {\n    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {\n      fsm.send({ type: \"POLL\" });\n    }\n  }\n  function setInForeground(inForeground) {\n    context.inForeground = inForeground;\n    startOrStop();\n    pollNowIfStale();\n  }\n  function onVisibilityChange() {\n    setInForeground(doc?.visibilityState !== \"hidden\");\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  win?.addEventListener(\"online\", onVisibilityChange);\n  win?.addEventListener(\"focus\", pollNowIfStale);\n  fsm.start();\n  return {\n    inc,\n    dec,\n    pollNowIfStale,\n    // Internal API, used by unit tests only to simulate visibility events\n    setInForeground\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/lib/SortedList.ts\nfunction bisectRight(arr, x, lt) {\n  let lo = 0;\n  let hi = arr.length;\n  while (lo < hi) {\n    const mid = lo + (hi - lo >> 1);\n    if (lt(x, arr[mid])) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\nvar SortedList = class _SortedList {\n  #data;\n  #lt;\n  constructor(alreadySortedList, lt) {\n    this.#lt = lt;\n    this.#data = alreadySortedList;\n  }\n  static from(arr, lt) {\n    const sorted = new _SortedList([], lt);\n    for (const item of arr) {\n      sorted.add(item);\n    }\n    return sorted;\n  }\n  static fromAlreadySorted(alreadySorted, lt) {\n    return new _SortedList(alreadySorted, lt);\n  }\n  /**\n   * Clones the sorted list to a new instance.\n   */\n  clone() {\n    return new _SortedList(this.#data.slice(), this.#lt);\n  }\n  /**\n   * Adds a new item to the sorted list, such that it remains sorted.\n   */\n  add(value) {\n    const idx = bisectRight(this.#data, value, this.#lt);\n    this.#data.splice(idx, 0, value);\n  }\n  /**\n   * Removes the given value from the sorted list, if it exists. The given\n   * value must be `===` to one of the list items. Only the first entry will be\n   * removed if the element exists in the sorted list multiple times.\n   */\n  remove(value) {\n    const idx = this.#data.indexOf(value);\n    if (idx >= 0) {\n      this.#data.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n  get length() {\n    return this.#data.length;\n  }\n  *filter(predicate) {\n    for (const item of this.#data) {\n      if (predicate(item)) {\n        yield item;\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this.#data[Symbol.iterator]();\n  }\n};\n\n// src/protocol/UserNotificationSettings.ts\nfunction isNotificationChannelEnabled(settings) {\n  return values(settings).every((enabled) => enabled === true);\n}\n\n// src/types/Others.ts\nvar TextEditorType = /* @__PURE__ */ ((TextEditorType2) => {\n  TextEditorType2[\"Lexical\"] = \"lexical\";\n  TextEditorType2[\"TipTap\"] = \"tiptap\";\n  return TextEditorType2;\n})(TextEditorType || {});\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nvar CommentsApiError = HttpError;\nvar NotificationsApiError = HttpError;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUIsR0FBRyxVQUFVO0FBQ3hFO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0EscUdBQXFHLGtCQUFrQjtBQUN2SDtBQUNBO0FBQ0EsV0FBVyxTQUFTLEVBQUUsVUFBVTtBQUNoQyxXQUFXLFNBQVMsRUFBRSxjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix3QkFBd0I7QUFDM0c7QUFDQTtBQUNBLGFBQWEsVUFBVSxRQUFRLFlBQVk7QUFDM0MsYUFBYSxTQUFTLFFBQVEsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE1BQXFDO0FBQ2xEO0FBQ0EsRUFBRSxDQUFRO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtB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QTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbURBQW1ELDRGQUE0RjtBQUMvSTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSUFBaUksY0FBYztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNLG1DQUFtQyxtQkFBbUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQXFDLEdBQUcsQ0FBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsK0JBQStCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUscUJBQXFCLE9BQU8sR0FBRyxLQUFLO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBcUMsR0FBRyxDQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWEsR0FBRyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJDQUEyQyw0QkFBNEI7QUFDdkU7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0NBQXNDLDZCQUE2QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9DQUFvQyxvQ0FBb0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxzQ0FBc0M7QUFDbkg7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMENBQTBDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUNBQXFDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRLG9CQUFvQix1QkFBdUIsTUFBTSxJQUFJLFFBQVEsUUFBUSxxQkFBcUIsc0JBQXNCO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBSyxFQUdOO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaLFlBQVk7QUFDWixjQUFjO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1gsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixjQUFjLGVBQWU7QUFDN0IsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsZ0NBQWdDLG1CQUFtQjtBQUNuRCxHQUFHO0FBQ0gsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixHQUFHO0FBQ0gsV0FBVyxlQUFlO0FBQzFCLDJCQUEyQixLQUFLLDhDQUE4QyxzQkFBc0IsYUFBYSxnQkFBZ0I7QUFDakksR0FBRztBQUNILGNBQWMsZUFBZTtBQUM3QixzQ0FBc0Msb0JBQW9CLFdBQVcsZUFBZTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLEdBQUc7QUFDSCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVyxlQUFlO0FBQzFCLHVCQUF1Qiw0QkFBNEIsSUFBSSxLQUFLO0FBQzVELEdBQUc7QUFDSCxjQUFjLGVBQWU7QUFDN0IsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWMsNENBQTRDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCLFlBQVk7QUFDbEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGdDQUFnQyxtQkFBbUI7QUFDbkQsbUNBQW1DLGlDQUFpQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEMsTUFBTTtBQUNOLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBMEZFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL2NvcmUvZGlzdC9pbmRleC5qcz9kYjMxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi4xOS4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9kdXBlLWRldGVjdGlvbi50c1xudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9O1xudmFyIGNyb3NzTGlua2VkRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2Nyb3NzLWxpbmtlZFwiO1xudmFyIGR1cGVzRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2R1cGVzXCI7XG52YXIgU1BBQ0UgPSBcIiBcIjtcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtc2cpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlY3REdXBlcyhwa2dOYW1lLCBwa2dWZXJzaW9uLCBwa2dGb3JtYXQpIHtcbiAgY29uc3QgcGtnSWQgPSBTeW1ib2wuZm9yKHBrZ05hbWUpO1xuICBjb25zdCBwa2dCdWlsZEluZm8gPSBwa2dGb3JtYXQgPyBgJHtwa2dWZXJzaW9uIHx8IFwiZGV2XCJ9ICgke3BrZ0Zvcm1hdH0pYCA6IHBrZ1ZlcnNpb24gfHwgXCJkZXZcIjtcbiAgaWYgKCFnW3BrZ0lkXSkge1xuICAgIGdbcGtnSWRdID0gcGtnQnVpbGRJbmZvO1xuICB9IGVsc2UgaWYgKGdbcGtnSWRdID09PSBwa2dCdWlsZEluZm8pIHtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtc2cgPSBbXG4gICAgICBgTXVsdGlwbGUgY29waWVzIG9mIExpdmVibG9ja3MgYXJlIGJlaW5nIGxvYWRlZCBpbiB5b3VyIHByb2plY3QuIFRoaXMgd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2R1cGVzRG9jcyArIFNQQUNFfWAsXG4gICAgICBcIlwiLFxuICAgICAgXCJDb25mbGljdHM6XCIsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7Z1twa2dJZF19IChhbHJlYWR5IGxvYWRlZClgLFxuICAgICAgYC0gJHtwa2dOYW1lfSAke3BrZ0J1aWxkSW5mb30gKHRyeWluZyB0byBsb2FkIHRoaXMgbm93KWBcbiAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgZXJyb3IobXNnKTtcbiAgfVxuICBpZiAocGtnVmVyc2lvbiAmJiBQS0dfVkVSU0lPTiAmJiBwa2dWZXJzaW9uICE9PSBQS0dfVkVSU0lPTikge1xuICAgIGVycm9yKFxuICAgICAgW1xuICAgICAgICBgQ3Jvc3MtbGlua2VkIHZlcnNpb25zIG9mIExpdmVibG9ja3MgZm91bmQsIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzISBTZWUgJHtjcm9zc0xpbmtlZERvY3MgKyBTUEFDRX1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgICAgYC0gJHtQS0dfTkFNRX0gaXMgYXQgJHtQS0dfVkVSU0lPTn1gLFxuICAgICAgICBgLSAke3BrZ05hbWV9IGlzIGF0ICR7cGtnVmVyc2lvbn1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkFsd2F5cyB1cGdyYWRlIGFsbCBMaXZlYmxvY2tzIHBhY2thZ2VzIHRvIHRoZSBzYW1lIHZlcnNpb24gbnVtYmVyLlwiXG4gICAgICBdLmpvaW4oXCJcXG5cIilcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb252ZXJ0LXBsYWluLWRhdGEudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnREYXRhKGRhdGEpIHtcbiAgY29uc3QgZWRpdGVkQXQgPSBkYXRhLmVkaXRlZEF0ID8gbmV3IERhdGUoZGF0YS5lZGl0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgcmVhY3Rpb25zID0gZGF0YS5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gKHtcbiAgICAuLi5yZWFjdGlvbixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHJlYWN0aW9uLmNyZWF0ZWRBdClcbiAgfSkpO1xuICBpZiAoZGF0YS5ib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXQsXG4gICAgICBkZWxldGVkQXRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREYXRhKGRhdGEpIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gIGNvbnN0IGNvbW1lbnRzID0gZGF0YS5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpXG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQsXG4gICAgdXBkYXRlZEF0LFxuICAgIGNvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoZGF0YSkge1xuICBjb25zdCBub3RpZmllZEF0ID0gbmV3IERhdGUoZGF0YS5ub3RpZmllZEF0KTtcbiAgY29uc3QgcmVhZEF0ID0gZGF0YS5yZWFkQXQgPyBuZXcgRGF0ZShkYXRhLnJlYWRBdCkgOiBudWxsO1xuICBpZiAoXCJhY3Rpdml0aWVzXCIgaW4gZGF0YSkge1xuICAgIGNvbnN0IGFjdGl2aXRpZXMgPSBkYXRhLmFjdGl2aXRpZXMubWFwKChhY3Rpdml0eSkgPT4gKHtcbiAgICAgIC4uLmFjdGl2aXR5LFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShhY3Rpdml0eS5jcmVhdGVkQXQpXG4gICAgfSkpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgbm90aWZpZWRBdCxcbiAgICAgIHJlYWRBdCxcbiAgICAgIGFjdGl2aXRpZXNcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBub3RpZmllZEF0LFxuICAgIHJlYWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbyhkYXRhKSB7XG4gIGNvbnN0IGRlbGV0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuZGVsZXRlZEF0KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGRlbGV0ZWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvKGRhdGEpIHtcbiAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgZGVsZXRlZEF0XG4gIH07XG59XG5cbi8vIHNyYy9saWIvZmFuY3ktY29uc29sZS50c1xudmFyIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFuY3lfY29uc29sZV9leHBvcnRzLCB7XG4gIGVycm9yOiAoKSA9PiBlcnJvcjIsXG4gIGVycm9yV2l0aFRpdGxlOiAoKSA9PiBlcnJvcldpdGhUaXRsZSxcbiAgd2FybjogKCkgPT4gd2FybixcbiAgd2FybldpdGhUaXRsZTogKCkgPT4gd2FybldpdGhUaXRsZVxufSk7XG52YXIgYmFkZ2UgPSBcImJhY2tncm91bmQ6IzBlMGQxMjtib3JkZXItcmFkaXVzOjk5OTlweDtjb2xvcjojZmZmO3BhZGRpbmc6M3B4IDdweDtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjYwMDtcIjtcbnZhciBib2xkID0gXCJmb250LXdlaWdodDo2MDBcIjtcbmZ1bmN0aW9uIHdyYXAobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIChtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXCIlY0xpdmVibG9ja3NcIiwgYmFkZ2UsIG1lc3NhZ2UsIC4uLmFyZ3MpXG4gICk7XG59XG52YXIgd2FybiA9IHdyYXAoXCJ3YXJuXCIpO1xudmFyIGVycm9yMiA9IHdyYXAoXCJlcnJvclwiKTtcbmZ1bmN0aW9uIHdyYXBXaXRoVGl0bGUobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICh0aXRsZSwgbWVzc2FnZSwgLi4uYXJncykgPT4gY29uc29sZVttZXRob2RdKFxuICAgICAgYCVjTGl2ZWJsb2NrcyVjICR7dGl0bGV9YCxcbiAgICAgIGJhZGdlLFxuICAgICAgYm9sZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICAuLi5hcmdzXG4gICAgKVxuICApO1xufVxudmFyIHdhcm5XaXRoVGl0bGUgPSB3cmFwV2l0aFRpdGxlKFwid2FyblwiKTtcbnZhciBlcnJvcldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJlcnJvclwiKTtcblxuLy8gc3JjL2xpYi9ndWFyZHMudHNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYmxvYikge1xuICByZXR1cm4gYmxvYiAhPT0gbnVsbCAmJiB0eXBlb2YgYmxvYiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxvYikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBpc1N0YXJ0c1dpdGhPcGVyYXRvcihibG9iKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGJsb2IpICYmIHR5cGVvZiBibG9iLnN0YXJ0c1dpdGggPT09IFwic3RyaW5nXCI7XG59XG5cbi8vIHNyYy9saWIvdXRpbHMudHNcbmZ1bmN0aW9uIHJhaXNlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGVudHJpZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopO1xufVxuZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG59XG5mdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKG9iaik7XG59XG5mdW5jdGlvbiBtYXBWYWx1ZXMob2JqLCBtYXBGbikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBwYWlyIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICBjb25zdCBrZXkgPSBwYWlyWzBdO1xuICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHBhaXJbMV07XG4gICAgcmVzdWx0W2tleV0gPSBtYXBGbih2YWx1ZSwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdHJ5UGFyc2VKc29uKHJhd01lc3NhZ2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyYXdNZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gYjY0ZGVjb2RlKGI2NHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZm9ybWF0dGVkVmFsdWUgPSBiNjR2YWx1ZS5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgICBjb25zdCBkZWNvZGVkVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoXG4gICAgICBhdG9iKGZvcm1hdHRlZFZhbHVlKS5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gXCIlXCIgKyAoXCIwMFwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgICAgfSkuam9pbihcIlwiKVxuICAgICk7XG4gICAgcmV0dXJuIGRlY29kZWRWYWx1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGF0b2IoYjY0dmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wYWN0KGl0ZW1zKSB7XG4gIHJldHVybiBpdGVtcy5maWx0ZXIoXG4gICAgKGl0ZW0pID0+IGl0ZW0gIT09IG51bGwgJiYgaXRlbSAhPT0gdm9pZCAwXG4gICk7XG59XG5mdW5jdGlvbiBjb21wYWN0T2JqZWN0KG9iaikge1xuICBjb25zdCBuZXdPYmogPSB7IC4uLm9iaiB9O1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGspID0+IHtcbiAgICBjb25zdCBrZXkgPSBrO1xuICAgIGlmIChuZXdPYmpba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxldGUgbmV3T2JqW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld09iajtcbn1cbmZ1bmN0aW9uIHdhaXQobWlsbGlzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgbWlsbGlzKSk7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoVGltZW91dChwcm9taXNlLCBtaWxsaXMsIGVycm1zZykge1xuICBsZXQgdGltZXJJRDtcbiAgY29uc3QgdGltZXIkID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgIHRpbWVySUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJybXNnKSk7XG4gICAgfSwgbWlsbGlzKTtcbiAgfSk7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVyJF0pLmZpbmFsbHkoKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVySUQpKTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVPblN1Y2Nlc3MoZmFjdG9yeUZuKSB7XG4gIGxldCBjYWNoZWQgPSBudWxsO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChjYWNoZWQgPT09IG51bGwpIHtcbiAgICAgIGNhY2hlZCA9IGZhY3RvcnlGbigpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY2FjaGVkID0gbnVsbDtcbiAgICAgICAgfSwgNWUzKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWQ7XG4gIH07XG59XG5cbi8vIHNyYy9saWIvYXV0b1JldHJ5LnRzXG52YXIgSHR0cEVycm9yID0gY2xhc3MgX0h0dHBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcmVzcG9uc2U7XG4gIGRldGFpbHM7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlc3BvbnNlLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJIdHRwRXJyb3JcIjtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgbGV0IGJvZHlBc1RleHQ7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHlBc1RleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIGNvbnN0IGJvZHlBc0pzb24gPSBib2R5QXNUZXh0ID8gdHJ5UGFyc2VKc29uKGJvZHlBc1RleHQpIDogdm9pZCAwO1xuICAgIGxldCBib2R5QXNKc29uT2JqZWN0O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHlBc0pzb24pKSB7XG4gICAgICBib2R5QXNKc29uT2JqZWN0ID0gYm9keUFzSnNvbjtcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2UgPSBcIlwiO1xuICAgIG1lc3NhZ2UgfHw9IHR5cGVvZiBib2R5QXNKc29uT2JqZWN0Py5tZXNzYWdlID09PSBcInN0cmluZ1wiID8gYm9keUFzSnNvbk9iamVjdC5tZXNzYWdlIDogXCJcIjtcbiAgICBtZXNzYWdlIHx8PSB0eXBlb2YgYm9keUFzSnNvbk9iamVjdD8uZXJyb3IgPT09IFwic3RyaW5nXCIgPyBib2R5QXNKc29uT2JqZWN0LmVycm9yIDogXCJcIjtcbiAgICBpZiAoYm9keUFzSnNvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBtZXNzYWdlIHx8PSBib2R5QXNUZXh0IHx8IFwiXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UgfHw9IHJlc3BvbnNlLnN0YXR1c1RleHQ7XG4gICAgbGV0IHBhdGg7XG4gICAgdHJ5IHtcbiAgICAgIHBhdGggPSBuZXcgVVJMKHJlc3BvbnNlLnVybCkucGF0aG5hbWU7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIG1lc3NhZ2UgKz0gcGF0aCAhPT0gdm9pZCAwID8gYCAoZ290IHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c30gZnJvbSAke3BhdGh9KWAgOiBgIChnb3Qgc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfSlgO1xuICAgIGNvbnN0IGRldGFpbHMgPSBib2R5QXNKc29uT2JqZWN0O1xuICAgIHJldHVybiBuZXcgX0h0dHBFcnJvcihtZXNzYWdlLCByZXNwb25zZSwgZGV0YWlscyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGFjY2Vzc29yIGZvciByZXNwb25zZS5zdGF0dXMuXG4gICAqL1xuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1cztcbiAgfVxufTtcbnZhciBET05UX1JFVFJZXzRYWCA9ICh4KSA9PiB4IGluc3RhbmNlb2YgSHR0cEVycm9yICYmIHguc3RhdHVzID49IDQwMCAmJiB4LnN0YXR1cyA8IDUwMDtcbmFzeW5jIGZ1bmN0aW9uIGF1dG9SZXRyeShwcm9taXNlRm4sIG1heFRyaWVzLCBiYWNrb2ZmLCBzaG91bGRTdG9wUmV0cnlpbmcgPSBET05UX1JFVFJZXzRYWCkge1xuICBjb25zdCBmYWxsYmFja0JhY2tvZmYgPSBiYWNrb2ZmLmxlbmd0aCA+IDAgPyBiYWNrb2ZmW2JhY2tvZmYubGVuZ3RoIC0gMV0gOiAwO1xuICBsZXQgYXR0ZW1wdCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgYXR0ZW1wdCsrO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZUZuKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoc2hvdWxkU3RvcFJldHJ5aW5nKGVycikpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgaWYgKGF0dGVtcHQgPj0gbWF4VHJpZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgYWZ0ZXIgJHttYXhUcmllc30gYXR0ZW1wdHM6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5ID0gYmFja29mZlthdHRlbXB0IC0gMV0gPz8gZmFsbGJhY2tCYWNrb2ZmO1xuICAgIHdhcm4oXG4gICAgICBgQXR0ZW1wdCAke2F0dGVtcHR9IHdhcyB1bnN1Y2Nlc3NmdWwuIFJldHJ5aW5nIGluICR7ZGVsYXl9IG1pbGxpc2Vjb25kcy5gXG4gICAgKTtcbiAgICBhd2FpdCB3YWl0KGRlbGF5KTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL2NvbnRyb2xsZWRQcm9taXNlLnRzXG5mdW5jdGlvbiBjb250cm9sbGVkUHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiBbcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0XTtcbn1cbmZ1bmN0aW9uIFByb21pc2Vfd2l0aFJlc29sdmVycygpIHtcbiAgY29uc3QgW3Byb21pc2UsIHJlc29sdmUsIHJlamVjdF0gPSBjb250cm9sbGVkUHJvbWlzZSgpO1xuICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn1cblxuLy8gc3JjL2xpYi9FdmVudFNvdXJjZS50c1xuZnVuY3Rpb24gbWFrZUV2ZW50U291cmNlKCkge1xuICBjb25zdCBfb2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgX29ic2VydmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiBfb2JzZXJ2ZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlT25jZShjYWxsYmFjaykge1xuICAgIGNvbnN0IHVuc3ViID0gc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgdW5zdWIoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhldmVudCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVuc3ViO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbChwcmVkaWNhdGUpIHtcbiAgICBsZXQgdW5zdWI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgIHVuc3ViID0gc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICBpZiAocHJlZGljYXRlID09PSB2b2lkIDAgfHwgcHJlZGljYXRlKGV2ZW50KSkge1xuICAgICAgICAgIHJlcyhldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdW5zdWI/LigpKTtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnkoZXZlbnQpIHtcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBfb2JzZXJ2ZXJzKSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGVkO1xuICB9XG4gIGZ1bmN0aW9uIGNvdW50KCkge1xuICAgIHJldHVybiBfb2JzZXJ2ZXJzLnNpemU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAvLyBQcml2YXRlL2ludGVybmFsIGNvbnRyb2wgb3ZlciBldmVudCBlbWlzc2lvblxuICAgIG5vdGlmeSxcbiAgICBzdWJzY3JpYmUsXG4gICAgc3Vic2NyaWJlT25jZSxcbiAgICBjb3VudCxcbiAgICB3YWl0VW50aWwsXG4gICAgW1N5bWJvbC5kaXNwb3NlXTogKCkgPT4ge1xuICAgICAgX29ic2VydmVycy5jbGVhcigpO1xuICAgIH0sXG4gICAgLy8gUHVibGljbHkgZXhwb3NhYmxlIHN1YnNjcmlwdGlvbiBBUElcbiAgICBvYnNlcnZhYmxlOiB7XG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBzdWJzY3JpYmVPbmNlLFxuICAgICAgd2FpdFVudGlsXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbWFrZUJ1ZmZlcmFibGVFdmVudFNvdXJjZSgpIHtcbiAgY29uc3QgZXZlbnRTb3VyY2UyID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGxldCBfYnVmZmVyID0gbnVsbDtcbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgX2J1ZmZlciA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKF9idWZmZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBfYnVmZmVyKSB7XG4gICAgICBldmVudFNvdXJjZTIubm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gICAgX2J1ZmZlciA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5T3JCdWZmZXIoZXZlbnQpIHtcbiAgICBpZiAoX2J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgX2J1ZmZlci5wdXNoKGV2ZW50KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV2ZW50U291cmNlMi5ub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmV2ZW50U291cmNlMixcbiAgICBub3RpZnk6IG5vdGlmeU9yQnVmZmVyLFxuICAgIHBhdXNlLFxuICAgIHVucGF1c2UsXG4gICAgW1N5bWJvbC5kaXNwb3NlXTogKCkgPT4ge1xuICAgICAgZXZlbnRTb3VyY2UyW1N5bWJvbC5kaXNwb3NlXSgpO1xuICAgICAgaWYgKF9idWZmZXIgIT09IG51bGwpIHtcbiAgICAgICAgX2J1ZmZlci5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9mcmVlemUudHNcbnZhciBmcmVlemUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyAoXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICh4KSA9PiB4XG4pIDogT2JqZWN0LmZyZWV6ZTtcblxuLy8gc3JjL2xpYi9zaWduYWxzLnRzXG52YXIga1NpbmtzID0gU3ltYm9sKFwia1NpbmtzXCIpO1xudmFyIGtUcmlnZ2VyID0gU3ltYm9sKFwia1RyaWdnZXJcIik7XG52YXIgc2lnbmFsc1RvVHJpZ2dlciA9IG51bGw7XG52YXIgdHJhY2tlZFJlYWRzID0gbnVsbDtcbmZ1bmN0aW9uIGJhdGNoKGNhbGxiYWNrKSB7XG4gIGlmIChzaWduYWxzVG9UcmlnZ2VyICE9PSBudWxsKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc2lnbmFsc1RvVHJpZ2dlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHRyeSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmb3IgKGNvbnN0IHNpZ25hbCBvZiBzaWduYWxzVG9UcmlnZ2VyKSB7XG4gICAgICBzaWduYWxba1RyaWdnZXJdKCk7XG4gICAgfVxuICAgIHNpZ25hbHNUb1RyaWdnZXIgPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlVHJpZ2dlcihzaWduYWwpIHtcbiAgaWYgKCFzaWduYWxzVG9UcmlnZ2VyKSByYWlzZShcIkV4cGVjdGVkIHRvIGJlIGluIGFuIGFjdGl2ZSBiYXRjaFwiKTtcbiAgc2lnbmFsc1RvVHJpZ2dlci5hZGQoc2lnbmFsKTtcbn1cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgcGF0Y2gpIHtcbiAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgY29uc3QgbmV3VmFsdWUgPSB7IC4uLnRhcmdldCB9O1xuICBPYmplY3Qua2V5cyhwYXRjaCkuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgY29uc3QgdmFsID0gcGF0Y2hba2V5XTtcbiAgICBpZiAobmV3VmFsdWVba2V5XSAhPT0gdmFsKSB7XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVsZXRlIG5ld1ZhbHVlW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZVtrZXldID0gdmFsO1xuICAgICAgfVxuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZWQgPyBuZXdWYWx1ZSA6IHRhcmdldDtcbn1cbnZhciBBYnN0cmFjdFNpZ25hbCA9IGNsYXNzIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBlcXVhbHM7XG4gICNldmVudFNvdXJjZTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBba1NpbmtzXTtcbiAgY29uc3RydWN0b3IoZXF1YWxzKSB7XG4gICAgdGhpcy5lcXVhbHMgPSBlcXVhbHMgPz8gT2JqZWN0LmlzO1xuICAgIHRoaXMuI2V2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gICAgdGhpc1trU2lua3NdID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmdldCA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdWJzY3JpYmUgPSB0aGlzLnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3Vic2NyaWJlT25jZSA9IHRoaXMuc3Vic2NyaWJlT25jZS5iaW5kKHRoaXMpO1xuICB9XG4gIFtTeW1ib2wuZGlzcG9zZV0oKSB7XG4gICAgdGhpcy4jZXZlbnRTb3VyY2VbU3ltYm9sLmRpc3Bvc2VdKCk7XG4gICAgdGhpcy4jZXZlbnRTb3VyY2UgPSBcIihkaXNwb3NlZClcIjtcbiAgICB0aGlzLmVxdWFscyA9IFwiKGRpc3Bvc2VkKVwiO1xuICB9XG4gIGdldCBoYXNXYXRjaGVycygpIHtcbiAgICBpZiAodGhpcy4jZXZlbnRTb3VyY2UuY291bnQoKSA+IDApIHJldHVybiB0cnVlO1xuICAgIGZvciAoY29uc3Qgc2luayBvZiB0aGlzW2tTaW5rc10pIHtcbiAgICAgIGlmIChzaW5rLmhhc1dhdGNoZXJzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgW2tUcmlnZ2VyXSgpIHtcbiAgICB0aGlzLiNldmVudFNvdXJjZS5ub3RpZnkoKTtcbiAgICBmb3IgKGNvbnN0IHNpbmsgb2YgdGhpc1trU2lua3NdKSB7XG4gICAgICBlbnF1ZXVlVHJpZ2dlcihzaW5rKTtcbiAgICB9XG4gIH1cbiAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuI2V2ZW50U291cmNlLmNvdW50KCkgPT09IDApIHtcbiAgICAgIHRoaXMuZ2V0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNldmVudFNvdXJjZS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICB9XG4gIHN1YnNjcmliZU9uY2UoY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bnN1YiA9IHRoaXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHVuc3ViKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5zdWI7XG4gIH1cbiAgd2FpdFVudGlsKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIndhaXRVbnRpbCBub3Qgc3VwcG9ydGVkIG9uIFNpZ25hbHNcIik7XG4gIH1cbiAgbWFya1NpbmtzRGlydHkoKSB7XG4gICAgZm9yIChjb25zdCBzaW5rIG9mIHRoaXNba1NpbmtzXSkge1xuICAgICAgc2luay5tYXJrRGlydHkoKTtcbiAgICB9XG4gIH1cbiAgYWRkU2luayhzaW5rKSB7XG4gICAgdGhpc1trU2lua3NdLmFkZChzaW5rKTtcbiAgfVxuICByZW1vdmVTaW5rKHNpbmspIHtcbiAgICB0aGlzW2tTaW5rc10uZGVsZXRlKHNpbmspO1xuICB9XG4gIGFzUmVhZG9ubHkoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgU2lnbmFsID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFNpZ25hbCB7XG4gICN2YWx1ZTtcbiAgY29uc3RydWN0b3IodmFsdWUsIGVxdWFscykge1xuICAgIHN1cGVyKGVxdWFscyk7XG4gICAgdGhpcy4jdmFsdWUgPSBmcmVlemUodmFsdWUpO1xuICB9XG4gIFtTeW1ib2wuZGlzcG9zZV0oKSB7XG4gICAgc3VwZXJbU3ltYm9sLmRpc3Bvc2VdKCk7XG4gICAgdGhpcy4jdmFsdWUgPSBcIihkaXNwb3NlZClcIjtcbiAgfVxuICBnZXQoKSB7XG4gICAgdHJhY2tlZFJlYWRzPy5hZGQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuI3ZhbHVlO1xuICB9XG4gIHNldChuZXdWYWx1ZSkge1xuICAgIGJhdGNoKCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbmV3VmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlKHRoaXMuI3ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5lcXVhbHModGhpcy4jdmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICB0aGlzLiN2YWx1ZSA9IGZyZWV6ZShuZXdWYWx1ZSk7XG4gICAgICAgIHRoaXMubWFya1NpbmtzRGlydHkoKTtcbiAgICAgICAgZW5xdWV1ZVRyaWdnZXIodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG52YXIgUGF0Y2hhYmxlU2lnbmFsID0gY2xhc3MgZXh0ZW5kcyBTaWduYWwge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoZnJlZXplKGNvbXBhY3RPYmplY3QoZGF0YSkpKTtcbiAgfVxuICBzZXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRG9uJ3QgY2FsbCAuc2V0KCkgZGlyZWN0bHksIHVzZSAucGF0Y2goKVwiKTtcbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgY3VycmVudCBvYmplY3QuXG4gICAqL1xuICBwYXRjaChwYXRjaCkge1xuICAgIHN1cGVyLnNldCgob2xkKSA9PiBtZXJnZShvbGQsIHBhdGNoKSk7XG4gIH1cbn07XG52YXIgSU5JVElBTCA9IFN5bWJvbCgpO1xudmFyIERlcml2ZWRTaWduYWwgPSBjbGFzcyBfRGVyaXZlZFNpZ25hbCBleHRlbmRzIEFic3RyYWN0U2lnbmFsIHtcbiAgI3ByZXZWYWx1ZTtcbiAgI2RpcnR5O1xuICAvLyBXaGVuIHRydWUsIHRoZSB2YWx1ZSBpbiAjdmFsdWUgbWF5IG5vdCBiZSB1cC10by1kYXRlIGFuZCBuZWVkcyByZS1jaGVja2luZ1xuICAjc291cmNlcztcbiAgI2RlcHM7XG4gICN0cmFuc2Zvcm07XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBzdGF0aWMgZnJvbSguLi5hcmdzKSB7XG4gICAgY29uc3QgbGFzdCA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBsYXN0ICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByYWlzZShcIkludmFsaWQgLmZyb20oKSBjYWxsLCBsYXN0IGFyZ3VtZW50IGV4cGVjdGVkIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgZXF1YWxzID0gbGFzdDtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGFyZ3MucG9wKCk7XG4gICAgICByZXR1cm4gbmV3IF9EZXJpdmVkU2lnbmFsKGFyZ3MsIHRyYW5zZm9ybSwgZXF1YWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gbGFzdDtcbiAgICAgIHJldHVybiBuZXcgX0Rlcml2ZWRTaWduYWwoYXJncywgdHJhbnNmb3JtKTtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IoZGVwcywgdHJhbnNmb3JtLCBlcXVhbHMpIHtcbiAgICBzdXBlcihlcXVhbHMpO1xuICAgIHRoaXMuI2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLiNwcmV2VmFsdWUgPSBJTklUSUFMO1xuICAgIHRoaXMuI2RlcHMgPSBkZXBzO1xuICAgIHRoaXMuI3NvdXJjZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuI3RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgfVxuICBbU3ltYm9sLmRpc3Bvc2VdKCkge1xuICAgIGZvciAoY29uc3Qgc3JjIG9mIHRoaXMuI3NvdXJjZXMpIHtcbiAgICAgIHNyYy5yZW1vdmVTaW5rKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLiNwcmV2VmFsdWUgPSBcIihkaXNwb3NlZClcIjtcbiAgICB0aGlzLiNzb3VyY2VzID0gXCIoZGlzcG9zZWQpXCI7XG4gICAgdGhpcy4jZGVwcyA9IFwiKGRpc3Bvc2VkKVwiO1xuICAgIHRoaXMuI3RyYW5zZm9ybSA9IFwiKGRpc3Bvc2VkKVwiO1xuICB9XG4gIGdldCBpc0RpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLiNkaXJ0eTtcbiAgfVxuICAjcmVjb21wdXRlKCkge1xuICAgIGNvbnN0IG9sZFRyYWNrZWRSZWFkcyA9IHRyYWNrZWRSZWFkcztcbiAgICBsZXQgZGVyaXZlZDtcbiAgICB0cmFja2VkUmVhZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRyeSB7XG4gICAgICBkZXJpdmVkID0gdGhpcy4jdHJhbnNmb3JtKC4uLnRoaXMuI2RlcHMubWFwKChwKSA9PiBwLmdldCgpKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNvbnN0IG9sZFNvdXJjZXMgPSB0aGlzLiNzb3VyY2VzO1xuICAgICAgdGhpcy4jc291cmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IHNpZyBvZiB0cmFja2VkUmVhZHMpIHtcbiAgICAgICAgdGhpcy4jc291cmNlcy5hZGQoc2lnKTtcbiAgICAgICAgb2xkU291cmNlcy5kZWxldGUoc2lnKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgb2xkU291cmNlIG9mIG9sZFNvdXJjZXMpIHtcbiAgICAgICAgb2xkU291cmNlLnJlbW92ZVNpbmsodGhpcyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG5ld1NvdXJjZSBvZiB0aGlzLiNzb3VyY2VzKSB7XG4gICAgICAgIG5ld1NvdXJjZS5hZGRTaW5rKHRoaXMpO1xuICAgICAgfVxuICAgICAgdHJhY2tlZFJlYWRzID0gb2xkVHJhY2tlZFJlYWRzO1xuICAgIH1cbiAgICB0aGlzLiNkaXJ0eSA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5lcXVhbHModGhpcy4jcHJldlZhbHVlLCBkZXJpdmVkKSkge1xuICAgICAgdGhpcy4jcHJldlZhbHVlID0gZGVyaXZlZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWFya0RpcnR5KCkge1xuICAgIGlmICghdGhpcy4jZGlydHkpIHtcbiAgICAgIHRoaXMuI2RpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMubWFya1NpbmtzRGlydHkoKTtcbiAgICB9XG4gIH1cbiAgZ2V0KCkge1xuICAgIGlmICh0aGlzLiNkaXJ0eSkge1xuICAgICAgdGhpcy4jcmVjb21wdXRlKCk7XG4gICAgfVxuICAgIHRyYWNrZWRSZWFkcz8uYWRkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLiNwcmV2VmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCBieSB0aGUgU2lnbmFsIHN5c3RlbSBpZiBvbmUgb3IgbW9yZSBvZiB0aGUgZGVwZW5kZW50IHNpZ25hbHMgaGF2ZVxuICAgKiBjaGFuZ2VkLiBJbiB0aGUgY2FzZSBvZiBhIERlcml2ZWRTaWduYWwsIHdlJ2xsIG9ubHkgd2FudCB0byByZS1ldmFsdWF0ZVxuICAgKiB0aGUgYWN0dWFsIHZhbHVlIGlmIGl0J3MgYmVpbmcgd2F0Y2hlZCwgb3IgYW55IG9mIHRoZWlyIHNpbmtzIGFyZSBiZWluZ1xuICAgKiB3YXRjaGVkIGFjdGl2ZWx5LlxuICAgKi9cbiAgW2tUcmlnZ2VyXSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzV2F0Y2hlcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZCA9IHRoaXMuI3JlY29tcHV0ZSgpO1xuICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICBzdXBlcltrVHJpZ2dlcl0oKTtcbiAgICB9XG4gIH1cbn07XG52YXIgTXV0YWJsZVNpZ25hbCA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RTaWduYWwge1xuICAjc3RhdGU7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxTdGF0ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIH1cbiAgW1N5bWJvbC5kaXNwb3NlXSgpIHtcbiAgICBzdXBlcltTeW1ib2wuZGlzcG9zZV0oKTtcbiAgICB0aGlzLiNzdGF0ZSA9IFwiKGRpc3Bvc2VkKVwiO1xuICB9XG4gIGdldCgpIHtcbiAgICB0cmFja2VkUmVhZHM/LmFkZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy4jc3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEludm9rZXMgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGFsbG93ZWQgdG8gbXV0YXRlIHRoZSBnaXZlbiBzdGF0ZVxuICAgKiB2YWx1ZS4gRG8gbm90IGNoYW5nZSB0aGUgdmFsdWUgb3V0c2lkZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIElmIHRoZSBjYWxsYmFjayBleHBsaWNpdGx5IHJldHVybnMgYGZhbHNlYCwgaXQncyBhc3N1bWVkIHRoYXQgdGhlIHN0YXRlXG4gICAqIHdhcyBub3QgY2hhbmdlZC5cbiAgICovXG4gIG11dGF0ZShjYWxsYmFjaykge1xuICAgIGJhdGNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrID8gY2FsbGJhY2sodGhpcy4jc3RhdGUpIDogdHJ1ZTtcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiBcInRoZW5cIiBpbiByZXN1bHQpIHtcbiAgICAgICAgcmFpc2UoXCJNdXRhYmxlU2lnbmFsLm11dGF0ZSgpIGRvZXMgbm90IHN1cHBvcnQgYXN5bmMgY2FsbGJhY2tzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5tYXJrU2lua3NEaXJ0eSgpO1xuICAgICAgICBlbnF1ZXVlVHJpZ2dlcih0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9zdHJpbmdpZnkudHNcbmZ1bmN0aW9uIHJlcGxhY2VyKF9rZXksIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpID8gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKS5yZWR1Y2UoKHNvcnRlZCwga2V5KSA9PiB7XG4gICAgc29ydGVkW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgIHJldHVybiBzb3J0ZWQ7XG4gIH0sIHt9KSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc3RhYmxlU3RyaW5naWZ5KHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5T3JMb2codmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3Qgc3RyaW5naWZ5OiAke2Vyci5tZXNzYWdlfWApO1xuICAgIGNvbnNvbGUuZXJyb3IodmFsdWUpO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG4vLyBzcmMvbGliL2JhdGNoLnRzXG52YXIgREVGQVVMVF9TSVpFID0gNTA7XG52YXIgQmF0Y2hDYWxsID0gY2xhc3Mge1xuICBpbnB1dDtcbiAgcmVzb2x2ZTtcbiAgcmVqZWN0O1xuICBwcm9taXNlO1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICB9XG59O1xudmFyIEJhdGNoID0gY2xhc3Mge1xuICAjcXVldWUgPSBbXTtcbiAgI2NhbGxiYWNrO1xuICAjc2l6ZTtcbiAgI2RlbGF5O1xuICAjZGVsYXlUaW1lb3V0SWQ7XG4gIGVycm9yID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdGhpcy4jY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLiNzaXplID0gb3B0aW9ucy5zaXplID8/IERFRkFVTFRfU0laRTtcbiAgICB0aGlzLiNkZWxheSA9IG9wdGlvbnMuZGVsYXk7XG4gIH1cbiAgI2NsZWFyRGVsYXlUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLiNkZWxheVRpbWVvdXRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZGVsYXlUaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jZGVsYXlUaW1lb3V0SWQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gICNzY2hlZHVsZSgpIHtcbiAgICBpZiAodGhpcy4jcXVldWUubGVuZ3RoID09PSB0aGlzLiNzaXplKSB7XG4gICAgICB2b2lkIHRoaXMuI2ZsdXNoKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNxdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuI2NsZWFyRGVsYXlUaW1lb3V0KCk7XG4gICAgICB0aGlzLiNkZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gdm9pZCB0aGlzLiNmbHVzaCgpLCB0aGlzLiNkZWxheSk7XG4gICAgfVxuICB9XG4gIGFzeW5jICNmbHVzaCgpIHtcbiAgICBpZiAodGhpcy4jcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhbGxzID0gdGhpcy4jcXVldWUuc3BsaWNlKDApO1xuICAgIGNvbnN0IGlucHV0cyA9IGNhbGxzLm1hcCgoY2FsbCkgPT4gY2FsbC5pbnB1dCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLiNjYWxsYmFjayhpbnB1dHMpO1xuICAgICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgICAgY2FsbHMuZm9yRWFjaCgoY2FsbCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0cz8uW2luZGV4XTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QobmV3IEVycm9yKFwiQ2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gYXJyYXkuXCIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYWxscy5sZW5ndGggIT09IHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBDYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheSBvZiB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIG51bWJlciBvZiBwcm92aWRlZCBpdGVtcy4gRXhwZWN0ZWQgJHtjYWxscy5sZW5ndGh9LCBidXQgZ290ICR7cmVzdWx0cy5sZW5ndGh9LmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICB0aGlzLmVycm9yID0gdHJ1ZTtcbiAgICAgIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICAgICAgY2FsbC5yZWplY3QoZXJyb3IzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQoaW5wdXQpIHtcbiAgICBjb25zdCBleGlzdGluZ0NhbGwgPSB0aGlzLiNxdWV1ZS5maW5kKFxuICAgICAgKGNhbGwyKSA9PiBzdGFibGVTdHJpbmdpZnkoY2FsbDIuaW5wdXQpID09PSBzdGFibGVTdHJpbmdpZnkoaW5wdXQpXG4gICAgKTtcbiAgICBpZiAoZXhpc3RpbmdDYWxsKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdDYWxsLnByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IGNhbGwgPSBuZXcgQmF0Y2hDYWxsKGlucHV0KTtcbiAgICB0aGlzLiNxdWV1ZS5wdXNoKGNhbGwpO1xuICAgIHRoaXMuI3NjaGVkdWxlKCk7XG4gICAgcmV0dXJuIGNhbGwucHJvbWlzZTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLiNxdWV1ZSA9IFtdO1xuICAgIHRoaXMuZXJyb3IgPSBmYWxzZTtcbiAgICB0aGlzLiNjbGVhckRlbGF5VGltZW91dCgpO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlQmF0Y2hTdG9yZShiYXRjaDIpIHtcbiAgY29uc3Qgc2lnbmFsID0gbmV3IE11dGFibGVTaWduYWwoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIGZ1bmN0aW9uIGdldENhY2hlS2V5KGFyZ3MpIHtcbiAgICByZXR1cm4gc3RhYmxlU3RyaW5naWZ5KGFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZShjYWNoZUtleSwgc3RhdGUpIHtcbiAgICBzaWduYWwubXV0YXRlKChjYWNoZSkgPT4ge1xuICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZShpbnB1dHMpIHtcbiAgICBzaWduYWwubXV0YXRlKChjYWNoZSkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXRzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICAgIGNhY2hlLmRlbGV0ZShnZXRDYWNoZUtleShpbnB1dCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVucXVldWUoaW5wdXQpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGlucHV0KTtcbiAgICBjb25zdCBjYWNoZSA9IHNpZ25hbC5nZXQoKTtcbiAgICBpZiAoY2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdXBkYXRlKGNhY2hlS2V5LCB7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhdGNoMi5nZXQoaW5wdXQpO1xuICAgICAgdXBkYXRlKGNhY2hlS2V5LCB7IGlzTG9hZGluZzogZmFsc2UsIGRhdGE6IHJlc3VsdCB9KTtcbiAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgIHVwZGF0ZShjYWNoZUtleSwge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SXRlbVN0YXRlKGlucHV0KSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShpbnB1dCk7XG4gICAgY29uc3QgY2FjaGUgPSBzaWduYWwuZ2V0KCk7XG4gICAgcmV0dXJuIGNhY2hlLmdldChjYWNoZUtleSk7XG4gIH1cbiAgZnVuY3Rpb24gX2NhY2hlS2V5cygpIHtcbiAgICBjb25zdCBjYWNoZSA9IHNpZ25hbC5nZXQoKTtcbiAgICByZXR1cm4gWy4uLmNhY2hlLmtleXMoKV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdWJzY3JpYmU6IHNpZ25hbC5zdWJzY3JpYmUsXG4gICAgZW5xdWV1ZSxcbiAgICBnZXRJdGVtU3RhdGUsXG4gICAgaW52YWxpZGF0ZSxcbiAgICBiYXRjaDogYmF0Y2gyLFxuICAgIF9jYWNoZUtleXNcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9jaHVuay50c1xuZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUpIHtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSArPSBzaXplKSB7XG4gICAgY2h1bmtzLnB1c2goYXJyYXkuc2xpY2UoaSwgaSArIHNpemUpKTtcbiAgfVxuICByZXR1cm4gY2h1bmtzO1xufVxuXG4vLyBzcmMvbGliL25hbm9pZC50c1xudmFyIG5hbm9pZCA9ICh0ID0gMjEpID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkodCkpLnJlZHVjZShcbiAgKHQyLCBlKSA9PiB0MiArPSAoZSAmPSA2MykgPCAzNiA/IGUudG9TdHJpbmcoMzYpIDogZSA8IDYyID8gKGUgLSAyNikudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCkgOiBlIDwgNjMgPyBcIl9cIiA6IFwiLVwiLFxuICBcIlwiXG4pO1xuXG4vLyBzcmMvbGliL2NyZWF0ZUlkcy50c1xudmFyIFRIUkVBRF9JRF9QUkVGSVggPSBcInRoXCI7XG52YXIgQ09NTUVOVF9JRF9QUkVGSVggPSBcImNtXCI7XG52YXIgQ09NTUVOVF9BVFRBQ0hNRU5UX0lEX1BSRUZJWCA9IFwiYXRcIjtcbnZhciBJTkJPWF9OT1RJRklDQVRJT05fSURfUFJFRklYID0gXCJpblwiO1xuZnVuY3Rpb24gY3JlYXRlT3B0aW1pc3RpY0lkKHByZWZpeCkge1xuICByZXR1cm4gYCR7cHJlZml4fV8ke25hbm9pZCgpfWA7XG59XG5mdW5jdGlvbiBjcmVhdGVUaHJlYWRJZCgpIHtcbiAgcmV0dXJuIGNyZWF0ZU9wdGltaXN0aWNJZChUSFJFQURfSURfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRJZCgpIHtcbiAgcmV0dXJuIGNyZWF0ZU9wdGltaXN0aWNJZChDT01NRU5UX0lEX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50QXR0YWNobWVudElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKENPTU1FTlRfQVRUQUNITUVOVF9JRF9QUkVGSVgpO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5ib3hOb3RpZmljYXRpb25JZCgpIHtcbiAgcmV0dXJuIGNyZWF0ZU9wdGltaXN0aWNJZChJTkJPWF9OT1RJRklDQVRJT05fSURfUFJFRklYKTtcbn1cblxuLy8gc3JjL2xpYi9EZWZhdWx0TWFwLnRzXG52YXIgRGVmYXVsdE1hcCA9IGNsYXNzIGV4dGVuZHMgTWFwIHtcbiAgI2RlZmF1bHRGbjtcbiAgLyoqXG4gICAqIElmIHRoZSBkZWZhdWx0IGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IsIGl0IGhhcyB0byBiZVxuICAgKiBwcm92aWRlZCBpbiBlYWNoIC5nZXRPckNyZWF0ZSgpIGNhbGwgaW5kaXZpZHVhbGx5LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGVmYXVsdEZuLCBlbnRyaWVzMikge1xuICAgIHN1cGVyKGVudHJpZXMyKTtcbiAgICB0aGlzLiNkZWZhdWx0Rm4gPSBkZWZhdWx0Rm47XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBrZXksIG9yIGNyZWF0ZXMgaXQuXG4gICAqXG4gICAqIERpZmZlcmVuY2UgZnJvbSBub3JtYWwgTWFwOiBpZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCBpdCB3aWxsIGJlIGNyZWF0ZWRcbiAgICogb24gdGhlIGZseSB1c2luZyB0aGUgZmFjdG9yeSBmdW5jdGlvbiwgYW5kIHRoYXQgdmFsdWUgd2lsbCBnZXQgcmV0dXJuZWRcbiAgICogaW5zdGVhZCBvZiBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGdldE9yQ3JlYXRlKGtleSwgZGVmYXVsdEZuKSB7XG4gICAgaWYgKHN1cGVyLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZuID0gZGVmYXVsdEZuID8/IHRoaXMuI2RlZmF1bHRGbiA/PyByYWlzZShcIkRlZmF1bHRNYXAgdXNlZCB3aXRob3V0IGEgZmFjdG9yeSBmdW5jdGlvblwiKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZm4oa2V5KTtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2xpYi9vYmplY3RUb1F1ZXJ5LnRzXG52YXIgaWRlbnRpZmllclJlZ2V4ID0gL15bYS16QS1aX11bYS16QS1aMC05X10qJC87XG5mdW5jdGlvbiBvYmplY3RUb1F1ZXJ5KG9iaikge1xuICBsZXQgZmlsdGVyTGlzdCA9IFtdO1xuICBjb25zdCBlbnRyaWVzMiA9IE9iamVjdC5lbnRyaWVzKG9iaik7XG4gIGNvbnN0IGtleVZhbHVlUGFpcnMgPSBbXTtcbiAgY29uc3Qga2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvciA9IFtdO1xuICBjb25zdCBpbmRleGVkS2V5cyA9IFtdO1xuICBlbnRyaWVzMi5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoIWlkZW50aWZpZXJSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBtdXN0IG9ubHkgY29udGFpbiBsZXR0ZXJzLCBudW1iZXJzLCBfXCIpO1xuICAgIH1cbiAgICBpZiAoaXNTaW1wbGVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGtleVZhbHVlUGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGlmIChpc1N0YXJ0c1dpdGhPcGVyYXRvcih2YWx1ZSkpIHtcbiAgICAgICAga2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvci5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleGVkS2V5cy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZmlsdGVyTGlzdCA9IFtcbiAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnMoa2V5VmFsdWVQYWlycyksXG4gICAgLi4uZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IpXG4gIF07XG4gIGluZGV4ZWRLZXlzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IG5lc3RlZEVudHJpZXMgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gICAgY29uc3QgbktleVZhbHVlUGFpcnMgPSBbXTtcbiAgICBjb25zdCBuS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvciA9IFtdO1xuICAgIG5lc3RlZEVudHJpZXMuZm9yRWFjaCgoW25lc3RlZEtleSwgbmVzdGVkVmFsdWVdKSA9PiB7XG4gICAgICBpZiAoaXNTdHJpbmdFbXB0eShuZXN0ZWRLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXNTaW1wbGVWYWx1ZShuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgbktleVZhbHVlUGFpcnMucHVzaChbZm9ybWF0RmlsdGVyS2V5KGtleSwgbmVzdGVkS2V5KSwgbmVzdGVkVmFsdWVdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTdGFydHNXaXRoT3BlcmF0b3IobmVzdGVkVmFsdWUpKSB7XG4gICAgICAgIG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLnB1c2goW1xuICAgICAgICAgIGZvcm1hdEZpbHRlcktleShrZXksIG5lc3RlZEtleSksXG4gICAgICAgICAgbmVzdGVkVmFsdWVcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZmlsdGVyTGlzdCA9IFtcbiAgICAgIC4uLmZpbHRlckxpc3QsXG4gICAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnMobktleVZhbHVlUGFpcnMpLFxuICAgICAgLi4uZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKVxuICAgIF07XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyTGlzdC5tYXAoKHsga2V5LCBvcGVyYXRvciwgdmFsdWUgfSkgPT4gYCR7a2V5fSR7b3BlcmF0b3J9JHtxdW90ZSh2YWx1ZSl9YCkuam9pbihcIiBcIik7XG59XG52YXIgZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzID0gKGtleVZhbHVlUGFpcnMpID0+IHtcbiAgY29uc3QgZmlsdGVycyA9IFtdO1xuICBrZXlWYWx1ZVBhaXJzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICBrZXksXG4gICAgICBvcGVyYXRvcjogXCI6XCIsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcnM7XG59O1xudmFyIGdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvciA9IChrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKSA9PiB7XG4gIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAga2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvci5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoXCJzdGFydHNXaXRoXCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnN0YXJ0c1dpdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgb3BlcmF0b3I6IFwiXlwiLFxuICAgICAgICB2YWx1ZTogdmFsdWUuc3RhcnRzV2l0aFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZpbHRlcnM7XG59O1xudmFyIGlzU2ltcGxlVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PT0gbnVsbDtcbn07XG52YXIgZm9ybWF0RmlsdGVyS2V5ID0gKGtleSwgbmVzdGVkS2V5KSA9PiB7XG4gIGlmIChuZXN0ZWRLZXkpIHtcbiAgICByZXR1cm4gYCR7a2V5fVske3F1b3RlKG5lc3RlZEtleSl9XWA7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn07XG52YXIgaXNTdHJpbmdFbXB0eSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gIXZhbHVlIHx8IHZhbHVlLnRvU3RyaW5nKCkudHJpbSgpID09PSBcIlwiO1xufTtcbmZ1bmN0aW9uIHF1b3RlKGlucHV0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKHJlc3VsdC5pbmNsdWRlcyhcIidcIikpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiBgJyR7cmVzdWx0LnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJyl9J2A7XG59XG5cbi8vIHNyYy9saWIvdXJsLnRzXG5mdW5jdGlvbiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVybGpvaW4oYmFzZVVybCwgcGF0aCwgcGFyYW1zKSB7XG4gIGNvbnN0IHVybDIgPSBuZXcgVVJMKHBhdGgsIGJhc2VVcmwpO1xuICBpZiAocGFyYW1zICE9PSB2b2lkIDApIHtcbiAgICB1cmwyLnNlYXJjaCA9IChwYXJhbXMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBwYXJhbXMgOiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB1cmwyLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB1cmwoc3RyaW5ncywgLi4udmFsdWVzMikge1xuICByZXR1cm4gc3RyaW5ncy5yZWR1Y2UoXG4gICAgKHJlc3VsdCwgc3RyLCBpKSA9PiByZXN1bHQgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWVzMltpIC0gMV0gPz8gXCJcIikgKyBzdHJcbiAgKTtcbn1cblxuLy8gc3JjL2FwaS1jbGllbnQudHNcbmZ1bmN0aW9uIGNyZWF0ZUFwaUNsaWVudCh7XG4gIGJhc2VVcmwsXG4gIGF1dGhNYW5hZ2VyLFxuICBmZXRjaFBvbHlmaWxsXG59KSB7XG4gIGNvbnN0IGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudChiYXNlVXJsLCBmZXRjaFBvbHlmaWxsKTtcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkc1NpbmNlKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzL2RlbHRhYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHNpbmNlOiBvcHRpb25zLnNpbmNlLnRvSVNPU3RyaW5nKClcbiAgICAgIH0sXG4gICAgICB7IHNpZ25hbDogb3B0aW9ucy5zaWduYWwgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgdXBkYXRlZDogcmVzdWx0LmRhdGEubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgICBkZWxldGVkOiByZXN1bHQuZGVsZXRlZFRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8pXG4gICAgICB9LFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiB7XG4gICAgICAgIHVwZGF0ZWQ6IHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMubWFwKGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IHJlc3VsdC5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm9cbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShyZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdCksXG4gICAgICBwZXJtaXNzaW9uSGludHM6IHJlc3VsdC5tZXRhLnBlcm1pc3Npb25IaW50c1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkcyhvcHRpb25zKSB7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChvcHRpb25zLnF1ZXJ5KSB7XG4gICAgICBxdWVyeSA9IG9iamVjdFRvUXVlcnkob3B0aW9ucy5xdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IFBBR0VfU0laRSA9IDUwO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHNgLFxuICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICAgIH0pLFxuICAgICAgICB7XG4gICAgICAgICAgY3Vyc29yOiBvcHRpb25zLmN1cnNvcixcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICBsaW1pdDogUEFHRV9TSVpFXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWRzOiByZXN1bHQuZGF0YS5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhXG4gICAgICAgICksXG4gICAgICAgIG5leHRDdXJzb3I6IHJlc3VsdC5tZXRhLm5leHRDdXJzb3IsXG4gICAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShyZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdCksXG4gICAgICAgIHBlcm1pc3Npb25IaW50czogcmVzdWx0Lm1ldGEucGVybWlzc2lvbkhpbnRzXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEh0dHBFcnJvciAmJiBlcnIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0aHJlYWRzOiBbXSxcbiAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IFtdLFxuICAgICAgICAgIG5leHRDdXJzb3I6IG51bGwsXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBIQUNLXG4gICAgICAgICAgLy8gcmVxdWVzdGVkQXQgbmVlZHMgdG8gYmUgYSAqc2VydmVyKiB0aW1lc3RhbXAgaGVyZS4gSG93ZXZlciwgb25cbiAgICAgICAgICAvLyB0aGlzIDQwNCBlcnJvciByZXNwb25zZSwgdGhlcmUgaXMgbm8gc3VjaCB0aW1lc3RhbXAuIFNvIG91dCBvZlxuICAgICAgICAgIC8vIHB1cmUgbmVjZXNzaXR5IHdlJ2xsIGZhbGwgYmFjayB0byBhIGxvY2FsIHRpbWVzdGFtcCBpbnN0ZWFkIChhbmRcbiAgICAgICAgICAvLyBhbGxvdyBmb3IgYSBwb3NzaWJsZSA2IGhvdXIgY2xvY2sgZGlmZmVyZW5jZSBiZXR3ZWVuIGNsaWVudCBhbmRcbiAgICAgICAgICAvLyBzZXJ2ZXIpLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSA2ICogNjAgKiA2MCAqIDFlMyksXG4gICAgICAgICAgcGVybWlzc2lvbkhpbnRzOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUaHJlYWQob3B0aW9ucykge1xuICAgIGNvbnN0IGNvbW1lbnRJZCA9IG9wdGlvbnMuY29tbWVudElkID8/IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgIGNvbnN0IHRocmVhZElkID0gb3B0aW9ucy50aHJlYWRJZCA/PyBjcmVhdGVUaHJlYWRJZCgpO1xuICAgIGNvbnN0IHRocmVhZCA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIGlkOiB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudDoge1xuICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgICAgIGF0dGFjaG1lbnRJZHM6IG9wdGlvbnMuYXR0YWNobWVudElkc1xuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVUaHJlYWQob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQuZGVsZXRlKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWQob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5yYXdHZXQoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkLXdpdGgtbm90aWZpY2F0aW9uLyR7b3B0aW9ucy50aHJlYWRJZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkOiBjb252ZXJ0VG9UaHJlYWREYXRhKGpzb24udGhyZWFkKSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb246IGpzb24uaW5ib3hOb3RpZmljYXRpb24gPyBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoanNvbi5pbmJveE5vdGlmaWNhdGlvbikgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkOiB2b2lkIDAsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRocmVhZCAke29wdGlvbnMudGhyZWFkSWR9LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRUaHJlYWRNZXRhZGF0YShvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vbWV0YWRhdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIG9wdGlvbnMubWV0YWRhdGFcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IGNvbW1lbnRJZCA9IG9wdGlvbnMuY29tbWVudElkID8/IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgIGNvbnN0IGNvbW1lbnQgPSBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L2NvbW1lbnRzYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgICAgYXR0YWNobWVudElkczogb3B0aW9ucy5hdHRhY2htZW50SWRzXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdENvbW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IGNvbW1lbnQgPSBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L2NvbW1lbnRzLyR7b3B0aW9ucy5jb21tZW50SWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgICAgYXR0YWNobWVudElkczogb3B0aW9ucy5hdHRhY2htZW50SWRzXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ29tbWVudChvcHRpb25zKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5kZWxldGUoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L2NvbW1lbnRzLyR7b3B0aW9ucy5jb21tZW50SWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZFJlYWN0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWFjdGlvbiA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vY29tbWVudHMvJHtvcHRpb25zLmNvbW1lbnRJZH0vcmVhY3Rpb25zYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7IGVtb2ppOiBvcHRpb25zLmVtb2ppIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKHJlYWN0aW9uKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZW1vdmVSZWFjdGlvbihvcHRpb25zKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5kZWxldGUoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L2NvbW1lbnRzLyR7b3B0aW9ucy5jb21tZW50SWR9L3JlYWN0aW9ucy8ke29wdGlvbnMuZW1vaml9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtUaHJlYWRBc1Jlc29sdmVkKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L21hcmstYXMtcmVzb2x2ZWRgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzVW5yZXNvbHZlZChvcHRpb25zKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfS9tYXJrLWFzLXVucmVzb2x2ZWRgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdXBsb2FkQXR0YWNobWVudChvcHRpb25zKSB7XG4gICAgY29uc3Qgcm9vbUlkID0gb3B0aW9ucy5yb29tSWQ7XG4gICAgY29uc3QgYWJvcnRTaWduYWwgPSBvcHRpb25zLnNpZ25hbDtcbiAgICBjb25zdCBhdHRhY2htZW50ID0gb3B0aW9ucy5hdHRhY2htZW50O1xuICAgIGNvbnN0IGFib3J0RXJyb3IgPSBhYm9ydFNpZ25hbCA/IG5ldyBET01FeGNlcHRpb24oXG4gICAgICBgVXBsb2FkIG9mIGF0dGFjaG1lbnQgJHtvcHRpb25zLmF0dGFjaG1lbnQuaWR9IHdhcyBhYm9ydGVkLmAsXG4gICAgICBcIkFib3J0RXJyb3JcIlxuICAgICkgOiB2b2lkIDA7XG4gICAgaWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBhYm9ydEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVSZXRyeUVycm9yID0gKGVycikgPT4ge1xuICAgICAgaWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgIHRocm93IGFib3J0RXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgSHR0cEVycm9yICYmIGVyci5zdGF0dXMgPT09IDQxMykge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBBVFRBQ0hNRU5UX1BBUlRfU0laRSA9IDUgKiAxMDI0ICogMTAyNDtcbiAgICBjb25zdCBSRVRSWV9BVFRFTVBUUyA9IDEwO1xuICAgIGNvbnN0IFJFVFJZX0RFTEFZUyA9IFtcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlM1xuICAgIF07XG4gICAgZnVuY3Rpb24gc3BsaXRGaWxlSW50b1BhcnRzKGZpbGUpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgd2hpbGUgKHN0YXJ0IDwgZmlsZS5zaXplKSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgQVRUQUNITUVOVF9QQVJUX1NJWkUsIGZpbGUuc2l6ZSk7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHBhcnROdW1iZXI6IHBhcnRzLmxlbmd0aCArIDEsXG4gICAgICAgICAgcGFydDogZmlsZS5zbGljZShzdGFydCwgZW5kKVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICAgIGlmIChhdHRhY2htZW50LnNpemUgPD0gQVRUQUNITUVOVF9QQVJUX1NJWkUpIHtcbiAgICAgIHJldHVybiBhdXRvUmV0cnkoXG4gICAgICAgIGFzeW5jICgpID0+IGh0dHBDbGllbnQucHV0QmxvYihcbiAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vdXBsb2FkLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGF0dGFjaG1lbnQubmFtZSl9YCxcbiAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgICAgcm9vbUlkXG4gICAgICAgICAgfSksXG4gICAgICAgICAgYXR0YWNobWVudC5maWxlLFxuICAgICAgICAgIHsgZmlsZVNpemU6IGF0dGFjaG1lbnQuc2l6ZSB9LFxuICAgICAgICAgIHsgc2lnbmFsOiBhYm9ydFNpZ25hbCB9XG4gICAgICAgICksXG4gICAgICAgIFJFVFJZX0FUVEVNUFRTLFxuICAgICAgICBSRVRSWV9ERUxBWVMsXG4gICAgICAgIGhhbmRsZVJldHJ5RXJyb3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB1cGxvYWRJZDtcbiAgICAgIGNvbnN0IHVwbG9hZGVkUGFydHMgPSBbXTtcbiAgICAgIGNvbnN0IGNyZWF0ZU11bHRpUGFydFVwbG9hZCA9IGF3YWl0IGF1dG9SZXRyeShcbiAgICAgICAgYXN5bmMgKCkgPT4gaHR0cENsaWVudC5wb3N0KFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS9tdWx0aXBhcnQvJHtlbmNvZGVVUklDb21wb25lbnQoYXR0YWNobWVudC5uYW1lKX1gLFxuICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICByb29tSWRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgeyBzaWduYWw6IGFib3J0U2lnbmFsIH0sXG4gICAgICAgICAgeyBmaWxlU2l6ZTogYXR0YWNobWVudC5zaXplIH1cbiAgICAgICAgKSxcbiAgICAgICAgUkVUUllfQVRURU1QVFMsXG4gICAgICAgIFJFVFJZX0RFTEFZUyxcbiAgICAgICAgaGFuZGxlUmV0cnlFcnJvclxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVwbG9hZElkID0gY3JlYXRlTXVsdGlQYXJ0VXBsb2FkLnVwbG9hZElkO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHNwbGl0RmlsZUludG9QYXJ0cyhhdHRhY2htZW50LmZpbGUpO1xuICAgICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBhYm9ydEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhdGNoZXMgPSBjaHVuayhwYXJ0cywgNSk7XG4gICAgICAgIGZvciAoY29uc3QgcGFydHMyIG9mIGJhdGNoZXMpIHtcbiAgICAgICAgICBjb25zdCB1cGxvYWRlZFBhcnRzUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgcGFydCwgcGFydE51bWJlciB9IG9mIHBhcnRzMikge1xuICAgICAgICAgICAgdXBsb2FkZWRQYXJ0c1Byb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIGF1dG9SZXRyeShcbiAgICAgICAgICAgICAgICBhc3luYyAoKSA9PiBodHRwQ2xpZW50LnB1dEJsb2IoXG4gICAgICAgICAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7Y3JlYXRlTXVsdGlQYXJ0VXBsb2FkLnVwbG9hZElkfS8ke1N0cmluZyhwYXJ0TnVtYmVyKX1gLFxuICAgICAgICAgICAgICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgICAgICAgICAgICByb29tSWRcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIHsgc2lnbmFsOiBhYm9ydFNpZ25hbCB9XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBSRVRSWV9BVFRFTVBUUyxcbiAgICAgICAgICAgICAgICBSRVRSWV9ERUxBWVMsXG4gICAgICAgICAgICAgICAgaGFuZGxlUmV0cnlFcnJvclxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGxvYWRlZFBhcnRzLnB1c2goLi4uYXdhaXQgUHJvbWlzZS5hbGwodXBsb2FkZWRQYXJ0c1Byb21pc2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgdGhyb3cgYWJvcnRFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3J0ZWRVcGxvYWRlZFBhcnRzID0gdXBsb2FkZWRQYXJ0cy5zb3J0KFxuICAgICAgICAgIChhLCBiKSA9PiBhLnBhcnROdW1iZXIgLSBiLnBhcnROdW1iZXJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGh0dHBDbGllbnQucG9zdChcbiAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7dXBsb2FkSWR9L2NvbXBsZXRlYCxcbiAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgICAgcm9vbUlkXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyBwYXJ0czogc29ydGVkVXBsb2FkZWRQYXJ0cyB9LFxuICAgICAgICAgIHsgc2lnbmFsOiBhYm9ydFNpZ25hbCB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgICAgaWYgKHVwbG9hZElkICYmIGVycm9yMz8ubmFtZSAmJiAoZXJyb3IzLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiIHx8IGVycm9yMy5uYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBodHRwQ2xpZW50LnJhd0RlbGV0ZShcbiAgICAgICAgICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7cm9vbUlkfS9hdHRhY2htZW50cy8ke2F0dGFjaG1lbnQuaWR9L211bHRpcGFydC8ke3VwbG9hZElkfWAsXG4gICAgICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgICAgICAgIHJvb21JZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcjQpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBhdHRhY2htZW50VXJsc0JhdGNoU3RvcmVzQnlSb29tID0gbmV3IERlZmF1bHRNYXAoKHJvb21JZCkgPT4ge1xuICAgIGNvbnN0IGJhdGNoMiA9IG5ldyBCYXRjaChcbiAgICAgIGFzeW5jIChiYXRjaGVkQXR0YWNobWVudElkcykgPT4ge1xuICAgICAgICBjb25zdCBhdHRhY2htZW50SWRzID0gYmF0Y2hlZEF0dGFjaG1lbnRJZHMuZmxhdCgpO1xuICAgICAgICBjb25zdCB7IHVybHMgfSA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2F0dGFjaG1lbnRzL3ByZXNpZ25lZC11cmxzYCxcbiAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgICAgcm9vbUlkXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyBhdHRhY2htZW50SWRzIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHVybHMubWFwKFxuICAgICAgICAgICh1cmwyKSA9PiB1cmwyID8/IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoaXMgYXR0YWNobWVudCdzIFVSTFwiKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHsgZGVsYXk6IDUwIH1cbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVCYXRjaFN0b3JlKGJhdGNoMik7XG4gIH0pO1xuICBmdW5jdGlvbiBnZXRPckNyZWF0ZUF0dGFjaG1lbnRVcmxzU3RvcmUocm9vbUlkKSB7XG4gICAgcmV0dXJuIGF0dGFjaG1lbnRVcmxzQmF0Y2hTdG9yZXNCeVJvb20uZ2V0T3JDcmVhdGUocm9vbUlkKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRBdHRhY2htZW50VXJsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBiYXRjaDIgPSBnZXRPckNyZWF0ZUF0dGFjaG1lbnRVcmxzU3RvcmUob3B0aW9ucy5yb29tSWQpLmJhdGNoO1xuICAgIHJldHVybiBiYXRjaDIuZ2V0KG9wdGlvbnMuYXR0YWNobWVudElkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXROb3RpZmljYXRpb25TZXR0aW5ncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAgdm9pZCAwLFxuICAgICAge1xuICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS9ub3RpZmljYXRpb24tc2V0dGluZ3NgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIG9wdGlvbnMuc2V0dGluZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IG1hcmtBc1JlYWRCYXRjaGVzQnlSb29tID0gbmV3IERlZmF1bHRNYXAoXG4gICAgKHJvb21JZCkgPT4gbmV3IEJhdGNoKFxuICAgICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbklkcyA9IGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcy5mbGF0KCk7XG4gICAgICAgIGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZGAsXG4gICAgICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgICAgIHJvb21JZFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgaW5ib3hOb3RpZmljYXRpb25JZHMgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgICB9LFxuICAgICAgeyBkZWxheTogNTAgfVxuICAgIClcbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya1Jvb21JbmJveE5vdGlmaWNhdGlvbkFzUmVhZChvcHRpb25zKSB7XG4gICAgY29uc3QgYmF0Y2gyID0gbWFya0FzUmVhZEJhdGNoZXNCeVJvb20uZ2V0T3JDcmVhdGUob3B0aW9ucy5yb29tSWQpO1xuICAgIHJldHVybiBiYXRjaDIuZ2V0KG9wdGlvbnMuaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGV4dE1lbnRpb24ob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucmF3UG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90ZXh0LW1lbnRpb25zYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHVzZXJJZDogb3B0aW9ucy51c2VySWQsXG4gICAgICAgIG1lbnRpb25JZDogb3B0aW9ucy5tZW50aW9uSWRcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRleHRNZW50aW9uKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnJhd0RlbGV0ZShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90ZXh0LW1lbnRpb25zLyR7b3B0aW9ucy5tZW50aW9uSWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRleHRWZXJzaW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5yYXdHZXQoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0veS12ZXJzaW9uLyR7b3B0aW9ucy52ZXJzaW9uSWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRleHRWZXJzaW9uKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnJhd1Bvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdmVyc2lvbmAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZXBvcnRUZXh0RWRpdG9yKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnJhd1Bvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGV4dC1tZXRhZGF0YWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGUsXG4gICAgICAgIHJvb3RLZXk6IG9wdGlvbnMucm9vdEtleVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUNvbnRleHR1YWxQcm9tcHQob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS9haS9jb250ZXh0dWFsLXByb21wdGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHByb21wdDogb3B0aW9ucy5wcm9tcHQsXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICBiZWZvcmVTZWxlY3Rpb246IG9wdGlvbnMuY29udGV4dC5iZWZvcmVTZWxlY3Rpb24sXG4gICAgICAgICAgc2VsZWN0aW9uOiBvcHRpb25zLmNvbnRleHQuc2VsZWN0aW9uLFxuICAgICAgICAgIGFmdGVyU2VsZWN0aW9uOiBvcHRpb25zLmNvbnRleHQuYWZ0ZXJTZWxlY3Rpb25cbiAgICAgICAgfSxcbiAgICAgICAgcHJldmlvdXM6IG9wdGlvbnMucHJldmlvdXNcbiAgICAgIH0sXG4gICAgICB7IHNpZ25hbDogb3B0aW9ucy5zaWduYWwgfVxuICAgICk7XG4gICAgaWYgKCFyZXN1bHQgfHwgcmVzdWx0LmNvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjb250ZW50IHJldHVybmVkIGZyb20gc2VydmVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmNvbnRlbnRbMF0udGV4dDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsaXN0VGV4dFZlcnNpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS92ZXJzaW9uc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbnM6IHJlc3VsdC52ZXJzaW9ucy5tYXAoKHsgY3JlYXRlZEF0LCAuLi52ZXJzaW9uIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGNyZWF0ZWRBdCksXG4gICAgICAgICAgLi4udmVyc2lvblxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUocmVzdWx0Lm1ldGEucmVxdWVzdGVkQXQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsaXN0VGV4dFZlcnNpb25zU2luY2Uob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3ZlcnNpb25zL2RlbHRhYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7IHNpbmNlOiBvcHRpb25zLnNpbmNlLnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbnM6IHJlc3VsdC52ZXJzaW9ucy5tYXAoKHsgY3JlYXRlZEF0LCAuLi52ZXJzaW9uIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGNyZWF0ZWRBdCksXG4gICAgICAgICAgLi4udmVyc2lvblxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUocmVzdWx0Lm1ldGEucmVxdWVzdGVkQXQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdHJlYW1TdG9yYWdlKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBodHRwQ2xpZW50LnJhd0dldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS9zdG9yYWdlYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcInJvb206cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc2VuZE1lc3NhZ2VzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5yYXdQb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3NlbmQtbWVzc2FnZWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIG5vbmNlOiBvcHRpb25zLm5vbmNlLFxuICAgICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlc1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0SW5ib3hOb3RpZmljYXRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBQQUdFX1NJWkUgPSA1MDtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9uc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7XG4gICAgICAgIGN1cnNvcjogb3B0aW9ucz8uY3Vyc29yLFxuICAgICAgICBsaW1pdDogUEFHRV9TSVpFXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YVxuICAgICAgKSxcbiAgICAgIHRocmVhZHM6IGpzb24udGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICBuZXh0Q3Vyc29yOiBqc29uLm1ldGEubmV4dEN1cnNvcixcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZShvcHRpb25zKSB7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnMvZGVsdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAgeyBzaW5jZTogb3B0aW9ucy5zaW5jZS50b0lTT1N0cmluZygpIH0sXG4gICAgICB7IHNpZ25hbDogb3B0aW9ucy5zaWduYWwgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgICB1cGRhdGVkOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKSxcbiAgICAgICAgZGVsZXRlZDoganNvbi5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm9cbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgdXBkYXRlZDoganNvbi50aHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgICAgZGVsZXRlZDoganNvbi5kZWxldGVkVGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbylcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoKSB7XG4gICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy9jb3VudGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSlcbiAgICApO1xuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKCkge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zL3JlYWRgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAge1xuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkczogXCJhbGxcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zL3JlYWRgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAge1xuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkc1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgY29uc3QgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQgPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb25JZHMgPSBiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMuZmxhdCgpO1xuICAgICAgYXdhaXQgbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcyk7XG4gICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgfSxcbiAgICB7IGRlbGF5OiA1MCB9XG4gICk7XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQuZ2V0KGluYm94Tm90aWZpY2F0aW9uSWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucygpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LmRlbGV0ZShcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlSW5ib3hOb3RpZmljYXRpb24oaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICAgIGF3YWl0IGh0dHBDbGllbnQuZGVsZXRlKFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnMvJHtpbmJveE5vdGlmaWNhdGlvbklkfWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB2b2lkIDAsXG4gICAgICB7IHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KSxcbiAgICAgIHNldHRpbmdzXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWwob3B0aW9ucykge1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAob3B0aW9ucz8ucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3RocmVhZHNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAge1xuICAgICAgICBjdXJzb3I6IG9wdGlvbnM/LmN1cnNvcixcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGxpbWl0OiBQQUdFX1NJWkVcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB0aHJlYWRzOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YVxuICAgICAgKSxcbiAgICAgIG5leHRDdXJzb3I6IGpzb24ubWV0YS5uZXh0Q3Vyc29yLFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdCksXG4gICAgICBwZXJtaXNzaW9uSGludHM6IGpzb24ubWV0YS5wZXJtaXNzaW9uSGludHNcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2MvdGhyZWFkcy9kZWx0YWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7IHNpbmNlOiBvcHRpb25zLnNpbmNlLnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGhyZWFkczoge1xuICAgICAgICB1cGRhdGVkOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgICBkZWxldGVkOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKVxuICAgICAgfSxcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgICB1cGRhdGVkOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKSxcbiAgICAgICAgZGVsZXRlZDoganNvbi5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm9cbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpLFxuICAgICAgcGVybWlzc2lvbkhpbnRzOiBqc29uLm1ldGEucGVybWlzc2lvbkhpbnRzXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC8vIFJvb20gdGhyZWFkc1xuICAgIGdldFRocmVhZHMsXG4gICAgZ2V0VGhyZWFkc1NpbmNlLFxuICAgIGNyZWF0ZVRocmVhZCxcbiAgICBnZXRUaHJlYWQsXG4gICAgZGVsZXRlVGhyZWFkLFxuICAgIGVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICBjcmVhdGVDb21tZW50LFxuICAgIGVkaXRDb21tZW50LFxuICAgIGRlbGV0ZUNvbW1lbnQsXG4gICAgYWRkUmVhY3Rpb24sXG4gICAgcmVtb3ZlUmVhY3Rpb24sXG4gICAgbWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gICAgbWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICBtYXJrUm9vbUluYm94Tm90aWZpY2F0aW9uQXNSZWFkLFxuICAgIC8vIFJvb20gbm90aWZpY2F0aW9uc1xuICAgIGdldE5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIC8vIFJvb20gdGV4dCBlZGl0b3JcbiAgICBjcmVhdGVUZXh0TWVudGlvbixcbiAgICBkZWxldGVUZXh0TWVudGlvbixcbiAgICBnZXRUZXh0VmVyc2lvbixcbiAgICBjcmVhdGVUZXh0VmVyc2lvbixcbiAgICByZXBvcnRUZXh0RWRpdG9yLFxuICAgIGxpc3RUZXh0VmVyc2lvbnMsXG4gICAgbGlzdFRleHRWZXJzaW9uc1NpbmNlLFxuICAgIC8vIFJvb20gYXR0YWNobWVudHNcbiAgICBnZXRBdHRhY2htZW50VXJsLFxuICAgIHVwbG9hZEF0dGFjaG1lbnQsXG4gICAgZ2V0T3JDcmVhdGVBdHRhY2htZW50VXJsc1N0b3JlLFxuICAgIC8vIFJvb20gc3RvcmFnZVxuICAgIHN0cmVhbVN0b3JhZ2UsXG4gICAgc2VuZE1lc3NhZ2VzLFxuICAgIC8vIE5vdGlmaWNhdGlvblxuICAgIGdldEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZSxcbiAgICBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZGVsZXRlSW5ib3hOb3RpZmljYXRpb24sXG4gICAgZ2V0VXNlck5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIHVwZGF0ZVVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAvLyBVc2VyIHRocmVhZHNcbiAgICBnZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWwsXG4gICAgZ2V0VXNlclRocmVhZHNTaW5jZV9leHBlcmltZW50YWwsXG4gICAgLy8gQUlcbiAgICBleGVjdXRlQ29udGV4dHVhbFByb21wdFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QmVhcmVyVG9rZW5Gcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSkge1xuICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICByZXR1cm4gYXV0aFZhbHVlLnB1YmxpY0FwaUtleTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXV0aFZhbHVlLnRva2VuLnJhdztcbiAgfVxufVxudmFyIEh0dHBDbGllbnQgPSBjbGFzcyB7XG4gICNiYXNlVXJsO1xuICAjZmV0Y2hQb2x5ZmlsbDtcbiAgY29uc3RydWN0b3IoYmFzZVVybCwgZmV0Y2hQb2x5ZmlsbCkge1xuICAgIHRoaXMuI2Jhc2VVcmwgPSBiYXNlVXJsO1xuICAgIHRoaXMuI2ZldGNoUG9seWZpbGwgPSBmZXRjaFBvbHlmaWxsO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQdWJsaWMgbWV0aG9kc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYW5kIG1ha2VzIHRoZSBIVFRQIHJlcXVlc3QsIGJ1dCBkb2VzIG5vdCBoYW5kbGUgdGhlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBUaGlzIGlzIHdoYXQgLnJhd0ZldGNoKCkgZG9lczogICAg8J+RiCBUaGlzIG1ldGhvZCFcbiAgICogICAxLiBTZXQgQ29udGVudC1UeXBlIGhlYWRlclxuICAgKiAgIDIuIFNldCBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgKiAgIDMuIENhbGwgdGhlIGNhbGxiYWNrIHRvIG9idGFpbiB0aGUgYGF1dGhWYWx1ZWAgdG8gdXNlIGluIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgKlxuICAgKiBUaGlzIGlzIHdoYXQgLmZldGNoKCkgZG9lcyBPTiBUT1Agb2YgdGhhdDpcbiAgICogICA0LiBQYXJzZSByZXNwb25zZSBib2R5IGFzIEpzb25cbiAgICogICA1LiAuLi5idXQgc2lsZW50bHkgcmV0dXJuIGB7fWAgaWYgdGhhdCBwYXJzaW5nIGZhaWxzXG4gICAqICAgNi4gVGhyb3cgSHR0cEVycm9yIGlmIHJlc3BvbnNlIGlzIGFuIGVycm9yXG4gICAqL1xuICBhc3luYyAjcmF3RmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgaWYgKCFlbmRwb2ludC5zdGFydHNXaXRoKFwiL3YyL2MvXCIpKSB7XG4gICAgICByYWlzZShcIlRoaXMgY2xpZW50IGNhbiBvbmx5IGJlIHVzZWQgdG8gbWFrZSAvdjIvYy8qIHJlcXVlc3RzXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwyID0gdXJsam9pbih0aGlzLiNiYXNlVXJsLCBlbmRwb2ludCwgcGFyYW1zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmV0Y2hQb2x5ZmlsbCh1cmwyLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAvLyBUaGVzZSBoZWFkZXJzIGFyZSBkZWZhdWx0LCBidXQgY2FuIGJlIG92ZXJyaWRlbiBieSBjdXN0b20gaGVhZGVyc1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgLy8gUG9zc2libGUgaGVhZGVyIG92ZXJyaWRlc1xuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAvLyBDYW5ub3QgYmUgb3ZlcnJpZGVuIGJ5IGN1c3RvbSBoZWFkZXJzXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKX1gLFxuICAgICAgICBcIlgtTEItQ2xpZW50XCI6IFBLR19WRVJTSU9OIHx8IFwiZGV2XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cywgbWFrZXMgdGhlIEhUVFAgcmVxdWVzdCwgYW5kIGhhbmRsZXMgdGhlIHJlc3BvbnNlIGJ5IHBhcnNpbmdcbiAgICogSlNPTiBhbmQvb3IgdGhyb3dpbmcgYW4gSHR0cEVycm9yIGlmIGl0IGZhaWxlZC5cbiAgICpcbiAgICogVGhpcyBpcyB3aGF0IC5yYXdGZXRjaCgpIGRvZXM6XG4gICAqICAgMS4gU2V0IENvbnRlbnQtVHlwZSBoZWFkZXJcbiAgICogICAyLiBTZXQgQXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICogICAzLiBDYWxsIHRoZSBjYWxsYmFjayB0byBvYnRhaW4gdGhlIGBhdXRoVmFsdWVgIHRvIHVzZSBpbiB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICpcbiAgICogVGhpcyBpcyB3aGF0IC5mZXRjaCgpIGRvZXMgT04gVE9QIG9mIHRoYXQ6ICAg8J+RiCBUaGlzIG1ldGhvZCFcbiAgICogICA0LiBQYXJzZSByZXNwb25zZSBib2R5IGFzIEpzb25cbiAgICogICA1LiAuLi5idXQgc2lsZW50bHkgcmV0dXJuIGB7fWAgaWYgdGhhdCBwYXJzaW5nIGZhaWxzICjwn6SUKVxuICAgKiAgIDYuIFRocm93IEh0dHBFcnJvciBpZiByZXNwb25zZSBpcyBhbiBlcnJvclxuICAgKi9cbiAgYXN5bmMgI2ZldGNoKGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy4jcmF3RmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9ucywgcGFyYW1zKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBIdHRwRXJyb3IuZnJvbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIEdFVCByZXF1ZXN0IGFuZCByZXR1cm5zIHRoZSByYXcgcmVzcG9uc2UuXG4gICAqIFdvbid0IHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICogQGRlcHJlY2F0ZWQgSWRlYWxseSwgdXNlIC5nZXQoKSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgcmF3R2V0KGVuZHBvaW50LCBhdXRoVmFsdWUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNyYXdGZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zLCBwYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIFBPU1QgcmVxdWVzdCBhbmQgcmV0dXJucyB0aGUgcmF3IHJlc3BvbnNlLlxuICAgKiBXb24ndCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqIEBkZXByZWNhdGVkIElkZWFsbHksIHVzZSAucG9zdCgpIGluc3RlYWQuXG4gICAqL1xuICBhc3luYyByYXdQb3N0KGVuZHBvaW50LCBhdXRoVmFsdWUsIGJvZHkpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jcmF3RmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHN0cmluZ2lmeU9yTG9nKGJvZHkpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIGEgREVMRVRFIHJlcXVlc3QgYW5kIHJldHVybnMgdGhlIHJhdyByZXNwb25zZS5cbiAgICogV29uJ3QgdGhyb3cgaWYgdGhlIHJlcG9uc2UgaXMgYSBub24tMnh4LlxuICAgKiBAZGVwcmVjYXRlZCBJZGVhbGx5LCB1c2UgLmRlbGV0ZSgpIGluc3RlYWQuXG4gICAqL1xuICBhc3luYyByYXdEZWxldGUoZW5kcG9pbnQsIGF1dGhWYWx1ZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNyYXdGZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCB7IG1ldGhvZDogXCJERUxFVEVcIiB9KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBHRVQgcmVxdWVzdCwgYW5kIHJldHVybiB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogV2lsbCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqL1xuICBhc3luYyBnZXQoZW5kcG9pbnQsIGF1dGhWYWx1ZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZldGNoKGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMsIHBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIGEgUE9TVCByZXF1ZXN0LCBhbmQgcmV0dXJuIHRoZSBKU09OIHJlc3BvbnNlLlxuICAgKiBXaWxsIHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICovXG4gIGFzeW5jIHBvc3QoZW5kcG9pbnQsIGF1dGhWYWx1ZSwgYm9keSwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZldGNoKFxuICAgICAgZW5kcG9pbnQsXG4gICAgICBhdXRoVmFsdWUsXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IHN0cmluZ2lmeU9yTG9nKGJvZHkpXG4gICAgICB9LFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBERUxFVEUgcmVxdWVzdCwgYW5kIHJldHVybiB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogV2lsbCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqL1xuICBhc3luYyBkZWxldGUoZW5kcG9pbnQsIGF1dGhWYWx1ZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCB7IG1ldGhvZDogXCJERUxFVEVcIiB9KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBQVVQgcmVxdWVzdCBmb3IgYSBCbG9iIGJvZHksIGFuZCByZXR1cm4gdGhlIEpTT04gcmVzcG9uc2UuXG4gICAqIFdpbGwgdGhyb3cgaWYgdGhlIHJlcG9uc2UgaXMgYSBub24tMnh4LlxuICAgKi9cbiAgYXN5bmMgcHV0QmxvYihlbmRwb2ludCwgYXV0aFZhbHVlLCBibG9iLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmV0Y2goXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGF1dGhWYWx1ZSxcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBibG9iXG4gICAgICB9LFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF92YWx1ZSwgZXJybXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgZXJybXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICBlcnIubmFtZSA9IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5uKHZhbHVlLCBlcnJtc2cgPSBcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG5vbi1udWxsYWJsZVwiKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwLCBlcnJtc2cpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9saWIvZnNtLnRzXG5mdW5jdGlvbiBkaXN0YW5jZShzdGF0ZTEsIHN0YXRlMikge1xuICBpZiAoc3RhdGUxID09PSBzdGF0ZTIpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGNvbnN0IGNodW5rczEgPSBzdGF0ZTEuc3BsaXQoXCIuXCIpO1xuICBjb25zdCBjaHVua3MyID0gc3RhdGUyLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgbWluTGVuID0gTWF0aC5taW4oY2h1bmtzMS5sZW5ndGgsIGNodW5rczIubGVuZ3RoKTtcbiAgbGV0IHNoYXJlZCA9IDA7XG4gIGZvciAoOyBzaGFyZWQgPCBtaW5MZW47IHNoYXJlZCsrKSB7XG4gICAgaWYgKGNodW5rczFbc2hhcmVkXSAhPT0gY2h1bmtzMltzaGFyZWRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgdXAgPSBjaHVua3MxLmxlbmd0aCAtIHNoYXJlZDtcbiAgY29uc3QgZG93biA9IGNodW5rczIubGVuZ3RoIC0gc2hhcmVkO1xuICByZXR1cm4gW3VwLCBkb3duXTtcbn1cbmZ1bmN0aW9uIHBhdHRlcm5zKHRhcmdldFN0YXRlLCBsZXZlbHMpIHtcbiAgY29uc3QgcGFydHMgPSB0YXJnZXRTdGF0ZS5zcGxpdChcIi5cIik7XG4gIGlmIChsZXZlbHMgPCAxIHx8IGxldmVscyA+IHBhcnRzLmxlbmd0aCArIDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBsZXZlbHNcIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmIChsZXZlbHMgPiBwYXJ0cy5sZW5ndGgpIHtcbiAgICByZXN1bHQucHVzaChcIipcIik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IHBhcnRzLmxlbmd0aCAtIGxldmVscyArIDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNsaWNlID0gcGFydHMuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNsaWNlLmpvaW4oXCIuXCIpICsgXCIuKlwiKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnB1c2godGFyZ2V0U3RhdGUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIFNhZmVDb250ZXh0ID0gY2xhc3Mge1xuICAjY3VycjtcbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLiNjdXJyID0gaW5pdGlhbENvbnRleHQ7XG4gIH1cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnI7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGFsbG93cyBwYXRjaGluZyBvZiB0aGUgY29udGV4dCwgYnlcbiAgICogY2FsbGluZyBgY29udGV4dC5wYXRjaCgpYC4gUGF0Y2hpbmcgaXMgb25seSBhbGxvd2VkIGZvciB0aGUgZHVyYXRpb25cbiAgICogb2YgdGhpcyB3aW5kb3cuXG4gICAqL1xuICBhbGxvd1BhdGNoaW5nKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGFsbG93ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHBhdGNoYWJsZUNvbnRleHQgPSB7XG4gICAgICAuLi50aGlzLiNjdXJyLFxuICAgICAgcGF0Y2gocGF0Y2gpIHtcbiAgICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgICBzZWxmLiNjdXJyID0gT2JqZWN0LmFzc2lnbih7fSwgc2VsZi4jY3VyciwgcGF0Y2gpO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBPYmplY3QuZW50cmllcyhwYXRjaCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhaXI7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcInBhdGNoXCIpIHtcbiAgICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBubyBsb25nZXIgcGF0Y2ggc3RhbGUgY29udGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY2FsbGJhY2socGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgYWxsb3dlZCA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxufTtcbnZhciBuZXh0SWQgPSAxO1xudmFyIEZTTSA9IGNsYXNzIHtcbiAgaWQ7XG4gIC8vIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgc3RhdGUgbWFjaGluZSBpcyBzdGlsbCBiZWluZyBjb25maWd1cmVkLCBoYXNcbiAgLy8gc3RhcnRlZCwgb3IgaGFzIHRlcm1pbmF0ZWRcbiAgI3J1bm5pbmdTdGF0ZTtcbiAgI2N1cnJlbnRDb250ZXh0O1xuICAjc3RhdGVzO1xuICAjY3VycmVudFN0YXRlT3JOdWxsO1xuICAjYWxsb3dlZFRyYW5zaXRpb25zO1xuICAjZXZlbnRIdWI7XG4gIGV2ZW50cztcbiAgLy9cbiAgLy8gVGhlIGNsZWFudXAgc3RhY2sgaXMgYSBzdGFjayBvZiAob3B0aW9uYWwpIGNhbGxiYWNrIGZ1bmN0aW9ucyB0aGF0IHdpbGxcbiAgLy8gYmUgcnVuIHdoZW4gZXhpdGluZyB0aGUgY3VycmVudCBzdGF0ZS4gSWYgYSBzdGF0ZSAob3Igc3RhdGUgZ3JvdXApIGRvZXNcbiAgLy8gbm90IGhhdmUgYW4gZXhpdCBoYW5kbGVyLCB0aGVuIHRoZSBlbnRyeSBmb3IgdGhhdCBsZXZlbCBtYXkgYmVcbiAgLy8gYHVuZGVmaW5lZGAsIGJ1dCB0aGVyZSB3aWxsIGJlIGFuIGV4cGxpY2l0IGVudHJ5IGluIHRoZSBzdGFjayBmb3IgaXQuXG4gIC8vXG4gIC8vIFRoaXMgd2lsbCBhbHdheXMgYmUgdHJ1ZTpcbiAgLy9cbiAgLy8gICBjbGVhbnVwU3RhY2subGVuZ3RoID09IGN1cnJlbnRTdGF0ZS5zcGxpdCgnLicpLmxlbmd0aCArIDFcbiAgLy9cbiAgLy8gRWFjaCBzdGFjayBsZXZlbCByZXByZXNlbnRzIGEgZGlmZmVyZW50IHN0YXRlIFwiZ3JvdXBcIi5cbiAgLy9cbiAgLy8gRm9yIGV4YW1wbGUsIGlmIHlvdSBhcmUgaW4gYSBzdGF0ZSBuYW1lZCBgZm9vLmJhci5xdXhgLCB0aGVuIHRoZSBzdGFja1xuICAvLyB3aWxsIGNvbnRhaW4gdGhlIGV4aXQgaGFuZGxlciBmb3IgYGZvby5iYXIucXV4YCAoYXQgdGhlIHRvcCksIHRoZW5cbiAgLy8gYGZvby5iYXIuKmAsIHRoZW4gYGZvby4qYCwgYW5kIGZpbmFsbHksIGAqYC5cbiAgLy9cbiAgI2NsZWFudXBTdGFjaztcbiAgI2VudGVyRm5zO1xuICAvLyBVc2VkIHRvIHByb3ZpZGUgYmV0dGVyIGVycm9yIG1lc3NhZ2VzXG4gICNrbm93bkV2ZW50VHlwZXM7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIHN0YXRlLCB3aGljaCBpcyBkZWZpbmVkIGJ5IHRoZSBmaXJzdCBjYWxsIG1hZGUgdG9cbiAgICogLmFkZFN0YXRlKCkuXG4gICAqL1xuICBnZXQgI2luaXRpYWxTdGF0ZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNzdGF0ZXMudmFsdWVzKClbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN0YXRlcyBkZWZpbmVkIHlldFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy4jY3VycmVudFN0YXRlT3JOdWxsID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlID09PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3RhcnRlZCB5ZXRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0b3BwZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjdXJyZW50U3RhdGVPck51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgbWFjaGluZSBieSBlbnRlcmluZyB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICh0aGlzLiNydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBtYWNoaW5lIGhhcyBhbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMuI3J1bm5pbmdTdGF0ZSA9IDEgLyogU1RBUlRFRCAqLztcbiAgICB0aGlzLiNjdXJyZW50U3RhdGVPck51bGwgPSB0aGlzLiNpbml0aWFsU3RhdGU7XG4gICAgdGhpcy4jZW50ZXIobnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSBzdGF0ZSBtYWNoaW5lLiBTdG9wcGluZyB0aGUgc3RhdGUgbWFjaGluZSB3aWxsIGNhbGwgZXhpdFxuICAgKiBoYW5kbGVycyBmb3IgdGhlIGN1cnJlbnQgc3RhdGUsIGJ1dCBub3QgZW50ZXIgYSBuZXcgc3RhdGUuXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLiNydW5uaW5nU3RhdGUgIT09IDEgLyogU1RBUlRFRCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0b3AgYSBzdGF0ZSBtYWNoaW5lIHRoYXQgaGFzbid0IHN0YXJ0ZWQgeWV0XCIpO1xuICAgIH1cbiAgICB0aGlzLiNleGl0KG51bGwpO1xuICAgIHRoaXMuI3J1bm5pbmdTdGF0ZSA9IDIgLyogU1RPUFBFRCAqLztcbiAgICB0aGlzLiNjdXJyZW50U3RhdGVPck51bGwgPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxDb250ZXh0KSB7XG4gICAgdGhpcy5pZCA9IG5leHRJZCsrO1xuICAgIHRoaXMuI3J1bm5pbmdTdGF0ZSA9IDAgLyogTk9UX1NUQVJURURfWUVUICovO1xuICAgIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbCA9IG51bGw7XG4gICAgdGhpcy4jc3RhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLiNlbnRlckZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy4jY2xlYW51cFN0YWNrID0gW107XG4gICAgdGhpcy4ja25vd25FdmVudFR5cGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLiNhbGxvd2VkVHJhbnNpdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuI2N1cnJlbnRDb250ZXh0ID0gbmV3IFNhZmVDb250ZXh0KGluaXRpYWxDb250ZXh0KTtcbiAgICB0aGlzLiNldmVudEh1YiA9IHtcbiAgICAgIGRpZFJlY2VpdmVFdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICB3aWxsVHJhbnNpdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICBkaWRJZ25vcmVFdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICB3aWxsRXhpdFN0YXRlOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIGRpZEVudGVyU3RhdGU6IG1ha2VFdmVudFNvdXJjZSgpXG4gICAgfTtcbiAgICB0aGlzLmV2ZW50cyA9IHtcbiAgICAgIGRpZFJlY2VpdmVFdmVudDogdGhpcy4jZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsVHJhbnNpdGlvbjogdGhpcy4jZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ub2JzZXJ2YWJsZSxcbiAgICAgIGRpZElnbm9yZUV2ZW50OiB0aGlzLiNldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5vYnNlcnZhYmxlLFxuICAgICAgd2lsbEV4aXRTdGF0ZTogdGhpcy4jZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5vYnNlcnZhYmxlLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogdGhpcy4jZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5vYnNlcnZhYmxlXG4gICAgfTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudENvbnRleHQuY3VycmVudDtcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIGFuIGV4cGxpY2l0IGZpbml0ZSBzdGF0ZSBpbiB0aGUgc3RhdGUgbWFjaGluZS5cbiAgICovXG4gIGFkZFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuI3J1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy4jc3RhdGVzLmFkZChzdGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25FbnRlcihuYW1lT3JQYXR0ZXJuLCBlbnRlckZuKSB7XG4gICAgaWYgKHRoaXMuI3J1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2VudGVyRm5zLmhhcyhuYW1lT3JQYXR0ZXJuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBUT0RPIFdlIF9jdXJyZW50bHlfIGRvbid0IHN1cHBvcnQgbXVsdGlwbGUgLm9uRW50ZXJzKCkgZm9yIHRoZSBzYW1lXG4gICAgICAgIC8vIHN0YXRlLCBidXQgdGhpcyBpcyBub3QgYSBmdW5kYW1lbnRhbCBsaW1pdGF0aW9uLiBKdXN0IG5vdFxuICAgICAgICAvLyBpbXBsZW1lbnRlZCB5ZXQuIElmIHdlIHdhbnRlZCB0bywgd2UgY291bGQgbWFrZSB0aGlzIGFuIGFycmF5LlxuICAgICAgICBgZW50ZXIvZXhpdCBmdW5jdGlvbiBmb3IgJHtuYW1lT3JQYXR0ZXJufSBhbHJlYWR5IGV4aXN0c2BcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuI2VudGVyRm5zLnNldChuYW1lT3JQYXR0ZXJuLCBlbnRlckZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVmaW5lcyBhIHByb21pc2UtYmFzZWQgc3RhdGUuIFdoZW4gdGhlIHN0YXRlIGlzIGVudGVyZWQsIHRoZSBwcm9taXNlIGlzXG4gICAqIGNyZWF0ZWQuIFdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMsIHRoZSBtYWNoaW5lIHdpbGwgdHJhbnNpdGlvbiB0byB0aGVcbiAgICogcHJvdmlkZWQgYG9uT0tgIHRhcmdldCBzdGF0ZS4gV2hlbiB0aGUgcHJvbWlzZSByZWplY3RzLCB0aGUgbWFjaGluZSB3aWxsXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIGBvbkVycm9yYCB0YXJnZXQgc3RhdGUuXG4gICAqXG4gICAqIE9wdGlvbmFsbHksIGEgYG1heFRpbWVvdXRgIGNhbiBiZSBzZXQuIElmIHRoZSB0aW1lb3V0IGhhcHBlbnMgYmVmb3JlIHRoZVxuICAgKiBwcm9taXNlIGlzIHNldHRsZWQsIHRoZW4gdGhlIG1hY2hpbmUgd2lsbCBhbHNvIHRyYW5zaXRpb24gdG8gdGhlIGBvbkVycm9yYFxuICAgKiB0YXJnZXQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZU9yUGF0dGVybiAgVGhlIHN0YXRlIG5hbWUsIG9yIHN0YXRlIGdyb3VwIHBhdHRlcm4gbmFtZS5cbiAgICogQHBhcmFtIHByb21pc2VGbiAgICAgICBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBzdGF0ZSBpcyBlbnRlcmVkLlxuICAgKiBAcGFyYW0gb25PSyAgICAgICAgICAgIFRoZSBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvIHdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMuXG4gICAqIEBwYXJhbSBvbkVycm9yICAgICAgICAgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8gd2hlbiB0aGUgcHJvbWlzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdHMsIG9yIHdoZW4gdGhlIHRpbWVvdXQgaGFwcGVucyBiZWZvcmUgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSBoYXMgYmVlbiBzZXR0bGVkLlxuICAgKiBAcGFyYW0gbWF4VGltZW91dCAgICAgIE9wdGlvbmFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBXaGVuIHRoZSBwcm9taXNlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludm9rZWQsIGl0J3MgcHJvdmlkZWQgd2l0aCBhblxuICAgKiBBYm9ydFNpZ25hbCAoMm5kIGFyZ3VtZW50KS5cbiAgICogSWYgYSBzdGF0ZSB0cmFuc2l0aW9uIGhhcHBlbnMgd2hpbGUgdGhlIHByb21pc2UgaXMgcGVuZGluZyAoZm9yIGV4YW1wbGUsXG4gICAqIGFuIGV2ZW50LCBvciBhIHRpbWVvdXQgaGFwcGVucyksIHRoZW4gYW4gYWJvcnQgc2lnbmFsIHdpbGwgYmUgdXNlZCB0b1xuICAgKiBpbmRpY2F0ZSB0aGlzLiBJbXBsZW1lbnRlcnMgY2FuIHVzZSB0aGlzIGFib3J0IHNpZ25hbCB0byB0ZXJtaW5hdGUgdGhlXG4gICAqIGluLWZsaWdodCBwcm9taXNlLCBvciBpZ25vcmUgaXRzIHJlc3VsdHMsIGV0Yy5cbiAgICovXG4gIG9uRW50ZXJBc3luYyhuYW1lT3JQYXR0ZXJuLCBwcm9taXNlRm4sIG9uT0ssIG9uRXJyb3IsIG1heFRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKG5hbWVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICBjb25zdCB0aW1lb3V0SWQgPSBtYXhUaW1lb3V0ID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IG5ldyBFcnJvcihcIlRpbWVkIG91dFwiKTtcbiAgICAgICAgdGhpcy4jdHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfRVJST1JcIiwgcmVhc29uIH0sIG9uRXJyb3IpO1xuICAgICAgfSwgbWF4VGltZW91dCkgOiB2b2lkIDA7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgdm9pZCBwcm9taXNlRm4odGhpcy4jY3VycmVudENvbnRleHQuY3VycmVudCwgc2lnbmFsKS50aGVuKFxuICAgICAgICAvLyBPbiBPS1xuICAgICAgICAoZGF0YSkgPT4ge1xuICAgICAgICAgIGlmICghc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4jdHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfT0tcIiwgZGF0YSB9LCBvbk9LKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE9uIEVycm9yXG4gICAgICAgIChyZWFzb24pID0+IHtcbiAgICAgICAgICBpZiAoIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuI3RyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX0VSUk9SXCIsIHJlYXNvbiB9LCBvbkVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgI2dldFN0YXRlc01hdGNoaW5nKG5hbWVPclBhdHRlcm4pIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgaWYgKG5hbWVPclBhdHRlcm4gPT09IFwiKlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIHRoaXMuI3N0YXRlcykge1xuICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZU9yUGF0dGVybi5lbmRzV2l0aChcIi4qXCIpKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBuYW1lT3JQYXR0ZXJuLnNsaWNlKDAsIC0xKTtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy4jc3RhdGVzKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBuYW1lT3JQYXR0ZXJuO1xuICAgICAgaWYgKHRoaXMuI3N0YXRlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3RhdGVzIG1hdGNoICR7SlNPTi5zdHJpbmdpZnkobmFtZU9yUGF0dGVybil9YCk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgYWxsIGFsbG93ZWQgb3V0Z29pbmcgdHJhbnNpdGlvbnMgZm9yIGEgc3RhdGUuXG4gICAqXG4gICAqIFRoZSB0YXJnZXRzIGZvciBlYWNoIGV2ZW50IGNhbiBiZSBkZWZpbmVkIGFzIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGVcbiAgICogbmV4dCBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvLiBUaGVzZSBmdW5jdGlvbnMgY2FuIGxvb2sgYXQgdGhlIGBldmVudGAgb3JcbiAgICogYGNvbnRleHRgIHBhcmFtcyB0byBjb25kaXRpb25hbGx5IGRlY2lkZSB3aGljaCBuZXh0IHN0YXRlIHRvIHRyYW5zaXRpb25cbiAgICogdG8uXG4gICAqXG4gICAqIElmIHlvdSBzZXQgaXQgdG8gYG51bGxgLCB0aGVuIHRoZSB0cmFuc2l0aW9uIHdpbGwgYmUgZXhwbGljaXRseSBmb3JiaWRkZW5cbiAgICogYW5kIHRocm93IGFuIGVycm9yLiBJZiB5b3UgZG9uJ3QgZGVmaW5lIGEgdGFyZ2V0IGZvciBhIHRyYW5zaXRpb24sIHRoZW5cbiAgICogc3VjaCBldmVudHMgd2lsbCBnZXQgaWdub3JlZC5cbiAgICovXG4gIGFkZFRyYW5zaXRpb25zKG5hbWVPclBhdHRlcm4sIG1hcHBpbmcpIHtcbiAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNyY1N0YXRlIG9mIHRoaXMuI2dldFN0YXRlc01hdGNoaW5nKG5hbWVPclBhdHRlcm4pKSB7XG4gICAgICBsZXQgbWFwID0gdGhpcy4jYWxsb3dlZFRyYW5zaXRpb25zLmdldChzcmNTdGF0ZSk7XG4gICAgICBpZiAobWFwID09PSB2b2lkIDApIHtcbiAgICAgICAgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jYWxsb3dlZFRyYW5zaXRpb25zLnNldChzcmNTdGF0ZSwgbWFwKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW3R5cGUsIHRhcmdldF9dIG9mIE9iamVjdC5lbnRyaWVzKG1hcHBpbmcpKSB7XG4gICAgICAgIGlmIChtYXAuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRyeWluZyB0byBzZXQgdHJhbnNpdGlvbiBcIiR7dHlwZX1cIiBvbiBcIiR7c3JjU3RhdGV9XCIgKHZpYSBcIiR7bmFtZU9yUGF0dGVybn1cIiksIGJ1dCBhIHRyYW5zaXRpb24gYWxyZWFkeSBleGlzdHMgdGhlcmUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0XztcbiAgICAgICAgdGhpcy4ja25vd25FdmVudFR5cGVzLmFkZCh0eXBlKTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Rm4gPSB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgPyB0YXJnZXQgOiAoKSA9PiB0YXJnZXQ7XG4gICAgICAgICAgbWFwLnNldCh0eXBlLCB0YXJnZXRGbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIExpa2UgYC5hZGRUcmFuc2l0aW9uKClgLCBidXQgdGFrZXMgYW4gKGFub255bW91cykgdHJhbnNpdGlvbiB3aGVuZXZlciB0aGVcbiAgICogdGltZXIgZmlyZXMuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZU9yUGF0dGVybiAgVGhlIHN0YXRlIG5hbWUsIG9yIHN0YXRlIGdyb3VwIHBhdHRlcm4gbmFtZS5cbiAgICogQHBhcmFtIGFmdGVyICAgICAgICAgICBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRvIHRha2UgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbi4gSWYgaW4gdGhlIG1lYW4gdGltZSwgYW5vdGhlciB0cmFuc2l0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgaXMgdGFrZW4sIHRoZSB0aW1lciB3aWxsIGdldCBjYW5jZWxsZWQuXG4gICAqIEBwYXJhbSB0YXJnZXQgICAgICAgICAgVGhlIHRhcmdldCBzdGF0ZSB0byBnbyB0by5cbiAgICovXG4gIGFkZFRpbWVkVHJhbnNpdGlvbihzdGF0ZU9yUGF0dGVybiwgYWZ0ZXIyLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKHN0YXRlT3JQYXR0ZXJuLCAoKSA9PiB7XG4gICAgICBjb25zdCBtcyA9IHR5cGVvZiBhZnRlcjIgPT09IFwiZnVuY3Rpb25cIiA/IGFmdGVyMih0aGlzLiNjdXJyZW50Q29udGV4dC5jdXJyZW50KSA6IGFmdGVyMjtcbiAgICAgIGNvbnN0IHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiN0cmFuc2l0aW9uKHsgdHlwZTogXCJUSU1FUlwiIH0sIHRhcmdldCk7XG4gICAgICB9LCBtcyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgI2dldFRhcmdldEZuKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNhbGxvd2VkVHJhbnNpdGlvbnMuZ2V0KHRoaXMuY3VycmVudFN0YXRlKT8uZ2V0KGV2ZW50TmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4aXRzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBjbGVhbnVwIGZ1bmN0aW9ucy5cbiAgICogQ2FsbCB0aGlzIGJlZm9yZSBjaGFuZ2luZyB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIGxldmVscyBEZWZpbmVzIGhvdyBtYW55IFwibGV2ZWxzXCIgb2YgbmVzdGluZyB3aWxsIGJlXG4gICAqIGV4aXRlZC4gRm9yIGV4YW1wbGUsIGlmIHlvdSB0cmFuc2l0aW9uIGZyb20gYGZvby5iYXIucXV4YCB0b1xuICAgKiBgZm9vLmJhci5iYXpgLCB0aGVuIHRoZSBsZXZlbCBpcyAxLiBCdXQgaWYgeW91IHRyYW5zaXRpb24gZnJvbVxuICAgKiBgZm9vLmJhci5xdXhgIHRvIGBibGEuYmxhYCwgdGhlbiB0aGUgbGV2ZWwgaXMgMy5cbiAgICogSWYgYG51bGxgLCBpdCB3aWxsIGV4aXQgYWxsIGxldmVscy5cbiAgICovXG4gICNleGl0KGxldmVscykge1xuICAgIHRoaXMuI2V2ZW50SHViLndpbGxFeGl0U3RhdGUubm90aWZ5KHRoaXMuY3VycmVudFN0YXRlKTtcbiAgICB0aGlzLiNjdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMgPz8gdGhpcy4jY2xlYW51cFN0YWNrLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy4jY2xlYW51cFN0YWNrLnBvcCgpPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVudGVycyB0aGUgY3VycmVudCBzdGF0ZSwgYW5kIGV4ZWN1dGVzIGFueSBuZWNlc3Nhcnkgb25FbnRlciBoYW5kbGVycy5cbiAgICogQ2FsbCB0aGlzIGRpcmVjdGx5IF9hZnRlcl8gc2V0dGluZyB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICovXG4gICNlbnRlcihsZXZlbHMpIHtcbiAgICBjb25zdCBlbnRlclBhdHRlcm5zID0gcGF0dGVybnMoXG4gICAgICB0aGlzLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGxldmVscyA/PyB0aGlzLmN1cnJlbnRTdGF0ZS5zcGxpdChcIi5cIikubGVuZ3RoICsgMVxuICAgICk7XG4gICAgdGhpcy4jY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGVudGVyUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgZW50ZXJGbiA9IHRoaXMuI2VudGVyRm5zLmdldChwYXR0ZXJuKTtcbiAgICAgICAgY29uc3QgY2xlYW51cEZuID0gZW50ZXJGbj8uKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFudXBGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy4jY2xlYW51cFN0YWNrLnB1c2goY2xlYW51cEZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNjbGVhbnVwU3RhY2sucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuI2V2ZW50SHViLmRpZEVudGVyU3RhdGUubm90aWZ5KHRoaXMuY3VycmVudFN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYW4gZXZlbnQgdG8gdGhlIG1hY2hpbmUsIHdoaWNoIG1heSBjYXVzZSBhbiBpbnRlcm5hbCBzdGF0ZVxuICAgKiB0cmFuc2l0aW9uIHRvIGhhcHBlbi4gV2hlbiB0aGF0IGhhcHBlbnMsIHdpbGwgdHJpZ2dlciBzaWRlIGVmZmVjdHMuXG4gICAqL1xuICBzZW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNrbm93bkV2ZW50VHlwZXMuaGFzKGV2ZW50LnR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXZlbnQgJHtKU09OLnN0cmluZ2lmeShldmVudC50eXBlKX1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3J1bm5pbmdTdGF0ZSA9PT0gMiAvKiBTVE9QUEVEICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEZuID0gdGhpcy4jZ2V0VGFyZ2V0Rm4oZXZlbnQudHlwZSk7XG4gICAgaWYgKHRhcmdldEZuICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLiN0cmFuc2l0aW9uKGV2ZW50LCB0YXJnZXRGbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gICN0cmFuc2l0aW9uKGV2ZW50LCB0YXJnZXQpIHtcbiAgICB0aGlzLiNldmVudEh1Yi5kaWRSZWNlaXZlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuY3VycmVudFN0YXRlO1xuICAgIGNvbnN0IHRhcmdldEZuID0gdHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiID8gdGFyZ2V0IDogKCkgPT4gdGFyZ2V0O1xuICAgIGNvbnN0IG5leHRUYXJnZXQgPSB0YXJnZXRGbihldmVudCwgdGhpcy4jY3VycmVudENvbnRleHQuY3VycmVudCk7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBsZXQgZWZmZWN0cyA9IHZvaWQgMDtcbiAgICBpZiAobmV4dFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy4jZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXh0VGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXh0VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXh0VGFyZ2V0LnRhcmdldDtcbiAgICAgIGVmZmVjdHMgPSBBcnJheS5pc0FycmF5KG5leHRUYXJnZXQuZWZmZWN0KSA/IG5leHRUYXJnZXQuZWZmZWN0IDogW25leHRUYXJnZXQuZWZmZWN0XTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNzdGF0ZXMuaGFzKG5leHRTdGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuZXh0IHN0YXRlIG5hbWU6ICR7SlNPTi5zdHJpbmdpZnkobmV4dFN0YXRlKX1gKTtcbiAgICB9XG4gICAgdGhpcy4jZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ubm90aWZ5KHsgZnJvbTogb2xkU3RhdGUsIHRvOiBuZXh0U3RhdGUgfSk7XG4gICAgY29uc3QgW3VwLCBkb3duXSA9IGRpc3RhbmNlKHRoaXMuY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpO1xuICAgIGlmICh1cCA+IDApIHtcbiAgICAgIHRoaXMuI2V4aXQodXApO1xuICAgIH1cbiAgICB0aGlzLiNjdXJyZW50U3RhdGVPck51bGwgPSBuZXh0U3RhdGU7XG4gICAgaWYgKGVmZmVjdHMgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZWZmZWN0c1RvUnVuID0gZWZmZWN0cztcbiAgICAgIHRoaXMuI2N1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0c1RvUnVuKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWZmZWN0KHBhdGNoYWJsZUNvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hhYmxlQ29udGV4dC5wYXRjaChlZmZlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkb3duID4gMCkge1xuICAgICAgdGhpcy4jZW50ZXIoZG93bik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvU2VydmVyTXNnLnRzXG52YXIgU2VydmVyTXNnQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcnZlck1zZ0NvZGUyKSA9PiB7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1BSRVNFTkNFXCJdID0gMTAwXSA9IFwiVVBEQVRFX1BSRVNFTkNFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVNFUl9KT0lORURcIl0gPSAxMDFdID0gXCJVU0VSX0pPSU5FRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVTRVJfTEVGVFwiXSA9IDEwMl0gPSBcIlVTRVJfTEVGVFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkJST0FEQ0FTVEVEX0VWRU5UXCJdID0gMTAzXSA9IFwiQlJPQURDQVNURURfRVZFTlRcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJST09NX1NUQVRFXCJdID0gMTA0XSA9IFwiUk9PTV9TVEFURVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIklOSVRJQUxfU1RPUkFHRV9TVEFURVwiXSA9IDIwMF0gPSBcIklOSVRJQUxfU1RPUkFHRV9TVEFURVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJSRUpFQ1RfU1RPUkFHRV9PUFwiXSA9IDI5OV0gPSBcIlJFSkVDVF9TVE9SQUdFX09QXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1lET0NcIl0gPSAzMDBdID0gXCJVUERBVEVfWURPQ1wiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9DUkVBVEVEXCJdID0gNDAwXSA9IFwiVEhSRUFEX0NSRUFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfREVMRVRFRFwiXSA9IDQwN10gPSBcIlRIUkVBRF9ERUxFVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX01FVEFEQVRBX1VQREFURURcIl0gPSA0MDFdID0gXCJUSFJFQURfTUVUQURBVEFfVVBEQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9VUERBVEVEXCJdID0gNDA4XSA9IFwiVEhSRUFEX1VQREFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0NSRUFURURcIl0gPSA0MDJdID0gXCJDT01NRU5UX0NSRUFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0VESVRFRFwiXSA9IDQwM10gPSBcIkNPTU1FTlRfRURJVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9ERUxFVEVEXCJdID0gNDA0XSA9IFwiQ09NTUVOVF9ERUxFVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9SRUFDVElPTl9BRERFRFwiXSA9IDQwNV0gPSBcIkNPTU1FTlRfUkVBQ1RJT05fQURERURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRURcIl0gPSA0MDZdID0gXCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRURcIjtcbiAgcmV0dXJuIFNlcnZlck1zZ0NvZGUyO1xufSkoU2VydmVyTXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9JV2ViU29ja2V0LnRzXG52YXIgV2Vic29ja2V0Q2xvc2VDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFdlYnNvY2tldENsb3NlQ29kZXMyKSA9PiB7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfTk9STUFMXCJdID0gMWUzXSA9IFwiQ0xPU0VfTk9STUFMXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfQUJOT1JNQUxcIl0gPSAxMDA2XSA9IFwiQ0xPU0VfQUJOT1JNQUxcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJVTkVYUEVDVEVEX0NPTkRJVElPTlwiXSA9IDEwMTFdID0gXCJVTkVYUEVDVEVEX0NPTkRJVElPTlwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlRSWV9BR0FJTl9MQVRFUlwiXSA9IDEwMTNdID0gXCJUUllfQUdBSU5fTEFURVJcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCJdID0gNGUzXSA9IFwiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk5PVF9BTExPV0VEXCJdID0gNDAwMV0gPSBcIk5PVF9BTExPV0VEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfU0VDT05EU1wiXSA9IDQwMDJdID0gXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCJdID0gNDAwM10gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU1wiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCJdID0gNDAwNF0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCJdID0gNDAwNV0gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU19QRVJfUk9PTVwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlJPT01fSURfVVBEQVRFRFwiXSA9IDQwMDZdID0gXCJST09NX0lEX1VQREFURURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJLSUNLRURcIl0gPSA0MTAwXSA9IFwiS0lDS0VEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVE9LRU5fRVhQSVJFRFwiXSA9IDQxMDldID0gXCJUT0tFTl9FWFBJUkVEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfV0lUSE9VVF9SRVRSWVwiXSA9IDQ5OTldID0gXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCI7XG4gIHJldHVybiBXZWJzb2NrZXRDbG9zZUNvZGVzMjtcbn0pKFdlYnNvY2tldENsb3NlQ29kZXMgfHwge30pO1xuZnVuY3Rpb24gc2hvdWxkRGlzY29ubmVjdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSA0OTk5IC8qIENMT1NFX1dJVEhPVVRfUkVUUlkgKi8gfHwgY29kZSA+PSA0ZTMgJiYgY29kZSA8IDQxMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSA0MTAwICYmIGNvZGUgPCA0MjAwO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMTMgLyogVFJZX0FHQUlOX0xBVEVSICovIHx8IGNvZGUgPj0gNDIwMCAmJiBjb2RlIDwgNDMwMDtcbn1cblxuLy8gc3JjL2Nvbm5lY3Rpb24udHNcbmZ1bmN0aW9uIGlzSWRsZShzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gXCJpbml0aWFsXCIgfHwgc3RhdHVzID09PSBcImRpc2Nvbm5lY3RlZFwiO1xufVxuZnVuY3Rpb24gdG9OZXdDb25uZWN0aW9uU3RhdHVzKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhdGUgPSBtYWNoaW5lLmN1cnJlbnRTdGF0ZTtcbiAgc3dpdGNoIChzdGF0ZSkge1xuICAgIGNhc2UgXCJAb2suY29ubmVjdGVkXCI6XG4gICAgY2FzZSBcIkBvay5hd2FpdGluZy1wb25nXCI6XG4gICAgICByZXR1cm4gXCJjb25uZWN0ZWRcIjtcbiAgICBjYXNlIFwiQGlkbGUuaW5pdGlhbFwiOlxuICAgICAgcmV0dXJuIFwiaW5pdGlhbFwiO1xuICAgIGNhc2UgXCJAYXV0aC5idXN5XCI6XG4gICAgY2FzZSBcIkBhdXRoLmJhY2tvZmZcIjpcbiAgICBjYXNlIFwiQGNvbm5lY3RpbmcuYnVzeVwiOlxuICAgIGNhc2UgXCJAY29ubmVjdGluZy5iYWNrb2ZmXCI6XG4gICAgY2FzZSBcIkBpZGxlLnpvbWJpZVwiOlxuICAgICAgcmV0dXJuIG1hY2hpbmUuY29udGV4dC5zdWNjZXNzQ291bnQgPiAwID8gXCJyZWNvbm5lY3RpbmdcIiA6IFwiY29ubmVjdGluZ1wiO1xuICAgIGNhc2UgXCJAaWRsZS5mYWlsZWRcIjpcbiAgICAgIHJldHVybiBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihzdGF0ZSwgXCJVbmtub3duIHN0YXRlXCIpO1xuICB9XG59XG52YXIgQkFDS09GRl9ERUxBWVMgPSBbMjUwLCA1MDAsIDFlMywgMmUzLCA0ZTMsIDhlMywgMWU0XTtcbnZhciBSRVNFVF9ERUxBWSA9IEJBQ0tPRkZfREVMQVlTWzBdIC0gMTtcbnZhciBCQUNLT0ZGX0RFTEFZU19TTE9XID0gWzJlMywgM2U0LCA2ZTQsIDNlNV07XG52YXIgSEVBUlRCRUFUX0lOVEVSVkFMID0gM2U0O1xudmFyIFBPTkdfVElNRU9VVCA9IDJlMztcbnZhciBBVVRIX1RJTUVPVVQgPSAxZTQ7XG52YXIgU09DS0VUX0NPTk5FQ1RfVElNRU9VVCA9IDFlNDtcbnZhciBTdG9wUmV0cnlpbmcgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIocmVhc29uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIG5leHRCYWNrb2ZmRGVsYXkoY3VycmVudERlbGF5LCBkZWxheXMpIHtcbiAgcmV0dXJuIGRlbGF5cy5maW5kKChkZWxheSkgPT4gZGVsYXkgPiBjdXJyZW50RGVsYXkpID8/IGRlbGF5c1tkZWxheXMubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVMpXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHkoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHtcbiAgICBiYWNrb2ZmRGVsYXk6IG5leHRCYWNrb2ZmRGVsYXkoY29udGV4dC5iYWNrb2ZmRGVsYXksIEJBQ0tPRkZfREVMQVlTX1NMT1cpXG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzZXRTdWNjZXNzQ291bnQoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHsgc3VjY2Vzc0NvdW50OiAwIH0pO1xufVxuZnVuY3Rpb24gbG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGxvZ2dlciA9IGxldmVsID09PSAyIC8qIEVSUk9SICovID8gZXJyb3IyIDogbGV2ZWwgPT09IDEgLyogV0FSTiAqLyA/IHdhcm4gOiAoXG4gICAgLyogYmxhY2sgaG9sZSAqL1xuICAgICgpID0+IHtcbiAgICB9XG4gICk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbG9nZ2VyKG1lc3NhZ2UpO1xuICB9O1xufVxuZnVuY3Rpb24gbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZSkge1xuICBjb25zdCBjb25uID0gXCJDb25uZWN0aW9uIHRvIExpdmVibG9ja3Mgd2Vic29ja2V0IHNlcnZlclwiO1xuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHdhcm4oYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLiAke1N0cmluZyhlKX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgaXNDbG9zZUV2ZW50KGUpID8gYCR7Y29ubn0gY2xvc2VkIHByZW1hdHVyZWx5IChjb2RlOiAke2UuY29kZX0pLiBSZXRyeWluZyBpbiAke2N0eC5iYWNrb2ZmRGVsYXl9bXMuYCA6IGAke2Nvbm59IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGxvZ0Nsb3NlRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgZGV0YWlscyA9IFtgY29kZTogJHtldmVudC5jb2RlfWBdO1xuICBpZiAoZXZlbnQucmVhc29uKSB7XG4gICAgZGV0YWlscy5wdXNoKGByZWFzb246ICR7ZXZlbnQucmVhc29ufWApO1xuICB9XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgd2FybihcbiAgICAgIGBDb25uZWN0aW9uIHRvIExpdmVibG9ja3Mgd2Vic29ja2V0IHNlcnZlciBjbG9zZWQgKCR7ZGV0YWlscy5qb2luKFwiLCBcIil9KS4gUmV0cnlpbmcgaW4gJHtjdHguYmFja29mZkRlbGF5fW1zLmBcbiAgICApO1xuICB9O1xufVxudmFyIGxvZ1Blcm1hbmVudENsb3NlID0gbG9nKFxuICAxIC8qIFdBUk4gKi8sXG4gIFwiQ29ubmVjdGlvbiB0byBXZWJTb2NrZXQgY2xvc2VkIHBlcm1hbmVudGx5LiBXb24ndCByZXRyeS5cIlxuKTtcbmZ1bmN0aW9uIGlzQ2xvc2VFdmVudChlcnJvcjMpIHtcbiAgcmV0dXJuICEoZXJyb3IzIGluc3RhbmNlb2YgRXJyb3IpICYmIGVycm9yMy50eXBlID09PSBcImNsb3NlXCI7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFjaW5nKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhcnQgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgZnVuY3Rpb24gbG9nMiguLi5hcmdzKSB7XG4gICAgd2FybihcbiAgICAgIGAkeygoKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyAxZTMpLnRvRml4ZWQoMil9IFtGU00gIyR7bWFjaGluZS5pZH1dYCxcbiAgICAgIC4uLmFyZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IHVuc3VicyA9IFtcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRSZWNlaXZlRXZlbnQuc3Vic2NyaWJlKChlKSA9PiBsb2cyKGBFdmVudCAke2UudHlwZX1gKSksXG4gICAgbWFjaGluZS5ldmVudHMud2lsbFRyYW5zaXRpb24uc3Vic2NyaWJlKFxuICAgICAgKHsgZnJvbSwgdG8gfSkgPT4gbG9nMihcIlRyYW5zaXRpb25pbmdcIiwgZnJvbSwgXCJcXHUyMTkyXCIsIHRvKVxuICAgICksXG4gICAgbWFjaGluZS5ldmVudHMuZGlkSWdub3JlRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgKGUpID0+IGxvZzIoXCJJZ25vcmVkIGV2ZW50XCIsIGUudHlwZSwgZSwgXCIoY3VycmVudCBzdGF0ZSB3b24ndCBoYW5kbGUgaXQpXCIpXG4gICAgKVxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLndpbGxFeGl0U3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFeGl0aW5nIHN0YXRlXCIsIHMpKSxcbiAgICAvLyBtYWNoaW5lLmV2ZW50cy5kaWRFbnRlclN0YXRlLnN1YnNjcmliZSgocykgPT4gbG9nKFwiRW50ZXJpbmcgc3RhdGVcIiwgcykpLFxuICBdO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgICB1bnN1YigpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZUNvbm5lY3Rpdml0eUV2ZW50cyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXR1c0RpZENoYW5nZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBjb25zdCBkaWRDb25uZWN0ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZERpc2Nvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgbGV0IGxhc3RTdGF0dXMgPSBudWxsO1xuICBjb25zdCB1bnN1YnNjcmliZSA9IG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zdCBjdXJyU3RhdHVzID0gdG9OZXdDb25uZWN0aW9uU3RhdHVzKG1hY2hpbmUpO1xuICAgIGlmIChjdXJyU3RhdHVzICE9PSBsYXN0U3RhdHVzKSB7XG4gICAgICBzdGF0dXNEaWRDaGFuZ2Uubm90aWZ5KGN1cnJTdGF0dXMpO1xuICAgIH1cbiAgICBpZiAobGFzdFN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIiAmJiBjdXJyU3RhdHVzICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBkaWREaXNjb25uZWN0Lm5vdGlmeSgpO1xuICAgIH0gZWxzZSBpZiAobGFzdFN0YXR1cyAhPT0gXCJjb25uZWN0ZWRcIiAmJiBjdXJyU3RhdHVzID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBkaWRDb25uZWN0Lm5vdGlmeSgpO1xuICAgIH1cbiAgICBsYXN0U3RhdHVzID0gY3VyclN0YXR1cztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzRGlkQ2hhbmdlOiBzdGF0dXNEaWRDaGFuZ2Uub2JzZXJ2YWJsZSxcbiAgICBkaWRDb25uZWN0OiBkaWRDb25uZWN0Lm9ic2VydmFibGUsXG4gICAgZGlkRGlzY29ubmVjdDogZGlkRGlzY29ubmVjdC5vYnNlcnZhYmxlLFxuICAgIHVuc3Vic2NyaWJlXG4gIH07XG59XG52YXIgYXNzaWduID0gKHBhdGNoKSA9PiAoY3R4KSA9PiBjdHgucGF0Y2gocGF0Y2gpO1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblN0YXRlTWFjaGluZShkZWxlZ2F0ZXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb25NZXNzYWdlID0gbWFrZUJ1ZmZlcmFibGVFdmVudFNvdXJjZSgpO1xuICBvbk1lc3NhZ2UucGF1c2UoKTtcbiAgY29uc3Qgb25Db25uZWN0aW9uRXJyb3IgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZmlyZUVycm9yRXZlbnQobWVzc2FnZSwgY29kZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvbkNvbm5lY3Rpb25FcnJvci5ub3RpZnkoeyBtZXNzYWdlLCBjb2RlIH0pO1xuICAgIH07XG4gIH1cbiAgY29uc3QgaW5pdGlhbENvbnRleHQgPSB7XG4gICAgc3VjY2Vzc0NvdW50OiAwLFxuICAgIGF1dGhWYWx1ZTogbnVsbCxcbiAgICBzb2NrZXQ6IG51bGwsXG4gICAgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWVxuICB9O1xuICBjb25zdCBtYWNoaW5lID0gbmV3IEZTTShpbml0aWFsQ29udGV4dCkuYWRkU3RhdGUoXCJAaWRsZS5pbml0aWFsXCIpLmFkZFN0YXRlKFwiQGlkbGUuZmFpbGVkXCIpLmFkZFN0YXRlKFwiQGlkbGUuem9tYmllXCIpLmFkZFN0YXRlKFwiQGF1dGguYnVzeVwiKS5hZGRTdGF0ZShcIkBhdXRoLmJhY2tvZmZcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5idXN5XCIpLmFkZFN0YXRlKFwiQGNvbm5lY3RpbmcuYmFja29mZlwiKS5hZGRTdGF0ZShcIkBvay5jb25uZWN0ZWRcIikuYWRkU3RhdGUoXCJAb2suYXdhaXRpbmctcG9uZ1wiKTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIipcIiwge1xuICAgIFJFQ09OTkVDVDoge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCByZXNldFN1Y2Nlc3NDb3VudF1cbiAgICB9LFxuICAgIERJU0NPTk5FQ1Q6IFwiQGlkbGUuaW5pdGlhbFwiXG4gIH0pO1xuICBtYWNoaW5lLm9uRW50ZXIoXCJAaWRsZS4qXCIsIHJlc2V0U3VjY2Vzc0NvdW50KS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLipcIiwge1xuICAgIENPTk5FQ1Q6IChfLCBjdHgpID0+IChcbiAgICAgIC8vIElmIHdlIHN0aWxsIGhhdmUgYSBrbm93biBhdXRoVmFsdWUsIHRyeSB0byByZWNvbm5lY3QgdG8gdGhlIHNvY2tldCBkaXJlY3RseSxcbiAgICAgIC8vIG90aGVyd2lzZSwgdHJ5IHRvIG9idGFpbiBhIG5ldyBhdXRoVmFsdWVcbiAgICAgIGN0eC5hdXRoVmFsdWUgIT09IG51bGwgPyBcIkBjb25uZWN0aW5nLmJ1c3lcIiA6IFwiQGF1dGguYnVzeVwiXG4gICAgKVxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBhdXRoLmJhY2tvZmZcIiwge1xuICAgIE5BVklHQVRPUl9PTkxJTkU6IHtcbiAgICAgIHRhcmdldDogXCJAYXV0aC5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7IGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVkgfSlcbiAgICB9XG4gIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcbiAgICBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAoY3R4KSA9PiBjdHguYmFja29mZkRlbGF5LFxuICAgIFwiQGF1dGguYnVzeVwiXG4gICkub25FbnRlckFzeW5jKFxuICAgIFwiQGF1dGguYnVzeVwiLFxuICAgICgpID0+IHdpdGhUaW1lb3V0KFxuICAgICAgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpLFxuICAgICAgQVVUSF9USU1FT1VULFxuICAgICAgXCJUaW1lZCBvdXQgZHVyaW5nIGF1dGhcIlxuICAgICksXG4gICAgLy8gT24gc3VjY2Vzc2Z1bCBhdXRoZW50aWNhdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgYXV0aFZhbHVlOiBva0V2ZW50LmRhdGFcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gQXV0aCBmYWlsZWRcbiAgICAoZmFpbGVkRXZlbnQpID0+IHtcbiAgICAgIGlmIChmYWlsZWRFdmVudC5yZWFzb24gaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5LFxuICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgIDIgLyogRVJST1IgKi8sXG4gICAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2ZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIEVycm9yID8gZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UgOiBTdHJpbmcoZmFpbGVkRXZlbnQucmVhc29uKX1gXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgb25Tb2NrZXRFcnJvciA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfRVJST1JcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0Q2xvc2UgPSAoZXZlbnQpID0+IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pO1xuICBjb25zdCBvblNvY2tldE1lc3NhZ2UgPSAoZXZlbnQpID0+IGV2ZW50LmRhdGEgPT09IFwicG9uZ1wiID8gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJQT05HXCIgfSkgOiBvbk1lc3NhZ2Uubm90aWZ5KGV2ZW50KTtcbiAgZnVuY3Rpb24gdGVhcmRvd25Tb2NrZXQoc29ja2V0KSB7XG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvblNvY2tldEVycm9yKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgb25Tb2NrZXRDbG9zZSk7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAY29ubmVjdGluZy5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy9cbiAgICAvLyBVc2UgdGhlIFwiY3JlYXRlU29ja2V0XCIgZGVsZWdhdGUgZnVuY3Rpb24gKHByb3ZpZGVkIHRvIHRoZVxuICAgIC8vIE1hbmFnZWRTb2NrZXQpIHRvIGNyZWF0ZSB0aGUgYWN0dWFsIFdlYlNvY2tldCBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgIC8vIFRoZW4sIHNldCB1cCBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMsIGFuZCB3YWl0IGZvciB0aGVcbiAgICAvLyBcIm9wZW5cIiBldmVudCB0byBvY2N1ci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIFwib3BlblwiIGV2ZW50IGhhcHBlbnMsIHdlJ3JlIHJlYWR5IHRvIHRyYW5zaXRpb24gdG8gdGhlXG4gICAgLy8gT0sgc3RhdGUuIFRoaXMgaXMgZG9uZSBieSByZXNvbHZpbmcgdGhlIFByb21pc2UuXG4gICAgLy9cbiAgICBhc3luYyAoY3R4LCBzaWduYWwpID0+IHtcbiAgICAgIGxldCBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gbnVsbDtcbiAgICAgIGxldCB1bmNvbmZpcm1lZFNvY2tldCA9IG51bGw7XG4gICAgICBjb25zdCBjb25uZWN0JCA9IG5ldyBQcm9taXNlKFxuICAgICAgICAocmVzb2x2ZSwgcmVqKSA9PiB7XG4gICAgICAgICAgaWYgKGN0eC5hdXRoVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggYXV0aFZhbHVlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzb2NrZXQgPSBkZWxlZ2F0ZXMuY3JlYXRlU29ja2V0KGN0eC5hdXRoVmFsdWUpO1xuICAgICAgICAgIHVuY29uZmlybWVkU29ja2V0ID0gc29ja2V0O1xuICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdChldmVudCkge1xuICAgICAgICAgICAgY2FwdHVyZWRQcmVtYXR1cmVFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgICByZWooZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBbYWN0b3IkLCBkaWRSZWNlaXZlQWN0b3JdID0gY29udHJvbGxlZFByb21pc2UoKTtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIGRpZFJlY2VpdmVBY3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB3YWl0Rm9yQWN0b3JJZChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyTXNnID0gdHJ5UGFyc2VKc29uKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgaWYgKHNlcnZlck1zZz8udHlwZSA9PT0gMTA0IC8qIFJPT01fU1RBVEUgKi8pIHtcbiAgICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgICAgIGlmIChvcHRpb25zLndhaXRGb3JBY3RvcklkKSB7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdhaXRGb3JBY3RvcklkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2b2lkIGFjdG9yJC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShbc29ja2V0LCB1bnN1Yl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gd2l0aFRpbWVvdXQoXG4gICAgICAgIGNvbm5lY3QkLFxuICAgICAgICBTT0NLRVRfQ09OTkVDVF9USU1FT1VULFxuICAgICAgICBcIlRpbWVkIG91dCBkdXJpbmcgd2Vic29ja2V0IGNvbm5lY3Rpb25cIlxuICAgICAgKS50aGVuKFxuICAgICAgICAvL1xuICAgICAgICAvLyBQYXJ0IDM6XG4gICAgICAgIC8vIEJ5IG5vdywgb3VyIFwib3BlblwiIGV2ZW50IGhhcyBmaXJlZCwgYW5kIHRoZSBwcm9taXNlIGhhcyBiZWVuXG4gICAgICAgIC8vIHJlc29sdmVkLiBUd28gcG9zc2libGUgc2NlbmFyaW9zOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBUaGUgaGFwcHkgcGF0aC4gTW9zdCBsaWtlbHkuXG4gICAgICAgIC8vIDIuIFVoLW9oLiBBIHByZW1hdHVyZSBjbG9zZS9lcnJvciBldmVudCBoYXMgYmVlbiBvYnNlcnZlZC4gTGV0J3NcbiAgICAgICAgLy8gICAgcmVqZWN0IHRoZSBwcm9taXNlIGFmdGVyIGFsbC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQW55IGNsb3NlL2Vycm9yIGV2ZW50IHRoYXQgd2lsbCBnZXQgc2NoZWR1bGVkIGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gb253YXJkcywgd2lsbCBiZSBjYXVnaHQgaW4gdGhlIE9LIHN0YXRlLCBhbmQgZGVhbHQgd2l0aFxuICAgICAgICAvLyBhY2NvcmRpbmdseS5cbiAgICAgICAgLy9cbiAgICAgICAgKFtzb2NrZXQsIHVuc3ViXSkgPT4ge1xuICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYm9ydGVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FwdHVyZWRQcmVtYXR1cmVFdmVudCkge1xuICAgICAgICAgICAgdGhyb3cgY2FwdHVyZWRQcmVtYXR1cmVFdmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgICAgfVxuICAgICAgKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICB0ZWFyZG93blNvY2tldCh1bmNvbmZpcm1lZFNvY2tldCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIE9ubHkgdHJhbnNpdGlvbiB0byBPSyBzdGF0ZSBhZnRlciBhIHN1Y2Nlc3NmdWxseSBvcGVuZWQgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAob2tFdmVudCkgPT4gKHtcbiAgICAgIHRhcmdldDogXCJAb2suY29ubmVjdGVkXCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7XG4gICAgICAgIHNvY2tldDogb2tFdmVudC5kYXRhLFxuICAgICAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gICAgICB9KVxuICAgIH0pLFxuICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWRcbiAgICAoZmFpbHVyZSkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gZmFpbHVyZS5yZWFzb247XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU3RvcFJldHJ5aW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGVyci5tZXNzYWdlKSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGVyci5tZXNzYWdlLCAtMSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNDbG9zZUV2ZW50KGVycikpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSA0MTA5IC8qIFRPS0VOX0VYUElSRUQgKi8pIHtcbiAgICAgICAgICByZXR1cm4gXCJAYXV0aC5idXN5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgICBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSxcbiAgICAgICAgICAgICAgbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZXJyKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZXJyLmNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLnJlYXNvbiksXG4gICAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGVyci5yZWFzb24sIGVyci5jb2RlKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXVxuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IHNlbmRIZWFydGJlYXQgPSB7XG4gICAgdGFyZ2V0OiBcIkBvay5hd2FpdGluZy1wb25nXCIsXG4gICAgZWZmZWN0OiAoY3R4KSA9PiB7XG4gICAgICBjdHguc29ja2V0Py5zZW5kKFwicGluZ1wiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1heWJlSGVhcnRiZWF0ID0gKCkgPT4ge1xuICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICAgIGNvbnN0IGNhblpvbWJpZSA9IGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiICYmIGRlbGVnYXRlcy5jYW5ab21iaWUoKTtcbiAgICByZXR1cm4gY2FuWm9tYmllID8gXCJAaWRsZS56b21iaWVcIiA6IHNlbmRIZWFydGJlYXQ7XG4gIH07XG4gIG1hY2hpbmUuYWRkVGltZWRUcmFuc2l0aW9uKFwiQG9rLmNvbm5lY3RlZFwiLCBIRUFSVEJFQVRfSU5URVJWQUwsIG1heWJlSGVhcnRiZWF0KS5hZGRUcmFuc2l0aW9ucyhcIkBvay5jb25uZWN0ZWRcIiwge1xuICAgIE5BVklHQVRPUl9PRkZMSU5FOiBtYXliZUhlYXJ0YmVhdCxcbiAgICAvLyBEb24ndCB0YWtlIHRoZSBicm93c2VyJ3Mgd29yZCBmb3IgaXQgd2hlbiBpdCBzYXlzIGl0J3Mgb2ZmbGluZS4gRG8gYSBwaW5nL3BvbmcgdG8gbWFrZSBzdXJlLlxuICAgIFdJTkRPV19HT1RfRk9DVVM6IHNlbmRIZWFydGJlYXRcbiAgfSk7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAaWRsZS56b21iaWVcIiwge1xuICAgIFdJTkRPV19HT1RfRk9DVVM6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiXG4gICAgLy8gV2hlbiBpbiB6b21iaWUgc3RhdGUsIHRoZSBjbGllbnQgd2lsbCB0cnkgdG8gd2FrZSB1cCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHdpbmRvdyByZWdhaW5zIGZvY3VzXG4gIH0pO1xuICBtYWNoaW5lLm9uRW50ZXIoXCJAb2suKlwiLCAoY3R4KSA9PiB7XG4gICAgY3R4LnBhdGNoKHsgc3VjY2Vzc0NvdW50OiBjdHguc3VjY2Vzc0NvdW50ICsgMSB9KTtcbiAgICBjb25zdCB0aW1lcklEID0gc2V0VGltZW91dChcbiAgICAgIC8vIE9uIHRoZSBuZXh0IHRpY2ssIHN0YXJ0IGRlbGl2ZXJpbmcgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBhbHJlYWR5XG4gICAgICAvLyBiZWVuIHJlY2VpdmVkLCBhbmQgY29udGludWUgc3luY2hyb25vdXMgZGVsaXZlcnkgb2YgYWxsIGZ1dHVyZVxuICAgICAgLy8gaW5jb21pbmcgbWVzc2FnZXMuXG4gICAgICBvbk1lc3NhZ2UudW5wYXVzZSxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiAoY3R4MikgPT4ge1xuICAgICAgdGVhcmRvd25Tb2NrZXQoY3R4Mi5zb2NrZXQpO1xuICAgICAgY3R4Mi5wYXRjaCh7IHNvY2tldDogbnVsbCB9KTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTtcbiAgICAgIG9uTWVzc2FnZS5wYXVzZSgpO1xuICAgIH07XG4gIH0pLmFkZFRyYW5zaXRpb25zKFwiQG9rLmF3YWl0aW5nLXBvbmdcIiwgeyBQT05HOiBcIkBvay5jb25uZWN0ZWRcIiB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suYXdhaXRpbmctcG9uZ1wiLCBQT05HX1RJTUVPVVQsIHtcbiAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgIC8vIExvZyBpbXBsaWNpdCBjb25uZWN0aW9uIGxvc3MgYW5kIGRyb3AgdGhlIGN1cnJlbnQgb3BlbiBzb2NrZXRcbiAgICBlZmZlY3Q6IGxvZyhcbiAgICAgIDEgLyogV0FSTiAqLyxcbiAgICAgIFwiUmVjZWl2ZWQgbm8gcG9uZyBmcm9tIHNlcnZlciwgYXNzdW1lIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcy5cIlxuICAgIClcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suKlwiLCB7XG4gICAgLy8gV2hlbiBhIHNvY2tldCByZWNlaXZlcyBhbiBlcnJvciwgdGhpcyBjYW4gY2F1c2UgdGhlIGNsb3Npbmcgb2YgdGhlXG4gICAgLy8gc29ja2V0LCBvciBub3QuIFNvIGFsd2F5cyBjaGVjayB0byBzZWUgaWYgdGhlIHNvY2tldCBpcyBzdGlsbCBPUEVOIG9yXG4gICAgLy8gbm90LiBXaGVuIHN0aWxsIE9QRU4sIGRvbid0IHRyYW5zaXRpb24uXG4gICAgRVhQTElDSVRfU09DS0VUX0VSUk9SOiAoXywgY29udGV4dCkgPT4ge1xuICAgICAgaWYgKGNvbnRleHQuc29ja2V0Py5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBpbmNyZWFzZUJhY2tvZmZEZWxheVxuICAgICAgfTtcbiAgICB9LFxuICAgIEVYUExJQ0lUX1NPQ0tFVF9DTE9TRTogKGUpID0+IHtcbiAgICAgIGlmIChzaG91bGREaXNjb25uZWN0KGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2dQZXJtYW5lbnRDbG9zZSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGUuZXZlbnQucmVhc29uLCBlLmV2ZW50LmNvZGUpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIGlmIChlLmV2ZW50LmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICAgIGNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gICAgY29uc3Qgcm9vdCA9IHdpbiA/PyBkb2M7XG4gICAgbWFjaGluZS5vbkVudGVyKFwiKlwiLCAoY3R4KSA9PiB7XG4gICAgICBmdW5jdGlvbiBvbk5ldHdvcmtPZmZsaW5lKCkge1xuICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIk5BVklHQVRPUl9PRkZMSU5FXCIgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvbk5ldHdvcmtCYWNrT25saW5lKCkge1xuICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIk5BVklHQVRPUl9PTkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikge1xuICAgICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiV0lORE9XX0dPVF9GT0NVU1wiIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25OZXR3b3JrQmFja09ubGluZSk7XG4gICAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgcm9vdD8uYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJvb3Q/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICAgIHdpbj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvbk5ldHdvcmtPZmZsaW5lKTtcbiAgICAgICAgdGVhcmRvd25Tb2NrZXQoY3R4LnNvY2tldCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGNsZWFudXBzID0gW107XG4gIGNvbnN0IHsgc3RhdHVzRGlkQ2hhbmdlLCBkaWRDb25uZWN0LCBkaWREaXNjb25uZWN0LCB1bnN1YnNjcmliZSB9ID0gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpO1xuICBjbGVhbnVwcy5wdXNoKHVuc3Vic2NyaWJlKTtcbiAgaWYgKG9wdGlvbnMuZW5hYmxlRGVidWdMb2dnaW5nKSB7XG4gICAgY2xlYW51cHMucHVzaChlbmFibGVUcmFjaW5nKG1hY2hpbmUpKTtcbiAgfVxuICBtYWNoaW5lLnN0YXJ0KCk7XG4gIHJldHVybiB7XG4gICAgbWFjaGluZSxcbiAgICBjbGVhbnVwcyxcbiAgICAvLyBPYnNlcnZhYmxlIGV2ZW50cyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGlzIG1hY2hpbmVcbiAgICBldmVudHM6IHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZSxcbiAgICAgIGRpZENvbm5lY3QsXG4gICAgICBkaWREaXNjb25uZWN0LFxuICAgICAgb25NZXNzYWdlOiBvbk1lc3NhZ2Uub2JzZXJ2YWJsZSxcbiAgICAgIG9uQ29ubmVjdGlvbkVycm9yOiBvbkNvbm5lY3Rpb25FcnJvci5vYnNlcnZhYmxlXG4gICAgfVxuICB9O1xufVxudmFyIE1hbmFnZWRTb2NrZXQgPSBjbGFzcyB7XG4gICNtYWNoaW5lO1xuICAjY2xlYW51cHM7XG4gIGV2ZW50cztcbiAgY29uc3RydWN0b3IoZGVsZWdhdGVzLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgPSBmYWxzZSwgd2FpdEZvckFjdG9ySWQgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBtYWNoaW5lLCBldmVudHMsIGNsZWFudXBzIH0gPSBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKFxuICAgICAgZGVsZWdhdGVzLFxuICAgICAgeyB3YWl0Rm9yQWN0b3JJZCwgZW5hYmxlRGVidWdMb2dnaW5nIH1cbiAgICApO1xuICAgIHRoaXMuI21hY2hpbmUgPSBtYWNoaW5lO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMuI2NsZWFudXBzID0gY2xlYW51cHM7XG4gIH1cbiAgZ2V0U3RhdHVzKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdG9OZXdDb25uZWN0aW9uU3RhdHVzKHRoaXMuI21hY2hpbmUpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIFwiaW5pdGlhbFwiO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBhdXRoIGF1dGhWYWx1ZS5cbiAgICovXG4gIGdldCBhdXRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hY2hpbmUuY29udGV4dC5hdXRoVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyBtZXRob2QgdG8gdHJ5IHRvIGNvbm5lY3QgdG8gYSBXZWJTb2NrZXQuIFRoaXMgb25seSBoYXMgYW4gZWZmZWN0XG4gICAqIGlmIHRoZSBtYWNoaW5lIGlzIGlkbGUgYXQgdGhlIG1vbWVudCwgb3RoZXJ3aXNlIHRoaXMgaXMgYSBuby1vcC5cbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgdGhpcy4jbWFjaGluZS5zZW5kKHsgdHlwZTogXCJDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIGlkbGUsIHdpbGwgdHJ5IHRvIGNvbm5lY3QuIE90aGVyd2lzZSwgaXQgd2lsbCBhdHRlbXB0IHRvIHJlY29ubmVjdCB0b1xuICAgKiB0aGUgc29ja2V0LCBwb3RlbnRpYWxseSBvYnRhaW5pbmcgYSBuZXcgYXV0aFZhbHVlIGZpcnN0LCBpZiBuZWVkZWQuXG4gICAqL1xuICByZWNvbm5lY3QoKSB7XG4gICAgdGhpcy4jbWFjaGluZS5zZW5kKHsgdHlwZTogXCJSRUNPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byBkaXNjb25uZWN0IGZyb20gdGhlIGN1cnJlbnQgV2ViU29ja2V0LiBJcyBnb2luZyB0byBiZVxuICAgKiBhIG5vLW9wIGlmIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb25uZWN0aW9uLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLiNtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkRJU0NPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIHN0b3AgdGhlIG1hY2hpbmUgYW5kIHJ1biBuZWNlc3NhcnkgY2xlYW51cCBmdW5jdGlvbnMuIEFmdGVyXG4gICAqIGNhbGxpbmcgZGVzdHJveSgpLCB5b3UgY2FuIG5vIGxvbmdlciB1c2UgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzIGJlZm9yZVxuICAgKiBsZXR0aW5nIHRoZSBpbnN0YW5jZSBnZXQgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI21hY2hpbmUuc3RvcCgpO1xuICAgIGxldCBjbGVhbnVwO1xuICAgIHdoaWxlIChjbGVhbnVwID0gdGhpcy4jY2xlYW51cHMucG9wKCkpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNhZmVseSBzZW5kIGEgbWVzc2FnZSB0byB0aGUgY3VycmVudCBXZWJTb2NrZXQgY29ubmVjdGlvbi4gV2lsbCBlbWl0IGEgbG9nXG4gICAqIG1lc3NhZ2UgaWYgdGhpcyBpcyBzb21laG93IGltcG9zc2libGUuXG4gICAqL1xuICBzZW5kKGRhdGEpIHtcbiAgICBjb25zdCBzb2NrZXQgPSB0aGlzLiNtYWNoaW5lLmNvbnRleHQ/LnNvY2tldDtcbiAgICBpZiAoc29ja2V0ID09PSBudWxsKSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHNlbmQ6IG5vdCBjb25uZWN0ZWQgeWV0XCIsIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IDEpIHtcbiAgICAgIHdhcm4oXCJDYW5ub3Qgc2VuZDogV2ViU29ja2V0IG5vIGxvbmdlciBvcGVuXCIsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQuc2VuZChkYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE5PVEU6IFVzZWQgYnkgdGhlIEUyRSBhcHAgb25seSwgdG8gc2ltdWxhdGUgZXhwbGljaXQgZXZlbnRzLlxuICAgKiBOb3QgaWRlYWwgdG8ga2VlcCBleHBvc2VkIDooXG4gICAqL1xuICBfcHJpdmF0ZVNlbmRNYWNoaW5lRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLiNtYWNoaW5lLnNlbmQoZXZlbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvQXV0aFRva2VuLnRzXG52YXIgUGVybWlzc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKFBlcm1pc3Npb24yKSA9PiB7XG4gIFBlcm1pc3Npb24yW1wiUmVhZFwiXSA9IFwicm9vbTpyZWFkXCI7XG4gIFBlcm1pc3Npb24yW1wiV3JpdGVcIl0gPSBcInJvb206d3JpdGVcIjtcbiAgUGVybWlzc2lvbjJbXCJQcmVzZW5jZVdyaXRlXCJdID0gXCJyb29tOnByZXNlbmNlOndyaXRlXCI7XG4gIFBlcm1pc3Npb24yW1wiQ29tbWVudHNXcml0ZVwiXSA9IFwiY29tbWVudHM6d3JpdGVcIjtcbiAgUGVybWlzc2lvbjJbXCJDb21tZW50c1JlYWRcIl0gPSBcImNvbW1lbnRzOnJlYWRcIjtcbiAgcmV0dXJuIFBlcm1pc3Npb24yO1xufSkoUGVybWlzc2lvbiB8fCB7fSk7XG5mdW5jdGlvbiBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gY2FuQ29tbWVudChzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOndyaXRlXCIgLyogQ29tbWVudHNXcml0ZSAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkKGRhdGEpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoZGF0YSkgJiYgKGRhdGEuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcImlkXCIgLyogSURfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXV0aFRva2VuKHJhd1Rva2VuU3RyaW5nKSB7XG4gIGNvbnN0IHRva2VuUGFydHMgPSByYXdUb2tlblN0cmluZy5zcGxpdChcIi5cIik7XG4gIGlmICh0b2tlblBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBpbnZhbGlkIEpXVCB0b2tlblwiKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gdHJ5UGFyc2VKc29uKGI2NGRlY29kZSh0b2tlblBhcnRzWzFdKSk7XG4gIGlmICghKHBheWxvYWQgJiYgaXNWYWxpZEF1dGhUb2tlblBheWxvYWQocGF5bG9hZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBdXRoZW50aWNhdGlvbiBlcnJvcjogZXhwZWN0ZWQgYSB2YWxpZCB0b2tlbiBidXQgZGlkIG5vdCBnZXQgb25lLiBIaW50OiBpZiB5b3UgYXJlIHVzaW5nIGEgY2FsbGJhY2ssIGVuc3VyZSB0aGUgcm9vbSBpcyBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgdG9rZW4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudENhbGxiYWNrXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmF3OiByYXdUb2tlblN0cmluZyxcbiAgICBwYXJzZWQ6IHBheWxvYWRcbiAgfTtcbn1cblxuLy8gc3JjL2F1dGgtbWFuYWdlci50c1xuZnVuY3Rpb24gY3JlYXRlQXV0aE1hbmFnZXIoYXV0aE9wdGlvbnMsIG9uQXV0aGVudGljYXRlKSB7XG4gIGNvbnN0IGF1dGhlbnRpY2F0aW9uID0gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKTtcbiAgY29uc3Qgc2VlblRva2VucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBjb25zdCBleHBpcnlUaW1lcyA9IFtdO1xuICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBzZWVuVG9rZW5zLmNsZWFyKCk7XG4gICAgdG9rZW5zLmxlbmd0aCA9IDA7XG4gICAgZXhwaXJ5VGltZXMubGVuZ3RoID0gMDtcbiAgICByZXF1ZXN0UHJvbWlzZXMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RlZFNjb3BlLCBzY29wZXMpIHtcbiAgICBpZiAocmVxdWVzdGVkU2NvcGUgPT09IFwiY29tbWVudHM6cmVhZFwiKSB7XG4gICAgICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6cmVhZFwiIC8qIENvbW1lbnRzUmVhZCAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6d3JpdGVcIiAvKiBDb21tZW50c1dyaXRlICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOnJlYWRcIiAvKiBSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdGVkU2NvcGUgPT09IFwicm9vbTpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOnJlYWRcIiAvKiBSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdE9wdGlvbnMpIHtcbiAgICBjb25zdCBub3cgPSBNYXRoLmNlaWwoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgZm9yIChsZXQgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBleHBpcnlUaW1lc1tpXTtcbiAgICAgIGlmIChleHBpcmVzQXQgPD0gbm93KSB7XG4gICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGV4cGlyeVRpbWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiaWRcIiAvKiBJRF9UT0tFTiAqLykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnBhcnNlZC5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLykge1xuICAgICAgICBpZiAoIXJlcXVlc3RPcHRpb25zLnJvb21JZCAmJiBPYmplY3QuZW50cmllcyh0b2tlbi5wYXJzZWQucGVybXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtyZXNvdXJjZSwgc2NvcGVzXSBvZiBPYmplY3QuZW50cmllcyh0b2tlbi5wYXJzZWQucGVybXMpKSB7XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZS5pbmNsdWRlcyhcIipcIikgJiYgaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhyZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0ZWRTY29wZSwgc2NvcGVzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZS5pbmNsdWRlcyhcIipcIikgJiYgcmVxdWVzdE9wdGlvbnMucm9vbUlkLnN0YXJ0c1dpdGgocmVzb3VyY2UucmVwbGFjZShcIipcIiwgXCJcIikpIHx8IHJlcXVlc3RPcHRpb25zLnJvb21JZCA9PT0gcmVzb3VyY2UgJiYgaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhyZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0ZWRTY29wZSwgc2NvcGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1ha2VBdXRoUmVxdWVzdChvcHRpb25zKSB7XG4gICAgY29uc3QgZmV0Y2hlciA9IGF1dGhPcHRpb25zLnBvbHlmaWxscz8uZmV0Y2ggPz8gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiB3aW5kb3cuZmV0Y2gpO1xuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcInByaXZhdGVcIikge1xuICAgICAgaWYgKGZldGNoZXIgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCB3aXRoIGEgdXJsIGFzIGF1dGggZW5kcG9pbnQsIHlvdSBuZWVkIHRvIHByb3ZpZGUgYSBmZXRjaCBwb2x5ZmlsbC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEF1dGhFbmRwb2ludChmZXRjaGVyLCBhdXRoZW50aWNhdGlvbi51cmwsIHtcbiAgICAgICAgcm9vbTogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VBdXRoVG9rZW4ocmVzcG9uc2UudG9rZW4pO1xuICAgICAgaWYgKHNlZW5Ub2tlbnMuaGFzKHBhcnNlZC5yYXcpKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUaGUgc2FtZSBMaXZlYmxvY2tzIGF1dGggdG9rZW4gd2FzIGlzc3VlZCBmcm9tIHRoZSBiYWNrZW5kIGJlZm9yZS4gQ2FjaGluZyBMaXZlYmxvY2tzIHRva2VucyBpcyBub3Qgc3VwcG9ydGVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBvbkF1dGhlbnRpY2F0ZT8uKHBhcnNlZC5wYXJzZWQpO1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRpb24uY2FsbGJhY2sob3B0aW9ucy5yb29tSWQpO1xuICAgICAgaWYgKHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VBdXRoVG9rZW4ocmVzcG9uc2UudG9rZW4pO1xuICAgICAgICAgIG9uQXV0aGVudGljYXRlPy4ocGFyc2VkLnBhcnNlZCk7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2UuZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke1wicmVhc29uXCIgaW4gcmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlLnJlYXNvbiA9PT0gXCJzdHJpbmdcIiA/IHJlc3BvbnNlLnJlYXNvbiA6IFwiRm9yYmlkZGVuXCJ9YDtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IgPT09IFwiZm9yYmlkZGVuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcocmVhc29uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdZb3VyIGF1dGhlbnRpY2F0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSB0b2tlbiwgYnV0IGl0IGRpZCBub3QuIEhpbnQ6IHRoZSByZXR1cm4gdmFsdWUgc2hvdWxkIGxvb2sgbGlrZTogeyB0b2tlbjogXCIuLi5cIiB9J1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJVbmV4cGVjdGVkIGF1dGhlbnRpY2F0aW9uIHR5cGUuIE11c3QgYmUgcHJpdmF0ZSBvciBjdXN0b20uXCJcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEF1dGhWYWx1ZShyZXF1ZXN0T3B0aW9ucykge1xuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInB1YmxpY1wiLCBwdWJsaWNBcGlLZXk6IGF1dGhlbnRpY2F0aW9uLnB1YmxpY0FwaUtleSB9O1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRUb2tlbiA9IGdldENhY2hlZFRva2VuKHJlcXVlc3RPcHRpb25zKTtcbiAgICBpZiAoY2FjaGVkVG9rZW4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW46IGNhY2hlZFRva2VuIH07XG4gICAgfVxuICAgIGxldCBjdXJyZW50UHJvbWlzZTtcbiAgICBpZiAocmVxdWVzdE9wdGlvbnMucm9vbUlkKSB7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlcy5nZXQocmVxdWVzdE9wdGlvbnMucm9vbUlkKTtcbiAgICAgIGlmIChjdXJyZW50UHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGN1cnJlbnRQcm9taXNlID0gbWFrZUF1dGhSZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLnNldChyZXF1ZXN0T3B0aW9ucy5yb29tSWQsIGN1cnJlbnRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXF1ZXN0UHJvbWlzZXMuZ2V0KFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIpO1xuICAgICAgaWYgKGN1cnJlbnRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgY3VycmVudFByb21pc2UgPSBtYWtlQXV0aFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuc2V0KFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIsIGN1cnJlbnRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgY3VycmVudFByb21pc2U7XG4gICAgICBjb25zdCBCVUZGRVIgPSAzMDtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMykgKyAodG9rZW4ucGFyc2VkLmV4cCAtIHRva2VuLnBhcnNlZC5pYXQpIC0gQlVGRkVSO1xuICAgICAgc2VlblRva2Vucy5hZGQodG9rZW4ucmF3KTtcbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayAhPT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLykge1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGV4cGlyeVRpbWVzLnB1c2goZXhwaXJlc0F0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6IFwic2VjcmV0XCIsIHRva2VuIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLmRlbGV0ZShyZXF1ZXN0T3B0aW9ucy5yb29tSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLmRlbGV0ZShcImxpdmVibG9ja3MtdXNlci10b2tlblwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNldCxcbiAgICBnZXRBdXRoVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVBdXRoZW50aWNhdGlvbihhdXRoT3B0aW9ucykge1xuICBjb25zdCB7IHB1YmxpY0FwaUtleSwgYXV0aEVuZHBvaW50IH0gPSBhdXRoT3B0aW9ucztcbiAgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwICYmIHB1YmxpY0FwaUtleSAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2Fubm90IHNpbXVsdGFuZW91c2x5IHVzZSBgcHVibGljQXBpS2V5YCBhbmQgYGF1dGhFbmRwb2ludGAgb3B0aW9ucy4gUGxlYXNlIHBpY2sgb25lIGFuZCBsZWF2ZSB0aGUgb3RoZXIgb3B0aW9uIHVuc3BlY2lmaWVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwdWJsaWNBcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAocHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJza19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGBwdWJsaWNBcGlLZXlgIG9wdGlvbi4gVGhlIHZhbHVlIHlvdSBwYXNzZWQgaXMgYSBzZWNyZXQga2V5LCB3aGljaCBzaG91bGQgbm90IGJlIHVzZWQgZnJvbSB0aGUgY2xpZW50LiBQbGVhc2Ugb25seSBldmVyIHBhc3MgYSBwdWJsaWMga2V5IGhlcmUuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFB1YmxpY0tleVwiXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIXB1YmxpY0FwaUtleS5zdGFydHNXaXRoKFwicGtfXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBrZXkuIFBsZWFzZSB1c2UgdGhlIHB1YmxpYyBrZXkgZm9ybWF0OiBwa188cHVibGljIGtleT4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFB1YmxpY0tleVwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwdWJsaWNcIixcbiAgICAgIHB1YmxpY0FwaUtleVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBhdXRoRW5kcG9pbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwcml2YXRlXCIsXG4gICAgICB1cmw6IGF1dGhFbmRwb2ludFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgICBjYWxsYmFjazogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhdXRoRW5kcG9pbnQgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIGBhdXRoRW5kcG9pbnRgIG9wdGlvbiBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudEF1dGhFbmRwb2ludFwiXG4gICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJJbnZhbGlkIExpdmVibG9ja3MgY2xpZW50IG9wdGlvbnMuIFBsZWFzZSBwcm92aWRlIGVpdGhlciBhIGBwdWJsaWNBcGlLZXlgIG9yIGBhdXRoRW5kcG9pbnRgIG9wdGlvbi4gVGhleSBjYW5ub3QgYm90aCBiZSBlbXB0eS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50XCJcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQXV0aEVuZHBvaW50KGZldGNoLCBlbmRwb2ludCwgYm9keSkge1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9LFxuICAgIGJvZHk6IHN0cmluZ2lmeU9yTG9nKGJvZHkpXG4gIH0pO1xuICBpZiAoIXJlcy5vaykge1xuICAgIGNvbnN0IHJlYXNvbiA9IGAkeyhhd2FpdCByZXMudGV4dCgpKS50cmltKCkgfHwgXCJyZWFzb24gbm90IHByb3ZpZGVkIGluIGF1dGggcmVzcG9uc2VcIn0gKCR7cmVzLnN0YXR1c30gcmV0dXJuZWQgYnkgUE9TVCAke2VuZHBvaW50fSlgO1xuICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEgfHwgcmVzLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKGBVbmF1dGhvcml6ZWQ6ICR7cmVhc29ufWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhdXRoZW50aWNhdGU6ICR7cmVhc29ufWApO1xuICAgIH1cbiAgfVxuICBsZXQgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIHdoZW4gZG9pbmcgYSBQT1NUIHJlcXVlc3Qgb24gXCIke2VuZHBvaW50fVwiLiAke1N0cmluZyhcbiAgICAgICAgZXJcbiAgICAgICl9YFxuICAgICk7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpIHx8IHR5cGVvZiBkYXRhLnRva2VuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgSlNPTiByZXNwb25zZSBvZiB0aGUgZm9ybSBcXGB7IHRva2VuOiBcIi4uLlwiIH1cXGAgd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIsIGJ1dCBnb3QgJHtzdHJpbmdpZnlPckxvZyhcbiAgICAgICAgZGF0YVxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7IHRva2VuIH0gPSBkYXRhO1xuICByZXR1cm4geyB0b2tlbiB9O1xufVxuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgREVGQVVMVF9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9hcGkubGl2ZWJsb2Nrcy5pb1wiO1xuXG4vLyBzcmMvaW50ZXJuYWwudHNcbnZhciBrSW50ZXJuYWwgPSBTeW1ib2woKTtcblxuLy8gc3JjL2RldnRvb2xzL2JyaWRnZS50c1xudmFyIF9icmlkZ2VBY3RpdmUgPSBmYWxzZTtcbmZ1bmN0aW9uIGFjdGl2YXRlQnJpZGdlKGFsbG93ZWQpIHtcbiAgX2JyaWRnZUFjdGl2ZSA9IGFsbG93ZWQ7XG59XG5mdW5jdGlvbiBzZW5kVG9QYW5lbChtZXNzYWdlLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmdWxsTXNnID0ge1xuICAgIC4uLm1lc3NhZ2UsXG4gICAgc291cmNlOiBcImxpdmVibG9ja3MtZGV2dG9vbHMtY2xpZW50XCJcbiAgfTtcbiAgaWYgKCEob3B0aW9ucz8uZm9yY2UgfHwgX2JyaWRnZUFjdGl2ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LnBvc3RNZXNzYWdlKGZ1bGxNc2csIFwiKlwiKTtcbn1cbnZhciBldmVudFNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQuc291cmNlID09PSB3aW5kb3cgJiYgZXZlbnQuZGF0YT8uc291cmNlID09PSBcImxpdmVibG9ja3MtZGV2dG9vbHMtcGFuZWxcIikge1xuICAgICAgZXZlbnRTb3VyY2Uubm90aWZ5KGV2ZW50LmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgfVxuICB9KTtcbn1cbnZhciBvbk1lc3NhZ2VGcm9tUGFuZWwgPSBldmVudFNvdXJjZS5vYnNlcnZhYmxlO1xuXG4vLyBzcmMvZGV2dG9vbHMvaW5kZXgudHNcbnZhciBWRVJTSU9OID0gUEtHX1ZFUlNJT04gfHwgXCJkZXZcIjtcbnZhciBfZGV2dG9vbHNTZXR1cEhhc1J1biA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBEZXZUb29scyhnZXRBbGxSb29tcykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKF9kZXZ0b29sc1NldHVwSGFzUnVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gdHJ1ZTtcbiAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgc3dpdGNoIChtc2cubXNnKSB7XG4gICAgICAvLyBXaGVuIGEgZGV2dG9vbCBwYW5lbCBzZW5kcyBhbiBleHBsaWNpdCBcImNvbm5lY3RcIiBtZXNzYWdlIGJhY2sgdG8gdGhpc1xuICAgICAgLy8gbGl2ZSBydW5uaW5nIGNsaWVudCAoaW4gcmVzcG9uc2UgdG8gdGhlIFwid2FrZS11cC1kZXZ0b29sc1wiIG1lc3NhZ2UsXG4gICAgICAvLyBvciB3aGVuIHRoZSBkZXZ0b29sIHBhbmVsIGlzIG9wZW5lZCBmb3IgdGhlIGZpcnN0IHRpbWUpLCBpdCBtZWFucyB0aGF0IGl0J3Mgb2theSB0b1xuICAgICAgLy8gc3RhcnQgZW1pdHRpbmcgbWVzc2FnZXMuXG4gICAgICAvLyBCZWZvcmUgdGhpcyBleHBsaWNpdCBhY2tub3dsZWRnZW1lbnQsIGFueSBjYWxsIHRvIHNlbmRUb1BhbmVsKCkgd2lsbFxuICAgICAgLy8gYmUgYSBuby1vcC5cbiAgICAgIGNhc2UgXCJjb25uZWN0XCI6IHtcbiAgICAgICAgYWN0aXZhdGVCcmlkZ2UodHJ1ZSk7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbUlkIG9mIGdldEFsbFJvb21zKCkpIHtcbiAgICAgICAgICBzZW5kVG9QYW5lbCh7XG4gICAgICAgICAgICBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICBjbGllbnRWZXJzaW9uOiBWRVJTSU9OXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwid2FrZS11cC1kZXZ0b29sc1wiIH0sIHsgZm9yY2U6IHRydWUgfSk7XG59XG52YXIgdW5zdWJzQnlSb29tSWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFN5bmNTdHJlYW0ocm9vbUlkKSB7XG4gIGNvbnN0IHVuc3VicyA9IHVuc3Vic0J5Um9vbUlkLmdldChyb29tSWQpID8/IFtdO1xuICB1bnN1YnNCeVJvb21JZC5kZWxldGUocm9vbUlkKTtcbiAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICB1bnN1YigpO1xuICB9XG59XG5mdW5jdGlvbiBzdGFydFN5bmNTdHJlYW0ocm9vbSkge1xuICBzdG9wU3luY1N0cmVhbShyb29tLmlkKTtcbiAgZnVsbFN5bmMocm9vbSk7XG4gIHVuc3Vic0J5Um9vbUlkLnNldChyb29tLmlkLCBbXG4gICAgLy8gV2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlc1xuICAgIHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pKSxcbiAgICAvLyBXaGVuIHN0b3JhZ2UgaW5pdGlhbGl6ZXMsIHNlbmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2UoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBzdG9yYWdlIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyBzdG9yYWdlIHJvb3RcbiAgICByb29tLmV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSksXG4gICAgLy8gQW55IHRpbWUgXCJtZVwiIG9yIFwib3RoZXJzXCIgdXBkYXRlcywgc2VuZCB0aGUgbmV3IHZhbHVlcyBhY2NvcmRpbmdseVxuICAgIHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jTWUocm9vbSkpLFxuICAgIHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNPdGhlcnMocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIHlkb2MgaXMgdXBkYXRlZCwgZm9yd2FyZCB0aGUgdXBkYXRlXG4gICAgcm9vbS5ldmVudHMueWRvYy5zdWJzY3JpYmUoKHVwZGF0ZSkgPT4gc3luY1lkb2NVcGRhdGUocm9vbSwgdXBkYXRlKSksXG4gICAgLy8gQW55IHRpbWUgYSBjdXN0b20gcm9vbSBldmVudCBpcyByZWNlaXZlZCwgZm9yd2FyZCBpdFxuICAgIHJvb20uZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgIChldmVudERhdGEpID0+IGZvcndhcmRFdmVudChyb29tLCBldmVudERhdGEpXG4gICAgKVxuICBdKTtcbn1cbmZ1bmN0aW9uIHN5bmNZZG9jVXBkYXRlKHJvb20sIHVwZGF0ZSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6Onlkb2NcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgdXBkYXRlXG4gIH0pO1xufVxudmFyIGxvYWRlZEF0ID0gRGF0ZS5ub3coKTtcbnZhciBldmVudENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gbmV4dEV2ZW50SWQoKSB7XG4gIHJldHVybiBgZXZlbnQtJHtsb2FkZWRBdH0tJHtldmVudENvdW50ZXIrK31gO1xufVxuZnVuY3Rpb24gZm9yd2FyZEV2ZW50KHJvb20sIGV2ZW50RGF0YSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OmV2ZW50czo6Y3VzdG9tLWV2ZW50XCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBcIkN1c3RvbUV2ZW50XCIsXG4gICAgICBpZDogbmV4dEV2ZW50SWQoKSxcbiAgICAgIGtleTogXCJFdmVudFwiLFxuICAgICAgY29ubmVjdGlvbklkOiBldmVudERhdGEuY29ubmVjdGlvbklkLFxuICAgICAgcGF5bG9hZDogZXZlbnREYXRhLmV2ZW50XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jQ29ubmVjdGlvbihyb29tKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBzdGF0dXM6IHJvb20uZ2V0U3RhdHVzKClcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkge1xuICBjb25zdCByb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgaWYgKHJvb3QpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgc3RvcmFnZTogcm9vdC50b1RyZWVOb2RlKFwicm9vdFwiKS5wYXlsb2FkXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jTWUocm9vbSkge1xuICBjb25zdCBtZSA9IHJvb21ba0ludGVybmFsXS5nZXRTZWxmX2ZvckRldlRvb2xzKCk7XG4gIGlmIChtZSkge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBtZVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY090aGVycyhyb29tKSB7XG4gIGNvbnN0IG90aGVycyA9IHJvb21ba0ludGVybmFsXS5nZXRPdGhlcnNfZm9yRGV2VG9vbHMoKTtcbiAgaWYgKG90aGVycykge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBvdGhlcnNcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZnVsbFN5bmMocm9vbSkge1xuICBjb25zdCByb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgY29uc3QgbWUgPSByb29tW2tJbnRlcm5hbF0uZ2V0U2VsZl9mb3JEZXZUb29scygpO1xuICBjb25zdCBvdGhlcnMgPSByb29tW2tJbnRlcm5hbF0uZ2V0T3RoZXJzX2ZvckRldlRvb2xzKCk7XG4gIHJvb20uZmV0Y2hZRG9jKFwiXCIpO1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6OmZ1bGxcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgc3RhdHVzOiByb29tLmdldFN0YXR1cygpLFxuICAgIHN0b3JhZ2U6IHJvb3Q/LnRvVHJlZU5vZGUoXCJyb290XCIpLnBheWxvYWQgPz8gbnVsbCxcbiAgICBtZSxcbiAgICBvdGhlcnNcbiAgfSk7XG59XG52YXIgcm9vbUNoYW5uZWxMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKSB7XG4gIGNvbnN0IGxpc3RlbmVyID0gcm9vbUNoYW5uZWxMaXN0ZW5lcnMuZ2V0KHJvb21JZCk7XG4gIHJvb21DaGFubmVsTGlzdGVuZXJzLmRlbGV0ZShyb29tSWQpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcigpO1xuICB9XG59XG5mdW5jdGlvbiBsaW5rRGV2VG9vbHMocm9vbUlkLCByb29tKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBzZW5kVG9QYW5lbCh7IG1zZzogXCJyb29tOjphdmFpbGFibGVcIiwgcm9vbUlkLCBjbGllbnRWZXJzaW9uOiBWRVJTSU9OIH0pO1xuICBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpO1xuICByb29tQ2hhbm5lbExpc3RlbmVycy5zZXQoXG4gICAgcm9vbUlkLFxuICAgIC8vIFJldHVybnMgdGhlIHVuc3Vic2NyaWJlIGNhbGxiYWNrLCB0aGF0IHdlIHN0b3JlIGluIHRoZVxuICAgIC8vIHJvb21DaGFubmVsTGlzdGVuZXJzIHJlZ2lzdHJ5XG4gICAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgICAgLy8gU2VudCBieSB0aGUgZGV2dG9vbCBwYW5lbCB3aGVuIGl0IHdhbnRzIHRvIHJlY2VpdmUgdGhlIHN5bmMgc3RyZWFtXG4gICAgICAgIC8vIGZvciBhIHJvb21cbiAgICAgICAgY2FzZSBcInJvb206OnN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgaWYgKG1zZy5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgc3RhcnRTeW5jU3RyZWFtKHJvb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicm9vbTo6dW5zdWJzY3JpYmVcIjoge1xuICAgICAgICAgIGlmIChtc2cucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgIHN0b3BTeW5jU3RyZWFtKHJvb21JZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHVubGlua0RldlRvb2xzKHJvb21JZCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RvcFN5bmNTdHJlYW0ocm9vbUlkKTtcbiAgc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKTtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjp1bmF2YWlsYWJsZVwiLFxuICAgIHJvb21JZFxuICB9KTtcbn1cblxuLy8gc3JjL2xpYi9wb3NpdGlvbi50c1xudmFyIE1JTl9DT0RFID0gMzI7XG52YXIgTUFYX0NPREUgPSAxMjY7XG52YXIgTlVNX0RJR0lUUyA9IE1BWF9DT0RFIC0gTUlOX0NPREUgKyAxO1xudmFyIFpFUk8gPSBudGhEaWdpdCgwKTtcbnZhciBPTkUgPSBudGhEaWdpdCgxKTtcbnZhciBaRVJPX05JTkUgPSBaRVJPICsgbnRoRGlnaXQoLTEpO1xuZnVuY3Rpb24gbnRoRGlnaXQobikge1xuICBjb25zdCBjb2RlID0gTUlOX0NPREUgKyAobiA8IDAgPyBOVU1fRElHSVRTICsgbiA6IG4pO1xuICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuIHZhbHVlOiAke259YCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5mdW5jdGlvbiBtYWtlUG9zaXRpb24oeCwgeSkge1xuICBpZiAoeCAhPT0gdm9pZCAwICYmIHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZXR3ZWVuKHgsIHkpO1xuICB9IGVsc2UgaWYgKHggIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBhZnRlcih4KTtcbiAgfSBlbHNlIGlmICh5ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmVmb3JlKHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPTkU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJlZm9yZShwb3MpIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gcG9zLmxlbmd0aCAtIDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDw9IE1JTl9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IGxhc3RJbmRleCkge1xuICAgICAgaWYgKGNvZGUgPT09IE1JTl9DT0RFICsgMSkge1xuICAgICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFpFUk9fTklORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkgKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9ORTtcbn1cbmZ1bmN0aW9uIGFmdGVyKHBvcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwb3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IE1BWF9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAxKTtcbiAgfVxuICByZXR1cm4gcG9zICsgT05FO1xufVxuZnVuY3Rpb24gYmV0d2VlbihsbywgaGkpIHtcbiAgaWYgKGxvIDwgaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4obG8sIGhpKTtcbiAgfSBlbHNlIGlmIChsbyA+IGhpKSB7XG4gICAgcmV0dXJuIF9iZXR3ZWVuKGhpLCBsbyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgdmFsdWUgYmV0d2VlbiB0d28gZXF1YWwgcG9zaXRpb25zXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfYmV0d2VlbihsbywgaGkpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbG9MZW4gPSBsby5sZW5ndGg7XG4gIGNvbnN0IGhpTGVuID0gaGkubGVuZ3RoO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGxvQ29kZSA9IGluZGV4IDwgbG9MZW4gPyBsby5jaGFyQ29kZUF0KGluZGV4KSA6IE1JTl9DT0RFO1xuICAgIGNvbnN0IGhpQ29kZSA9IGluZGV4IDwgaGlMZW4gPyBoaS5jaGFyQ29kZUF0KGluZGV4KSA6IE1BWF9DT0RFO1xuICAgIGlmIChsb0NvZGUgPT09IGhpQ29kZSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaGlDb2RlIC0gbG9Db2RlID09PSAxKSB7XG4gICAgICBjb25zdCBzaXplID0gaW5kZXggKyAxO1xuICAgICAgbGV0IHByZWZpeCA9IGxvLnN1YnN0cmluZygwLCBzaXplKTtcbiAgICAgIGlmIChwcmVmaXgubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBwcmVmaXggKz0gWkVSTy5yZXBlYXQoc2l6ZSAtIHByZWZpeC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VmZml4ID0gbG8uc3Vic3RyaW5nKHNpemUpO1xuICAgICAgY29uc3QgbmluZXMgPSBcIlwiO1xuICAgICAgcmV0dXJuIHByZWZpeCArIF9iZXR3ZWVuKHN1ZmZpeCwgbmluZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFrZU4obG8sIGluZGV4KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlDb2RlICsgbG9Db2RlID4+IDEpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGFrZU4ocG9zLCBuKSB7XG4gIHJldHVybiBuIDwgcG9zLmxlbmd0aCA/IHBvcy5zdWJzdHJpbmcoMCwgbikgOiBwb3MgKyBaRVJPLnJlcGVhdChuIC0gcG9zLmxlbmd0aCk7XG59XG52YXIgTUlOX05PTl9aRVJPX0NPREUgPSBNSU5fQ09ERSArIDE7XG5mdW5jdGlvbiBpc1BvcyhzdHIpIHtcbiAgaWYgKHN0ciA9PT0gXCJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0SWR4ID0gc3RyLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGxhc3QgPSBzdHIuY2hhckNvZGVBdChsYXN0SWR4KTtcbiAgaWYgKGxhc3QgPCBNSU5fTk9OX1pFUk9fQ09ERSB8fCBsYXN0ID4gTUFYX0NPREUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SWR4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCBNSU5fQ09ERSB8fCBjb2RlID4gTUFYX0NPREUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Qb3Moc3RyKSB7XG4gIGNvbnN0IGNvZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGNvZGVzLnB1c2goY29kZSA8IE1JTl9DT0RFID8gTUlOX0NPREUgOiBjb2RlID4gTUFYX0NPREUgPyBNQVhfQ09ERSA6IGNvZGUpO1xuICB9XG4gIHdoaWxlIChjb2Rlcy5sZW5ndGggPiAwICYmIGNvZGVzW2NvZGVzLmxlbmd0aCAtIDFdID09PSBNSU5fQ09ERSkge1xuICAgIGNvZGVzLmxlbmd0aC0tO1xuICB9XG4gIHJldHVybiBjb2Rlcy5sZW5ndGggPiAwID8gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5jb2RlcykgOiAoXG4gICAgLy8gRWRnZSBjYXNlOiB0aGUgc3RyIHdhcyBhIDAtb25seSBzdHJpbmcsIHdoaWNoIGlzIGludmFsaWQuIERlZmF1bHQgYmFjayB0byAuMVxuICAgIE9ORVxuICApO1xufVxuZnVuY3Rpb24gYXNQb3Moc3RyKSB7XG4gIHJldHVybiBpc1BvcyhzdHIpID8gc3RyIDogY29udmVydFRvUG9zKHN0cik7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9PcC50c1xudmFyIE9wQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE9wQ29kZTIpID0+IHtcbiAgT3BDb2RlMltPcENvZGUyW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlNFVF9QQVJFTlRfS0VZXCJdID0gMV0gPSBcIlNFVF9QQVJFTlRfS0VZXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9MSVNUXCJdID0gMl0gPSBcIkNSRUFURV9MSVNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlVQREFURV9PQkpFQ1RcIl0gPSAzXSA9IFwiVVBEQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfT0JKRUNUXCJdID0gNF0gPSBcIkNSRUFURV9PQkpFQ1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX0NSRFRcIl0gPSA1XSA9IFwiREVMRVRFX0NSRFRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX09CSkVDVF9LRVlcIl0gPSA2XSA9IFwiREVMRVRFX09CSkVDVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX01BUFwiXSA9IDddID0gXCJDUkVBVEVfTUFQXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9SRUdJU1RFUlwiXSA9IDhdID0gXCJDUkVBVEVfUkVHSVNURVJcIjtcbiAgcmV0dXJuIE9wQ29kZTI7XG59KShPcENvZGUgfHwge30pO1xuZnVuY3Rpb24gYWNrT3Aob3BJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgaWQ6IFwiQUNLXCIsXG4gICAgLy8gKEgpQUNLXG4gICAgb3BJZFxuICB9O1xufVxuZnVuY3Rpb24gaXNBY2tPcChvcCkge1xuICByZXR1cm4gb3AudHlwZSA9PT0gNSAvKiBERUxFVEVfQ1JEVCAqLyAmJiBvcC5pZCA9PT0gXCJBQ0tcIjtcbn1cblxuLy8gc3JjL2NyZHRzL0Fic3RyYWN0Q3JkdC50c1xuZnVuY3Rpb24gY3JkdEFzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gSGFzUGFyZW50KG5vZGUsIGtleSwgcG9zID0gYXNQb3Moa2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiSGFzUGFyZW50XCIsIG5vZGUsIGtleSwgcG9zIH0pO1xufVxudmFyIE5vUGFyZW50ID0gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiTm9QYXJlbnRcIiB9KTtcbmZ1bmN0aW9uIE9ycGhhbmVkKG9sZEtleSwgb2xkUG9zID0gYXNQb3Mob2xkS2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiT3JwaGFuZWRcIiwgb2xkS2V5LCBvbGRQb3MgfSk7XG59XG52YXIgQWJzdHJhY3RDcmR0ID0gY2xhc3Mge1xuICAvLyAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5eXiBUT0RPOiBNYWtlIHRoaXMgYW4gaW50ZXJmYWNlXG4gICNwb29sO1xuICAjaWQ7XG4gICNwYXJlbnQgPSBOb1BhcmVudDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0UGFyZW50S2V5T3JUaHJvdygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQga2V5IGlzIG1pc3NpbmdcIik7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZEtleTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50UG9zKCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zO1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkUG9zO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wb29sKCkge1xuICAgIHJldHVybiB0aGlzLiNwb29sO1xuICB9XG4gIGdldCByb29tSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvb2wgPyB0aGlzLiNwb29sLnJvb21JZCA6IG51bGw7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX2lkKCkge1xuICAgIHJldHVybiB0aGlzLiNpZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BhcmVudDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50S2V5KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRLZXk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIF9pc0xvY2FsKSB7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDUgLyogREVMRVRFX0NSRFQgKi86IHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZS5fZGV0YWNoQ2hpbGQoY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRQYXJlbnRMaW5rKG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQubm9kZSAhPT0gbmV3UGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcGFyZW50OiBub2RlIGFscmVhZHkgaGFzIGEgcGFyZW50XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI3BhcmVudCA9IEhhc1BhcmVudChuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLiNwYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIGlmICh0aGlzLiNpZCB8fCB0aGlzLiNwb29sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXR0YWNoIG5vZGU6IGFscmVhZHkgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIHBvb2wuYWRkTm9kZShpZCwgY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgIHRoaXMuI2lkID0gaWQ7XG4gICAgdGhpcy4jcG9vbCA9IHBvb2w7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIGlmICh0aGlzLiNwb29sICYmIHRoaXMuI2lkKSB7XG4gICAgICB0aGlzLiNwb29sLmRlbGV0ZU5vZGUodGhpcy4jaWQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjoge1xuICAgICAgICB0aGlzLiNwYXJlbnQgPSBPcnBoYW5lZCh0aGlzLnBhcmVudC5rZXksIHRoaXMucGFyZW50LnBvcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gTm9QYXJlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6IHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgICB0aGlzLiNwb29sID0gdm9pZCAwO1xuICB9XG4gIC8qKiBUaGlzIGNhY2hlcyB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IC50b0ltbXV0YWJsZSgpIGNhbGwgZm9yIHRoaXMgTGl2ZSBub2RlLiAqL1xuICAjY2FjaGVkSW1tdXRhYmxlO1xuICAjY2FjaGVkVHJlZU5vZGVLZXk7XG4gIC8qKiBUaGlzIGNhY2hlcyB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IC50b1RyZWVOb2RlKCkgY2FsbCBmb3IgdGhpcyBMaXZlIG5vZGUuICovXG4gICNjYWNoZWRUcmVlTm9kZTtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBDbGVhciB0aGUgSW1tdXRhYmxlIGNhY2hlLCBzbyB0aGF0IHRoZSBuZXh0IGNhbGwgdG8gYC50b0ltbXV0YWJsZSgpYCB3aWxsXG4gICAqIHJlY29tcHV0ZSB0aGUgZXF1aXZhbGVudCBJbW11dGFibGUgdmFsdWUgYWdhaW4uICBDYWxsIHRoaXMgYWZ0ZXIgZXZlcnlcbiAgICogbXV0YXRpb24gdG8gdGhlIExpdmUgbm9kZS5cbiAgICovXG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZEltbXV0YWJsZSAhPT0gdm9pZCAwIHx8IHRoaXMuI2NhY2hlZFRyZWVOb2RlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuI2NhY2hlZEltbXV0YWJsZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuI2NhY2hlZFRyZWVOb2RlID0gdm9pZCAwO1xuICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm9kZS5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogUmV0dXJuIGFuIHNuYXBzaG90IG9mIHRoaXMgTGl2ZSB0cmVlIGZvciB1c2UgaW4gRGV2VG9vbHMuXG4gICAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIGlmICh0aGlzLiNjYWNoZWRUcmVlTm9kZSA9PT0gdm9pZCAwIHx8IHRoaXMuI2NhY2hlZFRyZWVOb2RlS2V5ICE9PSBrZXkpIHtcbiAgICAgIHRoaXMuI2NhY2hlZFRyZWVOb2RlS2V5ID0ga2V5O1xuICAgICAgdGhpcy4jY2FjaGVkVHJlZU5vZGUgPSB0aGlzLl90b1RyZWVOb2RlKGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjYWNoZWRUcmVlTm9kZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIGltbXV0YWJsZSBzbmFwc2hvdCBvZiB0aGlzIExpdmUgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKi9cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZEltbXV0YWJsZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLiNjYWNoZWRJbW11dGFibGUgPSB0aGlzLl90b0ltbXV0YWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVkSW1tdXRhYmxlO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvU2VyaWFsaXplZENyZHQudHNcbnZhciBDcmR0VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENyZHRUeXBlMikgPT4ge1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiT0JKRUNUXCJdID0gMF0gPSBcIk9CSkVDVFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiTElTVFwiXSA9IDFdID0gXCJMSVNUXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJNQVBcIl0gPSAyXSA9IFwiTUFQXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJSRUdJU1RFUlwiXSA9IDNdID0gXCJSRUdJU1RFUlwiO1xuICByZXR1cm4gQ3JkdFR5cGUyO1xufSkoQ3JkdFR5cGUgfHwge30pO1xuZnVuY3Rpb24gaXNSb290Q3JkdChjcmR0KSB7XG4gIHJldHVybiBjcmR0LnR5cGUgPT09IDAgLyogT0JKRUNUICovICYmICFpc0NoaWxkQ3JkdChjcmR0KTtcbn1cbmZ1bmN0aW9uIGlzQ2hpbGRDcmR0KGNyZHQpIHtcbiAgcmV0dXJuIGNyZHQucGFyZW50SWQgIT09IHZvaWQgMCAmJiBjcmR0LnBhcmVudEtleSAhPT0gdm9pZCAwO1xufVxuXG4vLyBzcmMvY3JkdHMvTGl2ZVJlZ2lzdGVyLnRzXG52YXIgTGl2ZVJlZ2lzdGVyID0gY2xhc3MgX0xpdmVSZWdpc3RlciBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gICNkYXRhO1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNkYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZGF0YTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgX3BhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCByZWdpc3RlciA9IG5ldyBfTGl2ZVJlZ2lzdGVyKGl0ZW0uZGF0YSk7XG4gICAgcmVnaXN0ZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHJlZ2lzdGVyO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCBzZXJpYWxpemUgcmVnaXN0ZXIgaWYgcGFyZW50SWQgb3IgcGFyZW50S2V5IGlzIHVuZGVmaW5lZFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgcGFyZW50SWQsXG4gICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZVJlZ2lzdGVyIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMyAvKiBSRUdJU1RFUiAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKF9vcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKF9jcmR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkpzb25cIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuI2RhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5kYXRhKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVMaXN0LnRzXG5mdW5jdGlvbiBjb21wYXJlTm9kZVBvc2l0aW9uKGl0ZW1BLCBpdGVtQikge1xuICBjb25zdCBwb3NBID0gaXRlbUEuX3BhcmVudFBvcztcbiAgY29uc3QgcG9zQiA9IGl0ZW1CLl9wYXJlbnRQb3M7XG4gIHJldHVybiBwb3NBID09PSBwb3NCID8gMCA6IHBvc0EgPCBwb3NCID8gLTEgOiAxO1xufVxudmFyIExpdmVMaXN0ID0gY2xhc3MgX0xpdmVMaXN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgLy8gVE9ETzogTmFpdmUgYXJyYXkgYXQgZmlyc3QsIGZpbmQgYSBiZXR0ZXIgZGF0YSBzdHJ1Y3R1cmUuIE1heWJlIGFuIE9yZGVyIHN0YXRpc3RpY3MgdHJlZT9cbiAgI2l0ZW1zO1xuICAjaW1wbGljaXRseURlbGV0ZWRJdGVtcztcbiAgI3VuYWNrbm93bGVkZ2VkU2V0cztcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI2l0ZW1zID0gW107XG4gICAgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHBvc2l0aW9uID0gdm9pZCAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBtYWtlUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgY29uc3Qgbm9kZSA9IGxzb25Ub0xpdmVOb2RlKGl0ZW0pO1xuICAgICAgbm9kZS5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdQb3NpdGlvbik7XG4gICAgICB0aGlzLiNpdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgcG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBsaXN0ID0gbmV3IF9MaXZlTGlzdChbXSk7XG4gICAgbGlzdC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobGlzdCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbGlzdC5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHJlc3VsdGluZyBvcHMgd2lsbCBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgaWYgdGhleSBoYXZlIGFuICdvcElkJ1xuICAgKiBzbyB3ZSBtdXRhdGUgX3VuYWNrbm93bGVkZ2VkU2V0cyB0byBhdm9pZCBwb3RlbnRpYWwgZmxpY2tlcmluZ1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWJsb2Nrcy9saXZlYmxvY2tzL3B1bGwvMTE3N1xuICAgKlxuICAgKiBUaGlzIGlzIHF1aXRlIHVuaW50dWl0aXZlIGFuZCBzaG91bGQgZGlzYXBwZWFyIGFzIHNvb24gYXNcbiAgICogd2UgaW50cm9kdWNlIGFuIGV4cGxpY2l0IExpdmVMaXN0LlNldCBvcGVyYXRpb25cbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXlcbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jaXRlbXMpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleTIgPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgICBjb25zdCBjaGlsZE9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwYXJlbnRLZXkyLCBwb29sKSxcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgY29uc3QgY2hpbGRPcElkID0gY2hpbGRPcHNbMF0ub3BJZDtcbiAgICAgIGlmIChjaGlsZE9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldHMuc2V0KHBhcmVudEtleTIsIGNoaWxkT3BJZCk7XG4gICAgICB9XG4gICAgICBvcHMucHVzaCguLi5jaGlsZE9wcyk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gaW50byB0aGUgc29ydGVkIGxpc3QsIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uLlxuICAgKi9cbiAgX2luc2VydEFuZFNvcnQoaXRlbSkge1xuICAgIHRoaXMuI2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc29ydEl0ZW1zKCkge1xuICAgIHRoaXMuI2l0ZW1zLnNvcnQoY29tcGFyZU5vZGVQb3NpdGlvbik7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5kZXhPZlBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuI2l0ZW1zLmZpbmRJbmRleChcbiAgICAgIChpdGVtKSA9PiBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkgPT09IHBvc2l0aW9uXG4gICAgKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jaXRlbXMpIHtcbiAgICAgIGl0ZW0uX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuI2l0ZW1zKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgI2FwcGx5U2V0UmVtb3RlKG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgZGVsZXRlZElkID0gb3AuZGVsZXRlZElkO1xuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICBjb25zdCBpdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuI2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl07XG4gICAgICBpZiAoaXRlbVdpdGhTYW1lUG9zaXRpb24uX2lkID09PSBkZWxldGVkSWQpIHtcbiAgICAgICAgaXRlbVdpdGhTYW1lUG9zaXRpb24uX2RldGFjaCgpO1xuICAgICAgICB0aGlzLiNpdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dID0gY2hpbGQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBjaGlsZClcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5hZGQoaXRlbVdpdGhTYW1lUG9zaXRpb24pO1xuICAgICAgICB0aGlzLiNpdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dID0gY2hpbGQ7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gW1xuICAgICAgICAgIHNldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgY2hpbGQpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGRlbGV0ZURlbHRhMiA9IHRoaXMuI2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oXG4gICAgICAgICAgb3AuZGVsZXRlZElkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChkZWxldGVEZWx0YTIpIHtcbiAgICAgICAgICBkZWx0YS5wdXNoKGRlbGV0ZURlbHRhMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgICAgY29uc3QgZGVsZXRlRGVsdGEyID0gdGhpcy4jZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgb3AuZGVsZXRlZElkXG4gICAgICApO1xuICAgICAgaWYgKGRlbGV0ZURlbHRhMikge1xuICAgICAgICB1cGRhdGVzLnB1c2goZGVsZXRlRGVsdGEyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgdXBkYXRlcy5wdXNoKGluc2VydERlbHRhKHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpLCBjaGlsZCkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmV2ZXJzZTogW10sXG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIHVwZGF0ZXMpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAjYXBwbHlTZXRBY2sob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YSA9IFtdO1xuICAgIGNvbnN0IGRlbGV0ZWREZWx0YSA9IHRoaXMuI2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24ob3AuZGVsZXRlZElkKTtcbiAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICBkZWx0YS5wdXNoKGRlbGV0ZWREZWx0YSk7XG4gICAgfVxuICAgIGNvbnN0IHVuYWNrbm93bGVkZ2VkT3BJZCA9IHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0cy5nZXQob3AucGFyZW50S2V5KTtcbiAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh1bmFja25vd2xlZGdlZE9wSWQgIT09IG9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhLmxlbmd0aCA9PT0gMCA/IHsgbW9kaWZpZWQ6IGZhbHNlIH0gOiB7IG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSwgcmV2ZXJzZTogW10gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0cy5kZWxldGUob3AucGFyZW50S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy4jaXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5faWQgPT09IG9wLmlkKTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0gb3AucGFyZW50S2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChcbiAgICAgICAgICB0aGlzLiNpdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IFtwcmV2Tm9kZV0gPSB0aGlzLiNpdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIHByZXZOb2RlKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBpZiAobmV3SW5kZXggIT09IHByZXZJbmRleCkge1xuICAgICAgICBkZWx0YS5wdXNoKG1vdmVEZWx0YShwcmV2SW5kZXgsIG5ld0luZGV4LCBleGlzdGluZ0l0ZW0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBkZWx0YS5sZW5ndGggPiAwID8gbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSkgOiBmYWxzZSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9ycGhhbiA9IHRoaXMuX3Bvb2wuZ2V0Tm9kZShvcC5pZCk7XG4gICAgICBpZiAob3JwaGFuICYmIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKG9ycGhhbikpIHtcbiAgICAgICAgb3JwaGFuLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG9wLnBhcmVudEtleSk7XG4gICAgICAgIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKG9ycGhhbik7XG4gICAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQob3JwaGFuKTtcbiAgICAgICAgY29uc3QgcmVjcmVhdGVkSXRlbUluZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihvcnBoYW4pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEocmVjcmVhdGVkSXRlbUluZGV4LCBvcnBoYW4pIDogc2V0RGVsdGEocmVjcmVhdGVkSXRlbUluZGV4LCBvcnBoYW4pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLiNpdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5ld0l0ZW0sIG5ld0luZGV4IH0gPSB0aGlzLiNjcmVhdGVBdHRhY2hJdGVtQW5kU29ydChcbiAgICAgICAgICBvcCxcbiAgICAgICAgICBvcC5wYXJlbnRLZXlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIGF0IHRoaXMgcG9zaXRpb24sIHVwZGF0ZSBpcyBhIHNldCwgZWxzZSBpdCdzIGFuIGluc2VydFxuICAgICAgICAgICAgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID09PSAtMSA/IGluc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKSA6IHNldERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKSxcbiAgICAgICAgICAgIC4uLmRlbHRhXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVwZGF0ZSBkZWx0YSBvZiB0aGUgZGVsZXRpb24gb3IgbnVsbFxuICAgKi9cbiAgI2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oZGVsZXRlZElkKSB7XG4gICAgaWYgKGRlbGV0ZWRJZCA9PT0gdm9pZCAwIHx8IHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRJdGVtID0gdGhpcy5fcG9vbC5nZXROb2RlKGRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWRJdGVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZXRhY2hDaGlsZChkZWxldGVkSXRlbSk7XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lm1vZGlmaWVkLnVwZGF0ZXNbMF07XG4gIH1cbiAgI2FwcGx5UmVtb3RlSW5zZXJ0KG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gYXNQb3Mob3AucGFyZW50S2V5KTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuI3NoaWZ0SXRlbVBvc2l0aW9uKGV4aXN0aW5nSXRlbUluZGV4LCBrZXkpO1xuICAgIH1cbiAgICBjb25zdCB7IG5ld0l0ZW0sIG5ld0luZGV4IH0gPSB0aGlzLiNjcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKV0pLFxuICAgICAgcmV2ZXJzZTogW11cbiAgICB9O1xuICB9XG4gICNhcHBseUluc2VydEFjayhvcCkge1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuI2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgY29uc3Qga2V5ID0gYXNQb3Mob3AucGFyZW50S2V5KTtcbiAgICBjb25zdCBpdGVtSW5kZXhBdFBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSkge1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbS5fcGFyZW50S2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uSW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICAgIGlmIChpdGVtSW5kZXhBdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuI3NoaWZ0SXRlbVBvc2l0aW9uKGl0ZW1JbmRleEF0UG9zaXRpb24sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhpc3RpbmdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICBpZiAobmV3SW5kZXggPT09IG9sZFBvc2l0aW9uSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIG1vdmVEZWx0YShvbGRQb3NpdGlvbkluZGV4LCBuZXdJbmRleCwgZXhpc3RpbmdJdGVtKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9ycGhhbiA9IG5uKHRoaXMuX3Bvb2wpLmdldE5vZGUob3AuaWQpO1xuICAgICAgaWYgKG9ycGhhbiAmJiB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhvcnBoYW4pKSB7XG4gICAgICAgIG9ycGhhbi5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShvcnBoYW4pO1xuICAgICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG9ycGhhbik7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBvcnBoYW4pXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpdGVtSW5kZXhBdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuI3NoaWZ0SXRlbVBvc2l0aW9uKGl0ZW1JbmRleEF0UG9zaXRpb24sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy4jY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQob3AsIGtleSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNhcHBseUluc2VydFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBsZXQgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGJlZm9yZTIgPSB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0/Ll9wYXJlbnRQb3M7XG4gICAgICBjb25zdCBhZnRlcjIgPSB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zO1xuICAgICAgbmV3S2V5ID0gbWFrZVBvc2l0aW9uKGJlZm9yZTIsIGFmdGVyMik7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV1cbiAgICB9O1xuICB9XG4gICNhcHBseVNldFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXRzLnNldChrZXksIG5uKG9wLm9wSWQpKTtcbiAgICBjb25zdCBpbmRleE9mSXRlbVdpdGhTYW1lS2V5ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lS2V5ICE9PSAtMSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy4jaXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZUtleV07XG4gICAgICBleGlzdGluZ0l0ZW0uX2RldGFjaCgpO1xuICAgICAgdGhpcy4jaXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZUtleV0gPSBjaGlsZDtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICBleGlzdGluZ0l0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb3AuaWRcbiAgICAgICk7XG4gICAgICBjb25zdCBkZWx0YSA9IFtzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lS2V5LCBjaGlsZCldO1xuICAgICAgY29uc3QgZGVsZXRlZERlbHRhID0gdGhpcy4jZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgb3AuZGVsZXRlZElkXG4gICAgICApO1xuICAgICAgaWYgKGRlbGV0ZWREZWx0YSkge1xuICAgICAgICBkZWx0YS5wdXNoKGRlbGV0ZWREZWx0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgdGhpcy4jZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihvcC5kZWxldGVkSWQpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJldmVyc2U6IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAob3AuaW50ZW50ID09PSBcInNldFwiKSB7XG4gICAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLiNhcHBseVNldFJlbW90ZShvcCk7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy4jYXBwbHlTZXRBY2sob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy4jYXBwbHlTZXRVbmRvUmVkbyhvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuI2FwcGx5UmVtb3RlSW5zZXJ0KG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLiNhcHBseUluc2VydEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLiNhcHBseUluc2VydFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMobm4odGhpcy5faWQpLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgICAgY29uc3QgaW5kZXhUb0RlbGV0ZSA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKGluZGV4VG9EZWxldGUgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBbcHJldmlvdXNOb2RlXSA9IHRoaXMuI2l0ZW1zLnNwbGljZShpbmRleFRvRGVsZXRlLCAxKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4VG9EZWxldGUsIHByZXZpb3VzTm9kZSldKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgI2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCkge1xuICAgIGlmICh0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBjaGlsZC5fcGFyZW50S2V5O1xuICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAjYXBwbHlTZXRDaGlsZEtleUFjayhuZXdLZXksIGNoaWxkKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBpZiAodGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMoY2hpbGQpKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUoY2hpbGQpO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV3S2V5ID09PSBwcmV2aW91c0tleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAocHJldmlvdXNJbmRleCA9PT0gbmV3SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZClcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICk7XG4gICAgfVxuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAocHJldmlvdXNJbmRleCA9PT0gbmV3SW5kZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICBpZDogbm4oY2hpbGQuX2lkKSxcbiAgICAgICAgICBwYXJlbnRLZXk6IHByZXZpb3VzS2V5XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NldENoaWxkS2V5KG5ld0tleSwgY2hpbGQsIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICByZXR1cm4gdGhpcy4jYXBwbHlTZXRDaGlsZEtleVJlbW90ZShuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLiNhcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy4jYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvKG5ld0tleSwgY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTGlzdCBpZiBwYXJlbnQgaXMgbWlzc2luZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMuXG4gICAqL1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiNpdGVtcy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb25lIGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBMaXZlTGlzdC5cbiAgICovXG4gIHB1c2goZWxlbWVudCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KGVsZW1lbnQsIHRoaXMubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBvbmUgZWxlbWVudCBhdCBhIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0LlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHlvdSB3YW50IHRvIGluc2VydCB0aGUgZWxlbWVudC5cbiAgICovXG4gIGluc2VydChlbGVtZW50LCBpbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuI2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGluc2VydCBsaXN0IGl0ZW0gYXQgaW5kZXggXCJcdTAwMWQke2luZGV4fVwiLiBpbmRleCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuI2l0ZW1zLmxlbmd0aH1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBiZWZvcmUyID0gdGhpcy4jaXRlbXNbaW5kZXggLSAxXSA/IHRoaXMuI2l0ZW1zW2luZGV4IC0gMV0uX3BhcmVudFBvcyA6IHZvaWQgMDtcbiAgICBjb25zdCBhZnRlcjIgPSB0aGlzLiNpdGVtc1tpbmRleF0gPyB0aGlzLiNpdGVtc1tpbmRleF0uX3BhcmVudFBvcyA6IHZvaWQgMDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmUyLCBhZnRlcjIpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoZWxlbWVudCk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2luc2VydEFuZFNvcnQodmFsdWUpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgICBbdGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKGluZGV4LCB2YWx1ZSldKV1cbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNb3ZlIG9uZSBlbGVtZW50IGZyb20gb25lIGluZGV4IHRvIGFub3RoZXIuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gbW92ZVxuICAgKiBAcGFyYW0gdGFyZ2V0SW5kZXggVGhlIGluZGV4IHdoZXJlIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhZnRlciBtb3ZpbmcuXG4gICAqL1xuICBtb3ZlKGluZGV4LCB0YXJnZXRJbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGhpcy4jaXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPj0gdGhpcy4jaXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBjYW5ub3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBsaXN0IGxlbmd0aFwiKTtcbiAgICB9XG4gICAgbGV0IGJlZm9yZVBvc2l0aW9uID0gbnVsbDtcbiAgICBsZXQgYWZ0ZXJQb3NpdGlvbiA9IG51bGw7XG4gICAgaWYgKGluZGV4IDwgdGFyZ2V0SW5kZXgpIHtcbiAgICAgIGFmdGVyUG9zaXRpb24gPSB0YXJnZXRJbmRleCA9PT0gdGhpcy4jaXRlbXMubGVuZ3RoIC0gMSA/IHZvaWQgMCA6IHRoaXMuI2l0ZW1zW3RhcmdldEluZGV4ICsgMV0uX3BhcmVudFBvcztcbiAgICAgIGJlZm9yZVBvc2l0aW9uID0gdGhpcy4jaXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyUG9zaXRpb24gPSB0aGlzLiNpdGVtc1t0YXJnZXRJbmRleF0uX3BhcmVudFBvcztcbiAgICAgIGJlZm9yZVBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IDAgPyB2b2lkIDAgOiB0aGlzLiNpdGVtc1t0YXJnZXRJbmRleCAtIDFdLl9wYXJlbnRQb3M7XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKGJlZm9yZVBvc2l0aW9uLCBhZnRlclBvc2l0aW9uKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy4jaXRlbXNbaW5kZXhdO1xuICAgIGNvbnN0IHByZXZpb3VzUG9zaXRpb24gPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbdGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShpbmRleCwgdGFyZ2V0SW5kZXgsIGl0ZW0pXSldXG4gICAgICBdKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgICAgaWQ6IG5uKGl0ZW0uX2lkKSxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHBvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHByZXZpb3VzUG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbiBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShpbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLiNpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBkZWxldGUgbGlzdCBpdGVtIGF0IGluZGV4IFwiJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLiNpdGVtcy5sZW5ndGggLSAxfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLiNpdGVtc1tpbmRleF07XG4gICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgY29uc3QgW3ByZXZdID0gdGhpcy4jaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCkge1xuICAgICAgY29uc3QgY2hpbGRSZWNvcmRJZCA9IGl0ZW0uX2lkO1xuICAgICAgaWYgKGNoaWxkUmVjb3JkSWQpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBzdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgbm4odGhpcy5faWQpLFxuICAgICAgICAgIG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4LCBwcmV2KV0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgICAgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZDogY2hpbGRSZWNvcmRJZCxcbiAgICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpLFxuICAgICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgY29uc3QgcmV2ZXJzZU9wcyA9IFtdO1xuICAgICAgY29uc3QgdXBkYXRlRGVsdGEgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNpdGVtcykge1xuICAgICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICAgICAgY29uc3QgY2hpbGRJZCA9IGl0ZW0uX2lkO1xuICAgICAgICBpZiAoY2hpbGRJZCkge1xuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgICAgICAgICBpZDogY2hpbGRJZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXZlcnNlT3BzLnB1c2goXG4gICAgICAgICAgICAuLi5pdGVtLl90b09wcyhubih0aGlzLl9pZCksIGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHVwZGF0ZURlbHRhLnB1c2goZGVsZXRlRGVsdGEoMCwgaXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLiNpdGVtcyA9IFtdO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQobm4odGhpcy5faWQpLCBtYWtlVXBkYXRlKHRoaXMsIHVwZGF0ZURlbHRhKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jaXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNpdGVtcyA9IFtdO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG4gIHNldChpbmRleCwgaXRlbSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLiNpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzZXQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLiNpdGVtcy5sZW5ndGggLSAxfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuI2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGV4aXN0aW5nSXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGNvbnN0IGV4aXN0aW5nSWQgPSBleGlzdGluZ0l0ZW0uX2lkO1xuICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgY29uc3QgdmFsdWUgPSBsc29uVG9MaXZlTm9kZShpdGVtKTtcbiAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy4jaXRlbXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCk7XG4gICAgICB2YWx1ZS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwgbWFrZVVwZGF0ZSh0aGlzLCBbc2V0RGVsdGEoaW5kZXgsIHZhbHVlKV0pKTtcbiAgICAgIGNvbnN0IG9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIHZhbHVlLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHRoaXMuX3Bvb2wpLFxuICAgICAgICBleGlzdGluZ0lkXG4gICAgICApO1xuICAgICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXRzLnNldChwb3NpdGlvbiwgbm4ob3BzWzBdLm9wSWQpKTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICBleGlzdGluZ0l0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdm9pZCAwKSxcbiAgICAgICAgaWRcbiAgICAgICk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBBcnJheSBvZiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBMaXZlTGlzdC5cbiAgICovXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2l0ZW1zLm1hcChcbiAgICAgIChlbnRyeSkgPT4gbGl2ZU5vZGVUb0xzb24oZW50cnkpXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXlxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRklYTUUhIFRoaXMgaXNuJ3Qgc2FmZS5cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGFsbCBlbGVtZW50cyBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGZvciBlYWNoIGVsZW1lbnQsIHRha2luZyB0d28gYXJndW1lbnRzICh0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4KS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yIGV2ZXJ5IGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBldmVyeShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZXZlcnkocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IG9mIHRoZSBMaXZlTGlzdC4gUmV0dXJuIGEgdmFsdWUgdGhhdCBjb2VyY2VzIHRvIHRydWUgdG8ga2VlcCB0aGUgZWxlbWVudCwgb3IgdG8gZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QuXG4gICAqL1xuICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbHRlcihwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZS5cbiAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBmaW5kKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maW5kKHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgdW50aWwgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSBzYXRpc2Z5aW5nIGVsZW1lbnQgd2FzIGZvdW5kLlxuICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHRoYXQgcGFzc2VzIHRoZSB0ZXN0LiBPdGhlcndpc2UsIC0xLlxuICAgKi9cbiAgZmluZEluZGV4KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maW5kSW5kZXgocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFja2ZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFja2ZuKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZvckVhY2goY2FsbGJhY2tmbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9uIHRoZSBlbGVtZW50IHRvIGdldC5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuI2l0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVOb2RlVG9Mc29uKHRoaXMuI2l0ZW1zW2luZGV4XSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIExpdmVMaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUuXG4gICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggYXQuXG4gICAqIEByZXR1cm5zIFRoZSBmaXJzdCBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3Q7IC0xIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuIFRoZSBMaXZlTHNpdCBpcyBzZWFyY2hlZCBiYWNrd2FyZHMsIHN0YXJ0aW5nIGF0IGZyb21JbmRleC5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUuXG4gICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZyBiYWNrd2FyZHMuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBwb3B1bGF0ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gZXZlcnkgZWxlbWVudC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvciBldmVyeSBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIGVhY2ggZWxlbWVudCBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIG1hcChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLiNpdGVtcy5tYXAoXG4gICAgICAoZW50cnksIGkpID0+IGNhbGxiYWNrKFxuICAgICAgICBsaXZlTm9kZVRvTHNvbihlbnRyeSksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXlxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgRklYTUUhIFRoaXMgaXNuJ3Qgc2FmZS5cbiAgICAgICAgaVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHBhc3NlcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBhdCBsZWFzdCBvbmUgZWxlbWVudC4gT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICovXG4gIHNvbWUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLnNvbWUocHJlZGljYXRlKTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gbmV3IExpdmVMaXN0SXRlcmF0b3IodGhpcy4jaXRlbXMpO1xuICB9XG4gICNjcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KSB7XG4gICAgY29uc3QgbmV3SXRlbSA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBuZXdJdGVtLl9hdHRhY2gob3AuaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBuZXdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydChuZXdJdGVtKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIHJldHVybiB7IG5ld0l0ZW0sIG5ld0luZGV4IH07XG4gIH1cbiAgI3NoaWZ0SXRlbVBvc2l0aW9uKGluZGV4LCBrZXkpIHtcbiAgICBjb25zdCBzaGlmdGVkUG9zaXRpb24gPSBtYWtlUG9zaXRpb24oXG4gICAgICBrZXksXG4gICAgICB0aGlzLiNpdGVtcy5sZW5ndGggPiBpbmRleCArIDEgPyB0aGlzLiNpdGVtc1tpbmRleCArIDFdPy5fcGFyZW50UG9zIDogdm9pZCAwXG4gICAgKTtcbiAgICB0aGlzLiNpdGVtc1tpbmRleF0uX3NldFBhcmVudExpbmsodGhpcywgc2hpZnRlZFBvc2l0aW9uKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkxpdmVMaXN0XCIsXG4gICAgICBpZDogdGhpcy5faWQgPz8gbmFub2lkKCksXG4gICAgICBrZXksXG4gICAgICBwYXlsb2FkOiB0aGlzLiNpdGVtcy5tYXAoXG4gICAgICAgIChpdGVtLCBpbmRleCkgPT4gaXRlbS50b1RyZWVOb2RlKGluZGV4LnRvU3RyaW5nKCkpXG4gICAgICApXG4gICAgfTtcbiAgfVxuICB0b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudG9JbW11dGFibGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNpdGVtcy5tYXAoKG5vZGUpID0+IG5vZGUudG9JbW11dGFibGUoKSk7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IHJlc3VsdCA6IE9iamVjdC5mcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTGlzdCh0aGlzLiNpdGVtcy5tYXAoKGl0ZW0pID0+IGl0ZW0uY2xvbmUoKSkpO1xuICB9XG59O1xudmFyIExpdmVMaXN0SXRlcmF0b3IgPSBjbGFzcyB7XG4gICNpbm5lckl0ZXJhdG9yO1xuICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgIHRoaXMuI2lubmVySXRlcmF0b3IgPSBpdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24ocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4geyB2YWx1ZSB9O1xuICB9XG59O1xuZnVuY3Rpb24gbWFrZVVwZGF0ZShsaXZlTGlzdCwgZGVsdGFVcGRhdGVzKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbGl2ZUxpc3QsXG4gICAgdHlwZTogXCJMaXZlTGlzdFwiLFxuICAgIHVwZGF0ZXM6IGRlbHRhVXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gc2V0RGVsdGEoaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcInNldFwiLFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtXG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVEZWx0YShpbmRleCwgZGVsZXRlZE5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgIGluZGV4LFxuICAgIGRlbGV0ZWRJdGVtOiBkZWxldGVkTm9kZSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGRlbGV0ZWROb2RlLmRhdGEgOiBkZWxldGVkTm9kZVxuICB9O1xufVxuZnVuY3Rpb24gaW5zZXJ0RGVsdGEoaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcImluc2VydFwiLFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtXG4gIH07XG59XG5mdW5jdGlvbiBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1vdmVcIixcbiAgICBpbmRleCxcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbSxcbiAgICBwcmV2aW91c0luZGV4XG4gIH07XG59XG5mdW5jdGlvbiBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKG9wcywgZGVsZXRlZElkKSB7XG4gIHJldHVybiBvcHMubWFwKChvcCwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0T3AgPSBvcDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmZpcnN0T3AsXG4gICAgICAgIGludGVudDogXCJzZXRcIixcbiAgICAgICAgZGVsZXRlZElkXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3A7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2NyZHRzL0xpdmVNYXAudHNcbnZhciBMaXZlTWFwID0gY2xhc3MgX0xpdmVNYXAgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICAjbWFwO1xuICAjdW5hY2tub3dsZWRnZWRTZXQ7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKGVudHJpZXMyKSB7XG4gICAgICBjb25zdCBtYXBwZWRFbnRyaWVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzMikge1xuICAgICAgICBjb25zdCBub2RlID0gbHNvblRvTGl2ZU5vZGUodmFsdWUpO1xuICAgICAgICBub2RlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG1hcHBlZEVudHJpZXMucHVzaChba2V5LCBub2RlXSk7XG4gICAgICB9XG4gICAgICB0aGlzLiNtYXAgPSBuZXcgTWFwKG1hcHBlZEVudHJpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBfaXRlbV0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgX0xpdmVNYXAoKTtcbiAgICBtYXAuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChpZCk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobWFwLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICBtYXAuI21hcC5zZXQoY3JkdC5wYXJlbnRLZXksIGNoaWxkKTtcbiAgICAgIG1hcC5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5LCBvcElkIH0gPSBvcDtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXk7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICBjb25zdCBsYXN0VXBkYXRlT3BJZCA9IHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0LmdldChrZXkpO1xuICAgICAgaWYgKGxhc3RVcGRhdGVPcElkID09PSBvcElkKSB7XG4gICAgICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH0gZWxzZSBpZiAobGFzdFVwZGF0ZU9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XTtcbiAgICB9XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICB0aGlzLiNtYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuI21hcC52YWx1ZXMoKSkge1xuICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKGNoaWxkKSB7XG4gICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgY29uc3QgcGFyZW50S2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhpZCwgcGFyZW50S2V5LCB0aGlzLl9wb29sKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLiNtYXApIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gY2hpbGQpIHtcbiAgICAgICAgdGhpcy4jbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hpbGQuX2RldGFjaCgpO1xuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGUgPSB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICB1cGRhdGVzOiB7IFtwYXJlbnRLZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfTtcbiAgICByZXR1cm4geyBtb2RpZmllZDogc3RvcmFnZVVwZGF0ZSwgcmV2ZXJzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTWFwIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMiAvKiBNQVAgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIExpdmVNYXAuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIHRoaXMuI21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIGl0ZW0uX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb3BzID0gaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldC5zZXQoa2V5LCBubihvcHNbMF0ub3BJZCkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCksXG4gICAgICAgIG9sZFZhbHVlID8gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpIDogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBMaXZlTWFwLlxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5zaXplO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBvciBub3QuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byB0ZXN0IGZvciBwcmVzZW5jZS5cbiAgICovXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmhhcyhrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBieSBrZXkuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgYW4gZWxlbWVudCBleGlzdGVkIGFuZCBoYXMgYmVlbiByZW1vdmVkLCBvciBmYWxzZSBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgaWYgKGl0ZW0gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB0aGlzLiNtYXAuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgaXRlbS5faWQpIHtcbiAgICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzSWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgICAgICAgICBpZDogaXRlbS5faWQsXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzSWQsIGtleSksXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgW2tleSwgdmFsdWVdIHBhaXJzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICBlbnRyaWVzKCkge1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0aGlzLiNtYXAuZW50cmllcygpO1xuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3JWYWx1ZSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoaXRlcmF0b3JWYWx1ZS5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyeSA9IGl0ZXJhdG9yVmFsdWUudmFsdWU7XG4gICAgICAgIGNvbnN0IGtleSA9IGVudHJ5WzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKGl0ZXJhdG9yVmFsdWUudmFsdWVbMV0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBba2V5LCB2YWx1ZV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTYW1lIGZ1bmN0aW9uIG9iamVjdCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgZW50cmllcyBtZXRob2QuXG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGtleXMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5rZXlzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHZhbHVlcyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgdmFsdWVzKCkge1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0aGlzLiNtYXAudmFsdWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIHBlciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIHRoZSBNYXAgb2JqZWN0LCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVudHJ5IGluIHRoZSBtYXAuXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzKSB7XG4gICAgICBjYWxsYmFjayhlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IEFycmF5LmZyb20odGhpcy4jbWFwLmVudHJpZXMoKSkubWFwKFxuICAgICAgICAoW2tleTIsIHZhbF0pID0+IHZhbC50b1RyZWVOb2RlKGtleTIpXG4gICAgICApXG4gICAgfTtcbiAgfVxuICB0b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudG9JbW11dGFibGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlLnRvSW1tdXRhYmxlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU1hcChcbiAgICAgIEFycmF5LmZyb20odGhpcy4jbWFwKS5tYXAoKFtrZXksIG5vZGVdKSA9PiBba2V5LCBub2RlLmNsb25lKCldKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9MaXZlT2JqZWN0LnRzXG52YXIgTGl2ZU9iamVjdCA9IGNsYXNzIF9MaXZlT2JqZWN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgI21hcDtcbiAgI3Byb3BUb0xhc3RVcGRhdGU7XG4gIHN0YXRpYyAjYnVpbGRSb290QW5kUGFyZW50VG9DaGlsZHJlbihpdGVtcykge1xuICAgIGNvbnN0IHBhcmVudFRvQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCByb290ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgaXRlbXMpIHtcbiAgICAgIGlmIChpc1Jvb3RDcmR0KGNyZHQpKSB7XG4gICAgICAgIHJvb3QgPSBbaWQsIGNyZHRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHVwbGUgPSBbaWQsIGNyZHRdO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGNyZHQucGFyZW50SWQpO1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2godHVwbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFRvQ2hpbGRyZW4uc2V0KGNyZHQucGFyZW50SWQsIFt0dXBsZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IGNhbid0IGJlIG51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiBbcm9vdCwgcGFyZW50VG9DaGlsZHJlbl07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21JdGVtcyhpdGVtcywgcG9vbCkge1xuICAgIGNvbnN0IFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXSA9IF9MaXZlT2JqZWN0LiNidWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKTtcbiAgICByZXR1cm4gX0xpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudFRvQ2hpbGRyZW4sXG4gICAgICBwb29sXG4gICAgKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvYmogPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgbyA9IGNvbXBhY3RPYmplY3Qob2JqKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvW2tleV07XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhvKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcElkID0gcG9vbD8uZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXksXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpdmVPYmogPSBuZXcgX0xpdmVPYmplY3QoaXRlbS5kYXRhKTtcbiAgICBsaXZlT2JqLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KG5uKGxpdmVPYmouX2lkKSk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXZlT2JqO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXZlT2JqLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgICBsaXZlT2JqLiNtYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBsaXZlT2JqLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVPYmo7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgb3BJZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTHNvbihvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLykge1xuICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcElkKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNwcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpc0lkLCBrZXkgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQ6IHRoaXNJZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBwcmV2aW91c1ZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy4jbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLiNtYXApIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNtYXAudmFsdWVzKCkpIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBpc0xvY2FsKSB7XG4gICAgaWYgKG9wLnR5cGUgPT09IDMgLyogVVBEQVRFX09CSkVDVCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKTtcbiAgICB9IGVsc2UgaWYgKG9wLnR5cGUgPT09IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLiNhcHBseURlbGV0ZU9iamVjdEtleShvcCwgaXNMb2NhbCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICBpZiAoIWlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIiAmJiB0aGlzLnBhcmVudC5ub2RlLl9pZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIHBhcmVudElkOiB0aGlzLnBhcmVudC5ub2RlLl9pZCxcbiAgICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDAgLyogT0JKRUNUICovLFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAjYXBwbHlVcGRhdGUob3AsIGlzTG9jYWwpIHtcbiAgICBsZXQgaXNNb2RpZmllZCA9IGZhbHNlO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHJldmVyc2UgPSBbXTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlID0ge1xuICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgaWQsXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgcmV2ZXJzZS5wdXNoKC4uLm9sZFZhbHVlLl90b09wcyhpZCwga2V5KSk7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlVXBkYXRlLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkLCBrZXkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZURlbHRhID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcC5kYXRhW2tleV07XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLiNwcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wLm9wSWQpIHtcbiAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdXBkYXRlRGVsdGFba2V5XSA9IHsgdHlwZTogXCJ1cGRhdGVcIiB9O1xuICAgICAgdGhpcy4jbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMocmV2ZXJzZVVwZGF0ZS5kYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldmVyc2UudW5zaGlmdChyZXZlcnNlVXBkYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTW9kaWZpZWQgPyB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczogdXBkYXRlRGVsdGFcbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfSA6IHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgI2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qga2V5ID0gb3Aua2V5O1xuICAgIGlmICh0aGlzLiNtYXAuaGFzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKCFpc0xvY2FsICYmIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGxldCByZXZlcnNlID0gW107XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKGlkLCBvcC5rZXkpO1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBvbGRWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW29wLmtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBMaXZlT2JqZWN0IGludG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLiNtYXApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSBwcm9wZXJ0eSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgdGhpcy51cGRhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSB0aGUgTGl2ZU9iamVjdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGZyb20gdGhlIExpdmVPYmplY3RcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5O1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXlBc1N0cmluZyk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXlBc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgZGF0YTogeyBba2V5QXNTdHJpbmddOiBvbGRWYWx1ZSB9LFxuICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLiNtYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sXG4gICAgICAgICAga2V5OiBrZXlBc1N0cmluZyxcbiAgICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZSB3aXRoIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHBhdGNoIFRoZSBvYmplY3QgdXNlZCB0byBvdmVycmlkZXMgcHJvcGVydGllc1xuICAgKi9cbiAgdXBkYXRlKHBhdGNoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICBjb25zdCBvcElkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCB1cGRhdGVkUHJvcHMgPSB7fTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlT3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzLl9pZCwga2V5IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZU9wLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG5ld1ZhbHVlLl9hdHRhY2godGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBuZXdBdHRhY2hDaGlsZE9wcyA9IG5ld1ZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgY3JlYXRlQ3JkdE9wID0gbmV3QXR0YWNoQ2hpbGRPcHMuZmluZChcbiAgICAgICAgICAob3ApID0+IG9wLnBhcmVudElkID09PSB0aGlzLl9pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoY3JlYXRlQ3JkdE9wKSB7XG4gICAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihjcmVhdGVDcmR0T3Aub3BJZCkpO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKC4uLm5ld0F0dGFjaENoaWxkT3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRQcm9wc1trZXldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgb3BJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNtYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlT3AuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlT3BzLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZU9wKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQcm9wcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBvcHMudW5zaGlmdCh7XG4gICAgICAgIG9wSWQsXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICBkYXRhOiB1cGRhdGVkUHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiBzdXBlci50b1RyZWVOb2RlKGtleSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICBjb25zdCBub2RlSWQgPSB0aGlzLl9pZCA/PyBuYW5vaWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBpZDogbm9kZUlkLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLiNtYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsdWVdKSA9PiBpc0xpdmVOb2RlKHZhbHVlKSA/IHZhbHVlLnRvVHJlZU5vZGUoa2V5MikgOiB7IHR5cGU6IFwiSnNvblwiLCBpZDogYCR7bm9kZUlkfToke2tleTJ9YCwga2V5OiBrZXkyLCBwYXlsb2FkOiB2YWx1ZSB9XG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGlzTGl2ZVN0cnVjdHVyZSh2YWwpID8gdmFsLnRvSW1tdXRhYmxlKCkgOiB2YWw7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU9iamVjdChcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLiNtYXApLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9saXZlYmxvY2tzLWhlbHBlcnMudHNcbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKSB7XG4gIHJldHVybiBsc29uVG9MaXZlTm9kZShjcmVhdGlvbk9wVG9Mc29uKG9wKSk7XG59XG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9Mc29uKG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86XG4gICAgICByZXR1cm4gb3AuZGF0YTtcbiAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChvcC5kYXRhKTtcbiAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU1hcCgpO1xuICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZUxpc3QoW10pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob3AsIFwiVW5rbm93biBjcmVhdGlvbiBPcFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTYW1lTm9kZU9yQ2hpbGRPZihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgcmV0dXJuIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZS5wYXJlbnQubm9kZSwgcGFyZW50KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBMaXZlUmVnaXN0ZXIuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIENSRFQgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9Mc29uKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICBjYXNlIDAgLyogT0JKRUNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMSAvKiBMSVNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZUxpc3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDIgLyogTUFQICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU1hcC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzoge1xuICAgICAgcmV0dXJuIGNyZHQuZGF0YTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZUxpc3QodmFsdWUpIHx8IGlzTGl2ZU1hcCh2YWx1ZSkgfHwgaXNMaXZlT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgfHwgaXNMaXZlUmVnaXN0ZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNMaXZlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU1hcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwO1xufVxuZnVuY3Rpb24gaXNMaXZlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVSZWdpc3Rlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXI7XG59XG5mdW5jdGlvbiBjbG9uZUxzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBsaXZlTm9kZVRvTHNvbihvYmopIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlTGlzdCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlTWFwIHx8IG9iaiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NlcnROZXZlcihvYmosIFwiVW5rbm93biBBYnN0cmFjdENyZHRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxzb25Ub0xpdmVOb2RlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlUmVnaXN0ZXIodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3SXRlbXMpIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIGN1cnJlbnRJdGVtcy5mb3JFYWNoKChfLCBpZCkgPT4ge1xuICAgIGlmICghbmV3SXRlbXMuZ2V0KGlkKSkge1xuICAgICAgb3BzLnB1c2goe1xuICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbmV3SXRlbXMuZm9yRWFjaCgoY3JkdCwgaWQpID0+IHtcbiAgICBjb25zdCBjdXJyZW50Q3JkdCA9IGN1cnJlbnRJdGVtcy5nZXQoaWQpO1xuICAgIGlmIChjdXJyZW50Q3JkdCkge1xuICAgICAgaWYgKGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8pIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDcmR0LnR5cGUgIT09IDAgLyogT0JKRUNUICovIHx8IHN0cmluZ2lmeU9yTG9nKGNyZHQuZGF0YSkgIT09IHN0cmluZ2lmeU9yTG9nKGN1cnJlbnRDcmR0LmRhdGEpKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNyZHQucGFyZW50S2V5ICE9PSBjdXJyZW50Q3JkdC5wYXJlbnRLZXkpIHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGFyZW50S2V5OiBubihjcmR0LnBhcmVudEtleSwgXCJQYXJlbnQga2V5IG11c3Qgbm90IGJlIG1pc3NpbmdcIilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5LFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMSVNUICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDAgLyogT0JKRUNUICovOlxuICAgICAgICAgIGlmIChjcmR0LnBhcmVudElkID09PSB2b2lkIDAgfHwgY3JkdC5wYXJlbnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIkludGVybmFsIGVycm9yLiBDYW5ub3Qgc2VyaWFsaXplIHN0b3JhZ2Ugcm9vdCBpbnRvIGFuIG9wZXJhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogTUFQICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhzZWNvbmQudXBkYXRlcykpIHtcbiAgICB1cGRhdGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlczogdXBkYXRlcy5jb25jYXQoc2Vjb25kLnVwZGF0ZXMpXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc2Vjb25kO1xuICB9XG4gIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVPYmplY3RcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVNYXBcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlTWFwXCIpIHtcbiAgICByZXR1cm4gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVMaXN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZUxpc3RcIikge1xuICAgIHJldHVybiBtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIHtcbiAgfVxuICByZXR1cm4gc2Vjb25kO1xufVxuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNQbGFpbikge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoIHx8IFwicm9vdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKCFpc1BsYWluKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcbiAgICAgICAgbmVzdGVkVmFsdWUsXG4gICAgICAgIG5lc3RlZFBhdGhcbiAgICAgICk7XG4gICAgICBpZiAobm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9saWIvZGVidWcudHNcbmZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKG1zZywgdHJhY2VSb290KSB7XG4gIGNvbnN0IGVycm9yTGlrZSA9IHsgbmFtZTogbXNnIH07XG4gIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3JMaWtlLCB0cmFjZVJvb3QpO1xuICByZXR1cm4gZXJyb3JMaWtlLnN0YWNrO1xufVxuXG4vLyBzcmMvbGliL0RlcXVlLnRzXG52YXIgRGVxdWUgPSBjbGFzcyB7XG4gICNkYXRhO1xuICAjZnJvbnQ7XG4gICNiYWNrO1xuICAjc2l6ZTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy4jZGF0YSA9IHt9O1xuICAgIHRoaXMuI2Zyb250ID0gMDtcbiAgICB0aGlzLiNiYWNrID0gMTtcbiAgICB0aGlzLiNzaXplID0gMDtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiNzaXplO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy4jc2l6ZTtcbiAgICBjb25zdCBmcm9udCA9IHRoaXMuI2Zyb250O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB5aWVsZCB0aGlzLiNkYXRhW2Zyb250ICsgaV07XG4gICAgfVxuICB9XG4gIHB1c2godmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZXMyID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgaWYgKHRoaXMuI2JhY2sgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAtIHZhbHVlczIubGVuZ3RoIC0gMSlcbiAgICAgIHJhaXNlKFwiRGVxdWUgZnVsbFwiKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlMiBvZiB2YWx1ZXMyKSB7XG4gICAgICB0aGlzLiNkYXRhW3RoaXMuI2JhY2srKyAtIDFdID0gdmFsdWUyO1xuICAgIH1cbiAgICB0aGlzLiNzaXplICs9IHZhbHVlczIubGVuZ3RoO1xuICB9XG4gIHBvcCgpIHtcbiAgICBpZiAodGhpcy4jc2l6ZSA8IDEpIHJldHVybiB2b2lkIDA7XG4gICAgdGhpcy4jYmFjay0tO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZGF0YVt0aGlzLiNiYWNrIC0gMV07XG4gICAgZGVsZXRlIHRoaXMuI2RhdGFbdGhpcy4jYmFjayAtIDFdO1xuICAgIHRoaXMuI3NpemUtLTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcHVzaExlZnQodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZXMyID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgaWYgKHRoaXMuI2Zyb250IDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgKyB2YWx1ZXMyLmxlbmd0aClcbiAgICAgIHJhaXNlKFwiRGVxdWUgZnVsbFwiKTtcbiAgICBmb3IgKGxldCBpID0gdmFsdWVzMi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy4jZGF0YVstLXRoaXMuI2Zyb250XSA9IHZhbHVlczJbaV07XG4gICAgfVxuICAgIHRoaXMuI3NpemUgKz0gdmFsdWVzMi5sZW5ndGg7XG4gIH1cbiAgcG9wTGVmdCgpIHtcbiAgICBpZiAodGhpcy4jc2l6ZSA8IDEpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNkYXRhW3RoaXMuI2Zyb250XTtcbiAgICBkZWxldGUgdGhpcy4jZGF0YVt0aGlzLiNmcm9udF07XG4gICAgdGhpcy4jZnJvbnQrKztcbiAgICB0aGlzLiNzaXplLS07XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL0pzb24udHNcbmZ1bmN0aW9uIGlzSnNvblNjYWxhcihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBkYXRhID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzSnNvbkFycmF5KGRhdGEpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoZGF0YSkge1xuICByZXR1cm4gIWlzSnNvblNjYWxhcihkYXRhKSAmJiAhaXNKc29uQXJyYXkoZGF0YSk7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9DbGllbnRNc2cudHNcbnZhciBDbGllbnRNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoQ2xpZW50TXNnQ29kZTIpID0+IHtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJCUk9BRENBU1RfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RfRVZFTlRcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9TVE9SQUdFXCJdID0gMjAwXSA9IFwiRkVUQ0hfU1RPUkFHRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9ZRE9DXCJdID0gMzAwXSA9IFwiRkVUQ0hfWURPQ1wiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAxXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgcmV0dXJuIENsaWVudE1zZ0NvZGUyO1xufSkoQ2xpZW50TXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy9yZWZzL01hbmFnZWRPdGhlcnMudHNcbmZ1bmN0aW9uIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKSB7XG4gIGNvbnN0IHsgY29ubmVjdGlvbklkLCBpZCwgaW5mbyB9ID0gY29ubjtcbiAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoY29ubi5zY29wZXMpO1xuICByZXR1cm4gZnJlZXplKFxuICAgIGNvbXBhY3RPYmplY3Qoe1xuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgaWQsXG4gICAgICBpbmZvLFxuICAgICAgY2FuV3JpdGUsXG4gICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGNvbm4uc2NvcGVzKSxcbiAgICAgIGlzUmVhZE9ubHk6ICFjYW5Xcml0ZSxcbiAgICAgIC8vIERlcHJlY2F0ZWQsIGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcbiAgICAgIHByZXNlbmNlXG4gICAgfSlcbiAgKTtcbn1cbnZhciBNYW5hZ2VkT3RoZXJzID0gY2xhc3Mge1xuICAvLyBUcmFjayBtdXRhYmxlIHN0YXRlIGludGVybmFsbHksIGJ1dCBzaWduYWwgdG8gdGhlIG91dHNpZGUgd2hlbiB0aGVcbiAgLy8gb2JzZXJ2YWJsZSBkZXJpdmVkIHN0YXRlIGNoYW5nZXMgb25seVxuICAjaW50ZXJuYWw7XG4gICN1c2VyQ2FjaGU7XG4gIC8vIFRoZSBcImNsZWFuXCIgc2lnbmFsIHRoYXQgaXMgZXhwb3NlZCB0byB0aGUgb3V0c2lkZSB3b3JsZFxuICBzaWduYWw7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuI2ludGVybmFsID0gbmV3IE11dGFibGVTaWduYWwoe1xuICAgICAgY29ubmVjdGlvbnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBwcmVzZW5jZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICB9KTtcbiAgICB0aGlzLnNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICAgIHRoaXMuI2ludGVybmFsLFxuICAgICAgKF9pZ25vcmUpID0+IGNvbXBhY3QoXG4gICAgICAgIEFycmF5LmZyb20odGhpcy4jaW50ZXJuYWwuZ2V0KCkucHJlc2VuY2VzLmtleXMoKSkubWFwKFxuICAgICAgICAgIChjb25uZWN0aW9uSWQpID0+IHRoaXMuZ2V0VXNlcihOdW1iZXIoY29ubmVjdGlvbklkKSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy4jdXNlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvLyBTaG9ydGhhbmQgZm9yIC5zaWduYWwuZ2V0KClcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnNpZ25hbC5nZXQoKTtcbiAgfVxuICBjb25uZWN0aW9uSWRzKCkge1xuICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbC5nZXQoKS5jb25uZWN0aW9ucy5rZXlzKCk7XG4gIH1cbiAgY2xlYXJPdGhlcnMoKSB7XG4gICAgdGhpcy4jaW50ZXJuYWwubXV0YXRlKChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUuY29ubmVjdGlvbnMuY2xlYXIoKTtcbiAgICAgIHN0YXRlLnByZXNlbmNlcy5jbGVhcigpO1xuICAgICAgdGhpcy4jdXNlckNhY2hlLmNsZWFyKCk7XG4gICAgfSk7XG4gIH1cbiAgI19nZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jaW50ZXJuYWwuZ2V0KCk7XG4gICAgY29uc3QgY29ubiA9IHN0YXRlLmNvbm5lY3Rpb25zLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGNvbnN0IHByZXNlbmNlID0gc3RhdGUucHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb25uICE9PSB2b2lkIDAgJiYgcHJlc2VuY2UgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNhY2hlZFVzZXIgPSB0aGlzLiN1c2VyQ2FjaGUuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNhY2hlZFVzZXIpIHtcbiAgICAgIHJldHVybiBjYWNoZWRVc2VyO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZFVzZXIgPSB0aGlzLiNfZ2V0VXNlcihjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb21wdXRlZFVzZXIpIHtcbiAgICAgIHRoaXMuI3VzZXJDYWNoZS5zZXQoY29ubmVjdGlvbklkLCBjb21wdXRlZFVzZXIpO1xuICAgICAgcmV0dXJuIGNvbXB1dGVkVXNlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAjaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgdGhpcy4jdXNlckNhY2hlLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNvcmRzIGEga25vd24gY29ubmVjdGlvbi4gVGhpcyByZWNvcmRzIHRoZSBjb25uZWN0aW9uIElEIGFuZCB0aGVcbiAgICogYXNzb2NpYXRlZCBtZXRhZGF0YS5cbiAgICovXG4gIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBtZXRhVXNlcklkLCBtZXRhVXNlckluZm8sIHNjb3Blcykge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNvbm5lY3Rpb25zLnNldChcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICBmcmVlemUoe1xuICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICBpZDogbWV0YVVzZXJJZCxcbiAgICAgICAgICBpbmZvOiBtZXRhVXNlckluZm8sXG4gICAgICAgICAgc2NvcGVzXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgaWYgKCFzdGF0ZS5wcmVzZW5jZXMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBrbm93biBjb25uZWN0aW9uSWQuIFJlbW92ZXMgYm90aCB0aGUgY29ubmVjdGlvbidzIG1ldGFkYXRhIGFuZFxuICAgKiB0aGUgcHJlc2VuY2UgaW5mb3JtYXRpb24uXG4gICAqL1xuICByZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCkge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNvbm5lY3Rpb25zLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgc3RhdGUucHJlc2VuY2VzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RvcmVzIGEgbmV3IHVzZXIgZnJvbSBhIGZ1bGwgcHJlc2VuY2UgdXBkYXRlLiBJZiB0aGUgdXNlciBhbHJlYWR5IGV4aXN0cyxcbiAgICogaXRzIGtub3duIHByZXNlbmNlIGRhdGEgaXMgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBzZXRPdGhlcihjb25uZWN0aW9uSWQsIHByZXNlbmNlKSB7XG4gICAgdGhpcy4jaW50ZXJuYWwubXV0YXRlKChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUucHJlc2VuY2VzLnNldChjb25uZWN0aW9uSWQsIGZyZWV6ZShjb21wYWN0T2JqZWN0KHByZXNlbmNlKSkpO1xuICAgICAgaWYgKCFzdGF0ZS5jb25uZWN0aW9ucy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgcHJlc2VuY2UgZGF0YSBmb3IgYW4gZXhpc3RpbmcgXCJvdGhlclwiLiBJZiB3ZSBkb24ndCBrbm93IHRoZVxuICAgKiBpbml0aWFsIHByZXNlbmNlIGRhdGEgZm9yIHRoaXMgdXNlciB5ZXQsIGRpc2NhcmQgdGhpcyBwYXRjaCBhbmQgYXdhaXQgdGhlXG4gICAqIGZ1bGwgLnNldE90aGVyKCkgY2FsbCBmaXJzdC5cbiAgICovXG4gIHBhdGNoT3RoZXIoY29ubmVjdGlvbklkLCBwYXRjaCkge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IG9sZFByZXNlbmNlID0gc3RhdGUucHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgaWYgKG9sZFByZXNlbmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3UHJlc2VuY2UgPSBtZXJnZShvbGRQcmVzZW5jZSwgcGF0Y2gpO1xuICAgICAgaWYgKG9sZFByZXNlbmNlID09PSBuZXdQcmVzZW5jZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKG5ld1ByZXNlbmNlKSk7XG4gICAgICByZXR1cm4gdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3R5cGVzL0xpdmVibG9ja3NFcnJvci50c1xudmFyIExpdmVibG9ja3NFcnJvciA9IGNsYXNzIF9MaXZlYmxvY2tzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnRleHQ7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvbnRleHQsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZSB9KTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiTGl2ZWJsb2Nrc0Vycm9yXCI7XG4gIH1cbiAgLyoqIENvbnZlbmllbmNlIGFjY2Vzc29yIGZvciBlcnJvci5jb250ZXh0LnJvb21JZCAoaWYgYXZhaWxhYmxlKSAqL1xuICBnZXQgcm9vbUlkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucm9vbUlkO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBQcmVmZXIgdXNpbmcgYGNvbnRleHQuY29kZWAgaW5zdGVhZCwgdG8gZW5hYmxlIHR5cGUgbmFycm93aW5nICovXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29kZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIExpdmVibG9ja3NFcnJvciBmcm9tIGEgZ2VuZXJpYyBlcnJvciwgYnkgYXR0YWNoaW5nIExpdmVibG9ja3NcbiAgICogY29udGV4dHVhbCBpbmZvcm1hdGlvbiBsaWtlIHJvb20gSUQsIHRocmVhZCBJRCwgZXRjLlxuICAgKi9cbiAgc3RhdGljIGZyb20oY29udGV4dCwgY2F1c2UpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlYmxvY2tzRXJyb3IoXG4gICAgICBkZWZhdWx0TWVzc2FnZUZyb21Db250ZXh0KGNvbnRleHQpLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNhdXNlXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGRlZmF1bHRNZXNzYWdlRnJvbUNvbnRleHQoY29udGV4dCkge1xuICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgIGNhc2UgXCJST09NX0NPTk5FQ1RJT05fRVJST1JcIjoge1xuICAgICAgc3dpdGNoIChjb250ZXh0LmNvZGUpIHtcbiAgICAgICAgY2FzZSA0MDAxOlxuICAgICAgICAgIHJldHVybiBcIk5vdCBhbGxvd2VkIHRvIGNvbm5lY3QgdG8gdGhlIHJvb21cIjtcbiAgICAgICAgY2FzZSA0MDA1OlxuICAgICAgICAgIHJldHVybiBcIlJvb20gaXMgYWxyZWFkeSBmdWxsXCI7XG4gICAgICAgIGNhc2UgNDAwNjpcbiAgICAgICAgICByZXR1cm4gXCJLaWNrZWQgb3V0IG9mIHRoZSByb29tLCBiZWNhdXNlIHRoZSByb29tIElEIGNoYW5nZWRcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gXCJDb3VsZCBub3QgY29ubmVjdCB0byB0aGUgcm9vbVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXNlIFwiQ1JFQVRFX1RIUkVBRF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGNyZWF0ZSBuZXcgdGhyZWFkXCI7XG4gICAgY2FzZSBcIkRFTEVURV9USFJFQURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgdGhyZWFkXCI7XG4gICAgY2FzZSBcIkVESVRfVEhSRUFEX01FVEFEQVRBX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgZWRpdCB0aHJlYWQgbWV0YWRhdGFcIjtcbiAgICBjYXNlIFwiTUFSS19USFJFQURfQVNfUkVTT0xWRURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBtYXJrIHRocmVhZCBhcyByZXNvbHZlZFwiO1xuICAgIGNhc2UgXCJNQVJLX1RIUkVBRF9BU19VTlJFU09MVkVEX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgbWFyayB0aHJlYWQgYXMgdW5yZXNvbHZlZFwiO1xuICAgIGNhc2UgXCJDUkVBVEVfQ09NTUVOVF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGNyZWF0ZSBuZXcgY29tbWVudFwiO1xuICAgIGNhc2UgXCJFRElUX0NPTU1FTlRfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBlZGl0IGNvbW1lbnRcIjtcbiAgICBjYXNlIFwiREVMRVRFX0NPTU1FTlRfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgY29tbWVudFwiO1xuICAgIGNhc2UgXCJBRERfUkVBQ1RJT05fRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBhZGQgcmVhY3Rpb25cIjtcbiAgICBjYXNlIFwiUkVNT1ZFX1JFQUNUSU9OX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgcmVtb3ZlIHJlYWN0aW9uXCI7XG4gICAgY2FzZSBcIk1BUktfSU5CT1hfTk9USUZJQ0FUSU9OX0FTX1JFQURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBtYXJrIGluYm94IG5vdGlmaWNhdGlvbiBhcyByZWFkXCI7XG4gICAgY2FzZSBcIkRFTEVURV9JTkJPWF9OT1RJRklDQVRJT05fRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgaW5ib3ggbm90aWZpY2F0aW9uXCI7XG4gICAgY2FzZSBcIk1BUktfQUxMX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IG1hcmsgYWxsIGluYm94IG5vdGlmaWNhdGlvbnMgYXMgcmVhZFwiO1xuICAgIGNhc2UgXCJERUxFVEVfQUxMX0lOQk9YX05PVElGSUNBVElPTlNfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgYWxsIGluYm94IG5vdGlmaWNhdGlvbnNcIjtcbiAgICBjYXNlIFwiVVBEQVRFX05PVElGSUNBVElPTl9TRVRUSU5HU19FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IHVwZGF0ZSBub3RpZmljYXRpb24gc2V0dGluZ3NcIjtcbiAgICBjYXNlIFwiVVBEQVRFX1VTRVJfTk9USUZJQ0FUSU9OX1NFVFRJTkdTX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgdXBkYXRlIHVzZXIgbm90aWZpY2F0aW9uIHNldHRpbmdzXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihjb250ZXh0LCBcIlVuaGFuZGxlZCBjYXNlXCIpO1xuICB9XG59XG5cbi8vIHNyYy9yb29tLnRzXG52YXIgTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUgPSAxMDI0ICogMTAyNCAtIDUxMjtcbmZ1bmN0aW9uIG1ha2VJZEZhY3RvcnkoY29ubmVjdGlvbklkKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIHJldHVybiAoKSA9PiBgJHtjb25uZWN0aW9uSWR9OiR7Y291bnQrK31gO1xufVxuZnVuY3Rpb24gdXNlclRvVHJlZU5vZGUoa2V5LCB1c2VyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJVc2VyXCIsXG4gICAgaWQ6IGAke3VzZXIuY29ubmVjdGlvbklkfWAsXG4gICAga2V5LFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIGNvbm5lY3Rpb25JZDogdXNlci5jb25uZWN0aW9uSWQsXG4gICAgICBpZDogdXNlci5pZCxcbiAgICAgIGluZm86IHVzZXIuaW5mbyxcbiAgICAgIHByZXNlbmNlOiB1c2VyLnByZXNlbmNlLFxuICAgICAgaXNSZWFkT25seTogIXVzZXIuY2FuV3JpdGVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpIHtcbiAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gIGNvbnN0IGluQmFja2dyb3VuZFNpbmNlID0geyBjdXJyZW50OiBudWxsIH07XG4gIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID8/IERhdGUubm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgIGRvYz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgfTtcbiAgcmV0dXJuIFtpbkJhY2tncm91bmRTaW5jZSwgdW5zdWJdO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbShvcHRpb25zLCBjb25maWcpIHtcbiAgY29uc3QgaW5pdGlhbFByZXNlbmNlID0gb3B0aW9ucy5pbml0aWFsUHJlc2VuY2U7XG4gIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gb3B0aW9ucy5pbml0aWFsU3RvcmFnZTtcbiAgY29uc3QgaHR0cENsaWVudCA9IGNvbmZpZy5yb29tSHR0cENsaWVudDtcbiAgY29uc3QgW2luQmFja2dyb3VuZFNpbmNlLCB1bmluc3RhbGxCZ1RhYlNweV0gPSBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpO1xuICBjb25zdCBkZWxlZ2F0ZXMgPSB7XG4gICAgLi4uY29uZmlnLmRlbGVnYXRlcyxcbiAgICAvLyBBIGNvbm5lY3Rpb24gaXMgYWxsb3dlZCB0byBnbyBpbnRvIFwiem9tYmllIHN0YXRlXCIgb25seSBpZiBhbGwgb2YgdGhlXG4gICAgLy8gZm9sbG93aW5nIGNvbmRpdGlvbnMgYXBwbHk6XG4gICAgLy9cbiAgICAvLyAtIFRoZSBgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRgIGNsaWVudCBvcHRpb24gaXMgY29uZmlndXJlZFxuICAgIC8vIC0gVGhlIGJyb3dzZXIgd2luZG93IGhhcyBiZWVuIGluIHRoZSBiYWNrZ3JvdW5kIGZvciBhdCBsZWFzdFxuICAgIC8vICAgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBtaWxsaXNlY29uZHNcbiAgICAvLyAtIFRoZXJlIGFyZSBubyBwZW5kaW5nIGNoYW5nZXNcbiAgICAvL1xuICAgIGNhblpvbWJpZSgpIHtcbiAgICAgIHJldHVybiBjb25maWcuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgIT09IHZvaWQgMCAmJiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICE9PSBudWxsICYmIERhdGUubm93KCkgPiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICsgY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICYmIGdldFN0b3JhZ2VTdGF0dXMoKSAhPT0gXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9O1xuICBjb25zdCBtYW5hZ2VkU29ja2V0ID0gbmV3IE1hbmFnZWRTb2NrZXQoXG4gICAgZGVsZWdhdGVzLFxuICAgIGNvbmZpZy5lbmFibGVEZWJ1Z0xvZ2dpbmdcbiAgKTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBidWZmZXI6IHtcbiAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgbGFzdEZsdXNoZWRBdDogMCxcbiAgICAgIHByZXNlbmNlVXBkYXRlczogKFxuICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgaW5pdGlhbCBwcmVzZW5jZSBtZXNzYWdlIGFzIGEgRnVsbCBQcmVzZW5jZeKEoiB1cGRhdGVcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgICAgIGRhdGE6IGluaXRpYWxQcmVzZW5jZVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgc3RvcmFnZU9wZXJhdGlvbnM6IFtdXG4gICAgfSxcbiAgICBzdGF0aWNTZXNzaW9uSW5mb1NpZzogbmV3IFNpZ25hbChudWxsKSxcbiAgICBkeW5hbWljU2Vzc2lvbkluZm9TaWc6IG5ldyBTaWduYWwobnVsbCksXG4gICAgbXlQcmVzZW5jZTogbmV3IFBhdGNoYWJsZVNpZ25hbChpbml0aWFsUHJlc2VuY2UpLFxuICAgIG90aGVyczogbmV3IE1hbmFnZWRPdGhlcnMoKSxcbiAgICBpbml0aWFsU3RvcmFnZSxcbiAgICBpZEZhY3Rvcnk6IG51bGwsXG4gICAgLy8gVGhlIFlqcyBwcm92aWRlciBhc3NvY2lhdGVkIHRvIHRoaXMgcm9vbVxuICAgIHlqc1Byb3ZpZGVyOiB2b2lkIDAsXG4gICAgeWpzUHJvdmlkZXJEaWRDaGFuZ2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIFN0b3JhZ2VcbiAgICBjbG9jazogMCxcbiAgICBvcENsb2NrOiAwLFxuICAgIG5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICB1bmRvU3RhY2s6IFtdLFxuICAgIHJlZG9TdGFjazogW10sXG4gICAgcGF1c2VkSGlzdG9yeTogbnVsbCxcbiAgICBhY3RpdmVCYXRjaDogbnVsbCxcbiAgICB1bmFja25vd2xlZGdlZE9wczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAvLyBEZWJ1Z1xuICAgIG9wU3RhY2tUcmFjZXM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkgOiB2b2lkIDBcbiAgfTtcbiAgbGV0IGxhc3RUb2tlbktleTtcbiAgZnVuY3Rpb24gb25TdGF0dXNEaWRDaGFuZ2UobmV3U3RhdHVzKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gbWFuYWdlZFNvY2tldC5hdXRoVmFsdWU7XG4gICAgaWYgKGF1dGhWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdG9rZW5LZXkgPSBnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKTtcbiAgICAgIGlmICh0b2tlbktleSAhPT0gbGFzdFRva2VuS2V5KSB7XG4gICAgICAgIGxhc3RUb2tlbktleSA9IHRva2VuS2V5O1xuICAgICAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIpIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQ7XG4gICAgICAgICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mb1NpZy5zZXQoe1xuICAgICAgICAgICAgdXNlcklkOiB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaWQgOiB0b2tlbi51aWQsXG4gICAgICAgICAgICB1c2VySW5mbzogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmluZm8gOiB0b2tlbi51aVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm9TaWcuc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdm9pZCAwLFxuICAgICAgICAgICAgdXNlckluZm86IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50SHViLnN0YXR1cy5ub3RpZnkobmV3U3RhdHVzKTtcbiAgICBub3RpZnlTZWxmQ2hhbmdlZCgpO1xuICB9XG4gIGxldCBfY29ubmVjdGlvbkxvc3NUaW1lcklkO1xuICBsZXQgX2hhc0xvc3RDb25uZWN0aW9uID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGhhbmRsZUNvbm5lY3Rpb25Mb3NzRXZlbnQobmV3U3RhdHVzKSB7XG4gICAgaWYgKG5ld1N0YXR1cyA9PT0gXCJyZWNvbm5lY3RpbmdcIikge1xuICAgICAgX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJsb3N0XCIpO1xuICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250ZXh0Lm90aGVycy5jbGVhck90aGVycygpO1xuICAgICAgICBub3RpZnkoeyBvdGhlcnM6IFt7IHR5cGU6IFwicmVzZXRcIiB9XSB9KTtcbiAgICAgIH0sIGNvbmZpZy5sb3N0Q29ubmVjdGlvblRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCk7XG4gICAgICBpZiAoX2hhc0xvc3RDb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChuZXdTdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJmYWlsZWRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwicmVzdG9yZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgX2hhc0xvc3RDb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uRGlkQ29ubmVjdCgpIHtcbiAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7XG4gICAgICB0eXBlOiBcImZ1bGxcIixcbiAgICAgIGRhdGE6IChcbiAgICAgICAgLy8gQmVjYXVzZSBjb250ZXh0Lm1lLmN1cnJlbnQgaXMgYSByZWFkb25seSBvYmplY3QsIHdlJ2xsIGhhdmUgdG9cbiAgICAgICAgLy8gbWFrZSBhIGNvcHkgaGVyZS4gT3RoZXJ3aXNlLCB0eXBlIGVycm9ycyBoYXBwZW4gbGF0ZXIgd2hlblxuICAgICAgICAvLyBcInBhdGNoaW5nXCIgbXkgcHJlc2VuY2UuXG4gICAgICAgIHsgLi4uY29udGV4dC5teVByZXNlbmNlLmdldCgpIH1cbiAgICAgIClcbiAgICB9O1xuICAgIGlmIChfZ2V0U3RvcmFnZSQgIT09IG51bGwpIHtcbiAgICAgIHJlZnJlc2hTdG9yYWdlKHsgZmx1c2g6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIG9uRGlkRGlzY29ubmVjdCgpIHtcbiAgICBjbGVhclRpbWVvdXQoY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEKTtcbiAgfVxuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5vbk1lc3NhZ2Uuc3Vic2NyaWJlKGhhbmRsZVNlcnZlck1lc3NhZ2UpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5zdGF0dXNEaWRDaGFuZ2Uuc3Vic2NyaWJlKG9uU3RhdHVzRGlkQ2hhbmdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShoYW5kbGVDb25uZWN0aW9uTG9zc0V2ZW50KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuZGlkQ29ubmVjdC5zdWJzY3JpYmUob25EaWRDb25uZWN0KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuZGlkRGlzY29ubmVjdC5zdWJzY3JpYmUob25EaWREaXNjb25uZWN0KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25Db25uZWN0aW9uRXJyb3Iuc3Vic2NyaWJlKCh7IG1lc3NhZ2UsIGNvZGUgfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBcIlJPT01fQ09OTkVDVElPTl9FUlJPUlwiO1xuICAgIGNvbnN0IGVyciA9IG5ldyBMaXZlYmxvY2tzRXJyb3IobWVzc2FnZSwgeyB0eXBlLCBjb2RlLCByb29tSWQgfSk7XG4gICAgY29uc3QgZGlkTm90aWZ5ID0gY29uZmlnLmVycm9yRXZlbnRTb3VyY2Uubm90aWZ5KGVycik7XG4gICAgaWYgKCFkaWROb3RpZnkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZXJyb3IyKFxuICAgICAgICAgIGBDb25uZWN0aW9uIHRvIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkLiBSZWFzb246ICR7bWVzc2FnZX0gKGNvZGU6ICR7Y29kZX0pLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBwb29sID0ge1xuICAgIHJvb21JZDogY29uZmlnLnJvb21JZCxcbiAgICBnZXROb2RlOiAoaWQpID0+IGNvbnRleHQubm9kZXMuZ2V0KGlkKSxcbiAgICBhZGROb2RlOiAoaWQsIG5vZGUpID0+IHZvaWQgY29udGV4dC5ub2Rlcy5zZXQoaWQsIG5vZGUpLFxuICAgIGRlbGV0ZU5vZGU6IChpZCkgPT4gdm9pZCBjb250ZXh0Lm5vZGVzLmRlbGV0ZShpZCksXG4gICAgZ2VuZXJhdGVJZDogKCkgPT4gYCR7Z2V0Q29ubmVjdGlvbklkKCl9OiR7Y29udGV4dC5jbG9jaysrfWAsXG4gICAgZ2VuZXJhdGVPcElkOiAoKSA9PiBgJHtnZXRDb25uZWN0aW9uSWQoKX06JHtjb250ZXh0Lm9wQ2xvY2srK31gLFxuICAgIGRpc3BhdGNoKG9wcywgcmV2ZXJzZSwgc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhY2tUcmFjZSA9IGNhcHR1cmVTdGFja1RyYWNlKFwiU3RvcmFnZSBtdXRhdGlvblwiLCB0aGlzLmRpc3BhdGNoKTtcbiAgICAgICAgaWYgKHN0YWNrVHJhY2UpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICAgICAgaWYgKG9wLm9wSWQpIHtcbiAgICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5zZXQob3Aub3BJZCwgc3RhY2tUcmFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlQmF0Y2gpIHtcbiAgICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC5vcHMucHVzaChvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgIGFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnB1c2hMZWZ0KHJldmVyc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVG9VbmRvU3RhY2socmV2ZXJzZSk7XG4gICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIGRpc3BhdGNoT3BzKG9wcyk7XG4gICAgICAgIG5vdGlmeSh7IHN0b3JhZ2VVcGRhdGVzIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGU6ICgpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvU2lnLmdldCgpPy5zY29wZXM7XG4gICAgICBpZiAoc2NvcGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKTtcbiAgICAgIGlmICghY2FuV3JpdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IHdyaXRlIHRvIHN0b3JhZ2Ugd2l0aCBhIHJlYWQgb25seSB1c2VyLCBwbGVhc2UgZW5zdXJlIHRoZSB1c2VyIGhhcyB3cml0ZSBwZXJtaXNzaW9uc1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBldmVudEh1YiA9IHtcbiAgICBzdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIE5ldy9yZWNvbW1lbmRlZCBBUElcbiAgICBsb3N0Q29ubmVjdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgY3VzdG9tRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHNlbGY6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG15UHJlc2VuY2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG90aGVyczogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZUJhdGNoOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBoaXN0b3J5OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlRGlkTG9hZDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZVN0YXR1czogbWFrZUV2ZW50U291cmNlKCksXG4gICAgeWRvYzogbWFrZUV2ZW50U291cmNlKCksXG4gICAgY29tbWVudHM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHJvb21XaWxsRGVzdHJveTogbWFrZUV2ZW50U291cmNlKClcbiAgfTtcbiAgY29uc3Qgcm9vbUlkID0gY29uZmlnLnJvb21JZDtcbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGV4dE1lbnRpb24odXNlcklkLCBtZW50aW9uSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5jcmVhdGVUZXh0TWVudGlvbih7IHJvb21JZCwgdXNlcklkLCBtZW50aW9uSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGV4dE1lbnRpb24obWVudGlvbklkKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZGVsZXRlVGV4dE1lbnRpb24oeyByb29tSWQsIG1lbnRpb25JZCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZXBvcnRUZXh0RWRpdG9yKHR5cGUsIHJvb3RLZXkpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnJlcG9ydFRleHRFZGl0b3IoeyByb29tSWQsIHR5cGUsIHJvb3RLZXkgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbGlzdFRleHRWZXJzaW9ucygpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5saXN0VGV4dFZlcnNpb25zKHsgcm9vbUlkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnNTaW5jZShvcHRpb25zMikge1xuICAgIHJldHVybiBodHRwQ2xpZW50Lmxpc3RUZXh0VmVyc2lvbnNTaW5jZSh7XG4gICAgICByb29tSWQsXG4gICAgICBzaW5jZTogb3B0aW9uczIuc2luY2UsXG4gICAgICBzaWduYWw6IG9wdGlvbnMyLnNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRleHRWZXJzaW9uKHZlcnNpb25JZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmdldFRleHRWZXJzaW9uKHsgcm9vbUlkLCB2ZXJzaW9uSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGV4dFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuY3JlYXRlVGV4dFZlcnNpb24oeyByb29tSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUNvbnRleHR1YWxQcm9tcHQob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5leGVjdXRlQ29udGV4dHVhbFByb21wdCh7XG4gICAgICByb29tSWQsXG4gICAgICAuLi5vcHRpb25zMlxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uKiBjaHVua09wcyhtc2cpIHtcbiAgICBjb25zdCB7IG9wcywgLi4ucmVzdCB9ID0gbXNnO1xuICAgIGlmIChvcHMubGVuZ3RoIDwgMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNwbGl0IG9wcyBpbnRvIHNtYWxsZXIgY2h1bmtzXCIpO1xuICAgIH1cbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKG9wcy5sZW5ndGggLyAyKTtcbiAgICBjb25zdCBmaXJzdEhhbGYgPSBvcHMuc2xpY2UoMCwgbWlkKTtcbiAgICBjb25zdCBzZWNvbmRIYWxmID0gb3BzLnNsaWNlKG1pZCk7XG4gICAgZm9yIChjb25zdCBoYWxmT3BzIG9mIFtmaXJzdEhhbGYsIHNlY29uZEhhbGZdKSB7XG4gICAgICBjb25zdCBoYWxmID0geyBvcHM6IGhhbGZPcHMsIC4uLnJlc3QgfTtcbiAgICAgIGNvbnN0IHRleHQgPSBzdHJpbmdpZnlPckxvZyhbaGFsZl0pO1xuICAgICAgaWYgKCFpc1Rvb0JpZ0ZvcldlYlNvY2tldCh0ZXh0KSkge1xuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQqIGNodW5rT3BzKGhhbGYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiogY2h1bmtNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPCAyKSB7XG4gICAgICBpZiAobWVzc2FnZXNbMF0udHlwZSA9PT0gMjAxIC8qIFVQREFURV9TVE9SQUdFICovKSB7XG4gICAgICAgIHlpZWxkKiBjaHVua09wcyhtZXNzYWdlc1swXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCBzcGxpdCBpbnRvIGNodW5rcyBzbWFsbGVyIHRoYW4gdGhlIGFsbG93ZWQgbWVzc2FnZSBzaXplXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcihtZXNzYWdlcy5sZW5ndGggLyAyKTtcbiAgICBjb25zdCBmaXJzdEhhbGYgPSBtZXNzYWdlcy5zbGljZSgwLCBtaWQpO1xuICAgIGNvbnN0IHNlY29uZEhhbGYgPSBtZXNzYWdlcy5zbGljZShtaWQpO1xuICAgIGZvciAoY29uc3QgaGFsZiBvZiBbZmlyc3RIYWxmLCBzZWNvbmRIYWxmXSkge1xuICAgICAgY29uc3QgdGV4dCA9IHN0cmluZ2lmeU9yTG9nKGhhbGYpO1xuICAgICAgaWYgKCFpc1Rvb0JpZ0ZvcldlYlNvY2tldCh0ZXh0KSkge1xuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQqIGNodW5rTWVzc2FnZXMoaGFsZik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzVG9vQmlnRm9yV2ViU29ja2V0KHRleHQpIHtcbiAgICBpZiAodGV4dC5sZW5ndGggKiA0IDwgTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXh0KS5sZW5ndGggPj0gTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkU7XG4gIH1cbiAgZnVuY3Rpb24gc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgY29uc3Qgc3RyYXRlZ3kgPSBjb25maWcubGFyZ2VNZXNzYWdlU3RyYXRlZ3kgPz8gXCJkZWZhdWx0XCI7XG4gICAgY29uc3QgdGV4dCA9IHN0cmluZ2lmeU9yTG9nKG1lc3NhZ2VzKTtcbiAgICBpZiAoIWlzVG9vQmlnRm9yV2ViU29ja2V0KHRleHQpKSB7XG4gICAgICByZXR1cm4gbWFuYWdlZFNvY2tldC5zZW5kKHRleHQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICBjYXNlIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgIGVycm9yMihcIk1lc3NhZ2UgaXMgdG9vIGxhcmdlIGZvciB3ZWJzb2NrZXRzLCBub3Qgc2VuZGluZy4gQ29uZmlndXJlIGxhcmdlTWVzc2FnZVN0cmF0ZWd5IG9wdGlvbiB0byBkZWFsIHdpdGggdGhpcy5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJzcGxpdFwiOiB7XG4gICAgICAgIHdhcm4oXCJNZXNzYWdlIGlzIHRvbyBsYXJnZSBmb3Igd2Vic29ja2V0cywgc3BsaXR0aW5nIGludG8gc21hbGxlciBjaHVua3NcIik7XG4gICAgICAgIGZvciAoY29uc3QgY2h1bmsyIG9mIGNodW5rTWVzc2FnZXMobWVzc2FnZXMpKSB7XG4gICAgICAgICAgbWFuYWdlZFNvY2tldC5zZW5kKGNodW5rMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FzZSBcImV4cGVyaW1lbnRhbC1mYWxsYmFjay10by1odHRwXCI6IHtcbiAgICAgICAgd2FybihcIk1lc3NhZ2UgaXMgdG9vIGxhcmdlIGZvciB3ZWJzb2NrZXRzLCBzbyBzZW5kaW5nIG92ZXIgSFRUUCBpbnN0ZWFkXCIpO1xuICAgICAgICBjb25zdCBub25jZSA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvU2lnLmdldCgpPy5ub25jZSA/PyByYWlzZShcIlNlc3Npb24gaXMgbm90IGF1dGhvcml6ZWQgdG8gc2VuZCBtZXNzYWdlIG92ZXIgSFRUUFwiKTtcbiAgICAgICAgdm9pZCBodHRwQ2xpZW50LnNlbmRNZXNzYWdlcyh7IHJvb21JZCwgbm9uY2UsIG1lc3NhZ2VzIH0pLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICBpZiAoIXJlc3Aub2sgJiYgcmVzcC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgICAgbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGYgPSBEZXJpdmVkU2lnbmFsLmZyb20oXG4gICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mb1NpZyxcbiAgICBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mb1NpZyxcbiAgICBjb250ZXh0Lm15UHJlc2VuY2UsXG4gICAgKHN0YXRpY1Nlc3Npb24sIGR5bmFtaWNTZXNzaW9uLCBteVByZXNlbmNlKSA9PiB7XG4gICAgICBpZiAoc3RhdGljU2Vzc2lvbiA9PT0gbnVsbCB8fCBkeW5hbWljU2Vzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNhbldyaXRlID0gY2FuV3JpdGVTdG9yYWdlKGR5bmFtaWNTZXNzaW9uLnNjb3Blcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29ubmVjdGlvbklkOiBkeW5hbWljU2Vzc2lvbi5hY3RvcixcbiAgICAgICAgICBpZDogc3RhdGljU2Vzc2lvbi51c2VySWQsXG4gICAgICAgICAgaW5mbzogc3RhdGljU2Vzc2lvbi51c2VySW5mbyxcbiAgICAgICAgICBwcmVzZW5jZTogbXlQcmVzZW5jZSxcbiAgICAgICAgICBjYW5Xcml0ZSxcbiAgICAgICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGR5bmFtaWNTZXNzaW9uLnNjb3BlcylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGxldCBfbGFzdFNlbGY7XG4gIGZ1bmN0aW9uIG5vdGlmeVNlbGZDaGFuZ2VkKCkge1xuICAgIGNvbnN0IGN1cnJTZWxmID0gc2VsZi5nZXQoKTtcbiAgICBpZiAoY3VyclNlbGYgIT09IG51bGwgJiYgY3VyclNlbGYgIT09IF9sYXN0U2VsZikge1xuICAgICAgZXZlbnRIdWIuc2VsZi5ub3RpZnkoY3VyclNlbGYpO1xuICAgICAgX2xhc3RTZWxmID0gY3VyclNlbGY7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGZBc1RyZWVOb2RlID0gRGVyaXZlZFNpZ25hbC5mcm9tKFxuICAgIHNlbGYsXG4gICAgKG1lKSA9PiBtZSAhPT0gbnVsbCA/IHVzZXJUb1RyZWVOb2RlKFwiTWVcIiwgbWUpIDogbnVsbFxuICApO1xuICBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVJvb3RGcm9tTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogY2Fubm90IGxvYWQgc3RvcmFnZSB3aXRob3V0IGl0ZW1zXCIpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHVwZGF0ZVJvb3QobWVzc2FnZS5pdGVtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQucm9vdCA9IExpdmVPYmplY3QuX2Zyb21JdGVtcyhtZXNzYWdlLml0ZW1zLCBwb29sKTtcbiAgICB9XG4gICAgY29uc3QgY2FuV3JpdGUgPSBzZWxmLmdldCgpPy5jYW5Xcml0ZSA/PyB0cnVlO1xuICAgIGNvbnN0IHN0YWNrU2l6ZUJlZm9yZSA9IGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0LmluaXRpYWxTdG9yYWdlKSB7XG4gICAgICBpZiAoY29udGV4dC5yb290LmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGNhbldyaXRlKSB7XG4gICAgICAgICAgY29udGV4dC5yb290LnNldChrZXksIGNsb25lTHNvbihjb250ZXh0LmluaXRpYWxTdG9yYWdlW2tleV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEF0dGVtcHRlZCB0byBwb3B1bGF0ZSBtaXNzaW5nIHN0b3JhZ2Uga2V5ICcke2tleX0nLCBidXQgY3VycmVudCB1c2VyIGhhcyBubyB3cml0ZSBhY2Nlc3NgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSBzdGFja1NpemVCZWZvcmU7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUm9vdChpdGVtcykge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50SXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBub2RlXSBvZiBjb250ZXh0Lm5vZGVzKSB7XG4gICAgICBjdXJyZW50SXRlbXMuc2V0KGlkLCBub2RlLl9zZXJpYWxpemUoKSk7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IGdldFRyZWVzRGlmZk9wZXJhdGlvbnMoY3VycmVudEl0ZW1zLCBuZXcgTWFwKGl0ZW1zKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMob3BzLCBmYWxzZSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzKTtcbiAgfVxuICBmdW5jdGlvbiBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMpIHtcbiAgICBpZiAoY29udGV4dC51bmRvU3RhY2subGVuZ3RoID49IDUwKSB7XG4gICAgICBjb250ZXh0LnVuZG9TdGFjay5zaGlmdCgpO1xuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5wdXNoKGhpc3RvcnlPcHMpO1xuICAgIG9uSGlzdG9yeUNoYW5nZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFRvVW5kb1N0YWNrKGhpc3RvcnlPcHMpIHtcbiAgICBpZiAoY29udGV4dC5wYXVzZWRIaXN0b3J5ICE9PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkucHVzaExlZnQoaGlzdG9yeU9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeSh1cGRhdGVzKSB7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSB1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzO1xuICAgIGNvbnN0IG90aGVyc1VwZGF0ZXMgPSB1cGRhdGVzLm90aGVycztcbiAgICBpZiAob3RoZXJzVXBkYXRlcyAhPT0gdm9pZCAwICYmIG90aGVyc1VwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuZ2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIG90aGVyc1VwZGF0ZXMpIHtcbiAgICAgICAgZXZlbnRIdWIub3RoZXJzLm5vdGlmeSh7IC4uLmV2ZW50LCBvdGhlcnMgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGVzLnByZXNlbmNlID8/IGZhbHNlKSB7XG4gICAgICBub3RpZnlTZWxmQ2hhbmdlZCgpO1xuICAgICAgZXZlbnRIdWIubXlQcmVzZW5jZS5ub3RpZnkoY29udGV4dC5teVByZXNlbmNlLmdldCgpKTtcbiAgICB9XG4gICAgaWYgKHN0b3JhZ2VVcGRhdGVzICE9PSB2b2lkIDAgJiYgc3RvcmFnZVVwZGF0ZXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IHVwZGF0ZXMyID0gQXJyYXkuZnJvbShzdG9yYWdlVXBkYXRlcy52YWx1ZXMoKSk7XG4gICAgICBldmVudEh1Yi5zdG9yYWdlQmF0Y2gubm90aWZ5KHVwZGF0ZXMyKTtcbiAgICB9XG4gICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICB9XG4gIGZ1bmN0aW9uIGdldENvbm5lY3Rpb25JZCgpIHtcbiAgICBjb25zdCBpbmZvID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm9TaWcuZ2V0KCk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmFjdG9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludGVybmFsLiBUcmllZCB0byBnZXQgY29ubmVjdGlvbiBpZCBidXQgY29ubmVjdGlvbiB3YXMgbmV2ZXIgb3BlblwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wcyhyYXdPcHMsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICByZXZlcnNlOiBuZXcgRGVxdWUoKSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgcHJlc2VuY2U6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVkTm9kZUlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgb3BzID0gcmF3T3BzLm1hcCgob3ApID0+IHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIgJiYgIW9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ub3AsIG9wSWQ6IHBvb2wuZ2VuZXJhdGVPcElkKCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgPT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb25zdCByZXZlcnNlID0ge1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgcmV2ZXJzZS5kYXRhW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuZ2V0KClba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Lm15UHJlc2VuY2UucGF0Y2gob3AuZGF0YSk7XG4gICAgICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7IHR5cGU6IFwicGFydGlhbFwiLCBkYXRhOiBvcC5kYXRhIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFba2V5XSA9IG9wLmRhdGFba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnJldmVyc2UucHVzaExlZnQocmV2ZXJzZSk7XG4gICAgICAgIG91dHB1dC5wcmVzZW5jZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc291cmNlO1xuICAgICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICAgIHNvdXJjZSA9IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9wSWQgPSBubihvcC5vcElkKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBubihjb250ZXh0Lm9wU3RhY2tUcmFjZXMpLmRlbGV0ZShvcElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGVsZXRlZCA9IGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuZGVsZXRlKG9wSWQpO1xuICAgICAgICAgIHNvdXJjZSA9IGRlbGV0ZWQgPyAyIC8qIEFDSyAqLyA6IDEgLyogUkVNT1RFICovO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGx5T3BSZXN1bHQgPSBhcHBseU9wKG9wLCBzb3VyY2UpO1xuICAgICAgICBpZiAoYXBwbHlPcFJlc3VsdC5tb2RpZmllZCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVJZCA9IGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQ7XG4gICAgICAgICAgaWYgKCEobm9kZUlkICYmIGNyZWF0ZWROb2RlSWRzLmhhcyhub2RlSWQpKSkge1xuICAgICAgICAgICAgb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgICAgbm4oYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZCksXG4gICAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgICAgb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLmdldChubihhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkKSksXG4gICAgICAgICAgICAgICAgYXBwbHlPcFJlc3VsdC5tb2RpZmllZFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3V0cHV0LnJldmVyc2UucHVzaExlZnQoYXBwbHlPcFJlc3VsdC5yZXZlcnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wLnR5cGUgPT09IDIgLyogQ1JFQVRFX0xJU1QgKi8gfHwgb3AudHlwZSA9PT0gNyAvKiBDUkVBVEVfTUFQICovIHx8IG9wLnR5cGUgPT09IDQgLyogQ1JFQVRFX09CSkVDVCAqLykge1xuICAgICAgICAgICAgY3JlYXRlZE5vZGVJZHMuYWRkKG5uKG9wLmlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvcHMsXG4gICAgICByZXZlcnNlOiBBcnJheS5mcm9tKG91dHB1dC5yZXZlcnNlKSxcbiAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXM6IG91dHB1dC5zdG9yYWdlVXBkYXRlcyxcbiAgICAgICAgcHJlc2VuY2U6IG91dHB1dC5wcmVzZW5jZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlPcChvcCwgc291cmNlKSB7XG4gICAgaWYgKGlzQWNrT3Aob3ApKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi86XG4gICAgICBjYXNlIDMgLyogVVBEQVRFX09CSkVDVCAqLzpcbiAgICAgIGNhc2UgNSAvKiBERUxFVEVfQ1JEVCAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuX2FwcGx5KG9wLCBzb3VyY2UgPT09IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgMSAvKiBTRVRfUEFSRU5UX0tFWSAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudC5ub2RlLl9zZXRDaGlsZEtleShcbiAgICAgICAgICAgIGFzUG9zKG9wLnBhcmVudEtleSksXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOiB7XG4gICAgICAgIGlmIChvcC5wYXJlbnRJZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLnBhcmVudElkKTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnROb2RlLl9hdHRhY2hDaGlsZChvcCwgc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUHJlc2VuY2UocGF0Y2gsIG9wdGlvbnMyKSB7XG4gICAgY29uc3Qgb2xkVmFsdWVzID0ge307XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0ge1xuICAgICAgICB0eXBlOiBcInBhcnRpYWxcIixcbiAgICAgICAgZGF0YToge31cbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICBjb25zdCBvdmVycmlkZVZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgIGlmIChvdmVycmlkZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3ZlcnJpZGVWYWx1ZTtcbiAgICAgIG9sZFZhbHVlc1trZXldID0gY29udGV4dC5teVByZXNlbmNlLmdldCgpW2tleV07XG4gICAgfVxuICAgIGNvbnRleHQubXlQcmVzZW5jZS5wYXRjaChwYXRjaCk7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIGlmIChvcHRpb25zMj8uYWRkVG9IaXN0b3J5KSB7XG4gICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gucmV2ZXJzZU9wcy5wdXNoTGVmdCh7XG4gICAgICAgICAgdHlwZTogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgIGRhdGE6IG9sZFZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gudXBkYXRlcy5wcmVzZW5jZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgICBpZiAob3B0aW9uczI/LmFkZFRvSGlzdG9yeSkge1xuICAgICAgICBhZGRUb1VuZG9TdGFjayhbeyB0eXBlOiBcInByZXNlbmNlXCIsIGRhdGE6IG9sZFZhbHVlcyB9XSk7XG4gICAgICB9XG4gICAgICBub3RpZnkoeyBwcmVzZW5jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLnRhcmdldEFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IG9sZFVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgY29udGV4dC5vdGhlcnMuc2V0T3RoZXIobWVzc2FnZS5hY3RvciwgbWVzc2FnZS5kYXRhKTtcbiAgICAgIGNvbnN0IG5ld1VzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgaWYgKG9sZFVzZXIgPT09IHZvaWQgMCAmJiBuZXdVc2VyICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlbnRlclwiLCB1c2VyOiBuZXdVc2VyIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnBhdGNoT3RoZXIobWVzc2FnZS5hY3RvciwgbWVzc2FnZS5kYXRhKSwgbWVzc2FnZTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgIHVwZGF0ZXM6IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgdXNlclxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VyTGVmdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICBjb250ZXh0Lm90aGVycy5yZW1vdmVDb25uZWN0aW9uKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJsZWF2ZVwiLCB1c2VyIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIG9uUm9vbVN0YXRlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm9TaWcuc2V0KHtcbiAgICAgIGFjdG9yOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgbm9uY2U6IG1lc3NhZ2Uubm9uY2UsXG4gICAgICBzY29wZXM6IG1lc3NhZ2Uuc2NvcGVzXG4gICAgfSk7XG4gICAgY29udGV4dC5pZEZhY3RvcnkgPSBtYWtlSWRGYWN0b3J5KG1lc3NhZ2UuYWN0b3IpO1xuICAgIG5vdGlmeVNlbGZDaGFuZ2VkKCk7XG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uSWQgb2YgY29udGV4dC5vdGhlcnMuY29ubmVjdGlvbklkcygpKSB7XG4gICAgICBjb25zdCB1c2VyID0gbWVzc2FnZS51c2Vyc1tjb25uZWN0aW9uSWRdO1xuICAgICAgaWYgKHVzZXIgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250ZXh0Lm90aGVycy5yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG1lc3NhZ2UudXNlcnMpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2tleV07XG4gICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSBOdW1iZXIoa2V5KTtcbiAgICAgIGNvbnRleHQub3RoZXJzLnNldENvbm5lY3Rpb24oXG4gICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgdXNlci5pZCxcbiAgICAgICAgdXNlci5pbmZvLFxuICAgICAgICB1c2VyLnNjb3Blc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyZXNldFwiIH07XG4gIH1cbiAgZnVuY3Rpb24gY2FuVW5kbygpIHtcbiAgICByZXR1cm4gY29udGV4dC51bmRvU3RhY2subGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBjYW5SZWRvKCkge1xuICAgIHJldHVybiBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIG9uSGlzdG9yeUNoYW5nZSgpIHtcbiAgICBldmVudEh1Yi5oaXN0b3J5Lm5vdGlmeSh7IGNhblVuZG86IGNhblVuZG8oKSwgY2FuUmVkbzogY2FuUmVkbygpIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnRleHQub3RoZXJzLnNldENvbm5lY3Rpb24oXG4gICAgICBtZXNzYWdlLmFjdG9yLFxuICAgICAgbWVzc2FnZS5pZCxcbiAgICAgIG1lc3NhZ2UuaW5mbyxcbiAgICAgIG1lc3NhZ2Uuc2NvcGVzXG4gICAgKTtcbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICBkYXRhOiBjb250ZXh0Lm15UHJlc2VuY2UuZ2V0KCksXG4gICAgICB0YXJnZXRBY3RvcjogbWVzc2FnZS5hY3RvclxuICAgIH0pO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgcmV0dXJuIHVzZXIgPyB7IHR5cGU6IFwiZW50ZXJcIiwgdXNlciB9IDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VydmVyTWVzc2FnZShkYXRhKSB7XG4gICAgaWYgKCFpc0pzb25PYmplY3QoZGF0YSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2VzKHRleHQpIHtcbiAgICBjb25zdCBkYXRhID0gdHJ5UGFyc2VKc29uKHRleHQpO1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoaXNKc29uQXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybiBjb21wYWN0KGRhdGEubWFwKChpdGVtKSA9PiBwYXJzZVNlcnZlck1lc3NhZ2UoaXRlbSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoW3BhcnNlU2VydmVyTWVzc2FnZShkYXRhKV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhcHBseUFuZFNlbmRPcHMob2ZmbGluZU9wcykge1xuICAgIGlmIChvZmZsaW5lT3BzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBjb25zdCBpbk9wcyA9IEFycmF5LmZyb20ob2ZmbGluZU9wcy52YWx1ZXMoKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaW5PcHMsIHRydWUpO1xuICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMjAxIC8qIFVQREFURV9TVE9SQUdFICovLFxuICAgICAgb3BzOiByZXN1bHQub3BzXG4gICAgfSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzKTtcbiAgICBzZW5kTWVzc2FnZXMobWVzc2FnZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVNlcnZlck1lc3NhZ2UoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBwYXJzZVNlcnZlck1lc3NhZ2VzKGV2ZW50LmRhdGEpO1xuICAgIGlmIChtZXNzYWdlcyA9PT0gbnVsbCB8fCBtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlcyA9IHtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgb3RoZXJzOiBbXVxuICAgIH07XG4gICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICBjYXNlIDEwMSAvKiBVU0VSX0pPSU5FRCAqLzoge1xuICAgICAgICAgIGNvbnN0IHVzZXJKb2luZWRVcGRhdGUgPSBvblVzZXJKb2luZWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIGlmICh1c2VySm9pbmVkVXBkYXRlKSB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKHVzZXJKb2luZWRVcGRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi86IHtcbiAgICAgICAgICBjb25zdCBvdGhlcnNQcmVzZW5jZVVwZGF0ZSA9IG9uVXBkYXRlUHJlc2VuY2VNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIGlmIChvdGhlcnNQcmVzZW5jZVVwZGF0ZSkge1xuICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChvdGhlcnNQcmVzZW5jZVVwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTAzIC8qIEJST0FEQ0FTVEVEX0VWRU5UICovOiB7XG4gICAgICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuZ2V0KCk7XG4gICAgICAgICAgZXZlbnRIdWIuY3VzdG9tRXZlbnQubm90aWZ5KHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogbWVzc2FnZS5hY3RvcixcbiAgICAgICAgICAgIHVzZXI6IG1lc3NhZ2UuYWN0b3IgPCAwID8gbnVsbCA6IG90aGVycy5maW5kKCh1KSA9PiB1LmNvbm5lY3Rpb25JZCA9PT0gbWVzc2FnZS5hY3RvcikgPz8gbnVsbCxcbiAgICAgICAgICAgIGV2ZW50OiBtZXNzYWdlLmV2ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxMDIgLyogVVNFUl9MRUZUICovOiB7XG4gICAgICAgICAgY29uc3QgZXZlbnQyID0gb25Vc2VyTGVmdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgaWYgKGV2ZW50Mikge1xuICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChldmVudDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMwMCAvKiBVUERBVEVfWURPQyAqLzoge1xuICAgICAgICAgIGV2ZW50SHViLnlkb2Mubm90aWZ5KG1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTA0IC8qIFJPT01fU1RBVEUgKi86IHtcbiAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG9uUm9vbVN0YXRlTWVzc2FnZShtZXNzYWdlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyMDAgLyogSU5JVElBTF9TVE9SQUdFX1NUQVRFICovOiB7XG4gICAgICAgICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyaXRlIGV2ZW50XG4gICAgICAgIGNhc2UgMjAxIC8qIFVQREFURV9TVE9SQUdFICovOiB7XG4gICAgICAgICAgY29uc3QgYXBwbHlSZXN1bHQgPSBhcHBseU9wcyhtZXNzYWdlLm9wcywgZmFsc2UpO1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFwcGx5UmVzdWx0LnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXModXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5nZXQoa2V5KSwgdmFsdWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWNlaXZpbmcgYSBSZWplY3RlZE9wcyBtZXNzYWdlIGluIHRoZSBjbGllbnQgbWVhbnMgdGhhdCB0aGUgc2VydmVyIGlzIG5vXG4gICAgICAgIC8vIGxvbmdlciBpbiBzeW5jIHdpdGggdGhlIGNsaWVudC4gVHJ5aW5nIHRvIHN5bmNocm9uaXplIHRoZSBjbGllbnQgYWdhaW4gYnlcbiAgICAgICAgLy8gcm9sbGluZyBiYWNrIHBhcnRpY3VsYXIgT3BzIG1heSBiZSBoYXJkL2ltcG9zc2libGUuIEl0J3MgZmluZSB0byBub3QgdHJ5IGFuZFxuICAgICAgICAvLyBhY2NlcHQgdGhlIG91dC1vZi1zeW5jIHJlYWxpdHkgYW5kIHRocm93IGFuIGVycm9yLiBXZSBsb29rIGF0IHRoaXMga2luZCBvZiBidWdcbiAgICAgICAgLy8gYXMgYSBkZXZlbG9wZXItb3duZWQgYnVnLiBJbiBwcm9kdWN0aW9uLCB0aGVzZSBlcnJvcnMgYXJlIG5vdCBleHBlY3RlZCB0byBoYXBwZW4uXG4gICAgICAgIGNhc2UgMjk5IC8qIFJFSkVDVF9TVE9SQUdFX09QICovOiB7XG4gICAgICAgICAgZXJyb3JXaXRoVGl0bGUoXG4gICAgICAgICAgICBcIlN0b3JhZ2UgbXV0YXRpb24gcmVqZWN0aW9uIGVycm9yXCIsXG4gICAgICAgICAgICBtZXNzYWdlLnJlYXNvblxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgdHJhY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3BJZCBvZiBtZXNzYWdlLm9wSWRzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyYWNlID0gY29udGV4dC5vcFN0YWNrVHJhY2VzPy5nZXQob3BJZCk7XG4gICAgICAgICAgICAgIGlmICh0cmFjZSkge1xuICAgICAgICAgICAgICAgIHRyYWNlcy5hZGQodHJhY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2VzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgIHdhcm5XaXRoVGl0bGUoXG4gICAgICAgICAgICAgICAgXCJUaGUgZm9sbG93aW5nIGZ1bmN0aW9uIGNhbGxzIGNhdXNlZCB0aGUgcmVqZWN0ZWQgc3RvcmFnZSBtdXRhdGlvbnM6XCIsXG4gICAgICAgICAgICAgICAgYFxuXG4ke0FycmF5LmZyb20odHJhY2VzKS5qb2luKFwiXFxuXFxuXCIpfWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYFN0b3JhZ2UgbXV0YXRpb25zIHJlamVjdGVkIGJ5IHNlcnZlcjogJHttZXNzYWdlLnJlYXNvbn1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDQwMCAvKiBUSFJFQURfQ1JFQVRFRCAqLzpcbiAgICAgICAgY2FzZSA0MDcgLyogVEhSRUFEX0RFTEVURUQgKi86XG4gICAgICAgIGNhc2UgNDAxIC8qIFRIUkVBRF9NRVRBREFUQV9VUERBVEVEICovOlxuICAgICAgICBjYXNlIDQwOCAvKiBUSFJFQURfVVBEQVRFRCAqLzpcbiAgICAgICAgY2FzZSA0MDUgLyogQ09NTUVOVF9SRUFDVElPTl9BRERFRCAqLzpcbiAgICAgICAgY2FzZSA0MDYgLyogQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEICovOlxuICAgICAgICBjYXNlIDQwMiAvKiBDT01NRU5UX0NSRUFURUQgKi86XG4gICAgICAgIGNhc2UgNDAzIC8qIENPTU1FTlRfRURJVEVEICovOlxuICAgICAgICBjYXNlIDQwNCAvKiBDT01NRU5UX0RFTEVURUQgKi86IHtcbiAgICAgICAgICBldmVudEh1Yi5jb21tZW50cy5ub3RpZnkobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbm90aWZ5KHVwZGF0ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGZsdXNoTm93T3JTb29uKCkge1xuICAgIGNvbnN0IHN0b3JhZ2VPcHMgPSBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucztcbiAgICBpZiAoc3RvcmFnZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIHN0b3JhZ2VPcHMpIHtcbiAgICAgICAgY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5zZXQobm4ob3Aub3BJZCksIG9wKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zID0gW107XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZE1pbGxpcyA9IG5vdyAtIGNvbnRleHQuYnVmZmVyLmxhc3RGbHVzaGVkQXQ7XG4gICAgaWYgKGVsYXBzZWRNaWxsaXMgPj0gY29uZmlnLnRocm90dGxlRGVsYXkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzVG9GbHVzaCA9IHNlcmlhbGl6ZUJ1ZmZlcigpO1xuICAgICAgaWYgKG1lc3NhZ2VzVG9GbHVzaC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzVG9GbHVzaCk7XG4gICAgICBjb250ZXh0LmJ1ZmZlciA9IHtcbiAgICAgICAgZmx1c2hUaW1lcklEOiB2b2lkIDAsXG4gICAgICAgIGxhc3RGbHVzaGVkQXQ6IG5vdyxcbiAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICBzdG9yYWdlT3BlcmF0aW9uczogW10sXG4gICAgICAgIHByZXNlbmNlVXBkYXRlczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgICBmbHVzaE5vd09yU29vbixcbiAgICAgICAgY29uZmlnLnRocm90dGxlRGVsYXkgLSBlbGFwc2VkTWlsbGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXJpYWxpemVCdWZmZXIoKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKFxuICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMudHlwZSA9PT0gXCJmdWxsXCIgPyB7XG4gICAgICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgICAgICAvLyBQb3B1bGF0aW5nIHRoZSBgdGFyZ2V0QWN0b3JgIGZpZWxkIHR1cm5zIHRoaXMgbWVzc2FnZSBpbnRvXG4gICAgICAgICAgLy8gYSBGdWxsIFByZXNlbmNl4oSiIHVwZGF0ZSBtZXNzYWdlIChub3QgYSBwYXRjaCksIHdoaWNoIHdpbGwgZ2V0XG4gICAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYnkgb3RoZXIgY2xpZW50cyBhcyBzdWNoLlxuICAgICAgICAgIHRhcmdldEFjdG9yOiAtMSxcbiAgICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVxuICAgICAgICB9IDoge1xuICAgICAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcykge1xuICAgICAgbWVzc2FnZXMucHVzaChldmVudCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogMjAxIC8qIFVQREFURV9TVE9SQUdFICovLFxuICAgICAgICBvcHM6IGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVlEb2ModXBkYXRlLCBndWlkLCBpc1YyKSB7XG4gICAgY29uc3QgY2xpZW50TXNnID0ge1xuICAgICAgdHlwZTogMzAxIC8qIFVQREFURV9ZRE9DICovLFxuICAgICAgdXBkYXRlLFxuICAgICAgZ3VpZCxcbiAgICAgIHYyOiBpc1YyXG4gICAgfTtcbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKGNsaWVudE1zZyk7XG4gICAgZXZlbnRIdWIueWRvYy5ub3RpZnkoY2xpZW50TXNnKTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGJyb2FkY2FzdEV2ZW50KGV2ZW50LCBvcHRpb25zMiA9IHtcbiAgICBzaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeTogZmFsc2VcbiAgfSkge1xuICAgIGlmIChtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpICE9PSBcImNvbm5lY3RlZFwiICYmICFvcHRpb25zMi5zaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDEwMyAvKiBCUk9BRENBU1RfRVZFTlQgKi8sXG4gICAgICBldmVudFxuICAgIH0pO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcGF0Y2hPcHMob3BzKSB7XG4gICAgY29uc3QgeyBzdG9yYWdlT3BlcmF0aW9ucyB9ID0gY29udGV4dC5idWZmZXI7XG4gICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgIHN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGxldCBfZ2V0U3RvcmFnZSQgPSBudWxsO1xuICBsZXQgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IG51bGw7XG4gIGZ1bmN0aW9uIHByb2Nlc3NJbml0aWFsU3RvcmFnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdW5hY2tub3dsZWRnZWRPcHMgPSBuZXcgTWFwKGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMpO1xuICAgIGNyZWF0ZU9yVXBkYXRlUm9vdEZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuICAgIGFwcGx5QW5kU2VuZE9wcyh1bmFja25vd2xlZGdlZE9wcyk7XG4gICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZT8uKCk7XG4gICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIGV2ZW50SHViLnN0b3JhZ2VEaWRMb2FkLm5vdGlmeSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0b3JhZ2UoKSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkgcmV0dXJuO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgaHR0cENsaWVudC5zdHJlYW1TdG9yYWdlKHsgcm9vbUlkIH0pO1xuICAgIHByb2Nlc3NJbml0aWFsU3RvcmFnZSh7IHR5cGU6IDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi8sIGl0ZW1zIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2hTdG9yYWdlKG9wdGlvbnMyKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcztcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX3N0cmVhbURhdGEpIHtcbiAgICAgIHZvaWQgc3RyZWFtU3RvcmFnZSgpO1xuICAgIH0gZWxzZSBpZiAoIW1lc3NhZ2VzLnNvbWUoKG1zZykgPT4gbXNnLnR5cGUgPT09IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovKSkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7IHR5cGU6IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9uczIuZmx1c2gpIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0TG9hZGluZ1N0b3JhZ2UoKSB7XG4gICAgaWYgKF9nZXRTdG9yYWdlJCA9PT0gbnVsbCkge1xuICAgICAgcmVmcmVzaFN0b3JhZ2UoeyBmbHVzaDogdHJ1ZSB9KTtcbiAgICAgIF9nZXRTdG9yYWdlJCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIHJldHVybiBfZ2V0U3RvcmFnZSQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVNuYXBzaG90KCkge1xuICAgIGNvbnN0IHJvb3QgPSBjb250ZXh0LnJvb3Q7XG4gICAgaWYgKHJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2UoKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgcm9vdDogY29udGV4dC5yb290XG4gICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgIHJldHVybiB7XG4gICAgICByb290OiBubihjb250ZXh0LnJvb3QpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmZXRjaFlEb2ModmVjdG9yLCBndWlkLCBpc1YyKSB7XG4gICAgaWYgKCFjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5maW5kKChtKSA9PiB7XG4gICAgICByZXR1cm4gbS50eXBlID09PSAzMDAgLyogRkVUQ0hfWURPQyAqLyAmJiBtLnZlY3RvciA9PT0gdmVjdG9yICYmIG0uZ3VpZCA9PT0gZ3VpZCAmJiBtLnYyID09PSBpc1YyO1xuICAgIH0pKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogMzAwIC8qIEZFVENIX1lET0MgKi8sXG4gICAgICAgIHZlY3RvcixcbiAgICAgICAgZ3VpZCxcbiAgICAgICAgdjI6IGlzVjJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGEgYmF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnVuZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoaGlzdG9yeU9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaGlzdG9yeU9wcywgdHJ1ZSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzKTtcbiAgICBjb250ZXh0LnJlZG9TdGFjay5wdXNoKHJlc3VsdC5yZXZlcnNlKTtcbiAgICBvbkhpc3RvcnlDaGFuZ2UoKTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHJlc3VsdC5vcHMpIHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVkbygpIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVkbyBpcyBub3QgYWxsb3dlZCBkdXJpbmcgYSBiYXRjaFwiKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucmVkb1N0YWNrLnBvcCgpO1xuICAgIGlmIChoaXN0b3J5T3BzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhoaXN0b3J5T3BzLCB0cnVlKTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMpO1xuICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgIG9uSGlzdG9yeUNoYW5nZSgpO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSAwO1xuICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gYmF0Y2gyKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBsZXQgcmV0dXJuVmFsdWUgPSB2b2lkIDA7XG4gICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IHtcbiAgICAgIG9wczogW10sXG4gICAgICB1cGRhdGVzOiB7XG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICBwcmVzZW5jZTogZmFsc2UsXG4gICAgICAgIG90aGVyczogW11cbiAgICAgIH0sXG4gICAgICByZXZlcnNlT3BzOiBuZXcgRGVxdWUoKVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY29uc3QgY3VycmVudEJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSBudWxsO1xuICAgICAgaWYgKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWRkVG9VbmRvU3RhY2soQXJyYXkuZnJvbShjdXJyZW50QmF0Y2gucmV2ZXJzZU9wcykpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBkaXNwYXRjaE9wcyhjdXJyZW50QmF0Y2gub3BzKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeShjdXJyZW50QmF0Y2gudXBkYXRlcyk7XG4gICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcGF1c2VIaXN0b3J5KCkge1xuICAgIGlmIChjb250ZXh0LnBhdXNlZEhpc3RvcnkgPT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG5ldyBEZXF1ZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXN1bWVIaXN0b3J5KCkge1xuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnBhdXNlZEhpc3Rvcnk7XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBpZiAoaGlzdG9yeU9wcyAhPT0gbnVsbCAmJiBoaXN0b3J5T3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIF9hZGRUb1JlYWxVbmRvU3RhY2soQXJyYXkuZnJvbShoaXN0b3J5T3BzKSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHN5bmNTb3VyY2VGb3JTdG9yYWdlID0gY29uZmlnLmNyZWF0ZVN5bmNTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVN0YXR1cygpIHtcbiAgICBpZiAoY29udGV4dC5yb290ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBfZ2V0U3RvcmFnZSQgPT09IG51bGwgPyBcIm5vdC1sb2FkZWRcIiA6IFwibG9hZGluZ1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5zaXplID09PSAwID8gXCJzeW5jaHJvbml6ZWRcIiA6IFwic3luY2hyb25pemluZ1wiO1xuICAgIH1cbiAgfVxuICBsZXQgX2xhc3RTdG9yYWdlU3RhdHVzID0gZ2V0U3RvcmFnZVN0YXR1cygpO1xuICBmdW5jdGlvbiBub3RpZnlTdG9yYWdlU3RhdHVzKCkge1xuICAgIGNvbnN0IHN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gICAgaWYgKF9sYXN0U3RvcmFnZVN0YXR1cyAhPT0gc3RvcmFnZVN0YXR1cykge1xuICAgICAgX2xhc3RTdG9yYWdlU3RhdHVzID0gc3RvcmFnZVN0YXR1cztcbiAgICAgIGV2ZW50SHViLnN0b3JhZ2VTdGF0dXMubm90aWZ5KHN0b3JhZ2VTdGF0dXMpO1xuICAgIH1cbiAgICBzeW5jU291cmNlRm9yU3RvcmFnZS5zZXRTeW5jU3RhdHVzKFxuICAgICAgc3RvcmFnZVN0YXR1cyA9PT0gXCJzeW5jaHJvbml6aW5nXCIgPyBcInN5bmNocm9uaXppbmdcIiA6IFwic3luY2hyb25pemVkXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGlzUHJlc2VuY2VSZWFkeSgpIHtcbiAgICByZXR1cm4gc2VsZi5nZXQoKSAhPT0gbnVsbDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWxQcmVzZW5jZVJlYWR5KCkge1xuICAgIHdoaWxlICghaXNQcmVzZW5jZVJlYWR5KCkpIHtcbiAgICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSB9ID0gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCk7XG4gICAgICBjb25zdCB1bnN1YjEgPSBldmVudHMuc2VsZi5zdWJzY3JpYmVPbmNlKHJlc29sdmUpO1xuICAgICAgY29uc3QgdW5zdWIyID0gZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmVPbmNlKHJlc29sdmUpO1xuICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIHVuc3ViMSgpO1xuICAgICAgdW5zdWIyKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzU3RvcmFnZVJlYWR5KCkge1xuICAgIHJldHVybiBnZXRTdG9yYWdlU25hcHNob3QoKSAhPT0gbnVsbDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWxTdG9yYWdlUmVhZHkoKSB7XG4gICAgd2hpbGUgKCFpc1N0b3JhZ2VSZWFkeSgpKSB7XG4gICAgICBhd2FpdCBnZXRTdG9yYWdlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG90aGVyc19mb3JEZXZUb29scyA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICBjb250ZXh0Lm90aGVycy5zaWduYWwsXG4gICAgKG90aGVycykgPT4gb3RoZXJzLm1hcCgob3RoZXIsIGluZGV4KSA9PiB1c2VyVG9UcmVlTm9kZShgT3RoZXIgJHtpbmRleH1gLCBvdGhlcikpXG4gICk7XG4gIGNvbnN0IGV2ZW50cyA9IHtcbiAgICBzdGF0dXM6IGV2ZW50SHViLnN0YXR1cy5vYnNlcnZhYmxlLFxuICAgIGxvc3RDb25uZWN0aW9uOiBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5vYnNlcnZhYmxlLFxuICAgIGN1c3RvbUV2ZW50OiBldmVudEh1Yi5jdXN0b21FdmVudC5vYnNlcnZhYmxlLFxuICAgIG90aGVyczogZXZlbnRIdWIub3RoZXJzLm9ic2VydmFibGUsXG4gICAgc2VsZjogZXZlbnRIdWIuc2VsZi5vYnNlcnZhYmxlLFxuICAgIG15UHJlc2VuY2U6IGV2ZW50SHViLm15UHJlc2VuY2Uub2JzZXJ2YWJsZSxcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBzdG9yYWdlOiBldmVudEh1Yi5zdG9yYWdlQmF0Y2gub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlQmF0Y2g6IGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5vYnNlcnZhYmxlLFxuICAgIGhpc3Rvcnk6IGV2ZW50SHViLmhpc3Rvcnkub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlRGlkTG9hZDogZXZlbnRIdWIuc3RvcmFnZURpZExvYWQub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlU3RhdHVzOiBldmVudEh1Yi5zdG9yYWdlU3RhdHVzLm9ic2VydmFibGUsXG4gICAgeWRvYzogZXZlbnRIdWIueWRvYy5vYnNlcnZhYmxlLFxuICAgIGNvbW1lbnRzOiBldmVudEh1Yi5jb21tZW50cy5vYnNlcnZhYmxlLFxuICAgIHJvb21XaWxsRGVzdHJveTogZXZlbnRIdWIucm9vbVdpbGxEZXN0cm95Lm9ic2VydmFibGVcbiAgfTtcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkc1NpbmNlKG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0VGhyZWFkc1NpbmNlKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHNpbmNlOiBvcHRpb25zMi5zaW5jZSxcbiAgICAgIHNpZ25hbDogb3B0aW9uczIuc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkcyhvcHRpb25zMikge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmdldFRocmVhZHMoe1xuICAgICAgcm9vbUlkLFxuICAgICAgcXVlcnk6IG9wdGlvbnMyPy5xdWVyeSxcbiAgICAgIGN1cnNvcjogb3B0aW9uczI/LmN1cnNvclxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZCh0aHJlYWRJZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmdldFRocmVhZCh7IHJvb21JZCwgdGhyZWFkSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGhyZWFkKG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuY3JlYXRlVGhyZWFkKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHRocmVhZElkOiBvcHRpb25zMi50aHJlYWRJZCxcbiAgICAgIGNvbW1lbnRJZDogb3B0aW9uczIuY29tbWVudElkLFxuICAgICAgbWV0YWRhdGE6IG9wdGlvbnMyLm1ldGFkYXRhLFxuICAgICAgYm9keTogb3B0aW9uczIuYm9keSxcbiAgICAgIGF0dGFjaG1lbnRJZHM6IG9wdGlvbnMyLmF0dGFjaG1lbnRJZHNcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVUaHJlYWQodGhyZWFkSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5kZWxldGVUaHJlYWQoeyByb29tSWQsIHRocmVhZElkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRUaHJlYWRNZXRhZGF0YSh7XG4gICAgbWV0YWRhdGEsXG4gICAgdGhyZWFkSWRcbiAgfSkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmVkaXRUaHJlYWRNZXRhZGF0YSh7IHJvb21JZCwgdGhyZWFkSWQsIG1ldGFkYXRhIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtUaHJlYWRBc1Jlc29sdmVkKHRocmVhZElkKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQubWFya1RocmVhZEFzUmVzb2x2ZWQoeyByb29tSWQsIHRocmVhZElkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtUaHJlYWRBc1VucmVzb2x2ZWQodGhyZWFkSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5tYXJrVGhyZWFkQXNVbnJlc29sdmVkKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHRocmVhZElkXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tbWVudChvcHRpb25zMikge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmNyZWF0ZUNvbW1lbnQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgdGhyZWFkSWQ6IG9wdGlvbnMyLnRocmVhZElkLFxuICAgICAgY29tbWVudElkOiBvcHRpb25zMi5jb21tZW50SWQsXG4gICAgICBib2R5OiBvcHRpb25zMi5ib2R5LFxuICAgICAgYXR0YWNobWVudElkczogb3B0aW9uczIuYXR0YWNobWVudElkc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRDb21tZW50KG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZWRpdENvbW1lbnQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgdGhyZWFkSWQ6IG9wdGlvbnMyLnRocmVhZElkLFxuICAgICAgY29tbWVudElkOiBvcHRpb25zMi5jb21tZW50SWQsXG4gICAgICBib2R5OiBvcHRpb25zMi5ib2R5LFxuICAgICAgYXR0YWNobWVudElkczogb3B0aW9uczIuYXR0YWNobWVudElkc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNvbW1lbnQoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZFxuICB9KSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZGVsZXRlQ29tbWVudCh7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBhZGRSZWFjdGlvbih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGVtb2ppXG4gIH0pIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5hZGRSZWFjdGlvbih7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlUmVhY3Rpb24oe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBlbW9qaVxuICB9KSB7XG4gICAgcmV0dXJuIGF3YWl0IGh0dHBDbGllbnQucmVtb3ZlUmVhY3Rpb24oe1xuICAgICAgcm9vbUlkLFxuICAgICAgdGhyZWFkSWQsXG4gICAgICBjb21tZW50SWQsXG4gICAgICBlbW9qaVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHByZXBhcmVBdHRhY2htZW50KGZpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsb2NhbEF0dGFjaG1lbnRcIixcbiAgICAgIHN0YXR1czogXCJpZGxlXCIsXG4gICAgICBpZDogY3JlYXRlQ29tbWVudEF0dGFjaG1lbnRJZCgpLFxuICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgbWltZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgIGZpbGVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZEF0dGFjaG1lbnQoYXR0YWNobWVudCwgb3B0aW9uczIgPSB7fSkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnVwbG9hZEF0dGFjaG1lbnQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgYXR0YWNobWVudCxcbiAgICAgIHNpZ25hbDogb3B0aW9uczIuc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QXR0YWNobWVudFVybChhdHRhY2htZW50SWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXRBdHRhY2htZW50VXJsKHsgcm9vbUlkLCBhdHRhY2htZW50SWQgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3Mob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXROb3RpZmljYXRpb25TZXR0aW5ncyh7XG4gICAgICByb29tSWQsXG4gICAgICBzaWduYWw6IG9wdGlvbnMyPy5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzKHsgcm9vbUlkLCBzZXR0aW5ncyB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICAgIGF3YWl0IGh0dHBDbGllbnQubWFya1Jvb21JbmJveE5vdGlmaWNhdGlvbkFzUmVhZCh7XG4gICAgICByb29tSWQsXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbklkXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc3luY1NvdXJjZUZvcllqcyA9IGNvbmZpZy5jcmVhdGVTeW5jU291cmNlKCk7XG4gIGZ1bmN0aW9uIHlqc1N0YXR1c0RpZENoYW5nZShzdGF0dXMpIHtcbiAgICByZXR1cm4gc3luY1NvdXJjZUZvcllqcy5zZXRTeW5jU3RhdHVzKFxuICAgICAgc3RhdHVzID09PSBcInN5bmNocm9uaXppbmdcIiA/IFwic3luY2hyb25pemluZ1wiIDogXCJzeW5jaHJvbml6ZWRcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICBba0ludGVybmFsXToge1xuICAgICAgICBnZXQgcHJlc2VuY2VCdWZmZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXM/LmRhdGEgPz8gbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgdW5kb1N0YWNrKCkge1xuICAgICAgICAgIHJldHVybiBkZWVwQ2xvbmUoY29udGV4dC51bmRvU3RhY2spO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0IG5vZGVDb3VudCgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5ub2Rlcy5zaXplO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0WWpzUHJvdmlkZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQueWpzUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFlqc1Byb3ZpZGVyKG5ld1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC55anNQcm92aWRlcj8ub2ZmKFwic3RhdHVzXCIsIHlqc1N0YXR1c0RpZENoYW5nZSk7XG4gICAgICAgICAgY29udGV4dC55anNQcm92aWRlciA9IG5ld1Byb3ZpZGVyO1xuICAgICAgICAgIG5ld1Byb3ZpZGVyPy5vbihcInN0YXR1c1wiLCB5anNTdGF0dXNEaWRDaGFuZ2UpO1xuICAgICAgICAgIGNvbnRleHQueWpzUHJvdmlkZXJEaWRDaGFuZ2Uubm90aWZ5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHlqc1Byb3ZpZGVyRGlkQ2hhbmdlOiBjb250ZXh0Lnlqc1Byb3ZpZGVyRGlkQ2hhbmdlLm9ic2VydmFibGUsXG4gICAgICAgIC8vIHNlbmQgbWV0YWRhdGEgd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIHJlcG9ydFRleHRFZGl0b3IsXG4gICAgICAgIC8vIGNyZWF0ZSBhIHRleHQgbWVudGlvbiB3aGVuIHVzaW5nIGEgdGV4dCBlZGl0b3JcbiAgICAgICAgY3JlYXRlVGV4dE1lbnRpb24sXG4gICAgICAgIC8vIGRlbGV0ZSBhIHRleHQgbWVudGlvbiB3aGVuIHVzaW5nIGEgdGV4dCBlZGl0b3JcbiAgICAgICAgZGVsZXRlVGV4dE1lbnRpb24sXG4gICAgICAgIC8vIGxpc3QgdmVyc2lvbnMgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIGxpc3RUZXh0VmVyc2lvbnMsXG4gICAgICAgIC8vIExpc3QgdmVyc2lvbnMgb2YgdGhlIGRvY3VtZW50IHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZVxuICAgICAgICBsaXN0VGV4dFZlcnNpb25zU2luY2UsXG4gICAgICAgIC8vIGdldCBhIHNwZWNpZmljIHZlcnNpb25cbiAgICAgICAgZ2V0VGV4dFZlcnNpb24sXG4gICAgICAgIC8vIGNyZWF0ZSBhIHZlcnNpb25cbiAgICAgICAgY3JlYXRlVGV4dFZlcnNpb24sXG4gICAgICAgIC8vIGV4ZWN1dGUgYSBjb250ZXh0dWFsIHByb21wdFxuICAgICAgICBleGVjdXRlQ29udGV4dHVhbFByb21wdCxcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgdGhlIExpdmVibG9ja3MgYnJvd3NlciBleHRlbnNpb25cbiAgICAgICAgZ2V0U2VsZl9mb3JEZXZUb29sczogKCkgPT4gc2VsZkFzVHJlZU5vZGUuZ2V0KCksXG4gICAgICAgIGdldE90aGVyc19mb3JEZXZUb29sczogKCkgPT4gb3RoZXJzX2ZvckRldlRvb2xzLmdldCgpLFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgc2ltdWxhdGU6IHtcbiAgICAgICAgICAvLyBUaGVzZSBleGlzdCBvbmx5IGZvciBvdXIgRTJFIHRlc3RpbmcgYXBwXG4gICAgICAgICAgZXhwbGljaXRDbG9zZTogKGV2ZW50KSA9PiBtYW5hZ2VkU29ja2V0Ll9wcml2YXRlU2VuZE1hY2hpbmVFdmVudCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pLFxuICAgICAgICAgIHJhd1NlbmQ6IChkYXRhKSA9PiBtYW5hZ2VkU29ja2V0LnNlbmQoZGF0YSlcbiAgICAgICAgfSxcbiAgICAgICAgYXR0YWNobWVudFVybHNTdG9yZTogaHR0cENsaWVudC5nZXRPckNyZWF0ZUF0dGFjaG1lbnRVcmxzU3RvcmUocm9vbUlkKVxuICAgICAgfSxcbiAgICAgIGlkOiBjb25maWcucm9vbUlkLFxuICAgICAgc3Vic2NyaWJlOiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKFxuICAgICAgICBjb25maWcucm9vbUlkLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIGNvbmZpZy5lcnJvckV2ZW50U291cmNlXG4gICAgICApLFxuICAgICAgY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5jb25uZWN0KCksXG4gICAgICByZWNvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCksXG4gICAgICBkaXNjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmRpc2Nvbm5lY3QoKSxcbiAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByb29tV2lsbERlc3Ryb3ksIC4uLmV2ZW50c0V4Y2VwdERlc3Ryb3kgfSA9IGV2ZW50SHViO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBPYmplY3QudmFsdWVzKGV2ZW50c0V4Y2VwdERlc3Ryb3kpKSB7XG4gICAgICAgICAgc291cmNlW1N5bWJvbC5kaXNwb3NlXSgpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50SHViLnJvb21XaWxsRGVzdHJveS5ub3RpZnkoKTtcbiAgICAgICAgY29udGV4dC55anNQcm92aWRlcj8ub2ZmKFwic3RhdHVzXCIsIHlqc1N0YXR1c0RpZENoYW5nZSk7XG4gICAgICAgIHN5bmNTb3VyY2VGb3JTdG9yYWdlLmRlc3Ryb3koKTtcbiAgICAgICAgc3luY1NvdXJjZUZvcllqcy5kZXN0cm95KCk7XG4gICAgICAgIHVuaW5zdGFsbEJnVGFiU3B5KCk7XG4gICAgICAgIG1hbmFnZWRTb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICByb29tV2lsbERlc3Ryb3lbU3ltYm9sLmRpc3Bvc2VdKCk7XG4gICAgICB9LFxuICAgICAgLy8gUHJlc2VuY2VcbiAgICAgIHVwZGF0ZVByZXNlbmNlLFxuICAgICAgdXBkYXRlWURvYyxcbiAgICAgIGJyb2FkY2FzdEV2ZW50LFxuICAgICAgLy8gU3RvcmFnZVxuICAgICAgYmF0Y2g6IGJhdGNoMixcbiAgICAgIGhpc3Rvcnk6IHtcbiAgICAgICAgdW5kbyxcbiAgICAgICAgcmVkbyxcbiAgICAgICAgY2FuVW5kbyxcbiAgICAgICAgY2FuUmVkbyxcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIHBhdXNlOiBwYXVzZUhpc3RvcnksXG4gICAgICAgIHJlc3VtZTogcmVzdW1lSGlzdG9yeVxuICAgICAgfSxcbiAgICAgIGZldGNoWURvYyxcbiAgICAgIGdldFN0b3JhZ2UsXG4gICAgICBnZXRTdG9yYWdlU25hcHNob3QsXG4gICAgICBnZXRTdG9yYWdlU3RhdHVzLFxuICAgICAgaXNQcmVzZW5jZVJlYWR5LFxuICAgICAgaXNTdG9yYWdlUmVhZHksXG4gICAgICB3YWl0VW50aWxQcmVzZW5jZVJlYWR5OiBtZW1vaXplT25TdWNjZXNzKHdhaXRVbnRpbFByZXNlbmNlUmVhZHkpLFxuICAgICAgd2FpdFVudGlsU3RvcmFnZVJlYWR5OiBtZW1vaXplT25TdWNjZXNzKHdhaXRVbnRpbFN0b3JhZ2VSZWFkeSksXG4gICAgICBldmVudHMsXG4gICAgICAvLyBDb3JlXG4gICAgICBnZXRTdGF0dXM6ICgpID0+IG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCksXG4gICAgICBnZXRTZWxmOiAoKSA9PiBzZWxmLmdldCgpLFxuICAgICAgLy8gUHJlc2VuY2VcbiAgICAgIGdldFByZXNlbmNlOiAoKSA9PiBjb250ZXh0Lm15UHJlc2VuY2UuZ2V0KCksXG4gICAgICBnZXRPdGhlcnM6ICgpID0+IGNvbnRleHQub3RoZXJzLmdldCgpLFxuICAgICAgLy8gQ29tbWVudHNcbiAgICAgIGdldFRocmVhZHMsXG4gICAgICBnZXRUaHJlYWRzU2luY2UsXG4gICAgICBnZXRUaHJlYWQsXG4gICAgICBjcmVhdGVUaHJlYWQsXG4gICAgICBkZWxldGVUaHJlYWQsXG4gICAgICBlZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgICBtYXJrVGhyZWFkQXNSZXNvbHZlZCxcbiAgICAgIG1hcmtUaHJlYWRBc1VucmVzb2x2ZWQsXG4gICAgICBjcmVhdGVDb21tZW50LFxuICAgICAgZWRpdENvbW1lbnQsXG4gICAgICBkZWxldGVDb21tZW50LFxuICAgICAgYWRkUmVhY3Rpb24sXG4gICAgICByZW1vdmVSZWFjdGlvbixcbiAgICAgIHByZXBhcmVBdHRhY2htZW50LFxuICAgICAgdXBsb2FkQXR0YWNobWVudCxcbiAgICAgIGdldEF0dGFjaG1lbnRVcmwsXG4gICAgICAvLyBOb3RpZmljYXRpb25zXG4gICAgICBnZXROb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkXG4gICAgfSxcbiAgICAvLyBFeHBsaWN0bHkgbWFrZSB0aGUgaW50ZXJuYWwgZmllbGQgbm9uLWVudW1lcmFibGUsIHRvIGF2b2lkIGFnZ3Jlc3NpdmVcbiAgICAvLyBmcmVlemluZyB3aGVuIHVzZWQgd2l0aCBJbW1lclxuICAgIGtJbnRlcm5hbCxcbiAgICB7IGVudW1lcmFibGU6IGZhbHNlIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIG1ha2VDbGFzc2ljU3Vic2NyaWJlRm4ocm9vbUlkLCBldmVudHMsIGVycm9yRXZlbnRzKSB7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgY29uc3QgcmVsYXRlZFVwZGF0ZXMgPSB1cGRhdGVzLmZpbHRlcihcbiAgICAgICAgKHVwZGF0ZSkgPT4gaXNTYW1lTm9kZU9yQ2hpbGRPZih1cGRhdGUubm9kZSwgbm9kZSlcbiAgICAgICk7XG4gICAgICBpZiAocmVsYXRlZFVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjYWxsYmFjayhyZWxhdGVkVXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICAgIGlmICh1cGRhdGUubm9kZS5faWQgPT09IG5vZGUuX2lkKSB7XG4gICAgICAgICAgY2FsbGJhY2sodXBkYXRlLm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZpcnN0LCBzZWNvbmQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIGlzUm9vbUV2ZW50TmFtZShmaXJzdCkpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBjYWxsYmFjayBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm15LXByZXNlbmNlXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5teVByZXNlbmNlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJvdGhlcnNcIjoge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvdGhlcnMsIC4uLmludGVybmFsRXZlbnQgfSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNiKG90aGVycywgaW50ZXJuYWxFdmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICByZXR1cm4gZXJyb3JFdmVudHMuc3Vic2NyaWJlKChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInN0YXR1c1wiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuc3RhdHVzLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJsb3N0LWNvbm5lY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmxvc3RDb25uZWN0aW9uLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImhpc3RvcnlcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmhpc3Rvcnkuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcInN0b3JhZ2Utc3RhdHVzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlU3RhdHVzLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImNvbW1lbnRzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5jb21tZW50cy5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKFxuICAgICAgICAgICAgZmlyc3QsXG4gICAgICAgICAgICBgXCIke1N0cmluZyhmaXJzdCl9XCIgaXMgbm90IGEgdmFsaWQgZXZlbnQgbmFtZWBcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Vjb25kID09PSB2b2lkIDAgfHwgdHlwZW9mIGZpcnN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2FsbGJhY2sgPSBmaXJzdDtcbiAgICAgICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKHN0b3JhZ2VDYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc3BlY2lmeSBhIGxpc3RlbmVyIGNhbGxiYWNrXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNMaXZlTm9kZShmaXJzdCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBmaXJzdDtcbiAgICAgIGlmIChvcHRpb25zPy5pc0RlZXApIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5KG5vZGUsIHN0b3JhZ2VDYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlQ2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVTaGFsbG93bHkobm9kZSwgbm9kZUNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCR7U3RyaW5nKGZpcnN0KX0gaXMgbm90IGEgdmFsdWUgdGhhdCBjYW4gYmUgc3Vic2NyaWJlZCB0by5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3Vic2NyaWJlO1xufVxuZnVuY3Rpb24gaXNSb29tRXZlbnROYW1lKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gXCJteS1wcmVzZW5jZVwiIHx8IHZhbHVlID09PSBcIm90aGVyc1wiIHx8IHZhbHVlID09PSBcImV2ZW50XCIgfHwgdmFsdWUgPT09IFwiZXJyb3JcIiB8fCB2YWx1ZSA9PT0gXCJoaXN0b3J5XCIgfHwgdmFsdWUgPT09IFwic3RhdHVzXCIgfHwgdmFsdWUgPT09IFwic3RvcmFnZS1zdGF0dXNcIiB8fCB2YWx1ZSA9PT0gXCJsb3N0LWNvbm5lY3Rpb25cIiB8fCB2YWx1ZSA9PT0gXCJjb25uZWN0aW9uXCIgfHwgdmFsdWUgPT09IFwiY29tbWVudHNcIjtcbn1cbmZ1bmN0aW9uIG1ha2VBdXRoRGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYXV0aE1hbmFnZXIpIHtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICByZXR1cm4gYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwicm9vbTpyZWFkXCIsIHJvb21JZCB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VDcmVhdGVTb2NrZXREZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBiYXNlVXJsLCBXZWJTb2NrZXRQb2x5ZmlsbCkge1xuICByZXR1cm4gKGF1dGhWYWx1ZSkgPT4ge1xuICAgIGNvbnN0IHdzID0gV2ViU29ja2V0UG9seWZpbGwgPz8gKHR5cGVvZiBXZWJTb2NrZXQgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiBXZWJTb2NrZXQpO1xuICAgIGlmICh3cyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICBcIlRvIHVzZSBMaXZlYmxvY2tzIGNsaWVudCBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQsIHlvdSBuZWVkIHRvIHByb3ZpZGUgYSBXZWJTb2NrZXQgcG9seWZpbGwuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHVybDIgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgIHVybDIucHJvdG9jb2wgPSB1cmwyLnByb3RvY29sID09PSBcImh0dHA6XCIgPyBcIndzXCIgOiBcIndzc1wiO1xuICAgIHVybDIucGF0aG5hbWUgPSBcIi92N1wiO1xuICAgIHVybDIuc2VhcmNoUGFyYW1zLnNldChcInJvb21JZFwiLCByb29tSWQpO1xuICAgIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJzZWNyZXRcIikge1xuICAgICAgdXJsMi5zZWFyY2hQYXJhbXMuc2V0KFwidG9rXCIsIGF1dGhWYWx1ZS50b2tlbi5yYXcpO1xuICAgIH0gZWxzZSBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICAgIHVybDIuc2VhcmNoUGFyYW1zLnNldChcInB1YmtleVwiLCBhdXRoVmFsdWUucHVibGljQXBpS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKGF1dGhWYWx1ZSwgXCJVbmhhbmRsZWQgY2FzZVwiKTtcbiAgICB9XG4gICAgdXJsMi5zZWFyY2hQYXJhbXMuc2V0KFwidmVyc2lvblwiLCBQS0dfVkVSU0lPTiB8fCBcImRldlwiKTtcbiAgICByZXR1cm4gbmV3IHdzKHVybDIudG9TdHJpbmcoKSk7XG4gIH07XG59XG5cbi8vIHNyYy9jbGllbnQudHNcbnZhciBNSU5fVEhST1RUTEUgPSAxNjtcbnZhciBNQVhfVEhST1RUTEUgPSAxZTM7XG52YXIgREVGQVVMVF9USFJPVFRMRSA9IDEwMDtcbnZhciBNSU5fQkFDS0dST1VORF9LRUVQX0FMSVZFX1RJTUVPVVQgPSAxNWUzO1xudmFyIE1JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDIwMDtcbnZhciBSRUNPTU1FTkRFRF9NSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAxZTM7XG52YXIgTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gM2U0O1xudmFyIERFRkFVTFRfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSA1ZTM7XG52YXIgUkVTT0xWRV9VU0VSU19CQVRDSF9ERUxBWSA9IDUwO1xudmFyIFJFU09MVkVfUk9PTVNfSU5GT19CQVRDSF9ERUxBWSA9IDUwO1xuZnVuY3Rpb24gZ2V0QmFzZVVybChiYXNlVXJsKSB7XG4gIGlmICh0eXBlb2YgYmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiBiYXNlVXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgcmV0dXJuIGJhc2VVcmw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQkFTRV9VUkw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChvcHRpb25zKSB7XG4gIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBvcHRpb25zO1xuICBjb25zdCB0aHJvdHRsZURlbGF5ID0gZ2V0VGhyb3R0bGUoY2xpZW50T3B0aW9ucy50aHJvdHRsZSA/PyBERUZBVUxUX1RIUk9UVExFKTtcbiAgY29uc3QgbG9zdENvbm5lY3Rpb25UaW1lb3V0ID0gZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0KFxuICAgIGNsaWVudE9wdGlvbnMubG9zdENvbm5lY3Rpb25UaW1lb3V0ID8/IERFRkFVTFRfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVRcbiAgKTtcbiAgY29uc3QgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgPSBnZXRCYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dChcbiAgICBjbGllbnRPcHRpb25zLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XG4gICk7XG4gIGNvbnN0IGJhc2VVcmwgPSBnZXRCYXNlVXJsKGNsaWVudE9wdGlvbnMuYmFzZVVybCk7XG4gIGNvbnN0IGN1cnJlbnRVc2VySWQgPSBuZXcgU2lnbmFsKHZvaWQgMCk7XG4gIGNvbnN0IGF1dGhNYW5hZ2VyID0gY3JlYXRlQXV0aE1hbmFnZXIob3B0aW9ucywgKHRva2VuKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmlkIDogdG9rZW4udWlkO1xuICAgIGN1cnJlbnRVc2VySWQuc2V0KCgpID0+IHVzZXJJZCk7XG4gIH0pO1xuICBjb25zdCBmZXRjaFBvbHlmaWxsID0gY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmZldGNoIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdsb2JhbFRoaXMuZmV0Y2g/LmJpbmQoZ2xvYmFsVGhpcyk7XG4gIGNvbnN0IGh0dHBDbGllbnQgPSBjcmVhdGVBcGlDbGllbnQoe1xuICAgIGJhc2VVcmwsXG4gICAgZmV0Y2hQb2x5ZmlsbCxcbiAgICBhdXRoTWFuYWdlclxuICB9KTtcbiAgY29uc3Qgcm9vbXNCeUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gdGVhcmRvd25Sb29tKHJvb20pIHtcbiAgICB1bmxpbmtEZXZUb29scyhyb29tLmlkKTtcbiAgICByb29tc0J5SWQuZGVsZXRlKHJvb20uaWQpO1xuICAgIHJvb20uZGVzdHJveSgpO1xuICB9XG4gIGZ1bmN0aW9uIGxlYXNlUm9vbShkZXRhaWxzKSB7XG4gICAgY29uc3QgbGVhdmUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzZWxmID0gbGVhdmU7XG4gICAgICBpZiAoIWRldGFpbHMudW5zdWJzLmRlbGV0ZShzZWxmKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiVGhpcyBsZWF2ZSBmdW5jdGlvbiB3YXMgYWxyZWFkeSBjYWxsZWQuIENhbGxpbmcgaXQgbW9yZSB0aGFuIG9uY2UgaGFzIG5vIGVmZmVjdC5cIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRldGFpbHMudW5zdWJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0ZWFyZG93blJvb20oZGV0YWlscy5yb29tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZGV0YWlscy51bnN1YnMuYWRkKGxlYXZlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vbTogZGV0YWlscy5yb29tLFxuICAgICAgbGVhdmVcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGVudGVyUm9vbShyb29tSWQsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHJvb21zQnlJZC5nZXQocm9vbUlkKTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxlYXNlUm9vbShleGlzdGluZyk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMyID0gYXJnc1swXSA/PyB7fTtcbiAgICBjb25zdCBpbml0aWFsUHJlc2VuY2UgPSAodHlwZW9mIG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlKHJvb21JZCkgOiBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2UpID8/IHt9O1xuICAgIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gKHR5cGVvZiBvcHRpb25zMi5pbml0aWFsU3RvcmFnZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2Uocm9vbUlkKSA6IG9wdGlvbnMyLmluaXRpYWxTdG9yYWdlKSA/PyB7fTtcbiAgICBjb25zdCBuZXdSb29tID0gY3JlYXRlUm9vbShcbiAgICAgIHsgaW5pdGlhbFByZXNlbmNlLCBpbml0aWFsU3RvcmFnZSB9LFxuICAgICAge1xuICAgICAgICByb29tSWQsXG4gICAgICAgIHRocm90dGxlRGVsYXksXG4gICAgICAgIGxvc3RDb25uZWN0aW9uVGltZW91dCxcbiAgICAgICAgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQsXG4gICAgICAgIHBvbHlmaWxsczogY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHMsXG4gICAgICAgIGRlbGVnYXRlczogY2xpZW50T3B0aW9ucy5tb2NrZWREZWxlZ2F0ZXMgPz8ge1xuICAgICAgICAgIGNyZWF0ZVNvY2tldDogbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIGJhc2VVcmwsXG4gICAgICAgICAgICBjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uV2ViU29ja2V0XG4gICAgICAgICAgKSxcbiAgICAgICAgICBhdXRoZW50aWNhdGU6IG1ha2VBdXRoRGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYXV0aE1hbmFnZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGVuYWJsZURlYnVnTG9nZ2luZzogY2xpZW50T3B0aW9ucy5lbmFibGVEZWJ1Z0xvZ2dpbmcsXG4gICAgICAgIGJhc2VVcmwsXG4gICAgICAgIGVycm9yRXZlbnRTb3VyY2U6IGxpdmVibG9ja3NFcnJvclNvdXJjZSxcbiAgICAgICAgbGFyZ2VNZXNzYWdlU3RyYXRlZ3k6IGNsaWVudE9wdGlvbnMubGFyZ2VNZXNzYWdlU3RyYXRlZ3kgPz8gKGNsaWVudE9wdGlvbnMudW5zdGFibGVfZmFsbGJhY2tUb0hUVFAgPyBcImV4cGVyaW1lbnRhbC1mYWxsYmFjay10by1odHRwXCIgOiB2b2lkIDApLFxuICAgICAgICB1bnN0YWJsZV9zdHJlYW1EYXRhOiAhIWNsaWVudE9wdGlvbnMudW5zdGFibGVfc3RyZWFtRGF0YSxcbiAgICAgICAgcm9vbUh0dHBDbGllbnQ6IGh0dHBDbGllbnQsXG4gICAgICAgIGNyZWF0ZVN5bmNTb3VyY2VcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IG5ld1Jvb21EZXRhaWxzID0ge1xuICAgICAgcm9vbTogbmV3Um9vbSxcbiAgICAgIHVuc3ViczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgcm9vbXNCeUlkLnNldChyb29tSWQsIG5ld1Jvb21EZXRhaWxzKTtcbiAgICBzZXR1cERldlRvb2xzKCgpID0+IEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSkpO1xuICAgIGxpbmtEZXZUb29scyhyb29tSWQsIG5ld1Jvb20pO1xuICAgIGNvbnN0IHNob3VsZENvbm5lY3QgPSBvcHRpb25zMi5hdXRvQ29ubmVjdCA/PyB0cnVlO1xuICAgIGlmIChzaG91bGRDb25uZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIGF0b2IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5hdG9iID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIllvdSBuZWVkIHRvIHBvbHlmaWxsIGF0b2IgdG8gdXNlIHRoZSBjbGllbnQgaW4geW91ciBlbnZpcm9ubWVudC4gUGxlYXNlIGZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGF0IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9saXZlYmxvY2tzLWNsaWVudC9hdG9iLXBvbHlmaWxsXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbC5hdG9iID0gY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHMuYXRvYjtcbiAgICAgIH1cbiAgICAgIG5ld1Jvb20uY29ubmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gbGVhc2VSb29tKG5ld1Jvb21EZXRhaWxzKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSb29tKHJvb21JZCkge1xuICAgIGNvbnN0IHJvb20gPSByb29tc0J5SWQuZ2V0KHJvb21JZCk/LnJvb207XG4gICAgcmV0dXJuIHJvb20gPyByb29tIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgYXV0aE1hbmFnZXIucmVzZXQoKTtcbiAgICBjdXJyZW50VXNlcklkLnNldCgoKSA9PiB2b2lkIDApO1xuICAgIGZvciAoY29uc3QgeyByb29tIH0gb2Ygcm9vbXNCeUlkLnZhbHVlcygpKSB7XG4gICAgICBpZiAoIWlzSWRsZShyb29tLmdldFN0YXR1cygpKSkge1xuICAgICAgICByb29tLnJlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCByZXNvbHZlVXNlcnMgPSBjbGllbnRPcHRpb25zLnJlc29sdmVVc2VycztcbiAgY29uc3Qgd2FybklmTm9SZXNvbHZlVXNlcnMgPSBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoXG4gICAgKCkgPT4gIXJlc29sdmVVc2VycyxcbiAgICBcIlNldCB0aGUgcmVzb2x2ZVVzZXJzIG9wdGlvbiBpbiBjcmVhdGVDbGllbnQgdG8gc3BlY2lmeSB1c2VyIGluZm8uXCJcbiAgKTtcbiAgY29uc3QgYmF0Y2hlZFJlc29sdmVVc2VycyA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZFVzZXJJZHMpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZHMgPSBiYXRjaGVkVXNlcklkcy5mbGF0KCk7XG4gICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc29sdmVVc2Vycz8uKHsgdXNlcklkcyB9KTtcbiAgICAgIHdhcm5JZk5vUmVzb2x2ZVVzZXJzKCk7XG4gICAgICByZXR1cm4gdXNlcnMgPz8gdXNlcklkcy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICB9LFxuICAgIHsgZGVsYXk6IFJFU09MVkVfVVNFUlNfQkFUQ0hfREVMQVkgfVxuICApO1xuICBjb25zdCB1c2Vyc1N0b3JlID0gY3JlYXRlQmF0Y2hTdG9yZShiYXRjaGVkUmVzb2x2ZVVzZXJzKTtcbiAgZnVuY3Rpb24gaW52YWxpZGF0ZVJlc29sdmVkVXNlcnModXNlcklkcykge1xuICAgIHVzZXJzU3RvcmUuaW52YWxpZGF0ZSh1c2VySWRzKTtcbiAgfVxuICBjb25zdCByZXNvbHZlUm9vbXNJbmZvID0gY2xpZW50T3B0aW9ucy5yZXNvbHZlUm9vbXNJbmZvO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVSb29tc0luZm8gPSBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoXG4gICAgKCkgPT4gIXJlc29sdmVSb29tc0luZm8sXG4gICAgXCJTZXQgdGhlIHJlc29sdmVSb29tc0luZm8gb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHJvb20gaW5mby5cIlxuICApO1xuICBjb25zdCBiYXRjaGVkUmVzb2x2ZVJvb21zSW5mbyA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZFJvb21JZHMpID0+IHtcbiAgICAgIGNvbnN0IHJvb21JZHMgPSBiYXRjaGVkUm9vbUlkcy5mbGF0KCk7XG4gICAgICBjb25zdCByb29tc0luZm8gPSBhd2FpdCByZXNvbHZlUm9vbXNJbmZvPy4oeyByb29tSWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlUm9vbXNJbmZvKCk7XG4gICAgICByZXR1cm4gcm9vbXNJbmZvID8/IHJvb21JZHMubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgfVxuICApO1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2hlZFJlc29sdmVSb29tc0luZm8pO1xuICBmdW5jdGlvbiBpbnZhbGlkYXRlUmVzb2x2ZWRSb29tc0luZm8ocm9vbUlkcykge1xuICAgIHJvb21zSW5mb1N0b3JlLmludmFsaWRhdGUocm9vbUlkcyk7XG4gIH1cbiAgY29uc3QgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBpbnZhbGlkYXRlUmVzb2x2ZWRNZW50aW9uU3VnZ2VzdGlvbnMoKSB7XG4gICAgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUuY2xlYXIoKTtcbiAgfVxuICBjb25zdCBzeW5jU3RhdHVzU291cmNlcyA9IFtdO1xuICBjb25zdCBzeW5jU3RhdHVzU2lnbmFsID0gbmV3IFNpZ25hbChcInN5bmNocm9uaXplZFwiKTtcbiAgY29uc3QgbGl2ZWJsb2Nrc0Vycm9yU291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGZ1bmN0aW9uIGdldFN5bmNTdGF0dXMoKSB7XG4gICAgY29uc3Qgc3RhdHVzID0gc3luY1N0YXR1c1NpZ25hbC5nZXQoKTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBcInN5bmNocm9uaXppbmdcIiA/IHN0YXR1cyA6IFwic3luY2hyb25pemVkXCI7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb21wdXRlKCkge1xuICAgIHN5bmNTdGF0dXNTaWduYWwuc2V0KFxuICAgICAgc3luY1N0YXR1c1NvdXJjZXMuc29tZSgoc3JjKSA9PiBzcmMuZ2V0KCkgPT09IFwic3luY2hyb25pemluZ1wiKSA/IFwic3luY2hyb25pemluZ1wiIDogc3luY1N0YXR1c1NvdXJjZXMuc29tZSgoc3JjKSA9PiBzcmMuZ2V0KCkgPT09IFwiaGFzLWxvY2FsLWNoYW5nZXNcIikgPyBcImhhcy1sb2NhbC1jaGFuZ2VzXCIgOiBcInN5bmNocm9uaXplZFwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVTeW5jU291cmNlKCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBTaWduYWwoXCJzeW5jaHJvbml6ZWRcIik7XG4gICAgc3luY1N0YXR1c1NvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIGNvbnN0IHVuc3ViID0gc291cmNlLnN1YnNjcmliZSgoKSA9PiByZWNvbXB1dGUoKSk7XG4gICAgZnVuY3Rpb24gc2V0U3luY1N0YXR1cyhzdGF0dXMpIHtcbiAgICAgIHNvdXJjZS5zZXQoc3RhdHVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHVuc3ViKCk7XG4gICAgICBjb25zdCBpbmRleCA9IHN5bmNTdGF0dXNTb3VyY2VzLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbSA9PT0gc291cmNlKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGNvbnN0IFtyZWZdID0gc3luY1N0YXR1c1NvdXJjZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgY29uc3Qgd2FzU3RpbGxQZW5kaW5nID0gcmVmLmdldCgpICE9PSBcInN5bmNocm9uaXplZFwiO1xuICAgICAgICBpZiAod2FzU3RpbGxQZW5kaW5nKSB7XG4gICAgICAgICAgcmVjb21wdXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc2V0U3luY1N0YXR1cywgZGVzdHJveSB9O1xuICB9XG4gIHtcbiAgICBjb25zdCBtYXliZVByZXZlbnRDbG9zZSA9IChlKSA9PiB7XG4gICAgICBpZiAoY2xpZW50T3B0aW9ucy5wcmV2ZW50VW5zYXZlZENoYW5nZXMgJiYgc3luY1N0YXR1c1NpZ25hbC5nZXQoKSAhPT0gXCJzeW5jaHJvbml6ZWRcIikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdm9pZCAwO1xuICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBtYXliZVByZXZlbnRDbG9zZSk7XG4gIH1cbiAgY29uc3QgY2xpZW50ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIGVudGVyUm9vbSxcbiAgICAgIGdldFJvb20sXG4gICAgICBsb2dvdXQsXG4gICAgICAvLyBQdWJsaWMgaW5ib3ggbm90aWZpY2F0aW9ucyBBUElcbiAgICAgIGdldEluYm94Tm90aWZpY2F0aW9uczogaHR0cENsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZTogaHR0cENsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZSxcbiAgICAgIGdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiBodHRwQ2xpZW50LmdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICAgICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDogaHR0cENsaWVudC5tYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkOiBodHRwQ2xpZW50Lm1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICAgIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczogaHR0cENsaWVudC5kZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICBkZWxldGVJbmJveE5vdGlmaWNhdGlvbjogaHR0cENsaWVudC5kZWxldGVJbmJveE5vdGlmaWNhdGlvbixcbiAgICAgIC8vIFB1YmxpYyBjaGFubmVsIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBBUElcbiAgICAgIGdldE5vdGlmaWNhdGlvblNldHRpbmdzOiBodHRwQ2xpZW50LmdldFVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzOiBodHRwQ2xpZW50LnVwZGF0ZVVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIC8vIEFkdmFuY2VkIHJlc29sdmVycyBBUElzXG4gICAgICByZXNvbHZlcnM6IHtcbiAgICAgICAgaW52YWxpZGF0ZVVzZXJzOiBpbnZhbGlkYXRlUmVzb2x2ZWRVc2VycyxcbiAgICAgICAgaW52YWxpZGF0ZVJvb21zSW5mbzogaW52YWxpZGF0ZVJlc29sdmVkUm9vbXNJbmZvLFxuICAgICAgICBpbnZhbGlkYXRlTWVudGlvblN1Z2dlc3Rpb25zOiBpbnZhbGlkYXRlUmVzb2x2ZWRNZW50aW9uU3VnZ2VzdGlvbnNcbiAgICAgIH0sXG4gICAgICBnZXRTeW5jU3RhdHVzLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGVycm9yOiBsaXZlYmxvY2tzRXJyb3JTb3VyY2UsXG4gICAgICAgIHN5bmNTdGF0dXM6IHN5bmNTdGF0dXNTaWduYWxcbiAgICAgIH0sXG4gICAgICAvLyBJbnRlcm5hbFxuICAgICAgW2tJbnRlcm5hbF06IHtcbiAgICAgICAgY3VycmVudFVzZXJJZCxcbiAgICAgICAgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUsXG4gICAgICAgIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnM6IGNsaWVudE9wdGlvbnMucmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyxcbiAgICAgICAgdXNlcnNTdG9yZSxcbiAgICAgICAgcm9vbXNJbmZvU3RvcmUsXG4gICAgICAgIGdldFJvb21JZHMoKSB7XG4gICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGh0dHBDbGllbnQsXG4gICAgICAgIC8vIFR5cGUtbGV2ZWwgaGVscGVyIG9ubHksIGl0J3MgZWZmZWN0aXZlbHkgb25seSBhbiBpZGVudGl0eS1mdW5jdGlvbiBhdCBydW50aW1lXG4gICAgICAgIGFzOiAoKSA9PiBjbGllbnQsXG4gICAgICAgIGNyZWF0ZVN5bmNTb3VyY2UsXG4gICAgICAgIGVtaXRFcnJvcjogKGNvbnRleHQsIGNhdXNlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXJyb3IzID0gTGl2ZWJsb2Nrc0Vycm9yLmZyb20oY29udGV4dCwgY2F1c2UpO1xuICAgICAgICAgIGNvbnN0IGRpZE5vdGlmeSA9IGxpdmVibG9ja3NFcnJvclNvdXJjZS5ub3RpZnkoZXJyb3IzKTtcbiAgICAgICAgICBpZiAoIWRpZE5vdGlmeSkge1xuICAgICAgICAgICAgZXJyb3IyKGVycm9yMy5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGtJbnRlcm5hbCxcbiAgICB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIGNsaWVudDtcbn1cbmZ1bmN0aW9uIGNoZWNrQm91bmRzKG9wdGlvbiwgdmFsdWUsIG1pbiwgbWF4LCByZWNvbW1lbmRlZE1pbikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDwgbWluIHx8IG1heCAhPT0gdm9pZCAwICYmIHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbWF4ICE9PSB2b2lkIDAgPyBgJHtvcHRpb259IHNob3VsZCBiZSBiZXR3ZWVuICR7cmVjb21tZW5kZWRNaW4gPz8gbWlufSBhbmQgJHttYXh9LmAgOiBgJHtvcHRpb259IHNob3VsZCBiZSBhdCBsZWFzdCAke3JlY29tbWVuZGVkTWluID8/IG1pbn0uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcbiAgICBcImJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XCIsXG4gICAgdmFsdWUsXG4gICAgTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUXG4gICk7XG59XG5mdW5jdGlvbiBnZXRUaHJvdHRsZSh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXCJ0aHJvdHRsZVwiLCB2YWx1ZSwgTUlOX1RIUk9UVExFLCBNQVhfVEhST1RUTEUpO1xufVxuZnVuY3Rpb24gZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcbiAgICBcImxvc3RDb25uZWN0aW9uVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCxcbiAgICBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoY29uZGl0aW9uLCAuLi5hcmdzKSB7XG4gIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIWhhc1dhcm5lZCAmJiAodHlwZW9mIGNvbmRpdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gY29uZGl0aW9uKCkgOiBjb25kaXRpb24pKSB7XG4gICAgICAgIHdhcm4oLi4uYXJncyk7XG4gICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2NvbW1lbnRzL2NvbW1lbnQtYm9keS50c1xuZnVuY3Rpb24gaXNDb21tZW50Qm9keVBhcmFncmFwaChlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJwYXJhZ3JhcGhcIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlUZXh0KGVsZW1lbnQpIHtcbiAgcmV0dXJuICEoXCJ0eXBlXCIgaW4gZWxlbWVudCkgJiYgXCJ0ZXh0XCIgaW4gZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC50ZXh0ID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keU1lbnRpb24oZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibWVudGlvblwiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keUxpbmsoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibGlua1wiO1xufVxudmFyIGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHMgPSB7XG4gIHBhcmFncmFwaDogaXNDb21tZW50Qm9keVBhcmFncmFwaCxcbiAgdGV4dDogaXNDb21tZW50Qm9keVRleHQsXG4gIGxpbms6IGlzQ29tbWVudEJvZHlMaW5rLFxuICBtZW50aW9uOiBpc0NvbW1lbnRCb2R5TWVudGlvblxufTtcbnZhciBjb21tZW50Qm9keUVsZW1lbnRzVHlwZXMgPSB7XG4gIHBhcmFncmFwaDogXCJibG9ja1wiLFxuICB0ZXh0OiBcImlubGluZVwiLFxuICBsaW5rOiBcImlubGluZVwiLFxuICBtZW50aW9uOiBcImlubGluZVwiXG59O1xuZnVuY3Rpb24gdHJhdmVyc2VDb21tZW50Qm9keShib2R5LCBlbGVtZW50T3JWaXNpdG9yLCBwb3NzaWJseVZpc2l0b3IpIHtcbiAgaWYgKCFib2R5IHx8ICFib2R5Py5jb250ZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSB0eXBlb2YgZWxlbWVudE9yVmlzaXRvciA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnRPclZpc2l0b3IgOiB2b2lkIDA7XG4gIGNvbnN0IHR5cGUgPSBlbGVtZW50ID8gY29tbWVudEJvZHlFbGVtZW50c1R5cGVzW2VsZW1lbnRdIDogXCJhbGxcIjtcbiAgY29uc3QgZ3VhcmQgPSBlbGVtZW50ID8gY29tbWVudEJvZHlFbGVtZW50c0d1YXJkc1tlbGVtZW50XSA6ICgpID0+IHRydWU7XG4gIGNvbnN0IHZpc2l0b3IgPSB0eXBlb2YgZWxlbWVudE9yVmlzaXRvciA9PT0gXCJmdW5jdGlvblwiID8gZWxlbWVudE9yVmlzaXRvciA6IHBvc3NpYmx5VmlzaXRvcjtcbiAgZm9yIChjb25zdCBibG9jayBvZiBib2R5LmNvbnRlbnQpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJhbGxcIiB8fCB0eXBlID09PSBcImJsb2NrXCIpIHtcbiAgICAgIGlmIChndWFyZChibG9jaykpIHtcbiAgICAgICAgdmlzaXRvcj8uKGJsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJpbmxpbmVcIikge1xuICAgICAgZm9yIChjb25zdCBpbmxpbmUgb2YgYmxvY2suY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGd1YXJkKGlubGluZSkpIHtcbiAgICAgICAgICB2aXNpdG9yPy4oaW5saW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5KGJvZHkpIHtcbiAgY29uc3QgbWVudGlvbmVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgdHJhdmVyc2VDb21tZW50Qm9keShcbiAgICBib2R5LFxuICAgIFwibWVudGlvblwiLFxuICAgIChtZW50aW9uKSA9PiBtZW50aW9uZWRJZHMuYWRkKG1lbnRpb24uaWQpXG4gICk7XG4gIHJldHVybiBBcnJheS5mcm9tKG1lbnRpb25lZElkcyk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KGJvZHksIHJlc29sdmVVc2Vycykge1xuICBjb25zdCByZXNvbHZlZFVzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgaWYgKCFyZXNvbHZlVXNlcnMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRVc2VycztcbiAgfVxuICBjb25zdCB1c2VySWRzID0gZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5KGJvZHkpO1xuICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc29sdmVVc2Vycyh7XG4gICAgdXNlcklkc1xuICB9KTtcbiAgZm9yIChjb25zdCBbaW5kZXgsIHVzZXJJZF0gb2YgdXNlcklkcy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCB1c2VyID0gdXNlcnM/LltpbmRleF07XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHJlc29sdmVkVXNlcnMuc2V0KHVzZXJJZCwgdXNlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNvbHZlZFVzZXJzO1xufVxudmFyIGh0bWxFc2NhcGFibGVzID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiMzOTtcIlxufTtcbnZhciBodG1sRXNjYXBhYmxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgT2JqZWN0LmtleXMoaHRtbEVzY2FwYWJsZXMpLm1hcCgoZW50aXR5KSA9PiBgXFxcXCR7ZW50aXR5fWApLmpvaW4oXCJ8XCIpLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIGh0bWxTYWZlKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1N0cmluZyh2YWx1ZSldLCBbXSk7XG59XG5mdW5jdGlvbiBqb2luSHRtbChzdHJpbmdzKSB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhbXCJcIl0sIFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFxuICAgIFtcIlwiLCAuLi5BcnJheShzdHJpbmdzLmxlbmd0aCAtIDEpLmZpbGwoXCJcIiksIFwiXCJdLFxuICAgIHN0cmluZ3NcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZUh0bWwodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSHRtbFNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gam9pbkh0bWwodmFsdWUpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkucmVwbGFjZShcbiAgICBodG1sRXNjYXBhYmxlc1JlZ2V4LFxuICAgIChjaGFyYWN0ZXIpID0+IGh0bWxFc2NhcGFibGVzW2NoYXJhY3Rlcl1cbiAgKTtcbn1cbnZhciBIdG1sU2FmZVN0cmluZyA9IGNsYXNzIHtcbiAgI3N0cmluZ3M7XG4gICN2YWx1ZXM7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlczIpIHtcbiAgICB0aGlzLiNzdHJpbmdzID0gc3RyaW5ncztcbiAgICB0aGlzLiN2YWx1ZXMgPSB2YWx1ZXMyO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNzdHJpbmdzLnJlZHVjZSgocmVzdWx0LCBzdHIsIGkpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVIdG1sKG5uKHRoaXMuI3ZhbHVlc1tpIC0gMV0pKSArIHN0cjtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGh0bWwoc3RyaW5ncywgLi4udmFsdWVzMikge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlczIpO1xufVxudmFyIG1hcmtkb3duRXNjYXBhYmxlcyA9IHtcbiAgXzogXCJcXFxcX1wiLFxuICBcIipcIjogXCJcXFxcKlwiLFxuICBcIiNcIjogXCJcXFxcI1wiLFxuICBcImBcIjogXCJcXFxcYFwiLFxuICBcIn5cIjogXCJcXFxcflwiLFxuICBcIiFcIjogXCJcXFxcIVwiLFxuICBcInxcIjogXCJcXFxcfFwiLFxuICBcIihcIjogXCJcXFxcKFwiLFxuICBcIilcIjogXCJcXFxcKVwiLFxuICBcIntcIjogXCJcXFxce1wiLFxuICBcIn1cIjogXCJcXFxcfVwiLFxuICBcIltcIjogXCJcXFxcW1wiLFxuICBcIl1cIjogXCJcXFxcXVwiXG59O1xudmFyIG1hcmtkb3duRXNjYXBhYmxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgT2JqZWN0LmtleXMobWFya2Rvd25Fc2NhcGFibGVzKS5tYXAoKGVudGl0eSkgPT4gYFxcXFwke2VudGl0eX1gKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBqb2luTWFya2Rvd24oc3RyaW5ncykge1xuICBpZiAoc3RyaW5ncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKFtcIlwiXSwgW10pO1xuICB9XG4gIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKFxuICAgIFtcIlwiLCAuLi5BcnJheShzdHJpbmdzLmxlbmd0aCAtIDEpLmZpbGwoXCJcIiksIFwiXCJdLFxuICAgIHN0cmluZ3NcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZU1hcmtkb3duKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcmtkb3duU2FmZVN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBqb2luTWFya2Rvd24odmFsdWUpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkucmVwbGFjZShcbiAgICBtYXJrZG93bkVzY2FwYWJsZXNSZWdleCxcbiAgICAoY2hhcmFjdGVyKSA9PiBtYXJrZG93bkVzY2FwYWJsZXNbY2hhcmFjdGVyXVxuICApO1xufVxudmFyIE1hcmtkb3duU2FmZVN0cmluZyA9IGNsYXNzIHtcbiAgI3N0cmluZ3M7XG4gICN2YWx1ZXM7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlczIpIHtcbiAgICB0aGlzLiNzdHJpbmdzID0gc3RyaW5ncztcbiAgICB0aGlzLiN2YWx1ZXMgPSB2YWx1ZXMyO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNzdHJpbmdzLnJlZHVjZSgocmVzdWx0LCBzdHIsIGkpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVNYXJrZG93bihubih0aGlzLiN2YWx1ZXNbaSAtIDFdKSkgKyBzdHI7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBtYXJrZG93bihzdHJpbmdzLCAuLi52YWx1ZXMyKSB7XG4gIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlczIpO1xufVxuZnVuY3Rpb24gdG9BYnNvbHV0ZVVybCh1cmwyKSB7XG4gIGlmICh1cmwyLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHVybDIuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgcmV0dXJuIHVybDI7XG4gIH0gZWxzZSBpZiAodXJsMi5zdGFydHNXaXRoKFwid3d3LlwiKSkge1xuICAgIHJldHVybiBcImh0dHBzOi8vXCIgKyB1cmwyO1xuICB9XG4gIHJldHVybjtcbn1cbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4gY2hpbGRyZW4sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC50ZXh0LFxuICBsaW5rOiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudGV4dCA/PyBlbGVtZW50LnVybCxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIGBAJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9YDtcbiAgfVxufTtcbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuID8gaHRtbGA8cD4ke2h0bWxTYWZlKGNoaWxkcmVuKX08L3A+YCA6IGNoaWxkcmVuO1xuICB9LFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LnRleHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGh0bWxgJHtjaGlsZHJlbn1gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ib2xkKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPHN0cm9uZz4ke2NoaWxkcmVufTwvc3Ryb25nPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lml0YWxpYykge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxlbT4ke2NoaWxkcmVufTwvZW0+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc3RyaWtldGhyb3VnaCkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxzPiR7Y2hpbGRyZW59PC9zPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmNvZGUpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8Y29kZT4ke2NoaWxkcmVufTwvY29kZT5gO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbGAke2NoaWxkcmVufWA7XG4gIH0sXG4gIGxpbms6ICh7IGVsZW1lbnQsIGhyZWYgfSkgPT4ge1xuICAgIHJldHVybiBodG1sYDxhIGhyZWY9XCIke2hyZWZ9XCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiPiR7ZWxlbWVudC50ZXh0ID8gaHRtbGAke2VsZW1lbnQudGV4dH1gIDogZWxlbWVudC51cmx9PC9hPmA7XG4gIH0sXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBodG1sYDxzcGFuIGRhdGEtbWVudGlvbj5AJHt1c2VyPy5uYW1lID8gaHRtbGAke3VzZXI/Lm5hbWV9YCA6IGVsZW1lbnQuaWR9PC9zcGFuPmA7XG4gIH1cbn07XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4ge1xuICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmJvbGQpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gKioke2NoaWxkcmVufSoqYDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaXRhbGljKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYF8ke2NoaWxkcmVufV9gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zdHJpa2V0aHJvdWdoKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYH5+JHtjaGlsZHJlbn1+fmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmNvZGUpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gXFxgJHtjaGlsZHJlbn1cXGBgO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIGxpbms6ICh7IGVsZW1lbnQsIGhyZWYgfSkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bmBbJHtlbGVtZW50LnRleHQgPz8gZWxlbWVudC51cmx9XSgke2hyZWZ9KWA7XG4gIH0sXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bmBAJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9YDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHN0cmluZ2lmeUNvbW1lbnRCb2R5KGJvZHksIG9wdGlvbnMpIHtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucz8uZm9ybWF0ID8/IFwicGxhaW5cIjtcbiAgY29uc3Qgc2VwYXJhdG9yID0gb3B0aW9ucz8uc2VwYXJhdG9yID8/IChmb3JtYXQgPT09IFwibWFya2Rvd25cIiA/IFwiXFxuXFxuXCIgOiBcIlxcblwiKTtcbiAgY29uc3QgZWxlbWVudHMgPSB7XG4gICAgLi4uZm9ybWF0ID09PSBcImh0bWxcIiA/IHN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzIDogZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keU1hcmtkb3duRWxlbWVudHMgOiBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMsXG4gICAgLi4ub3B0aW9ucz8uZWxlbWVudHNcbiAgfTtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IGF3YWl0IHJlc29sdmVVc2Vyc0luQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBvcHRpb25zPy5yZXNvbHZlVXNlcnNcbiAgKTtcbiAgY29uc3QgYmxvY2tzID0gYm9keS5jb250ZW50LmZsYXRNYXAoKGJsb2NrLCBibG9ja0luZGV4KSA9PiB7XG4gICAgc3dpdGNoIChibG9jay50eXBlKSB7XG4gICAgICBjYXNlIFwicGFyYWdyYXBoXCI6IHtcbiAgICAgICAgY29uc3QgaW5saW5lcyA9IGJsb2NrLmNoaWxkcmVuLmZsYXRNYXAoKGlubGluZSwgaW5saW5lSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keU1lbnRpb24oaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlubGluZS5pZCA/IFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubWVudGlvbihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICB1c2VyOiByZXNvbHZlZFVzZXJzLmdldChpbmxpbmUuaWQpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmxpbmVJbmRleFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdIDogW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5TGluayhpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBlbGVtZW50cy5saW5rKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGlubGluZSxcbiAgICAgICAgICAgICAgICAgIGhyZWY6IHRvQWJzb2x1dGVVcmwoaW5saW5lLnVybCkgPz8gaW5saW5lLnVybFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlUZXh0KGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWxlbWVudHMudGV4dCh7IGVsZW1lbnQ6IGlubGluZSB9LCBpbmxpbmVJbmRleCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGVsZW1lbnRzLnBhcmFncmFwaChcbiAgICAgICAgICAgIHsgZWxlbWVudDogYmxvY2ssIGNoaWxkcmVuOiBpbmxpbmVzLmpvaW4oXCJcIikgfSxcbiAgICAgICAgICAgIGJsb2NrSW5kZXhcbiAgICAgICAgICApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGJsb2Nrcy5qb2luKHNlcGFyYXRvcik7XG59XG5cbi8vIHNyYy9jb21tZW50cy9jb21tZW50LXVybC50c1xudmFyIFBMQUNFSE9MREVSX0JBU0VfVVJMID0gXCJodHRwczovL2xvY2FsaG9zdDo5OTk5XCI7XG52YXIgQUJTT0xVVEVfVVJMX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVpcXGQrXFwtLl0qPzovO1xuZnVuY3Rpb24gZ2VuZXJhdGVDb21tZW50VXJsKHtcbiAgcm9vbVVybCxcbiAgY29tbWVudElkXG59KSB7XG4gIGNvbnN0IGlzQWJzb2x1dGUgPSBBQlNPTFVURV9VUkxfUkVHRVgudGVzdChyb29tVXJsKTtcbiAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTChcbiAgICByb29tVXJsLFxuICAgIGlzQWJzb2x1dGUgPyB2b2lkIDAgOiBQTEFDRUhPTERFUl9CQVNFX1VSTFxuICApO1xuICB1cmxPYmplY3QuaGFzaCA9IGAjJHtjb21tZW50SWR9YDtcbiAgcmV0dXJuIGlzQWJzb2x1dGUgPyB1cmxPYmplY3QuaHJlZiA6IHVybE9iamVjdC5ocmVmLnJlcGxhY2UoUExBQ0VIT0xERVJfQkFTRV9VUkwsIFwiXCIpO1xufVxuXG4vLyBzcmMvY3JkdHMvdXRpbHMudHNcbmZ1bmN0aW9uIHRvUGxhaW5Mc29uKGxzb24pIHtcbiAgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIGRhdGE6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMobHNvbi50b09iamVjdCgpKS5mbGF0TWFwKFxuICAgICAgICAgIChba2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDAgPyBbW2tleSwgdG9QbGFpbkxzb24odmFsdWUpXV0gOiBbXVxuICAgICAgICApXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIFsuLi5sc29uXS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgdG9QbGFpbkxzb24odmFsdWUpXSlcbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlTGlzdFwiLFxuICAgICAgZGF0YTogWy4uLmxzb25dLm1hcCgoaXRlbSkgPT4gdG9QbGFpbkxzb24oaXRlbSkpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbHNvbjtcbiAgfVxufVxuXG4vLyBzcmMvaW1tdXRhYmxlLnRzXG5mdW5jdGlvbiBsc29uT2JqZWN0VG9Kc29uKG9iaikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgY29uc3QgdmFsID0gb2JqW2tleV07XG4gICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxpdmVPYmplY3RUb0pzb24obGl2ZU9iamVjdCkge1xuICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbihsaXZlT2JqZWN0LnRvT2JqZWN0KCkpO1xufVxuZnVuY3Rpb24gbGl2ZU1hcFRvSnNvbihtYXApIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICByZXN1bHRba2V5XSA9IGxzb25Ub0pzb24odmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsc29uTGlzdFRvSnNvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUubWFwKGxzb25Ub0pzb24pO1xufVxuZnVuY3Rpb24gbGl2ZUxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIGxzb25MaXN0VG9Kc29uKHZhbHVlLnRvQXJyYXkoKSk7XG59XG5mdW5jdGlvbiBsc29uVG9Kc29uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gbGl2ZU9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiBsaXZlTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwKSB7XG4gICAgcmV0dXJuIGxpdmVNYXBUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlLmRhdGE7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGxzb25MaXN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uT2JqZWN0VG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBkZWVwTGl2ZWlmeSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IExpdmVMaXN0KHZhbHVlLm1hcChkZWVwTGl2ZWlmeSkpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgY29uc3QgaW5pdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICBjb25zdCB2YWwgPSB2YWx1ZVtrZXldO1xuICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaW5pdFtrZXldID0gZGVlcExpdmVpZnkodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaXZlT2JqZWN0KGluaXQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlTGlzdChsaXZlTGlzdCwgcHJldiwgbmV4dCkge1xuICBsZXQgaSA9IDA7XG4gIGxldCBwcmV2RW5kID0gcHJldi5sZW5ndGggLSAxO1xuICBsZXQgbmV4dEVuZCA9IG5leHQubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZOb2RlID0gcHJldlswXTtcbiAgbGV0IG5leHROb2RlID0gbmV4dFswXTtcbiAgb3V0ZXI6IHtcbiAgICB3aGlsZSAocHJldk5vZGUgPT09IG5leHROb2RlKSB7XG4gICAgICArK2k7XG4gICAgICBpZiAoaSA+IHByZXZFbmQgfHwgaSA+IG5leHRFbmQpIHtcbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbaV07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbaV07XG4gICAgfVxuICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICBuZXh0Tm9kZSA9IG5leHRbbmV4dEVuZF07XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgcHJldkVuZC0tO1xuICAgICAgbmV4dEVuZC0tO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W3ByZXZFbmRdO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIH1cbiAgfVxuICBpZiAoaSA+IHByZXZFbmQpIHtcbiAgICBpZiAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICB3aGlsZSAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaSA+IG5leHRFbmQpIHtcbiAgICBsZXQgbG9jYWxJID0gaTtcbiAgICB3aGlsZSAobG9jYWxJIDw9IHByZXZFbmQpIHtcbiAgICAgIGxpdmVMaXN0LmRlbGV0ZShpKTtcbiAgICAgIGxvY2FsSSsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoaSA8PSBwcmV2RW5kICYmIGkgPD0gbmV4dEVuZCkge1xuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgICAgY29uc3QgbGl2ZUxpc3ROb2RlID0gbGl2ZUxpc3QuZ2V0KGkpO1xuICAgICAgaWYgKGlzTGl2ZU9iamVjdChsaXZlTGlzdE5vZGUpICYmIGlzUGxhaW5PYmplY3QocHJldk5vZGUpICYmIGlzUGxhaW5PYmplY3QobmV4dE5vZGUpKSB7XG4gICAgICAgIHBhdGNoTGl2ZU9iamVjdChsaXZlTGlzdE5vZGUsIHByZXZOb2RlLCBuZXh0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXZlTGlzdC5zZXQoaSwgZGVlcExpdmVpZnkobmV4dE5vZGUpKTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgbGl2ZUxpc3QuaW5zZXJ0KGRlZXBMaXZlaWZ5KG5leHRbaV0pLCBpKTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZU9iamVjdEtleShsaXZlT2JqZWN0LCBrZXksIHByZXYsIG5leHQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IG5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5leHQpO1xuICAgIGlmIChub25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgZXJyb3IyKFxuICAgICAgICBgTmV3IHN0YXRlIHBhdGg6ICcke25vblNlcmlhbGl6YWJsZVZhbHVlLnBhdGh9JyB2YWx1ZTogJyR7U3RyaW5nKFxuICAgICAgICAgIG5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlXG4gICAgICAgICl9JyBpcyBub3Qgc2VyaWFsaXphYmxlLlxuT25seSBzZXJpYWxpemFibGUgdmFsdWUgY2FuIGJlIHN5bmNlZCB3aXRoIExpdmVibG9ja3MuYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBsaXZlT2JqZWN0LmdldChrZXkpO1xuICBpZiAobmV4dCA9PT0gdm9pZCAwKSB7XG4gICAgbGl2ZU9iamVjdC5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgbGl2ZU9iamVjdC5zZXQoa2V5LCBkZWVwTGl2ZWlmeShuZXh0KSk7XG4gIH0gZWxzZSBpZiAocHJldiA9PT0gbmV4dCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpc0xpdmVMaXN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHByZXYpICYmIEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICBwYXRjaExpdmVMaXN0KHZhbHVlLCBwcmV2LCBuZXh0KTtcbiAgfSBlbHNlIGlmIChpc0xpdmVPYmplY3QodmFsdWUpICYmIGlzUGxhaW5PYmplY3QocHJldikgJiYgaXNQbGFpbk9iamVjdChuZXh0KSkge1xuICAgIHBhdGNoTGl2ZU9iamVjdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgbGl2ZU9iamVjdC5zZXQoa2V5LCBkZWVwTGl2ZWlmeShuZXh0KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZU9iamVjdChyb290LCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgIHBhdGNoTGl2ZU9iamVjdEtleShyb290LCBrZXksIHByZXZba2V5XSwgbmV4dFtrZXldKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgaWYgKG5leHRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICByb290LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LmtleXModXBkYXRlcykubGVuZ3RoID4gMCkge1xuICAgIHJvb3QudXBkYXRlKHVwZGF0ZXMpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRzUGF0aChub2RlKSB7XG4gIGNvbnN0IHBhdGggPSBbXTtcbiAgd2hpbGUgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICBpZiAoaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgcGF0aC5wdXNoKG5vZGUucGFyZW50Lm5vZGUuX2luZGV4T2ZQb3NpdGlvbihub2RlLnBhcmVudC5rZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5wdXNoKG5vZGUucGFyZW50LmtleSk7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudC5ub2RlO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0KHN0YXRlLCB1cGRhdGVzKSB7XG4gIHJldHVybiB1cGRhdGVzLnJlZHVjZShcbiAgICAoc3RhdGUyLCB1cGRhdGUpID0+IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdFdpdGhVcGRhdGUoc3RhdGUyLCB1cGRhdGUpLFxuICAgIHN0YXRlXG4gICk7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlLCB1cGRhdGUpIHtcbiAgY29uc3QgcGF0aCA9IGdldFBhcmVudHNQYXRoKHVwZGF0ZS5ub2RlKTtcbiAgcmV0dXJuIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoc3RhdGUsIHBhdGgsIHVwZGF0ZSk7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpIHtcbiAgY29uc3QgcGF0aEl0ZW0gPSBwYXRoLnBvcCgpO1xuICBpZiAocGF0aEl0ZW0gPT09IHZvaWQgMCkge1xuICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJMaXZlT2JqZWN0XCI6IHtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVPYmplY3QgYnV0IHN0YXRlIHdhcyBub3QgYW4gb2JqZWN0XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSB1cGRhdGUubm9kZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJMaXZlTGlzdFwiOiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZUxpc3QgYnV0IHN0YXRlIHdhcyBub3QgYW4gYXJyYXlcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1N0YXRlID0gc3RhdGUubWFwKCh4KSA9PiB4KTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0VXBkYXRlIG9mIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXdTdGF0ZS5tYXAoXG4gICAgICAgICAgICAgIChpdGVtLCBpbmRleCkgPT4gaW5kZXggPT09IGxpc3RVcGRhdGUuaW5kZXggPyBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSkgOiBpdGVtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcImluc2VydFwiKSB7XG4gICAgICAgICAgICBpZiAobGlzdFVwZGF0ZS5pbmRleCA9PT0gbmV3U3RhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlLnB1c2gobHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUuaW5kZXgpLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4KVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZS5zcGxpY2UobGlzdFVwZGF0ZS5pbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwibW92ZVwiKSB7XG4gICAgICAgICAgICBpZiAobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ID4gbGlzdFVwZGF0ZS5pbmRleCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleCwgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShcbiAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLmluZGV4ICsgMVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXggKyAxKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZU1hcFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlTWFwIGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB1cGRhdGUubm9kZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnN0YXRlXTtcbiAgICBuZXdBcnJheVtwYXRoSXRlbV0gPSBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKFxuICAgICAgc3RhdGVbcGF0aEl0ZW1dLFxuICAgICAgcGF0aCxcbiAgICAgIHVwZGF0ZVxuICAgICk7XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9IGVsc2UgaWYgKGlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICBjb25zdCBub2RlID0gc3RhdGVbcGF0aEl0ZW1dO1xuICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhdGVBc09iaiA9IHN0YXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGVBc09iaixcbiAgICAgICAgW3BhdGhJdGVtXTogbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShub2RlLCBwYXRoLCB1cGRhdGUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9kZXByZWNhdGlvbi50c1xudmFyIF9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5mdW5jdGlvbiBkZXByZWNhdGUobWVzc2FnZSwga2V5ID0gbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MuaGFzKGtleSkpIHtcbiAgICAgIF9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncy5hZGQoa2V5KTtcbiAgICAgIGVycm9yV2l0aFRpdGxlKFwiRGVwcmVjYXRpb24gd2FybmluZ1wiLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZUlmKGNvbmRpdGlvbiwgbWVzc2FnZSwga2V5ID0gbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgZGVwcmVjYXRlKG1lc3NhZ2UsIGtleSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0aHJvd1VzYWdlRXJyb3IobWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgdXNhZ2VFcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB1c2FnZUVycm9yLm5hbWUgPSBcIlVzYWdlIGVycm9yXCI7XG4gICAgZXJyb3JXaXRoVGl0bGUoXCJVc2FnZSBlcnJvclwiLCBtZXNzYWdlKTtcbiAgICB0aHJvdyB1c2FnZUVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcklmKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgdGhyb3dVc2FnZUVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvbGliL1BvbGxlci50c1xudmFyIEJBQ0tPRkZfREVMQVlTMiA9IFsxZTMsIDJlMywgNGUzLCA4ZTMsIDFlNF07XG5mdW5jdGlvbiBtYWtlUG9sbGVyKGNhbGxiYWNrLCBpbnRlcnZhbE1zLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHZvaWQgMDtcbiAgY29uc3QgbWF4U3RhbGVUaW1lTXMgPSBvcHRpb25zPy5tYXhTdGFsZVRpbWVNcyA/PyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgaW5Gb3JlZ3JvdW5kOiBkb2M/LnZpc2liaWxpdHlTdGF0ZSAhPT0gXCJoaWRkZW5cIixcbiAgICBsYXN0U3VjY2Vzc2Z1bFBvbGxBdDogc3RhcnRUaW1lLFxuICAgIGNvdW50OiAwLFxuICAgIGJhY2tvZmY6IDBcbiAgfTtcbiAgZnVuY3Rpb24gbWF5UG9sbCgpIHtcbiAgICByZXR1cm4gY29udGV4dC5jb3VudCA+IDAgJiYgY29udGV4dC5pbkZvcmVncm91bmQ7XG4gIH1cbiAgY29uc3QgZnNtID0gbmV3IEZTTSh7fSkuYWRkU3RhdGUoXCJAaWRsZVwiKS5hZGRTdGF0ZShcIkBlbmFibGVkXCIpLmFkZFN0YXRlKFwiQHBvbGxpbmdcIik7XG4gIGZzbS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlXCIsIHsgU1RBUlQ6IFwiQGVuYWJsZWRcIiB9KTtcbiAgZnNtLmFkZFRyYW5zaXRpb25zKFwiQGVuYWJsZWRcIiwgeyBTVE9QOiBcIkBpZGxlXCIsIFBPTEw6IFwiQHBvbGxpbmdcIiB9KTtcbiAgZnNtLmFkZFRpbWVkVHJhbnNpdGlvbihcbiAgICBcIkBlbmFibGVkXCIsXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgbGFzdFBvbGwgPSBjb250ZXh0Lmxhc3RTdWNjZXNzZnVsUG9sbEF0O1xuICAgICAgY29uc3QgbmV4dFBvbGwgPSBsYXN0UG9sbCArIGludGVydmFsTXM7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgbmV4dFBvbGwgLSBwZXJmb3JtYW5jZS5ub3coKSkgKyBjb250ZXh0LmJhY2tvZmY7XG4gICAgfSxcbiAgICBcIkBwb2xsaW5nXCJcbiAgKTtcbiAgZnNtLm9uRW50ZXJBc3luYyhcbiAgICBcIkBwb2xsaW5nXCIsXG4gICAgYXN5bmMgKF9jdHgsIHNpZ25hbCkgPT4ge1xuICAgICAgYXdhaXQgY2FsbGJhY2soc2lnbmFsKTtcbiAgICAgIGlmICghc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgY29udGV4dC5sYXN0U3VjY2Vzc2Z1bFBvbGxBdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gV2hlbiBPS1xuICAgICgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogbWF5UG9sbCgpID8gXCJAZW5hYmxlZFwiIDogXCJAaWRsZVwiLFxuICAgICAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgICAgICBjb250ZXh0LmJhY2tvZmYgPSAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gV2hlbiBlcnJvclxuICAgICgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogbWF5UG9sbCgpID8gXCJAZW5hYmxlZFwiIDogXCJAaWRsZVwiLFxuICAgICAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgICAgICBjb250ZXh0LmJhY2tvZmYgPSBCQUNLT0ZGX0RFTEFZUzIuZmluZCgoZGVsYXkpID0+IGRlbGF5ID4gY29udGV4dC5iYWNrb2ZmKSA/PyBCQUNLT0ZGX0RFTEFZUzJbQkFDS09GRl9ERUxBWVMyLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgM2U0XG4gICAgLy8gQWJvcnQgdGhlIHBvbGwgaWYgdGhlIGNhbGxiYWNrIHRha2VzIG1vcmUgdGhhbiAzMCBzZWNvbmRzIHRvIGNvbXBsZXRlXG4gICk7XG4gIGZ1bmN0aW9uIHN0YXJ0T3JTdG9wKCkge1xuICAgIGlmIChtYXlQb2xsKCkpIHtcbiAgICAgIGZzbS5zZW5kKHsgdHlwZTogXCJTVEFSVFwiIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmc20uc2VuZCh7IHR5cGU6IFwiU1RPUFwiIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbmMoKSB7XG4gICAgY29udGV4dC5jb3VudCsrO1xuICAgIHN0YXJ0T3JTdG9wKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVjKCkge1xuICAgIGNvbnRleHQuY291bnQtLTtcbiAgICBpZiAoY29udGV4dC5jb3VudCA8IDApIHtcbiAgICAgIGNvbnRleHQuY291bnQgPSAwO1xuICAgIH1cbiAgICBzdGFydE9yU3RvcCgpO1xuICB9XG4gIGZ1bmN0aW9uIHBvbGxOb3dJZlN0YWxlKCkge1xuICAgIGlmIChwZXJmb3JtYW5jZS5ub3coKSAtIGNvbnRleHQubGFzdFN1Y2Nlc3NmdWxQb2xsQXQgPiBtYXhTdGFsZVRpbWVNcykge1xuICAgICAgZnNtLnNlbmQoeyB0eXBlOiBcIlBPTExcIiB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0SW5Gb3JlZ3JvdW5kKGluRm9yZWdyb3VuZCkge1xuICAgIGNvbnRleHQuaW5Gb3JlZ3JvdW5kID0gaW5Gb3JlZ3JvdW5kO1xuICAgIHN0YXJ0T3JTdG9wKCk7XG4gICAgcG9sbE5vd0lmU3RhbGUoKTtcbiAgfVxuICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgc2V0SW5Gb3JlZ3JvdW5kKGRvYz8udmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiKTtcbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBwb2xsTm93SWZTdGFsZSk7XG4gIGZzbS5zdGFydCgpO1xuICByZXR1cm4ge1xuICAgIGluYyxcbiAgICBkZWMsXG4gICAgcG9sbE5vd0lmU3RhbGUsXG4gICAgLy8gSW50ZXJuYWwgQVBJLCB1c2VkIGJ5IHVuaXQgdGVzdHMgb25seSB0byBzaW11bGF0ZSB2aXNpYmlsaXR5IGV2ZW50c1xuICAgIHNldEluRm9yZWdyb3VuZFxuICB9O1xufVxuXG4vLyBzcmMvbGliL3NoYWxsb3cudHNcbmZ1bmN0aW9uIHNoYWxsb3dBcnJheSh4cywgeXMpIHtcbiAgaWYgKHhzLmxlbmd0aCAhPT0geXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5pcyh4c1tpXSwgeXNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2hhbGxvd09iaihvYmpBLCBvYmpCKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChvYmpBKSB8fCAhaXNQbGFpbk9iamVjdChvYmpCKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmpCKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGtleXNBLmV2ZXJ5KFxuICAgIChrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXkpICYmIE9iamVjdC5pcyhvYmpBW2tleV0sIG9iakJba2V5XSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3coYSwgYikge1xuICBpZiAoT2JqZWN0LmlzKGEsIGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICBjb25zdCBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gIGlmIChpc0FycmF5QSB8fCBpc0FycmF5Qikge1xuICAgIGlmICghaXNBcnJheUEgfHwgIWlzQXJyYXlCKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzaGFsbG93QXJyYXkoYSwgYik7XG4gIH1cbiAgcmV0dXJuIHNoYWxsb3dPYmooYSwgYik7XG59XG5cbi8vIHNyYy9saWIvU29ydGVkTGlzdC50c1xuZnVuY3Rpb24gYmlzZWN0UmlnaHQoYXJyLCB4LCBsdCkge1xuICBsZXQgbG8gPSAwO1xuICBsZXQgaGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIGNvbnN0IG1pZCA9IGxvICsgKGhpIC0gbG8gPj4gMSk7XG4gICAgaWYgKGx0KHgsIGFyclttaWRdKSkge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvID0gbWlkICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvO1xufVxudmFyIFNvcnRlZExpc3QgPSBjbGFzcyBfU29ydGVkTGlzdCB7XG4gICNkYXRhO1xuICAjbHQ7XG4gIGNvbnN0cnVjdG9yKGFscmVhZHlTb3J0ZWRMaXN0LCBsdCkge1xuICAgIHRoaXMuI2x0ID0gbHQ7XG4gICAgdGhpcy4jZGF0YSA9IGFscmVhZHlTb3J0ZWRMaXN0O1xuICB9XG4gIHN0YXRpYyBmcm9tKGFyciwgbHQpIHtcbiAgICBjb25zdCBzb3J0ZWQgPSBuZXcgX1NvcnRlZExpc3QoW10sIGx0KTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBzb3J0ZWQuYWRkKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gc29ydGVkO1xuICB9XG4gIHN0YXRpYyBmcm9tQWxyZWFkeVNvcnRlZChhbHJlYWR5U29ydGVkLCBsdCkge1xuICAgIHJldHVybiBuZXcgX1NvcnRlZExpc3QoYWxyZWFkeVNvcnRlZCwgbHQpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHNvcnRlZCBsaXN0IHRvIGEgbmV3IGluc3RhbmNlLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfU29ydGVkTGlzdCh0aGlzLiNkYXRhLnNsaWNlKCksIHRoaXMuI2x0KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRoZSBzb3J0ZWQgbGlzdCwgc3VjaCB0aGF0IGl0IHJlbWFpbnMgc29ydGVkLlxuICAgKi9cbiAgYWRkKHZhbHVlKSB7XG4gICAgY29uc3QgaWR4ID0gYmlzZWN0UmlnaHQodGhpcy4jZGF0YSwgdmFsdWUsIHRoaXMuI2x0KTtcbiAgICB0aGlzLiNkYXRhLnNwbGljZShpZHgsIDAsIHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gdmFsdWUgZnJvbSB0aGUgc29ydGVkIGxpc3QsIGlmIGl0IGV4aXN0cy4gVGhlIGdpdmVuXG4gICAqIHZhbHVlIG11c3QgYmUgYD09PWAgdG8gb25lIG9mIHRoZSBsaXN0IGl0ZW1zLiBPbmx5IHRoZSBmaXJzdCBlbnRyeSB3aWxsIGJlXG4gICAqIHJlbW92ZWQgaWYgdGhlIGVsZW1lbnQgZXhpc3RzIGluIHRoZSBzb3J0ZWQgbGlzdCBtdWx0aXBsZSB0aW1lcy5cbiAgICovXG4gIHJlbW92ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuI2RhdGEuaW5kZXhPZih2YWx1ZSk7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLiNkYXRhLnNwbGljZShpZHgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhLmxlbmd0aDtcbiAgfVxuICAqZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNkYXRhKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGl0ZW0pKSB7XG4gICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3RvY29sL1VzZXJOb3RpZmljYXRpb25TZXR0aW5ncy50c1xuZnVuY3Rpb24gaXNOb3RpZmljYXRpb25DaGFubmVsRW5hYmxlZChzZXR0aW5ncykge1xuICByZXR1cm4gdmFsdWVzKHNldHRpbmdzKS5ldmVyeSgoZW5hYmxlZCkgPT4gZW5hYmxlZCA9PT0gdHJ1ZSk7XG59XG5cbi8vIHNyYy90eXBlcy9PdGhlcnMudHNcbnZhciBUZXh0RWRpdG9yVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFRleHRFZGl0b3JUeXBlMikgPT4ge1xuICBUZXh0RWRpdG9yVHlwZTJbXCJMZXhpY2FsXCJdID0gXCJsZXhpY2FsXCI7XG4gIFRleHRFZGl0b3JUeXBlMltcIlRpcFRhcFwiXSA9IFwidGlwdGFwXCI7XG4gIHJldHVybiBUZXh0RWRpdG9yVHlwZTI7XG59KShUZXh0RWRpdG9yVHlwZSB8fCB7fSk7XG5cbi8vIHNyYy9pbmRleC50c1xuZGV0ZWN0RHVwZXMoUEtHX05BTUUsIFBLR19WRVJTSU9OLCBQS0dfRk9STUFUKTtcbnZhciBDb21tZW50c0FwaUVycm9yID0gSHR0cEVycm9yO1xudmFyIE5vdGlmaWNhdGlvbnNBcGlFcnJvciA9IEh0dHBFcnJvcjtcbmV4cG9ydCB7XG4gIENsaWVudE1zZ0NvZGUsXG4gIENvbW1lbnRzQXBpRXJyb3IsXG4gIENyZHRUeXBlLFxuICBEZWZhdWx0TWFwLFxuICBEZXJpdmVkU2lnbmFsLFxuICBIdHRwRXJyb3IsXG4gIExpdmVMaXN0LFxuICBMaXZlTWFwLFxuICBMaXZlT2JqZWN0LFxuICBMaXZlYmxvY2tzRXJyb3IsXG4gIE11dGFibGVTaWduYWwsXG4gIE5vdGlmaWNhdGlvbnNBcGlFcnJvcixcbiAgT3BDb2RlLFxuICBQZXJtaXNzaW9uLFxuICBQcm9taXNlX3dpdGhSZXNvbHZlcnMsXG4gIFNlcnZlck1zZ0NvZGUsXG4gIFNpZ25hbCxcbiAgU29ydGVkTGlzdCxcbiAgVGV4dEVkaXRvclR5cGUsXG4gIFdlYnNvY2tldENsb3NlQ29kZXMsXG4gIGFja09wLFxuICBhc1BvcyxcbiAgYXNzZXJ0LFxuICBhc3NlcnROZXZlcixcbiAgYXV0b1JldHJ5LFxuICBiNjRkZWNvZGUsXG4gIGJhdGNoLFxuICBjaHVuayxcbiAgY2xvbmVMc29uLFxuICBjb21wYWN0T2JqZWN0LFxuICBmYW5jeV9jb25zb2xlX2V4cG9ydHMgYXMgY29uc29sZSxcbiAgY29udmVydFRvQ29tbWVudERhdGEsXG4gIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24sXG4gIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YSxcbiAgY29udmVydFRvVGhyZWFkRGF0YSxcbiAgY3JlYXRlQ2xpZW50LFxuICBjcmVhdGVDb21tZW50QXR0YWNobWVudElkLFxuICBjcmVhdGVDb21tZW50SWQsXG4gIGNyZWF0ZUluYm94Tm90aWZpY2F0aW9uSWQsXG4gIGNyZWF0ZVRocmVhZElkLFxuICBkZXByZWNhdGUsXG4gIGRlcHJlY2F0ZUlmLFxuICBkZXRlY3REdXBlcyxcbiAgZW50cmllcyxcbiAgZXJyb3JJZixcbiAgZnJlZXplLFxuICBnZW5lcmF0ZUNvbW1lbnRVcmwsXG4gIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keSxcbiAgaHRtbCxcbiAgaHRtbFNhZmUsXG4gIGlzQ2hpbGRDcmR0LFxuICBpc0NvbW1lbnRCb2R5TGluayxcbiAgaXNDb21tZW50Qm9keU1lbnRpb24sXG4gIGlzQ29tbWVudEJvZHlUZXh0LFxuICBpc0pzb25BcnJheSxcbiAgaXNKc29uT2JqZWN0LFxuICBpc0pzb25TY2FsYXIsXG4gIGlzTGl2ZU5vZGUsXG4gIGlzTm90aWZpY2F0aW9uQ2hhbm5lbEVuYWJsZWQsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzUm9vdENyZHQsXG4gIGlzU3RhcnRzV2l0aE9wZXJhdG9yLFxuICBrSW50ZXJuYWwsXG4gIGtleXMsXG4gIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdCxcbiAgbHNvblRvSnNvbixcbiAgbWFrZUV2ZW50U291cmNlLFxuICBtYWtlUG9sbGVyLFxuICBtYWtlUG9zaXRpb24sXG4gIG1hcFZhbHVlcyxcbiAgbWVtb2l6ZU9uU3VjY2VzcyxcbiAgbmFub2lkLFxuICBubixcbiAgb2JqZWN0VG9RdWVyeSxcbiAgcGF0Y2hMaXZlT2JqZWN0S2V5LFxuICByYWlzZSxcbiAgcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keSxcbiAgc2hhbGxvdyxcbiAgc3RhYmxlU3RyaW5naWZ5LFxuICBzdHJpbmdpZnlDb21tZW50Qm9keSxcbiAgdGhyb3dVc2FnZUVycm9yLFxuICB0b0Fic29sdXRlVXJsLFxuICB0b1BsYWluTHNvbixcbiAgdHJ5UGFyc2VKc29uLFxuICB1cmwsXG4gIHVybGpvaW4sXG4gIHdhaXQsXG4gIHdpdGhUaW1lb3V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/LiveblocksExtension.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/LiveblocksExtension.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useIsEditorReady: () => (/* binding */ useIsEditorReady),\n/* harmony export */   useLiveblocksExtension: () => (/* binding */ useLiveblocksExtension)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var _liveblocks_react_private__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/react/_private */ \"(ssr)/./node_modules/@liveblocks/react/dist/chunk-5RVW253W.js\");\n/* harmony import */ var _liveblocks_yjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @liveblocks/yjs */ \"(ssr)/./node_modules/@liveblocks/yjs/dist/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_collaboration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-collaboration */ \"(ssr)/./node_modules/@tiptap/extension-collaboration/dist/index.js\");\n/* harmony import */ var _tiptap_extension_collaboration_cursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-collaboration-cursor */ \"(ssr)/./node_modules/@tiptap/extension-collaboration-cursor/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _ai_AiExtension_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ai/AiExtension.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/ai/AiExtension.js\");\n/* harmony import */ var _comments_CommentsExtension_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./comments/CommentsExtension.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/comments/CommentsExtension.js\");\n/* harmony import */ var _mentions_MentionExtension_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mentions/MentionExtension.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionExtension.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/types.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_OPTIONS = {\n  field: \"default\",\n  comments: true,\n  mentions: true,\n  offlineSupport_experimental: false,\n  enablePermanentUserData: false\n};\nconst LiveblocksCollab = _tiptap_extension_collaboration__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n  onCreate() {\n    if (!this.editor.extensionManager.extensions.find((e) => e.name === \"doc\")) {\n      console.warn(\n        \"[Liveblocks] The tiptap document extension is required for Liveblocks collaboration. Please add it or use Tiptap StarterKit extension.\"\n      );\n    }\n    if (!this.editor.extensionManager.extensions.find(\n      (e) => e.name === \"paragraph\"\n    )) {\n      console.warn(\n        \"[Liveblocks] The tiptap paragraph extension is required for Liveblocks collaboration. Please add it or use Tiptap StarterKit extension.\"\n      );\n    }\n    if (!this.editor.extensionManager.extensions.find((e) => e.name === \"text\")) {\n      console.warn(\n        \"[Liveblocks] The tiptap text extension is required for Liveblocks collaboration. Please add it or use Tiptap StarterKit extension.\"\n      );\n    }\n    if (this.editor.extensionManager.extensions.find((e) => e.name === \"history\")) {\n      console.warn(\n        \"[Liveblocks] The history extension is enabled, Liveblocks extension provides its own. Please remove or disable the History plugin to prevent unwanted conflicts.\"\n      );\n    }\n  }\n});\nfunction useIsEditorReady() {\n  const yjsProvider = (0,_liveblocks_react_private__WEBPACK_IMPORTED_MODULE_3__.useYjsProvider)();\n  const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(() => {\n    const status = yjsProvider?.getStatus();\n    return status === \"synchronizing\" || status === \"synchronized\";\n  }, [yjsProvider]);\n  const subscribe = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(\n    (callback) => {\n      if (yjsProvider === void 0)\n        return () => {\n        };\n      yjsProvider.on(\"status\", callback);\n      return () => {\n        yjsProvider.off(\"status\", callback);\n      };\n    },\n    [yjsProvider]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);\n}\nconst YChangeMark = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Mark.create({\n  name: \"ychange\",\n  inclusive: false,\n  parseHTML() {\n    return [{ tag: \"ychange\" }];\n  },\n  addAttributes() {\n    return {\n      user: {\n        default: null,\n        parseHTML: (element) => element.getAttribute(\"ychange_user\") ?? null,\n        renderHTML: (attributes) => {\n          if (!attributes.user) {\n            return {};\n          }\n          return { \"data-ychange-user\": attributes.user };\n        }\n      },\n      type: {\n        default: null,\n        parseHTML: (element) => element.getAttribute(\"ychange_type\") ?? null,\n        renderHTML: (attributes) => {\n          if (!attributes.type) {\n            return {};\n          }\n          return {\n            \"data-ychange-type\": attributes.type,\n            \"data-liveblocks\": \"\",\n            class: `lb-root lb-tiptap-change lb-tiptap-change-${attributes.type}`\n          };\n        }\n      },\n      color: {\n        default: null,\n        parseHTML: (element) => {\n          return element.getAttribute(\"ychange_color\") ?? null;\n        },\n        renderHTML: () => {\n          return {};\n        }\n      }\n    };\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"ychange\", HTMLAttributes, 0];\n  }\n});\nconst useLiveblocksExtension = (opts) => {\n  const options = {\n    ...DEFAULT_OPTIONS,\n    ...opts\n  };\n  const [editor, setEditor] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n  const room = (0,_liveblocks_react_private__WEBPACK_IMPORTED_MODULE_3__._useRoom)();\n  const isEditorReady = useIsEditorReady();\n  const client = (0,_liveblocks_react_private__WEBPACK_IMPORTED_MODULE_3__.useClient)();\n  const store = (0,_liveblocks_react_private__WEBPACK_IMPORTED_MODULE_3__.getUmbrellaStoreForClient)(client);\n  const roomId = room.id;\n  const yjsProvider = (0,_liveblocks_react_private__WEBPACK_IMPORTED_MODULE_3__.useYjsProvider)();\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {\n    if (!isEditorReady || !yjsProvider || !options.initialContent || !editor)\n      return;\n    const ydoc = yjsProvider.getYDoc();\n    const hasContentSet = ydoc.getMap(\"liveblocks_config\").get(\"hasContentSet\");\n    if (!hasContentSet) {\n      ydoc.getMap(\"liveblocks_config\").set(\"hasContentSet\", true);\n      editor.commands.setContent(options.initialContent);\n    }\n  }, [isEditorReady, yjsProvider, options.initialContent, editor]);\n  (0,_liveblocks_react_private__WEBPACK_IMPORTED_MODULE_3__.useReportTextEditor)(\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_5__.TextEditorType.TipTap,\n    options.field ?? DEFAULT_OPTIONS.field\n  );\n  const createTextMention = (0,_liveblocks_react_private__WEBPACK_IMPORTED_MODULE_3__.useCreateTextMention)();\n  const deleteTextMention = (0,_liveblocks_react_private__WEBPACK_IMPORTED_MODULE_3__.useDeleteTextMention)();\n  return _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Extension.create({\n    name: \"liveblocksExtension\",\n    onCreate() {\n      setEditor(this.editor);\n      if (this.editor.options.content) {\n        console.warn(\n          \"[Liveblocks] Initial content must be set in the useLiveblocksExtension hook option. Remove content from your editor options.\"\n        );\n      }\n      if (options.mentions && this.editor.extensionManager.extensions.find(\n        (e) => e.name.toLowerCase() === \"mention\"\n      )) {\n        console.warn(\n          \"[Liveblocks] Liveblocks own mention plugin is enabled, using another mention plugin may cause a conflict.\"\n        );\n      }\n      const self = room.getSelf();\n      const updateUser = ({\n        info,\n        id: userId\n      }) => {\n        if (!info) {\n          return;\n        }\n        const { user: storedUser } = this.storage.provider.awareness.getLocalState();\n        if (this.storage.permanentUserData) {\n          const pud = this.storage.permanentUserData.clients.get(\n            this.storage.doc.clientID\n          );\n          if (!pud || pud !== userId) {\n            this.storage.permanentUserData.setUserMapping(\n              this.storage.doc,\n              this.storage.doc.clientID,\n              userId ?? \"Unknown\"\n            );\n          }\n        }\n        if (info.name !== storedUser?.name || info.color !== storedUser?.color) {\n          this.editor.commands.updateUser({\n            name: info.name,\n            color: info.color\n          });\n        }\n      };\n      if (self?.info) {\n        updateUser(self);\n      }\n      this.storage.unsubs.push(room.events.self.subscribe(updateUser));\n      if (options.comments) {\n        const commentMarkType = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_4__.getMarkType)(\n          _types_js__WEBPACK_IMPORTED_MODULE_6__.LIVEBLOCKS_COMMENT_MARK_TYPE,\n          this.editor.schema\n        );\n        this.storage.unsubs.push(\n          store.outputs.threads.subscribe(() => {\n            const threadMap = new Map(\n              store.outputs.threads.get().findMany(roomId, { resolved: false }, \"asc\").map((thread) => [thread.id, true])\n            );\n            function isComment(mark) {\n              return mark.type.name === _types_js__WEBPACK_IMPORTED_MODULE_6__.LIVEBLOCKS_COMMENT_MARK_TYPE;\n            }\n            this.editor.state.doc.descendants((node, pos) => {\n              node.marks.forEach((mark) => {\n                if (isComment(mark)) {\n                  const markThreadId = mark.attrs.threadId;\n                  const isOrphan = !threadMap.has(markThreadId);\n                  if (isOrphan !== mark.attrs.orphan) {\n                    const { tr } = this.editor.state;\n                    const trimmedFrom = Math.max(pos, 0);\n                    const trimmedTo = Math.min(\n                      pos + node.nodeSize,\n                      this.editor.state.doc.content.size - 1\n                    );\n                    tr.removeMark(trimmedFrom, trimmedTo, commentMarkType);\n                    tr.addMark(\n                      trimmedFrom,\n                      trimmedTo,\n                      commentMarkType.create({\n                        ...mark.attrs,\n                        orphan: isOrphan\n                      })\n                    );\n                    this.editor.view.dispatch(tr);\n                  }\n                }\n              });\n            });\n          })\n        );\n      }\n    },\n    onDestroy() {\n      this.storage.unsubs.forEach((unsub) => unsub());\n    },\n    addGlobalAttributes() {\n      return [\n        {\n          types: [\"paragraph\", \"heading\"],\n          attributes: {\n            ychange: { default: null }\n          }\n        }\n      ];\n    },\n    addStorage() {\n      const provider = (0,_liveblocks_yjs__WEBPACK_IMPORTED_MODULE_7__.getYjsProviderForRoom)(room, {\n        enablePermanentUserData: !!options.ai || options.enablePermanentUserData,\n        offlineSupport_experimental: options.offlineSupport_experimental\n      });\n      return {\n        doc: provider.getYDoc(),\n        provider,\n        permanentUserData: provider.permanentUserData,\n        unsubs: []\n      };\n    },\n    addExtensions() {\n      const extensions = [\n        YChangeMark,\n        LiveblocksCollab.configure({\n          ySyncOptions: {\n            permanentUserData: this.storage.permanentUserData\n          },\n          document: this.storage.doc,\n          field: options.field\n        }),\n        _tiptap_extension_collaboration_cursor__WEBPACK_IMPORTED_MODULE_1__[\"default\"].configure({\n          provider: this.storage.provider\n        })\n      ];\n      if (options.comments) {\n        extensions.push(_comments_CommentsExtension_js__WEBPACK_IMPORTED_MODULE_8__.CommentsExtension);\n      }\n      if (options.mentions) {\n        extensions.push(\n          _mentions_MentionExtension_js__WEBPACK_IMPORTED_MODULE_9__.MentionExtension.configure({\n            onCreateMention: createTextMention,\n            onDeleteMention: deleteTextMention\n          })\n        );\n      }\n      if (options.ai) {\n        const resolveContextualPrompt = async ({\n          prompt,\n          context,\n          previous,\n          signal\n        }) => {\n          const result = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_5__.kInternal].executeContextualPrompt({\n            prompt,\n            context,\n            previous,\n            signal\n          });\n          return JSON.parse(result);\n        };\n        extensions.push(\n          _ai_AiExtension_js__WEBPACK_IMPORTED_MODULE_10__.AiExtension.configure({\n            resolveContextualPrompt,\n            ...typeof options.ai === \"boolean\" ? {} : options.ai,\n            doc: this.storage.doc,\n            pud: this.storage.permanentUserData\n          })\n        );\n      }\n      return extensions;\n    }\n  });\n};\n\n\n//# sourceMappingURL=LiveblocksExtension.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvTGl2ZWJsb2Nrc0V4dGVuc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTZEO0FBQ047QUFDaUc7QUFDaEc7QUFDSTtBQUNBO0FBQ2E7QUFDTTtBQUM3QjtBQUNrQjtBQUNGO0FBQ1I7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVFQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNCQUFzQix5RUFBYztBQUNwQyxzQkFBc0Isa0RBQVc7QUFDakM7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQkFBb0Isa0RBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsU0FBUywyREFBb0I7QUFDN0I7QUFDQSxvQkFBb0IsOENBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQkFBZ0I7QUFDaEY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBUTtBQUN0QyxlQUFlLG1FQUFPO0FBQ3RCO0FBQ0EsaUJBQWlCLG9FQUFTO0FBQzFCLGdCQUFnQixvRkFBeUI7QUFDekM7QUFDQSxzQkFBc0IseUVBQWM7QUFDcEMsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSw4RUFBbUI7QUFDckIsSUFBSSw0REFBYztBQUNsQjtBQUNBO0FBQ0EsNEJBQTRCLCtFQUFvQjtBQUNoRCw0QkFBNEIsK0VBQW9CO0FBQ2hELFNBQVMsbURBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5REFBVztBQUMzQyxVQUFVLG1FQUE0QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGlCQUFpQjtBQUM5RTtBQUNBO0FBQ0Esd0NBQXdDLG1FQUE0QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QixzRUFBcUI7QUFDNUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUSw4RUFBbUI7QUFDM0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3Qiw2RUFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyRUFBZ0I7QUFDMUI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyx1REFBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxVQUFVLDREQUFXO0FBQ3JCO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRW9EO0FBQ3BEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC10aXB0YXAvZGlzdC9MaXZlYmxvY2tzRXh0ZW5zaW9uLmpzP2QxMTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dEVkaXRvclR5cGUsIGtJbnRlcm5hbCB9IGZyb20gJ0BsaXZlYmxvY2tzL2NvcmUnO1xuaW1wb3J0IHsgdXNlUm9vbSwgdXNlQ2xpZW50IH0gZnJvbSAnQGxpdmVibG9ja3MvcmVhY3QnO1xuaW1wb3J0IHsgdXNlWWpzUHJvdmlkZXIsIGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQsIHVzZVJlcG9ydFRleHRFZGl0b3IsIHVzZUNyZWF0ZVRleHRNZW50aW9uLCB1c2VEZWxldGVUZXh0TWVudGlvbiB9IGZyb20gJ0BsaXZlYmxvY2tzL3JlYWN0L19wcml2YXRlJztcbmltcG9ydCB7IGdldFlqc1Byb3ZpZGVyRm9yUm9vbSB9IGZyb20gJ0BsaXZlYmxvY2tzL3lqcyc7XG5pbXBvcnQgeyBNYXJrLCBFeHRlbnNpb24sIGdldE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCBDb2xsYWJvcmF0aW9uIGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWNvbGxhYm9yYXRpb24nO1xuaW1wb3J0IENvbGxhYm9yYXRpb25DdXJzb3IgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvbi1jdXJzb3InO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN5bmNFeHRlcm5hbFN0b3JlLCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQWlFeHRlbnNpb24gfSBmcm9tICcuL2FpL0FpRXh0ZW5zaW9uLmpzJztcbmltcG9ydCB7IENvbW1lbnRzRXh0ZW5zaW9uIH0gZnJvbSAnLi9jb21tZW50cy9Db21tZW50c0V4dGVuc2lvbi5qcyc7XG5pbXBvcnQgeyBNZW50aW9uRXh0ZW5zaW9uIH0gZnJvbSAnLi9tZW50aW9ucy9NZW50aW9uRXh0ZW5zaW9uLmpzJztcbmltcG9ydCB7IExJVkVCTE9DS1NfQ09NTUVOVF9NQVJLX1RZUEUgfSBmcm9tICcuL3R5cGVzLmpzJztcblxuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICBmaWVsZDogXCJkZWZhdWx0XCIsXG4gIGNvbW1lbnRzOiB0cnVlLFxuICBtZW50aW9uczogdHJ1ZSxcbiAgb2ZmbGluZVN1cHBvcnRfZXhwZXJpbWVudGFsOiBmYWxzZSxcbiAgZW5hYmxlUGVybWFuZW50VXNlckRhdGE6IGZhbHNlXG59O1xuY29uc3QgTGl2ZWJsb2Nrc0NvbGxhYiA9IENvbGxhYm9yYXRpb24uZXh0ZW5kKHtcbiAgb25DcmVhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmV4dGVuc2lvbnMuZmluZCgoZSkgPT4gZS5uYW1lID09PSBcImRvY1wiKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIltMaXZlYmxvY2tzXSBUaGUgdGlwdGFwIGRvY3VtZW50IGV4dGVuc2lvbiBpcyByZXF1aXJlZCBmb3IgTGl2ZWJsb2NrcyBjb2xsYWJvcmF0aW9uLiBQbGVhc2UgYWRkIGl0IG9yIHVzZSBUaXB0YXAgU3RhcnRlcktpdCBleHRlbnNpb24uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghdGhpcy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5leHRlbnNpb25zLmZpbmQoXG4gICAgICAoZSkgPT4gZS5uYW1lID09PSBcInBhcmFncmFwaFwiXG4gICAgKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIltMaXZlYmxvY2tzXSBUaGUgdGlwdGFwIHBhcmFncmFwaCBleHRlbnNpb24gaXMgcmVxdWlyZWQgZm9yIExpdmVibG9ja3MgY29sbGFib3JhdGlvbi4gUGxlYXNlIGFkZCBpdCBvciB1c2UgVGlwdGFwIFN0YXJ0ZXJLaXQgZXh0ZW5zaW9uLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuZXh0ZW5zaW9ucy5maW5kKChlKSA9PiBlLm5hbWUgPT09IFwidGV4dFwiKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIltMaXZlYmxvY2tzXSBUaGUgdGlwdGFwIHRleHQgZXh0ZW5zaW9uIGlzIHJlcXVpcmVkIGZvciBMaXZlYmxvY2tzIGNvbGxhYm9yYXRpb24uIFBsZWFzZSBhZGQgaXQgb3IgdXNlIFRpcHRhcCBTdGFydGVyS2l0IGV4dGVuc2lvbi5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuZXh0ZW5zaW9ucy5maW5kKChlKSA9PiBlLm5hbWUgPT09IFwiaGlzdG9yeVwiKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIltMaXZlYmxvY2tzXSBUaGUgaGlzdG9yeSBleHRlbnNpb24gaXMgZW5hYmxlZCwgTGl2ZWJsb2NrcyBleHRlbnNpb24gcHJvdmlkZXMgaXRzIG93bi4gUGxlYXNlIHJlbW92ZSBvciBkaXNhYmxlIHRoZSBIaXN0b3J5IHBsdWdpbiB0byBwcmV2ZW50IHVud2FudGVkIGNvbmZsaWN0cy5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gdXNlSXNFZGl0b3JSZWFkeSgpIHtcbiAgY29uc3QgeWpzUHJvdmlkZXIgPSB1c2VZanNQcm92aWRlcigpO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBzdGF0dXMgPSB5anNQcm92aWRlcj8uZ2V0U3RhdHVzKCk7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gXCJzeW5jaHJvbml6aW5nXCIgfHwgc3RhdHVzID09PSBcInN5bmNocm9uaXplZFwiO1xuICB9LCBbeWpzUHJvdmlkZXJdKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2soXG4gICAgKGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAoeWpzUHJvdmlkZXIgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIHlqc1Byb3ZpZGVyLm9uKFwic3RhdHVzXCIsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHlqc1Byb3ZpZGVyLm9mZihcInN0YXR1c1wiLCBjYWxsYmFjayk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgW3lqc1Byb3ZpZGVyXVxuICApO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U25hcHNob3QpO1xufVxuY29uc3QgWUNoYW5nZU1hcmsgPSBNYXJrLmNyZWF0ZSh7XG4gIG5hbWU6IFwieWNoYW5nZVwiLFxuICBpbmNsdXNpdmU6IGZhbHNlLFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogXCJ5Y2hhbmdlXCIgfV07XG4gIH0sXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXI6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ5Y2hhbmdlX3VzZXJcIikgPz8gbnVsbCxcbiAgICAgICAgcmVuZGVySFRNTDogKGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMudXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBcImRhdGEteWNoYW5nZS11c2VyXCI6IGF0dHJpYnV0ZXMudXNlciB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHlwZToge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZShcInljaGFuZ2VfdHlwZVwiKSA/PyBudWxsLFxuICAgICAgICByZW5kZXJIVE1MOiAoYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgIGlmICghYXR0cmlidXRlcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcImRhdGEteWNoYW5nZS10eXBlXCI6IGF0dHJpYnV0ZXMudHlwZSxcbiAgICAgICAgICAgIFwiZGF0YS1saXZlYmxvY2tzXCI6IFwiXCIsXG4gICAgICAgICAgICBjbGFzczogYGxiLXJvb3QgbGItdGlwdGFwLWNoYW5nZSBsYi10aXB0YXAtY2hhbmdlLSR7YXR0cmlidXRlcy50eXBlfWBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShcInljaGFuZ2VfY29sb3JcIikgPz8gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVySFRNTDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcInljaGFuZ2VcIiwgSFRNTEF0dHJpYnV0ZXMsIDBdO1xuICB9XG59KTtcbmNvbnN0IHVzZUxpdmVibG9ja3NFeHRlbnNpb24gPSAob3B0cykgPT4ge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLkRFRkFVTFRfT1BUSU9OUyxcbiAgICAuLi5vcHRzXG4gIH07XG4gIGNvbnN0IFtlZGl0b3IsIHNldEVkaXRvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgaXNFZGl0b3JSZWFkeSA9IHVzZUlzRWRpdG9yUmVhZHkoKTtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCByb29tSWQgPSByb29tLmlkO1xuICBjb25zdCB5anNQcm92aWRlciA9IHVzZVlqc1Byb3ZpZGVyKCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0VkaXRvclJlYWR5IHx8ICF5anNQcm92aWRlciB8fCAhb3B0aW9ucy5pbml0aWFsQ29udGVudCB8fCAhZWRpdG9yKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHlkb2MgPSB5anNQcm92aWRlci5nZXRZRG9jKCk7XG4gICAgY29uc3QgaGFzQ29udGVudFNldCA9IHlkb2MuZ2V0TWFwKFwibGl2ZWJsb2Nrc19jb25maWdcIikuZ2V0KFwiaGFzQ29udGVudFNldFwiKTtcbiAgICBpZiAoIWhhc0NvbnRlbnRTZXQpIHtcbiAgICAgIHlkb2MuZ2V0TWFwKFwibGl2ZWJsb2Nrc19jb25maWdcIikuc2V0KFwiaGFzQ29udGVudFNldFwiLCB0cnVlKTtcbiAgICAgIGVkaXRvci5jb21tYW5kcy5zZXRDb250ZW50KG9wdGlvbnMuaW5pdGlhbENvbnRlbnQpO1xuICAgIH1cbiAgfSwgW2lzRWRpdG9yUmVhZHksIHlqc1Byb3ZpZGVyLCBvcHRpb25zLmluaXRpYWxDb250ZW50LCBlZGl0b3JdKTtcbiAgdXNlUmVwb3J0VGV4dEVkaXRvcihcbiAgICBUZXh0RWRpdG9yVHlwZS5UaXBUYXAsXG4gICAgb3B0aW9ucy5maWVsZCA/PyBERUZBVUxUX09QVElPTlMuZmllbGRcbiAgKTtcbiAgY29uc3QgY3JlYXRlVGV4dE1lbnRpb24gPSB1c2VDcmVhdGVUZXh0TWVudGlvbigpO1xuICBjb25zdCBkZWxldGVUZXh0TWVudGlvbiA9IHVzZURlbGV0ZVRleHRNZW50aW9uKCk7XG4gIHJldHVybiBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiBcImxpdmVibG9ja3NFeHRlbnNpb25cIixcbiAgICBvbkNyZWF0ZSgpIHtcbiAgICAgIHNldEVkaXRvcih0aGlzLmVkaXRvcik7XG4gICAgICBpZiAodGhpcy5lZGl0b3Iub3B0aW9ucy5jb250ZW50KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIltMaXZlYmxvY2tzXSBJbml0aWFsIGNvbnRlbnQgbXVzdCBiZSBzZXQgaW4gdGhlIHVzZUxpdmVibG9ja3NFeHRlbnNpb24gaG9vayBvcHRpb24uIFJlbW92ZSBjb250ZW50IGZyb20geW91ciBlZGl0b3Igb3B0aW9ucy5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMubWVudGlvbnMgJiYgdGhpcy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5leHRlbnNpb25zLmZpbmQoXG4gICAgICAgIChlKSA9PiBlLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJtZW50aW9uXCJcbiAgICAgICkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiW0xpdmVibG9ja3NdIExpdmVibG9ja3Mgb3duIG1lbnRpb24gcGx1Z2luIGlzIGVuYWJsZWQsIHVzaW5nIGFub3RoZXIgbWVudGlvbiBwbHVnaW4gbWF5IGNhdXNlIGEgY29uZmxpY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGYgPSByb29tLmdldFNlbGYoKTtcbiAgICAgIGNvbnN0IHVwZGF0ZVVzZXIgPSAoe1xuICAgICAgICBpbmZvLFxuICAgICAgICBpZDogdXNlcklkXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHVzZXI6IHN0b3JlZFVzZXIgfSA9IHRoaXMuc3RvcmFnZS5wcm92aWRlci5hd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlLnBlcm1hbmVudFVzZXJEYXRhKSB7XG4gICAgICAgICAgY29uc3QgcHVkID0gdGhpcy5zdG9yYWdlLnBlcm1hbmVudFVzZXJEYXRhLmNsaWVudHMuZ2V0KFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRvYy5jbGllbnRJRFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFwdWQgfHwgcHVkICE9PSB1c2VySWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5wZXJtYW5lbnRVc2VyRGF0YS5zZXRVc2VyTWFwcGluZyhcbiAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRvYyxcbiAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRvYy5jbGllbnRJRCxcbiAgICAgICAgICAgICAgdXNlcklkID8/IFwiVW5rbm93blwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mby5uYW1lICE9PSBzdG9yZWRVc2VyPy5uYW1lIHx8IGluZm8uY29sb3IgIT09IHN0b3JlZFVzZXI/LmNvbG9yKSB7XG4gICAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMudXBkYXRlVXNlcih7XG4gICAgICAgICAgICBuYW1lOiBpbmZvLm5hbWUsXG4gICAgICAgICAgICBjb2xvcjogaW5mby5jb2xvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHNlbGY/LmluZm8pIHtcbiAgICAgICAgdXBkYXRlVXNlcihzZWxmKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RvcmFnZS51bnN1YnMucHVzaChyb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZSh1cGRhdGVVc2VyKSk7XG4gICAgICBpZiAob3B0aW9ucy5jb21tZW50cykge1xuICAgICAgICBjb25zdCBjb21tZW50TWFya1R5cGUgPSBnZXRNYXJrVHlwZShcbiAgICAgICAgICBMSVZFQkxPQ0tTX0NPTU1FTlRfTUFSS19UWVBFLFxuICAgICAgICAgIHRoaXMuZWRpdG9yLnNjaGVtYVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0b3JhZ2UudW5zdWJzLnB1c2goXG4gICAgICAgICAgc3RvcmUub3V0cHV0cy50aHJlYWRzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aHJlYWRNYXAgPSBuZXcgTWFwKFxuICAgICAgICAgICAgICBzdG9yZS5vdXRwdXRzLnRocmVhZHMuZ2V0KCkuZmluZE1hbnkocm9vbUlkLCB7IHJlc29sdmVkOiBmYWxzZSB9LCBcImFzY1wiKS5tYXAoKHRocmVhZCkgPT4gW3RocmVhZC5pZCwgdHJ1ZV0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZnVuY3Rpb24gaXNDb21tZW50KG1hcmspIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcmsudHlwZS5uYW1lID09PSBMSVZFQkxPQ0tTX0NPTU1FTlRfTUFSS19UWVBFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lZGl0b3Iuc3RhdGUuZG9jLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKChtYXJrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tbWVudChtYXJrKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWFya1RocmVhZElkID0gbWFyay5hdHRycy50aHJlYWRJZDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGlzT3JwaGFuID0gIXRocmVhZE1hcC5oYXMobWFya1RocmVhZElkKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc09ycGhhbiAhPT0gbWFyay5hdHRycy5vcnBoYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0ciB9ID0gdGhpcy5lZGl0b3Iuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgICAgcG9zICsgbm9kZS5ub2RlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5zdGF0ZS5kb2MuY29udGVudC5zaXplIC0gMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKHRyaW1tZWRGcm9tLCB0cmltbWVkVG8sIGNvbW1lbnRNYXJrVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgICAgICAgdHJpbW1lZEZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgdHJpbW1lZFRvLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRNYXJrVHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWFyay5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ycGhhbjogaXNPcnBoYW5cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci52aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRGVzdHJveSgpIHtcbiAgICAgIHRoaXMuc3RvcmFnZS51bnN1YnMuZm9yRWFjaCgodW5zdWIpID0+IHVuc3ViKCkpO1xuICAgIH0sXG4gICAgYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlczogW1wicGFyYWdyYXBoXCIsIFwiaGVhZGluZ1wiXSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICB5Y2hhbmdlOiB7IGRlZmF1bHQ6IG51bGwgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9LFxuICAgIGFkZFN0b3JhZ2UoKSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGdldFlqc1Byb3ZpZGVyRm9yUm9vbShyb29tLCB7XG4gICAgICAgIGVuYWJsZVBlcm1hbmVudFVzZXJEYXRhOiAhIW9wdGlvbnMuYWkgfHwgb3B0aW9ucy5lbmFibGVQZXJtYW5lbnRVc2VyRGF0YSxcbiAgICAgICAgb2ZmbGluZVN1cHBvcnRfZXhwZXJpbWVudGFsOiBvcHRpb25zLm9mZmxpbmVTdXBwb3J0X2V4cGVyaW1lbnRhbFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb2M6IHByb3ZpZGVyLmdldFlEb2MoKSxcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIHBlcm1hbmVudFVzZXJEYXRhOiBwcm92aWRlci5wZXJtYW5lbnRVc2VyRGF0YSxcbiAgICAgICAgdW5zdWJzOiBbXVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEV4dGVuc2lvbnMoKSB7XG4gICAgICBjb25zdCBleHRlbnNpb25zID0gW1xuICAgICAgICBZQ2hhbmdlTWFyayxcbiAgICAgICAgTGl2ZWJsb2Nrc0NvbGxhYi5jb25maWd1cmUoe1xuICAgICAgICAgIHlTeW5jT3B0aW9uczoge1xuICAgICAgICAgICAgcGVybWFuZW50VXNlckRhdGE6IHRoaXMuc3RvcmFnZS5wZXJtYW5lbnRVc2VyRGF0YVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZG9jdW1lbnQ6IHRoaXMuc3RvcmFnZS5kb2MsXG4gICAgICAgICAgZmllbGQ6IG9wdGlvbnMuZmllbGRcbiAgICAgICAgfSksXG4gICAgICAgIENvbGxhYm9yYXRpb25DdXJzb3IuY29uZmlndXJlKHtcbiAgICAgICAgICBwcm92aWRlcjogdGhpcy5zdG9yYWdlLnByb3ZpZGVyXG4gICAgICAgIH0pXG4gICAgICBdO1xuICAgICAgaWYgKG9wdGlvbnMuY29tbWVudHMpIHtcbiAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKENvbW1lbnRzRXh0ZW5zaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm1lbnRpb25zKSB7XG4gICAgICAgIGV4dGVuc2lvbnMucHVzaChcbiAgICAgICAgICBNZW50aW9uRXh0ZW5zaW9uLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBvbkNyZWF0ZU1lbnRpb246IGNyZWF0ZVRleHRNZW50aW9uLFxuICAgICAgICAgICAgb25EZWxldGVNZW50aW9uOiBkZWxldGVUZXh0TWVudGlvblxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5haSkge1xuICAgICAgICBjb25zdCByZXNvbHZlQ29udGV4dHVhbFByb21wdCA9IGFzeW5jICh7XG4gICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgcHJldmlvdXMsXG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByb29tW2tJbnRlcm5hbF0uZXhlY3V0ZUNvbnRleHR1YWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHByZXZpb3VzLFxuICAgICAgICAgICAgc2lnbmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKFxuICAgICAgICAgIEFpRXh0ZW5zaW9uLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICByZXNvbHZlQ29udGV4dHVhbFByb21wdCxcbiAgICAgICAgICAgIC4uLnR5cGVvZiBvcHRpb25zLmFpID09PSBcImJvb2xlYW5cIiA/IHt9IDogb3B0aW9ucy5haSxcbiAgICAgICAgICAgIGRvYzogdGhpcy5zdG9yYWdlLmRvYyxcbiAgICAgICAgICAgIHB1ZDogdGhpcy5zdG9yYWdlLnBlcm1hbmVudFVzZXJEYXRhXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHRlbnNpb25zO1xuICAgIH1cbiAgfSk7XG59O1xuXG5leHBvcnQgeyB1c2VJc0VkaXRvclJlYWR5LCB1c2VMaXZlYmxvY2tzRXh0ZW5zaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaXZlYmxvY2tzRXh0ZW5zaW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/LiveblocksExtension.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/ai/AiExtension.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/ai/AiExtension.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AiExtension: () => (/* binding */ AiExtension),\n/* harmony export */   DEFAULT_STATE: () => (/* binding */ DEFAULT_STATE),\n/* harmony export */   isContextualPromptDiffResponse: () => (/* binding */ isContextualPromptDiffResponse)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/model */ \"(ssr)/./node_modules/@tiptap/pm/model/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/view/dist/index.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! y-prosemirror */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! y-prosemirror */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../types.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/types.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/utils.js\");\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_AI_NAME = \"AI\";\nconst DEFAULT_STATE = { phase: \"closed\" };\nconst RESOLVE_AI_PROMPT_RETRY_ATTEMPTS = 3;\nconst RESOLVE_AI_PROMPT_RETRY_DELAYS = [1e3, 2e3, 4e3];\nfunction getYjsBinding(editor) {\n  return y_prosemirror__WEBPACK_IMPORTED_MODULE_3__.ySyncPluginKey.getState(editor.view.state).binding;\n}\nfunction getLiveblocksYjsProvider(editor) {\n  return editor.extensionStorage.liveblocksExtension?.provider;\n}\nfunction isContextualPromptDiffResponse(response) {\n  return response.type === \"replace\" || response.type === \"insert\";\n}\nfunction isResolveContextualPromptResponse(response) {\n  return typeof response === \"object\" && response !== null && typeof response.text === \"string\" && typeof response.type === \"string\" && [\"insert\", \"replace\", \"other\"].includes(response.type);\n}\nfunction createParagraph(editor, text) {\n  const paragraph = editor.schema.nodes.paragraph ?? Object.values(editor.schema.nodes).find((node) => node.isBlock);\n  if (!paragraph) {\n    throw new Error(\"Could not create a paragraph.\");\n  }\n  return paragraph.create(null, text ? editor.schema.text(text) : void 0);\n}\nfunction getRevertTransaction(tr, editor, storage, doc) {\n  if (storage.snapshot) {\n    const binding = getYjsBinding(editor);\n    if (binding) {\n      binding.mapping.clear();\n      const docFromSnapshot = (0,yjs__WEBPACK_IMPORTED_MODULE_4__.createDocFromSnapshot)(\n        binding.doc,\n        storage.snapshot\n      );\n      const type = docFromSnapshot.getXmlFragment(\"default\");\n      const fragmentContent = (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_5__.yXmlFragmentToProseMirrorFragment)(\n        type,\n        editor.state.schema\n      );\n      tr.setMeta(\"addToHistory\", false);\n      tr.replace(\n        0,\n        editor.state.doc.content.size,\n        new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_0__.Slice(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(fragmentContent), 0, 0)\n      );\n      tr.setMeta(y_prosemirror__WEBPACK_IMPORTED_MODULE_3__.ySyncPluginKey, {\n        snapshot: null,\n        prevSnapshot: null\n      });\n      if (doc) {\n        doc.gc = true;\n      }\n      storage.snapshot = void 0;\n      return tr;\n    }\n  }\n  return null;\n}\nconst AiExtension = _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Extension.create({\n  name: \"liveblocksAi\",\n  addOptions() {\n    return {\n      doc: void 0,\n      pud: void 0,\n      resolveContextualPrompt: () => Promise.reject(),\n      name: DEFAULT_AI_NAME\n    };\n  },\n  addStorage() {\n    return {\n      state: DEFAULT_STATE,\n      name: this.options.name\n    };\n  },\n  addCommands() {\n    return {\n      askAi: (prompt) => () => {\n        if (typeof prompt === \"string\") {\n          this.editor.commands.$startAiToolbarThinking(prompt);\n        } else {\n          this.editor.commands.$openAiToolbarAsking();\n        }\n        return true;\n      },\n      $acceptAiToolbarResponse: () => ({ tr, view }) => {\n        const currentState = this.storage.state;\n        if (currentState.phase !== \"reviewing\") {\n          return false;\n        }\n        if (isContextualPromptDiffResponse(currentState.response)) {\n          const binding = getYjsBinding(this.editor);\n          if (!binding) {\n            return false;\n          }\n          const fragmentContent = (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_5__.yXmlFragmentToProseMirrorFragment)(\n            binding.type,\n            this.editor.state.schema\n          );\n          tr.setMeta(\"addToHistory\", false);\n          tr.replace(\n            0,\n            this.editor.state.doc.content.size,\n            new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_0__.Slice(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(fragmentContent), 0, 0)\n          );\n          tr.setMeta(y_prosemirror__WEBPACK_IMPORTED_MODULE_3__.ySyncPluginKey, {\n            snapshot: null,\n            prevSnapshot: null\n          });\n          this.storage.snapshot = void 0;\n        } else {\n          const paragraphs = currentState.response.text.split(\"\\n\").map((paragraph) => createParagraph(this.editor, paragraph));\n          tr.insert(this.editor.state.selection.$to.end(), paragraphs);\n          tr.setMeta(\"addToHistory\", true);\n          view.dispatch(tr);\n          tr.setMeta(\"preventDispatch\", true);\n        }\n        getLiveblocksYjsProvider(this.editor)?.unpause();\n        this.editor.setEditable(true);\n        this.storage.state = { phase: \"closed\" };\n        return true;\n      },\n      $closeAiToolbar: () => ({ tr, view }) => {\n        const currentState = this.storage.state;\n        if (currentState.phase === \"closed\") {\n          return false;\n        }\n        if (currentState.phase === \"thinking\") {\n          currentState.abortController.abort();\n        }\n        if (currentState.phase === \"thinking\" || currentState.phase === \"reviewing\") {\n          const revertTr = getRevertTransaction(\n            tr,\n            this.editor,\n            this.storage,\n            this.options.doc\n          );\n          if (revertTr) {\n            view.dispatch(revertTr);\n            tr.setMeta(\"preventDispatch\", true);\n          }\n        }\n        this.editor.commands.setTextSelection(currentState.initialSelection);\n        getLiveblocksYjsProvider(this.editor)?.unpause();\n        this.editor.setEditable(true);\n        this.storage.state = { phase: \"closed\" };\n        return true;\n      },\n      $openAiToolbarAsking: () => () => {\n        const currentState = this.storage.state;\n        if (currentState.phase !== \"closed\") {\n          return false;\n        }\n        if (this.editor.isFocused) {\n          this.editor.commands.blur();\n        }\n        this.storage.state = {\n          phase: \"asking\",\n          initialSelection: {\n            from: this.editor.state.selection.from,\n            to: this.editor.state.selection.to\n          },\n          customPrompt: \"\"\n        };\n        return true;\n      },\n      $startAiToolbarThinking: (prompt, withPreviousResponse) => ({ tr, view }) => {\n        const currentState = this.storage.state;\n        if (currentState.phase === \"thinking\") {\n          return false;\n        }\n        if (this.editor.isFocused) {\n          this.editor.commands.blur();\n        }\n        const abortController = new AbortController();\n        const provider = getLiveblocksYjsProvider(this.editor);\n        if (currentState.phase === \"reviewing\") {\n          const revertTr = getRevertTransaction(\n            tr,\n            this.editor,\n            this.storage,\n            this.options.doc\n          );\n          if (revertTr) {\n            view.dispatch(revertTr);\n            tr.setMeta(\"preventDispatch\", true);\n          }\n          this.editor.commands.setTextSelection(\n            currentState.initialSelection\n          );\n        }\n        this.storage.state = {\n          phase: \"thinking\",\n          initialSelection: currentState.initialSelection ?? {\n            from: this.editor.state.selection.from,\n            to: this.editor.state.selection.to\n          },\n          customPrompt: currentState.customPrompt ?? \"\",\n          prompt,\n          abortController,\n          previousResponse: currentState.response\n        };\n        this.editor.setEditable(false);\n        (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_7__.autoRetry)(\n          async () => {\n            await provider?.pause();\n            const response = await this.options.resolveContextualPrompt({\n              prompt,\n              context: (0,_utils_js__WEBPACK_IMPORTED_MODULE_8__.getContextualPromptContext)(this.editor, 3e3),\n              signal: abortController.signal,\n              previous: withPreviousResponse && currentState.phase === \"reviewing\" ? {\n                prompt: currentState.prompt,\n                response: {\n                  type: currentState.response?.type,\n                  text: currentState.response?.text\n                }\n              } : void 0\n            });\n            if (isResolveContextualPromptResponse(response)) {\n              return response;\n            } else {\n              throw new Error(\"Failed to resolve AI prompt.\");\n            }\n          },\n          RESOLVE_AI_PROMPT_RETRY_ATTEMPTS,\n          RESOLVE_AI_PROMPT_RETRY_DELAYS,\n          (error) => {\n            return abortController.signal.aborted || error instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_7__.HttpError && error.status >= 400 && error.status < 500;\n          }\n        ).then((response) => {\n          if (abortController.signal.aborted) {\n            return;\n          }\n          this.editor.commands._handleAiToolbarThinkingSuccess({\n            type: response.type,\n            text: response.text\n          });\n        }).catch((error) => {\n          if (abortController.signal.aborted) {\n            return;\n          }\n          this.editor.commands._handleAiToolbarThinkingError(error);\n        });\n        return true;\n      },\n      $cancelAiToolbarThinking: () => () => {\n        const currentState = this.storage.state;\n        if (currentState.phase !== \"thinking\") {\n          return false;\n        }\n        currentState.abortController.abort();\n        this.editor.setEditable(true);\n        this.storage.state = {\n          phase: \"asking\",\n          initialSelection: currentState.initialSelection,\n          customPrompt: currentState.prompt === currentState.customPrompt ? currentState.customPrompt : \"\"\n        };\n        return true;\n      },\n      _showAiToolbarReviewingDiff: () => () => {\n        if (this.storage.state.phase !== \"reviewing\") {\n          return false;\n        }\n        if (!this.options.doc || !this.storage.snapshot) {\n          return false;\n        }\n        const previousSnapshot = this.storage.snapshot ?? yjs__WEBPACK_IMPORTED_MODULE_4__.emptySnapshot;\n        const currentSnapshot = (0,yjs__WEBPACK_IMPORTED_MODULE_4__.snapshot)(this.options.doc);\n        if ((0,yjs__WEBPACK_IMPORTED_MODULE_4__.equalSnapshots)(previousSnapshot, currentSnapshot)) {\n          return true;\n        }\n        getYjsBinding(this.editor)?.renderSnapshot(\n          currentSnapshot,\n          previousSnapshot\n        );\n        return true;\n      },\n      _handleAiToolbarThinkingSuccess: (response) => ({ view, tr }) => {\n        const currentState = this.storage.state;\n        if (currentState.phase !== \"thinking\") {\n          return false;\n        }\n        if (!isContextualPromptDiffResponse(response)) {\n          this.storage.state = {\n            phase: \"reviewing\",\n            initialSelection: currentState.initialSelection,\n            customPrompt: \"\",\n            prompt: currentState.prompt,\n            response\n          };\n          return true;\n        }\n        if (!this.options.doc) {\n          return false;\n        }\n        this.options.doc.gc = false;\n        this.storage.snapshot = (0,yjs__WEBPACK_IMPORTED_MODULE_4__.snapshot)(this.options.doc);\n        this.storage.state = {\n          phase: \"reviewing\",\n          initialSelection: currentState.initialSelection,\n          customPrompt: \"\",\n          prompt: currentState.prompt,\n          response\n        };\n        const [firstParagraph, ...otherParagraphs] = response.text.split(\"\\n\");\n        tr.insertText(\n          firstParagraph,\n          response.type === \"insert\" ? this.editor.state.selection.to : this.editor.state.selection.from,\n          this.editor.state.selection.to\n        );\n        if (otherParagraphs.length > 0) {\n          const paragraphs = otherParagraphs.map(\n            (paragraph) => createParagraph(this.editor, paragraph)\n          );\n          tr.insert(tr.selection.$to.pos, paragraphs);\n        }\n        view.dispatch(tr);\n        tr.setMeta(\"preventDispatch\", true);\n        this.editor.commands._showAiToolbarReviewingDiff();\n        return true;\n      },\n      _handleAiToolbarThinkingError: (error) => () => {\n        const currentState = this.storage.state;\n        if (currentState.phase !== \"thinking\") {\n          return false;\n        }\n        this.editor.setEditable(true);\n        console.error(error);\n        this.storage.state = {\n          phase: \"asking\",\n          initialSelection: currentState.initialSelection,\n          customPrompt: currentState.prompt === currentState.customPrompt ? currentState.customPrompt : \"\",\n          error: error instanceof Error ? error : new Error(String(error), { cause: error })\n        };\n        return true;\n      },\n      _updateAiToolbarCustomPrompt: (customPrompt) => () => {\n        const currentState = this.storage.state;\n        if (typeof currentState.customPrompt !== \"string\") {\n          return false;\n        }\n        this.storage.state.customPrompt = typeof customPrompt === \"function\" ? customPrompt(currentState.customPrompt) : customPrompt;\n        return true;\n      }\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: _types_js__WEBPACK_IMPORTED_MODULE_9__.AI_TOOLBAR_SELECTION_PLUGIN,\n        props: {\n          decorations: ({ doc, selection }) => {\n            if (this.storage.state.phase === \"closed\" || this.storage.state.phase === \"reviewing\" && isContextualPromptDiffResponse(this.storage.state.response)) {\n              return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(doc, []);\n            }\n            const { from, to } = selection;\n            const decorations = [\n              _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.inline(from, to, {\n                class: \"lb-root lb-selection lb-tiptap-active-selection\"\n              })\n            ];\n            return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(doc, decorations);\n          }\n        }\n      })\n    ];\n  }\n});\n\n\n//# sourceMappingURL=AiExtension.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvYWkvQWlFeHRlbnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNmO0FBQ1U7QUFDVDtBQUNrQjtBQUNzQjtBQUNHO0FBQzNCO0FBQ0Q7O0FBRXpEO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdGQUFpQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQUssQ0FBQyxzREFBUTtBQUMxQjtBQUNBLGlCQUFpQix5REFBYztBQUMvQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseUNBQXlDLFVBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdGQUFpQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBSyxDQUFDLHNEQUFRO0FBQzlCO0FBQ0EscUJBQXFCLHlEQUFjO0FBQ25DO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLE9BQU87QUFDUCxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0VBQW9FLFVBQVU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJEQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFFQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSx1REFBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw4Q0FBYTtBQUN2RSxnQ0FBZ0MsNkNBQVE7QUFDeEMsWUFBWSxtREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3REFBd0QsVUFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGNBQWM7QUFDM0Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsb0RBQU07QUFDaEIsYUFBYSxrRUFBMkI7QUFDeEM7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0EscUJBQXFCLDBEQUFhO0FBQ2xDO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSxjQUFjLHVEQUFVO0FBQ3hCO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsbUJBQW1CLDBEQUFhO0FBQ2hDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRXFFO0FBQ3RFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC10aXB0YXAvZGlzdC9haS9BaUV4dGVuc2lvbi5qcz81ZGFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGF1dG9SZXRyeSwgSHR0cEVycm9yIH0gZnJvbSAnQGxpdmVibG9ja3MvY29yZSc7XG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50IH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCc7XG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB7IERlY29yYXRpb25TZXQsIERlY29yYXRpb24gfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnO1xuaW1wb3J0IHsgeVN5bmNQbHVnaW5LZXksIHlYbWxGcmFnbWVudFRvUHJvc2VNaXJyb3JGcmFnbWVudCB9IGZyb20gJ3ktcHJvc2VtaXJyb3InO1xuaW1wb3J0IHsgY3JlYXRlRG9jRnJvbVNuYXBzaG90LCBlbXB0eVNuYXBzaG90LCBzbmFwc2hvdCwgZXF1YWxTbmFwc2hvdHMgfSBmcm9tICd5anMnO1xuaW1wb3J0IHsgQUlfVE9PTEJBUl9TRUxFQ1RJT05fUExVR0lOIH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHsgZ2V0Q29udGV4dHVhbFByb21wdENvbnRleHQgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbmNvbnN0IERFRkFVTFRfQUlfTkFNRSA9IFwiQUlcIjtcbmNvbnN0IERFRkFVTFRfU1RBVEUgPSB7IHBoYXNlOiBcImNsb3NlZFwiIH07XG5jb25zdCBSRVNPTFZFX0FJX1BST01QVF9SRVRSWV9BVFRFTVBUUyA9IDM7XG5jb25zdCBSRVNPTFZFX0FJX1BST01QVF9SRVRSWV9ERUxBWVMgPSBbMWUzLCAyZTMsIDRlM107XG5mdW5jdGlvbiBnZXRZanNCaW5kaW5nKGVkaXRvcikge1xuICByZXR1cm4geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUoZWRpdG9yLnZpZXcuc3RhdGUpLmJpbmRpbmc7XG59XG5mdW5jdGlvbiBnZXRMaXZlYmxvY2tzWWpzUHJvdmlkZXIoZWRpdG9yKSB7XG4gIHJldHVybiBlZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZS5saXZlYmxvY2tzRXh0ZW5zaW9uPy5wcm92aWRlcjtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dHVhbFByb21wdERpZmZSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2UudHlwZSA9PT0gXCJyZXBsYWNlXCIgfHwgcmVzcG9uc2UudHlwZSA9PT0gXCJpbnNlcnRcIjtcbn1cbmZ1bmN0aW9uIGlzUmVzb2x2ZUNvbnRleHR1YWxQcm9tcHRSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gdHlwZW9mIHJlc3BvbnNlID09PSBcIm9iamVjdFwiICYmIHJlc3BvbnNlICE9PSBudWxsICYmIHR5cGVvZiByZXNwb25zZS50ZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByZXNwb25zZS50eXBlID09PSBcInN0cmluZ1wiICYmIFtcImluc2VydFwiLCBcInJlcGxhY2VcIiwgXCJvdGhlclwiXS5pbmNsdWRlcyhyZXNwb25zZS50eXBlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFncmFwaChlZGl0b3IsIHRleHQpIHtcbiAgY29uc3QgcGFyYWdyYXBoID0gZWRpdG9yLnNjaGVtYS5ub2Rlcy5wYXJhZ3JhcGggPz8gT2JqZWN0LnZhbHVlcyhlZGl0b3Iuc2NoZW1hLm5vZGVzKS5maW5kKChub2RlKSA9PiBub2RlLmlzQmxvY2spO1xuICBpZiAoIXBhcmFncmFwaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgYSBwYXJhZ3JhcGguXCIpO1xuICB9XG4gIHJldHVybiBwYXJhZ3JhcGguY3JlYXRlKG51bGwsIHRleHQgPyBlZGl0b3Iuc2NoZW1hLnRleHQodGV4dCkgOiB2b2lkIDApO1xufVxuZnVuY3Rpb24gZ2V0UmV2ZXJ0VHJhbnNhY3Rpb24odHIsIGVkaXRvciwgc3RvcmFnZSwgZG9jKSB7XG4gIGlmIChzdG9yYWdlLnNuYXBzaG90KSB7XG4gICAgY29uc3QgYmluZGluZyA9IGdldFlqc0JpbmRpbmcoZWRpdG9yKTtcbiAgICBpZiAoYmluZGluZykge1xuICAgICAgYmluZGluZy5tYXBwaW5nLmNsZWFyKCk7XG4gICAgICBjb25zdCBkb2NGcm9tU25hcHNob3QgPSBjcmVhdGVEb2NGcm9tU25hcHNob3QoXG4gICAgICAgIGJpbmRpbmcuZG9jLFxuICAgICAgICBzdG9yYWdlLnNuYXBzaG90XG4gICAgICApO1xuICAgICAgY29uc3QgdHlwZSA9IGRvY0Zyb21TbmFwc2hvdC5nZXRYbWxGcmFnbWVudChcImRlZmF1bHRcIik7XG4gICAgICBjb25zdCBmcmFnbWVudENvbnRlbnQgPSB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yRnJhZ21lbnQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGVkaXRvci5zdGF0ZS5zY2hlbWFcbiAgICAgICk7XG4gICAgICB0ci5zZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIsIGZhbHNlKTtcbiAgICAgIHRyLnJlcGxhY2UoXG4gICAgICAgIDAsXG4gICAgICAgIGVkaXRvci5zdGF0ZS5kb2MuY29udGVudC5zaXplLFxuICAgICAgICBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShmcmFnbWVudENvbnRlbnQpLCAwLCAwKVxuICAgICAgKTtcbiAgICAgIHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHtcbiAgICAgICAgc25hcHNob3Q6IG51bGwsXG4gICAgICAgIHByZXZTbmFwc2hvdDogbnVsbFxuICAgICAgfSk7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIGRvYy5nYyA9IHRydWU7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNuYXBzaG90ID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHRyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IEFpRXh0ZW5zaW9uID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwibGl2ZWJsb2Nrc0FpXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvYzogdm9pZCAwLFxuICAgICAgcHVkOiB2b2lkIDAsXG4gICAgICByZXNvbHZlQ29udGV4dHVhbFByb21wdDogKCkgPT4gUHJvbWlzZS5yZWplY3QoKSxcbiAgICAgIG5hbWU6IERFRkFVTFRfQUlfTkFNRVxuICAgIH07XG4gIH0sXG4gIGFkZFN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlOiBERUZBVUxUX1NUQVRFLFxuICAgICAgbmFtZTogdGhpcy5vcHRpb25zLm5hbWVcbiAgICB9O1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXNrQWk6IChwcm9tcHQpID0+ICgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9tcHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy4kc3RhcnRBaVRvb2xiYXJUaGlua2luZyhwcm9tcHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLiRvcGVuQWlUb29sYmFyQXNraW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgJGFjY2VwdEFpVG9vbGJhclJlc3BvbnNlOiAoKSA9PiAoeyB0ciwgdmlldyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RvcmFnZS5zdGF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5waGFzZSAhPT0gXCJyZXZpZXdpbmdcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb250ZXh0dWFsUHJvbXB0RGlmZlJlc3BvbnNlKGN1cnJlbnRTdGF0ZS5yZXNwb25zZSkpIHtcbiAgICAgICAgICBjb25zdCBiaW5kaW5nID0gZ2V0WWpzQmluZGluZyh0aGlzLmVkaXRvcik7XG4gICAgICAgICAgaWYgKCFiaW5kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZyYWdtZW50Q29udGVudCA9IHlYbWxGcmFnbWVudFRvUHJvc2VNaXJyb3JGcmFnbWVudChcbiAgICAgICAgICAgIGJpbmRpbmcudHlwZSxcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnN0YXRlLnNjaGVtYVxuICAgICAgICAgICk7XG4gICAgICAgICAgdHIuc2V0TWV0YShcImFkZFRvSGlzdG9yeVwiLCBmYWxzZSk7XG4gICAgICAgICAgdHIucmVwbGFjZShcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5zdGF0ZS5kb2MuY29udGVudC5zaXplLFxuICAgICAgICAgICAgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oZnJhZ21lbnRDb250ZW50KSwgMCwgMClcbiAgICAgICAgICApO1xuICAgICAgICAgIHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHtcbiAgICAgICAgICAgIHNuYXBzaG90OiBudWxsLFxuICAgICAgICAgICAgcHJldlNuYXBzaG90OiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5zdG9yYWdlLnNuYXBzaG90ID0gdm9pZCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhcmFncmFwaHMgPSBjdXJyZW50U3RhdGUucmVzcG9uc2UudGV4dC5zcGxpdChcIlxcblwiKS5tYXAoKHBhcmFncmFwaCkgPT4gY3JlYXRlUGFyYWdyYXBoKHRoaXMuZWRpdG9yLCBwYXJhZ3JhcGgpKTtcbiAgICAgICAgICB0ci5pbnNlcnQodGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLiR0by5lbmQoKSwgcGFyYWdyYXBocyk7XG4gICAgICAgICAgdHIuc2V0TWV0YShcImFkZFRvSGlzdG9yeVwiLCB0cnVlKTtcbiAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICB0ci5zZXRNZXRhKFwicHJldmVudERpc3BhdGNoXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGdldExpdmVibG9ja3NZanNQcm92aWRlcih0aGlzLmVkaXRvcik/LnVucGF1c2UoKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iuc2V0RWRpdGFibGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zdGF0ZSA9IHsgcGhhc2U6IFwiY2xvc2VkXCIgfTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgJGNsb3NlQWlUb29sYmFyOiAoKSA9PiAoeyB0ciwgdmlldyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RvcmFnZS5zdGF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5waGFzZSA9PT0gXCJjbG9zZWRcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFN0YXRlLnBoYXNlID09PSBcInRoaW5raW5nXCIpIHtcbiAgICAgICAgICBjdXJyZW50U3RhdGUuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5waGFzZSA9PT0gXCJ0aGlua2luZ1wiIHx8IGN1cnJlbnRTdGF0ZS5waGFzZSA9PT0gXCJyZXZpZXdpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHJldmVydFRyID0gZ2V0UmV2ZXJ0VHJhbnNhY3Rpb24oXG4gICAgICAgICAgICB0cixcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRvY1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHJldmVydFRyKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHJldmVydFRyKTtcbiAgICAgICAgICAgIHRyLnNldE1ldGEoXCJwcmV2ZW50RGlzcGF0Y2hcIiwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFRleHRTZWxlY3Rpb24oY3VycmVudFN0YXRlLmluaXRpYWxTZWxlY3Rpb24pO1xuICAgICAgICBnZXRMaXZlYmxvY2tzWWpzUHJvdmlkZXIodGhpcy5lZGl0b3IpPy51bnBhdXNlKCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnNldEVkaXRhYmxlKHRydWUpO1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc3RhdGUgPSB7IHBoYXNlOiBcImNsb3NlZFwiIH07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgICRvcGVuQWlUb29sYmFyQXNraW5nOiAoKSA9PiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RvcmFnZS5zdGF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5waGFzZSAhPT0gXCJjbG9zZWRcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3IuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuYmx1cigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zdGF0ZSA9IHtcbiAgICAgICAgICBwaGFzZTogXCJhc2tpbmdcIixcbiAgICAgICAgICBpbml0aWFsU2VsZWN0aW9uOiB7XG4gICAgICAgICAgICBmcm9tOiB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbSxcbiAgICAgICAgICAgIHRvOiB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb24udG9cbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1c3RvbVByb21wdDogXCJcIlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICAkc3RhcnRBaVRvb2xiYXJUaGlua2luZzogKHByb21wdCwgd2l0aFByZXZpb3VzUmVzcG9uc2UpID0+ICh7IHRyLCB2aWV3IH0pID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5zdG9yYWdlLnN0YXRlO1xuICAgICAgICBpZiAoY3VycmVudFN0YXRlLnBoYXNlID09PSBcInRoaW5raW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yLmlzRm9jdXNlZCkge1xuICAgICAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmJsdXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0TGl2ZWJsb2Nrc1lqc1Byb3ZpZGVyKHRoaXMuZWRpdG9yKTtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5waGFzZSA9PT0gXCJyZXZpZXdpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHJldmVydFRyID0gZ2V0UmV2ZXJ0VHJhbnNhY3Rpb24oXG4gICAgICAgICAgICB0cixcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRvY1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHJldmVydFRyKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHJldmVydFRyKTtcbiAgICAgICAgICAgIHRyLnNldE1ldGEoXCJwcmV2ZW50RGlzcGF0Y2hcIiwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFRleHRTZWxlY3Rpb24oXG4gICAgICAgICAgICBjdXJyZW50U3RhdGUuaW5pdGlhbFNlbGVjdGlvblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yYWdlLnN0YXRlID0ge1xuICAgICAgICAgIHBoYXNlOiBcInRoaW5raW5nXCIsXG4gICAgICAgICAgaW5pdGlhbFNlbGVjdGlvbjogY3VycmVudFN0YXRlLmluaXRpYWxTZWxlY3Rpb24gPz8ge1xuICAgICAgICAgICAgZnJvbTogdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmZyb20sXG4gICAgICAgICAgICB0bzogdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLnRvXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXN0b21Qcm9tcHQ6IGN1cnJlbnRTdGF0ZS5jdXN0b21Qcm9tcHQgPz8gXCJcIixcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLFxuICAgICAgICAgIHByZXZpb3VzUmVzcG9uc2U6IGN1cnJlbnRTdGF0ZS5yZXNwb25zZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVkaXRvci5zZXRFZGl0YWJsZShmYWxzZSk7XG4gICAgICAgIGF1dG9SZXRyeShcbiAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBwcm92aWRlcj8ucGF1c2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5vcHRpb25zLnJlc29sdmVDb250ZXh0dWFsUHJvbXB0KHtcbiAgICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgICBjb250ZXh0OiBnZXRDb250ZXh0dWFsUHJvbXB0Q29udGV4dCh0aGlzLmVkaXRvciwgM2UzKSxcbiAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICBwcmV2aW91czogd2l0aFByZXZpb3VzUmVzcG9uc2UgJiYgY3VycmVudFN0YXRlLnBoYXNlID09PSBcInJldmlld2luZ1wiID8ge1xuICAgICAgICAgICAgICAgIHByb21wdDogY3VycmVudFN0YXRlLnByb21wdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgdHlwZTogY3VycmVudFN0YXRlLnJlc3BvbnNlPy50eXBlLFxuICAgICAgICAgICAgICAgICAgdGV4dDogY3VycmVudFN0YXRlLnJlc3BvbnNlPy50ZXh0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IDogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1Jlc29sdmVDb250ZXh0dWFsUHJvbXB0UmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byByZXNvbHZlIEFJIHByb21wdC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBSRVNPTFZFX0FJX1BST01QVF9SRVRSWV9BVFRFTVBUUyxcbiAgICAgICAgICBSRVNPTFZFX0FJX1BST01QVF9SRVRSWV9ERUxBWVMsXG4gICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkIHx8IGVycm9yIGluc3RhbmNlb2YgSHR0cEVycm9yICYmIGVycm9yLnN0YXR1cyA+PSA0MDAgJiYgZXJyb3Iuc3RhdHVzIDwgNTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuX2hhbmRsZUFpVG9vbGJhclRoaW5raW5nU3VjY2Vzcyh7XG4gICAgICAgICAgICB0eXBlOiByZXNwb25zZS50eXBlLFxuICAgICAgICAgICAgdGV4dDogcmVzcG9uc2UudGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLl9oYW5kbGVBaVRvb2xiYXJUaGlua2luZ0Vycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgICRjYW5jZWxBaVRvb2xiYXJUaGlua2luZzogKCkgPT4gKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLnN0b3JhZ2Uuc3RhdGU7XG4gICAgICAgIGlmIChjdXJyZW50U3RhdGUucGhhc2UgIT09IFwidGhpbmtpbmdcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50U3RhdGUuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnNldEVkaXRhYmxlKHRydWUpO1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc3RhdGUgPSB7XG4gICAgICAgICAgcGhhc2U6IFwiYXNraW5nXCIsXG4gICAgICAgICAgaW5pdGlhbFNlbGVjdGlvbjogY3VycmVudFN0YXRlLmluaXRpYWxTZWxlY3Rpb24sXG4gICAgICAgICAgY3VzdG9tUHJvbXB0OiBjdXJyZW50U3RhdGUucHJvbXB0ID09PSBjdXJyZW50U3RhdGUuY3VzdG9tUHJvbXB0ID8gY3VycmVudFN0YXRlLmN1c3RvbVByb21wdCA6IFwiXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgX3Nob3dBaVRvb2xiYXJSZXZpZXdpbmdEaWZmOiAoKSA9PiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0b3JhZ2Uuc3RhdGUucGhhc2UgIT09IFwicmV2aWV3aW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZG9jIHx8ICF0aGlzLnN0b3JhZ2Uuc25hcHNob3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNTbmFwc2hvdCA9IHRoaXMuc3RvcmFnZS5zbmFwc2hvdCA/PyBlbXB0eVNuYXBzaG90O1xuICAgICAgICBjb25zdCBjdXJyZW50U25hcHNob3QgPSBzbmFwc2hvdCh0aGlzLm9wdGlvbnMuZG9jKTtcbiAgICAgICAgaWYgKGVxdWFsU25hcHNob3RzKHByZXZpb3VzU25hcHNob3QsIGN1cnJlbnRTbmFwc2hvdCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRZanNCaW5kaW5nKHRoaXMuZWRpdG9yKT8ucmVuZGVyU25hcHNob3QoXG4gICAgICAgICAgY3VycmVudFNuYXBzaG90LFxuICAgICAgICAgIHByZXZpb3VzU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgX2hhbmRsZUFpVG9vbGJhclRoaW5raW5nU3VjY2VzczogKHJlc3BvbnNlKSA9PiAoeyB2aWV3LCB0ciB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RvcmFnZS5zdGF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5waGFzZSAhPT0gXCJ0aGlua2luZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNDb250ZXh0dWFsUHJvbXB0RGlmZlJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgICAgIHRoaXMuc3RvcmFnZS5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHBoYXNlOiBcInJldmlld2luZ1wiLFxuICAgICAgICAgICAgaW5pdGlhbFNlbGVjdGlvbjogY3VycmVudFN0YXRlLmluaXRpYWxTZWxlY3Rpb24sXG4gICAgICAgICAgICBjdXN0b21Qcm9tcHQ6IFwiXCIsXG4gICAgICAgICAgICBwcm9tcHQ6IGN1cnJlbnRTdGF0ZS5wcm9tcHQsXG4gICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZG9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5kb2MuZ2MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNuYXBzaG90ID0gc25hcHNob3QodGhpcy5vcHRpb25zLmRvYyk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zdGF0ZSA9IHtcbiAgICAgICAgICBwaGFzZTogXCJyZXZpZXdpbmdcIixcbiAgICAgICAgICBpbml0aWFsU2VsZWN0aW9uOiBjdXJyZW50U3RhdGUuaW5pdGlhbFNlbGVjdGlvbixcbiAgICAgICAgICBjdXN0b21Qcm9tcHQ6IFwiXCIsXG4gICAgICAgICAgcHJvbXB0OiBjdXJyZW50U3RhdGUucHJvbXB0LFxuICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IFtmaXJzdFBhcmFncmFwaCwgLi4ub3RoZXJQYXJhZ3JhcGhzXSA9IHJlc3BvbnNlLnRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIHRyLmluc2VydFRleHQoXG4gICAgICAgICAgZmlyc3RQYXJhZ3JhcGgsXG4gICAgICAgICAgcmVzcG9uc2UudHlwZSA9PT0gXCJpbnNlcnRcIiA/IHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi50byA6IHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5mcm9tLFxuICAgICAgICAgIHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi50b1xuICAgICAgICApO1xuICAgICAgICBpZiAob3RoZXJQYXJhZ3JhcGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhzID0gb3RoZXJQYXJhZ3JhcGhzLm1hcChcbiAgICAgICAgICAgIChwYXJhZ3JhcGgpID0+IGNyZWF0ZVBhcmFncmFwaCh0aGlzLmVkaXRvciwgcGFyYWdyYXBoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdHIuaW5zZXJ0KHRyLnNlbGVjdGlvbi4kdG8ucG9zLCBwYXJhZ3JhcGhzKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgdHIuc2V0TWV0YShcInByZXZlbnREaXNwYXRjaFwiLCB0cnVlKTtcbiAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuX3Nob3dBaVRvb2xiYXJSZXZpZXdpbmdEaWZmKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIF9oYW5kbGVBaVRvb2xiYXJUaGlua2luZ0Vycm9yOiAoZXJyb3IpID0+ICgpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5zdG9yYWdlLnN0YXRlO1xuICAgICAgICBpZiAoY3VycmVudFN0YXRlLnBoYXNlICE9PSBcInRoaW5raW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3Iuc2V0RWRpdGFibGUodHJ1ZSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc3RhdGUgPSB7XG4gICAgICAgICAgcGhhc2U6IFwiYXNraW5nXCIsXG4gICAgICAgICAgaW5pdGlhbFNlbGVjdGlvbjogY3VycmVudFN0YXRlLmluaXRpYWxTZWxlY3Rpb24sXG4gICAgICAgICAgY3VzdG9tUHJvbXB0OiBjdXJyZW50U3RhdGUucHJvbXB0ID09PSBjdXJyZW50U3RhdGUuY3VzdG9tUHJvbXB0ID8gY3VycmVudFN0YXRlLmN1c3RvbVByb21wdCA6IFwiXCIsXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpLCB7IGNhdXNlOiBlcnJvciB9KVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBfdXBkYXRlQWlUb29sYmFyQ3VzdG9tUHJvbXB0OiAoY3VzdG9tUHJvbXB0KSA9PiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RvcmFnZS5zdGF0ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50U3RhdGUuY3VzdG9tUHJvbXB0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zdGF0ZS5jdXN0b21Qcm9tcHQgPSB0eXBlb2YgY3VzdG9tUHJvbXB0ID09PSBcImZ1bmN0aW9uXCIgPyBjdXN0b21Qcm9tcHQoY3VycmVudFN0YXRlLmN1c3RvbVByb21wdCkgOiBjdXN0b21Qcm9tcHQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogQUlfVE9PTEJBUl9TRUxFQ1RJT05fUExVR0lOLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGRlY29yYXRpb25zOiAoeyBkb2MsIHNlbGVjdGlvbiB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9yYWdlLnN0YXRlLnBoYXNlID09PSBcImNsb3NlZFwiIHx8IHRoaXMuc3RvcmFnZS5zdGF0ZS5waGFzZSA9PT0gXCJyZXZpZXdpbmdcIiAmJiBpc0NvbnRleHR1YWxQcm9tcHREaWZmUmVzcG9uc2UodGhpcy5zdG9yYWdlLnN0YXRlLnJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoZG9jLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9ucyA9IFtcbiAgICAgICAgICAgICAgRGVjb3JhdGlvbi5pbmxpbmUoZnJvbSwgdG8sIHtcbiAgICAgICAgICAgICAgICBjbGFzczogXCJsYi1yb290IGxiLXNlbGVjdGlvbiBsYi10aXB0YXAtYWN0aXZlLXNlbGVjdGlvblwiXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgZGVjb3JhdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuZXhwb3J0IHsgQWlFeHRlbnNpb24sIERFRkFVTFRfU1RBVEUsIGlzQ29udGV4dHVhbFByb21wdERpZmZSZXNwb25zZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWlFeHRlbnNpb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/ai/AiExtension.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/classnames.js":
/*!******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/classnames.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   classNames: () => (/* binding */ classNames)\n/* harmony export */ });\nfunction classNames(...args) {\n  return args.filter((arg) => typeof arg === \"string\" || typeof arg === \"number\").join(\" \");\n}\n\n\n//# sourceMappingURL=classnames.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvY2xhc3NuYW1lcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBOztBQUVzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvY2xhc3NuYW1lcy5qcz9lOTQwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGNsYXNzTmFtZXMoLi4uYXJncykge1xuICByZXR1cm4gYXJncy5maWx0ZXIoKGFyZykgPT4gdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKS5qb2luKFwiIFwiKTtcbn1cblxuZXhwb3J0IHsgY2xhc3NOYW1lcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xhc3NuYW1lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/classnames.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/comments/CommentsExtension.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/comments/CommentsExtension.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommentsExtension: () => (/* binding */ CommentsExtension)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/view/dist/index.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! y-prosemirror */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/types.js\");\n\n\n\n\n\n\nconst Comment = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark.create({\n  name: _types_js__WEBPACK_IMPORTED_MODULE_3__.LIVEBLOCKS_COMMENT_MARK_TYPE,\n  excludes: \"\",\n  inclusive: false,\n  keepOnSplit: true,\n  addAttributes() {\n    return {\n      orphan: {\n        parseHTML: (element) => !!element.getAttribute(\"data-orphan\"),\n        renderHTML: (attributes) => {\n          return attributes.orphan ? {\n            \"data-orphan\": \"true\"\n          } : {};\n        },\n        default: false\n      },\n      threadId: {\n        parseHTML: (element) => element.getAttribute(\"data-lb-thread-id\"),\n        renderHTML: (attributes) => {\n          return {\n            \"data-lb-thread-id\": attributes.threadId\n          };\n        },\n        default: \"\"\n      }\n    };\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"span\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(HTMLAttributes, {\n        class: \"lb-root lb-tiptap-thread-mark\"\n      })\n    ];\n  },\n  addProseMirrorPlugins() {\n    const updateState = (doc, selectedThreadId) => {\n      const threadPositions = /* @__PURE__ */ new Map();\n      const decorations = [];\n      doc.descendants((node, pos) => {\n        node.marks.forEach((mark) => {\n          if (mark.type === this.type) {\n            const thisThreadId = mark.attrs.threadId;\n            if (!thisThreadId) {\n              return;\n            }\n            const from = pos;\n            const to = from + node.nodeSize;\n            const currentPosition = threadPositions.get(thisThreadId) ?? {\n              from: Infinity,\n              to: 0\n            };\n            threadPositions.set(thisThreadId, {\n              from: Math.min(from, currentPosition.from),\n              to: Math.max(to, currentPosition.to)\n            });\n            if (selectedThreadId === thisThreadId) {\n              decorations.push(\n                _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.inline(from, to, {\n                  class: \"lb-root lb-tiptap-thread-mark-selected\"\n                })\n              );\n            }\n          }\n        });\n      });\n      return {\n        decorations: _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.DecorationSet.create(doc, decorations),\n        selectedThreadId,\n        threadPositions,\n        selectedThreadPos: selectedThreadId !== null ? threadPositions.get(selectedThreadId)?.to ?? null : null\n      };\n    };\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: _types_js__WEBPACK_IMPORTED_MODULE_3__.THREADS_PLUGIN_KEY,\n        state: {\n          init() {\n            return {\n              threadPositions: /* @__PURE__ */ new Map(),\n              selectedThreadId: null,\n              selectedThreadPos: null,\n              decorations: _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.DecorationSet.empty\n            };\n          },\n          apply(tr, state) {\n            const action = tr.getMeta(_types_js__WEBPACK_IMPORTED_MODULE_3__.THREADS_PLUGIN_KEY);\n            if (!tr.docChanged && !action) {\n              return state;\n            }\n            if (!action) {\n              return updateState(tr.doc, state.selectedThreadId);\n            }\n            if (action.name === _types_js__WEBPACK_IMPORTED_MODULE_3__.ThreadPluginActions.SET_SELECTED_THREAD_ID && state.selectedThreadId !== action.data) {\n              return updateState(tr.doc, action.data);\n            }\n            return state;\n          }\n        },\n        props: {\n          decorations: (state) => {\n            return _types_js__WEBPACK_IMPORTED_MODULE_3__.THREADS_PLUGIN_KEY.getState(state)?.decorations ?? _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.DecorationSet.empty;\n          },\n          handleClick: (view, pos, event) => {\n            if (event.button !== 0) {\n              return;\n            }\n            const selectThread = (threadId2) => {\n              view.dispatch(\n                view.state.tr.setMeta(_types_js__WEBPACK_IMPORTED_MODULE_3__.THREADS_PLUGIN_KEY, {\n                  name: _types_js__WEBPACK_IMPORTED_MODULE_3__.ThreadPluginActions.SET_SELECTED_THREAD_ID,\n                  data: threadId2\n                })\n              );\n            };\n            const node = view.state.doc.nodeAt(pos);\n            if (!node) {\n              selectThread(null);\n              return;\n            }\n            const commentMark = node.marks.find(\n              (mark) => mark.type === this.type\n            );\n            if (commentMark?.attrs.orphan) {\n              selectThread(null);\n              return;\n            }\n            const threadId = commentMark?.attrs.threadId;\n            selectThread(threadId ?? null);\n          }\n        }\n      })\n    ];\n  }\n});\nconst CommentsExtension = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Extension.create({\n  name: \"liveblocksComments\",\n  priority: 95,\n  addExtensions() {\n    return [Comment];\n  },\n  addStorage() {\n    return {\n      pendingComment: false\n    };\n  },\n  addCommands() {\n    return {\n      addPendingComment: () => () => {\n        if (this.editor.state.selection.empty) {\n          return false;\n        }\n        this.editor.view.dispatch(\n          this.editor.state.tr.setMeta(_types_js__WEBPACK_IMPORTED_MODULE_3__.THREADS_PLUGIN_KEY, {\n            name: _types_js__WEBPACK_IMPORTED_MODULE_3__.ThreadPluginActions.SET_SELECTED_THREAD_ID,\n            data: null\n          })\n        );\n        this.storage.pendingComment = true;\n        return true;\n      },\n      closePendingComment: () => () => {\n        this.storage.pendingComment = false;\n        return true;\n      },\n      selectThread: (id) => () => {\n        this.editor.view.dispatch(\n          this.editor.state.tr.setMeta(_types_js__WEBPACK_IMPORTED_MODULE_3__.THREADS_PLUGIN_KEY, {\n            name: _types_js__WEBPACK_IMPORTED_MODULE_3__.ThreadPluginActions.SET_SELECTED_THREAD_ID,\n            data: id\n          })\n        );\n        return true;\n      },\n      addComment: (id) => ({ commands }) => {\n        if (!this.storage.pendingComment || this.editor.state.selection.empty) {\n          return false;\n        }\n        commands.setMark(_types_js__WEBPACK_IMPORTED_MODULE_3__.LIVEBLOCKS_COMMENT_MARK_TYPE, { threadId: id });\n        this.storage.pendingComment = false;\n        return true;\n      }\n    };\n  },\n  onSelectionUpdate({ transaction }) {\n    if (!this.storage.pendingComment || transaction.getMeta(y_prosemirror__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)) {\n      return;\n    }\n    this.storage.pendingComment = false;\n  },\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: _types_js__WEBPACK_IMPORTED_MODULE_3__.THREADS_ACTIVE_SELECTION_PLUGIN,\n        props: {\n          decorations: ({ doc, selection }) => {\n            if (!this.storage.pendingComment) {\n              return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.DecorationSet.create(doc, []);\n            }\n            const { from, to } = selection;\n            const decorations = [\n              _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.inline(from, to, {\n                class: \"lb-root lb-selection lb-tiptap-active-selection\"\n              })\n            ];\n            return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.DecorationSet.create(doc, decorations);\n          }\n        }\n      })\n    ];\n  }\n});\n\n\n//# sourceMappingURL=CommentsExtension.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvY29tbWVudHMvQ29tbWVudHNFeHRlbnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWdFO0FBQ3RCO0FBQ2tCO0FBQ2I7QUFDc0Y7O0FBRXJJLGdCQUFnQiw4Q0FBSTtBQUNwQixRQUFRLG1FQUE0QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0EsTUFBTSw2REFBZTtBQUNyQjtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQVU7QUFDMUI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLHFCQUFxQiwwREFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFNO0FBQ2hCLGFBQWEseURBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBYTtBQUN4QztBQUNBLFdBQVc7QUFDWDtBQUNBLHNDQUFzQyx5REFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBEQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFrQixpQ0FBaUMsMERBQWE7QUFDbkYsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5REFBa0I7QUFDeEQsd0JBQXdCLDBEQUFtQjtBQUMzQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRCwwQkFBMEIsbURBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseURBQWtCO0FBQ3pELGtCQUFrQiwwREFBbUI7QUFDckM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsdUNBQXVDLHlEQUFrQjtBQUN6RCxrQkFBa0IsMERBQW1CO0FBQ3JDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1FQUE0QixJQUFJLGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLGFBQWE7QUFDbkMsNERBQTRELHlEQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxvREFBTTtBQUNoQixhQUFhLHNFQUErQjtBQUM1QztBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQSxxQkFBcUIsMERBQWE7QUFDbEM7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLGNBQWMsdURBQVU7QUFDeEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxtQkFBbUIsMERBQWE7QUFDaEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFNEI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXRpcHRhcC9kaXN0L2NvbW1lbnRzL0NvbW1lbnRzRXh0ZW5zaW9uLmpzPzMwYWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFyaywgbWVyZ2VBdHRyaWJ1dGVzLCBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3JztcbmltcG9ydCB7IHlTeW5jUGx1Z2luS2V5IH0gZnJvbSAneS1wcm9zZW1pcnJvcic7XG5pbXBvcnQgeyBMSVZFQkxPQ0tTX0NPTU1FTlRfTUFSS19UWVBFLCBUSFJFQURTX1BMVUdJTl9LRVksIFRocmVhZFBsdWdpbkFjdGlvbnMsIFRIUkVBRFNfQUNUSVZFX1NFTEVDVElPTl9QTFVHSU4gfSBmcm9tICcuLi90eXBlcy5qcyc7XG5cbmNvbnN0IENvbW1lbnQgPSBNYXJrLmNyZWF0ZSh7XG4gIG5hbWU6IExJVkVCTE9DS1NfQ09NTUVOVF9NQVJLX1RZUEUsXG4gIGV4Y2x1ZGVzOiBcIlwiLFxuICBpbmNsdXNpdmU6IGZhbHNlLFxuICBrZWVwT25TcGxpdDogdHJ1ZSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3JwaGFuOiB7XG4gICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+ICEhZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW9ycGhhblwiKSxcbiAgICAgICAgcmVuZGVySFRNTDogKGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5vcnBoYW4gPyB7XG4gICAgICAgICAgICBcImRhdGEtb3JwaGFuXCI6IFwidHJ1ZVwiXG4gICAgICAgICAgfSA6IHt9O1xuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHRocmVhZElkOiB7XG4gICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1sYi10aHJlYWQtaWRcIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwiZGF0YS1sYi10aHJlYWQtaWRcIjogYXR0cmlidXRlcy50aHJlYWRJZFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6IFwiXCJcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXG4gICAgICBcInNwYW5cIixcbiAgICAgIG1lcmdlQXR0cmlidXRlcyhIVE1MQXR0cmlidXRlcywge1xuICAgICAgICBjbGFzczogXCJsYi1yb290IGxiLXRpcHRhcC10aHJlYWQtbWFya1wiXG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCB1cGRhdGVTdGF0ZSA9IChkb2MsIHNlbGVjdGVkVGhyZWFkSWQpID0+IHtcbiAgICAgIGNvbnN0IHRocmVhZFBvc2l0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgZG9jLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKChtYXJrKSA9PiB7XG4gICAgICAgICAgaWYgKG1hcmsudHlwZSA9PT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjb25zdCB0aGlzVGhyZWFkSWQgPSBtYXJrLmF0dHJzLnRocmVhZElkO1xuICAgICAgICAgICAgaWYgKCF0aGlzVGhyZWFkSWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnJvbSA9IHBvcztcbiAgICAgICAgICAgIGNvbnN0IHRvID0gZnJvbSArIG5vZGUubm9kZVNpemU7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSB0aHJlYWRQb3NpdGlvbnMuZ2V0KHRoaXNUaHJlYWRJZCkgPz8ge1xuICAgICAgICAgICAgICBmcm9tOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgdG86IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aHJlYWRQb3NpdGlvbnMuc2V0KHRoaXNUaHJlYWRJZCwge1xuICAgICAgICAgICAgICBmcm9tOiBNYXRoLm1pbihmcm9tLCBjdXJyZW50UG9zaXRpb24uZnJvbSksXG4gICAgICAgICAgICAgIHRvOiBNYXRoLm1heCh0bywgY3VycmVudFBvc2l0aW9uLnRvKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRUaHJlYWRJZCA9PT0gdGhpc1RocmVhZElkKSB7XG4gICAgICAgICAgICAgIGRlY29yYXRpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgRGVjb3JhdGlvbi5pbmxpbmUoZnJvbSwgdG8sIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzOiBcImxiLXJvb3QgbGItdGlwdGFwLXRocmVhZC1tYXJrLXNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKSxcbiAgICAgICAgc2VsZWN0ZWRUaHJlYWRJZCxcbiAgICAgICAgdGhyZWFkUG9zaXRpb25zLFxuICAgICAgICBzZWxlY3RlZFRocmVhZFBvczogc2VsZWN0ZWRUaHJlYWRJZCAhPT0gbnVsbCA/IHRocmVhZFBvc2l0aW9ucy5nZXQoc2VsZWN0ZWRUaHJlYWRJZCk/LnRvID8/IG51bGwgOiBudWxsXG4gICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IFRIUkVBRFNfUExVR0lOX0tFWSxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdGhyZWFkUG9zaXRpb25zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICAgICAgICBzZWxlY3RlZFRocmVhZElkOiBudWxsLFxuICAgICAgICAgICAgICBzZWxlY3RlZFRocmVhZFBvczogbnVsbCxcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnM6IERlY29yYXRpb25TZXQuZW1wdHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcHBseSh0ciwgc3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHRyLmdldE1ldGEoVEhSRUFEU19QTFVHSU5fS0VZKTtcbiAgICAgICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCAmJiAhYWN0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZSh0ci5kb2MsIHN0YXRlLnNlbGVjdGVkVGhyZWFkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGlvbi5uYW1lID09PSBUaHJlYWRQbHVnaW5BY3Rpb25zLlNFVF9TRUxFQ1RFRF9USFJFQURfSUQgJiYgc3RhdGUuc2VsZWN0ZWRUaHJlYWRJZCAhPT0gYWN0aW9uLmRhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKHRyLmRvYywgYWN0aW9uLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBkZWNvcmF0aW9uczogKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gVEhSRUFEU19QTFVHSU5fS0VZLmdldFN0YXRlKHN0YXRlKT8uZGVjb3JhdGlvbnMgPz8gRGVjb3JhdGlvblNldC5lbXB0eTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhbmRsZUNsaWNrOiAodmlldywgcG9zLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RUaHJlYWQgPSAodGhyZWFkSWQyKSA9PiB7XG4gICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgdmlldy5zdGF0ZS50ci5zZXRNZXRhKFRIUkVBRFNfUExVR0lOX0tFWSwge1xuICAgICAgICAgICAgICAgICAgbmFtZTogVGhyZWFkUGx1Z2luQWN0aW9ucy5TRVRfU0VMRUNURURfVEhSRUFEX0lELFxuICAgICAgICAgICAgICAgICAgZGF0YTogdGhyZWFkSWQyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgc2VsZWN0VGhyZWFkKG51bGwpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb21tZW50TWFyayA9IG5vZGUubWFya3MuZmluZChcbiAgICAgICAgICAgICAgKG1hcmspID0+IG1hcmsudHlwZSA9PT0gdGhpcy50eXBlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGNvbW1lbnRNYXJrPy5hdHRycy5vcnBoYW4pIHtcbiAgICAgICAgICAgICAgc2VsZWN0VGhyZWFkKG51bGwpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aHJlYWRJZCA9IGNvbW1lbnRNYXJrPy5hdHRycy50aHJlYWRJZDtcbiAgICAgICAgICAgIHNlbGVjdFRocmVhZCh0aHJlYWRJZCA/PyBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5jb25zdCBDb21tZW50c0V4dGVuc2lvbiA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImxpdmVibG9ja3NDb21tZW50c1wiLFxuICBwcmlvcml0eTogOTUsXG4gIGFkZEV4dGVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIFtDb21tZW50XTtcbiAgfSxcbiAgYWRkU3RvcmFnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGVuZGluZ0NvbW1lbnQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZFBlbmRpbmdDb21tZW50OiAoKSA9PiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3Iudmlldy5kaXNwYXRjaChcbiAgICAgICAgICB0aGlzLmVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKFRIUkVBRFNfUExVR0lOX0tFWSwge1xuICAgICAgICAgICAgbmFtZTogVGhyZWFkUGx1Z2luQWN0aW9ucy5TRVRfU0VMRUNURURfVEhSRUFEX0lELFxuICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5wZW5kaW5nQ29tbWVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGNsb3NlUGVuZGluZ0NvbW1lbnQ6ICgpID0+ICgpID0+IHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnBlbmRpbmdDb21tZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIHNlbGVjdFRocmVhZDogKGlkKSA9PiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZWRpdG9yLnZpZXcuZGlzcGF0Y2goXG4gICAgICAgICAgdGhpcy5lZGl0b3Iuc3RhdGUudHIuc2V0TWV0YShUSFJFQURTX1BMVUdJTl9LRVksIHtcbiAgICAgICAgICAgIG5hbWU6IFRocmVhZFBsdWdpbkFjdGlvbnMuU0VUX1NFTEVDVEVEX1RIUkVBRF9JRCxcbiAgICAgICAgICAgIGRhdGE6IGlkXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgYWRkQ29tbWVudDogKGlkKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5zdG9yYWdlLnBlbmRpbmdDb21tZW50IHx8IHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb21tYW5kcy5zZXRNYXJrKExJVkVCTE9DS1NfQ09NTUVOVF9NQVJLX1RZUEUsIHsgdGhyZWFkSWQ6IGlkIH0pO1xuICAgICAgICB0aGlzLnN0b3JhZ2UucGVuZGluZ0NvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgb25TZWxlY3Rpb25VcGRhdGUoeyB0cmFuc2FjdGlvbiB9KSB7XG4gICAgaWYgKCF0aGlzLnN0b3JhZ2UucGVuZGluZ0NvbW1lbnQgfHwgdHJhbnNhY3Rpb24uZ2V0TWV0YSh5U3luY1BsdWdpbktleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdG9yYWdlLnBlbmRpbmdDb21tZW50ID0gZmFsc2U7XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogVEhSRUFEU19BQ1RJVkVfU0VMRUNUSU9OX1BMVUdJTixcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBkZWNvcmF0aW9uczogKHsgZG9jLCBzZWxlY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0b3JhZ2UucGVuZGluZ0NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbnMgPSBbXG4gICAgICAgICAgICAgIERlY29yYXRpb24uaW5saW5lKGZyb20sIHRvLCB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IFwibGItcm9vdCBsYi1zZWxlY3Rpb24gbGItdGlwdGFwLWFjdGl2ZS1zZWxlY3Rpb25cIlxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbmV4cG9ydCB7IENvbW1lbnRzRXh0ZW5zaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21tZW50c0V4dGVuc2lvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/comments/CommentsExtension.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/context.js":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/context.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   useCurrentEditor: () => (/* binding */ useCurrentEditor)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n\nconst EditorContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nfunction EditorProvider({\n  editor,\n  children\n}) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EditorContext.Provider, {\n    value: editor,\n    children\n  });\n}\nfunction useCurrentEditor(source, parent) {\n  const currentEditor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorContext);\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_2__.nn)(currentEditor, `${source} can\\u2019t be used outside of ${parent}.`);\n}\n\n\n//# sourceMappingURL=context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvY29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF3QztBQUNGO0FBQ1k7O0FBRWxELHNCQUFzQixvREFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCLHNEQUFHO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3QixpREFBVTtBQUNsQyxTQUFTLG9EQUFFLG1CQUFtQixRQUFRLGdDQUFnQyxPQUFPO0FBQzdFOztBQUU0QztBQUM1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvY29udGV4dC5qcz8wZjEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IG5uIH0gZnJvbSAnQGxpdmVibG9ja3MvY29yZSc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBFZGl0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIEVkaXRvclByb3ZpZGVyKHtcbiAgZWRpdG9yLFxuICBjaGlsZHJlblxufSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGVkaXRvcixcbiAgICBjaGlsZHJlblxuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZUN1cnJlbnRFZGl0b3Ioc291cmNlLCBwYXJlbnQpIHtcbiAgY29uc3QgY3VycmVudEVkaXRvciA9IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG4gIHJldHVybiBubihjdXJyZW50RWRpdG9yLCBgJHtzb3VyY2V9IGNhblxcdTIwMTl0IGJlIHVzZWQgb3V0c2lkZSBvZiAke3BhcmVudH0uYCk7XG59XG5cbmV4cG9ydCB7IEVkaXRvclByb3ZpZGVyLCB1c2VDdXJyZW50RWRpdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/Avatar.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/mentions/Avatar.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Avatar: () => (/* binding */ Avatar)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liveblocks/react */ \"(ssr)/./node_modules/@liveblocks/react/dist/chunk-5RVW253W.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _classnames_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classnames.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/classnames.js\");\n\n\n\n\n\nconst Avatar = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  function Avatar2(props, forwardedRef) {\n    const { userId, className, ...spanProps } = props;\n    const { user, isLoading } = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_2__._useUser)(userId);\n    const avatar = user ? user.avatar : void 0;\n    const name = user ? user.name : void 0;\n    function Initials() {\n      const initials = name ? getInitials(name) : void 0;\n      if (initials) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n          \"aria-hidden\": true,\n          className: \"lb-avatar-fallback\",\n          children: initials\n        });\n      }\n      if (isLoading)\n        return null;\n      if (user === void 0)\n        return null;\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n        \"aria-label\": userId,\n        title: userId,\n        className: \"lb-avatar-fallback\",\n        children: getInitials(userId)\n      });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", {\n      \"data-loading\": isLoading ? \"\" : void 0,\n      ...spanProps,\n      className: (0,_classnames_js__WEBPACK_IMPORTED_MODULE_3__.classNames)(\"lb-avatar\", className),\n      ref: forwardedRef,\n      children: [\n        avatar && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n          src: avatar,\n          alt: name,\n          className: \"lb-avatar-image\"\n        }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Initials, {})\n      ]\n    });\n  }\n);\nfunction getInitials(name) {\n  return name.trim().split(\" \").reduce((initials, name2, index, array) => {\n    if (index === 0 || index === array.length - 1) {\n      initials += name2.charAt(0).toLocaleUpperCase();\n    }\n    return initials;\n  }, \"\");\n}\n\n\n//# sourceMappingURL=Avatar.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvbWVudGlvbnMvQXZhdGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThDO0FBQ0Y7QUFDVDtBQUNXOztBQUU5QyxlQUFlLGlEQUFVO0FBQ3pCO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUMsWUFBWSxrQkFBa0IsRUFBRSwyREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNEQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkJBQTJCLHVEQUFJO0FBQy9CO0FBQ0E7QUFDQSxpQkFBaUIsMERBQVU7QUFDM0I7QUFDQTtBQUNBLGtDQUFrQyxzREFBRztBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCLHNEQUFHLGFBQWE7QUFDeEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXRpcHRhcC9kaXN0L21lbnRpb25zL0F2YXRhci5qcz8yYmUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCwganN4cyB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IHVzZVVzZXIgfSBmcm9tICdAbGl2ZWJsb2Nrcy9yZWFjdCc7XG5pbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gJy4uL2NsYXNzbmFtZXMuanMnO1xuXG5jb25zdCBBdmF0YXIgPSBmb3J3YXJkUmVmKFxuICBmdW5jdGlvbiBBdmF0YXIyKHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgICBjb25zdCB7IHVzZXJJZCwgY2xhc3NOYW1lLCAuLi5zcGFuUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdXNlciwgaXNMb2FkaW5nIH0gPSB1c2VVc2VyKHVzZXJJZCk7XG4gICAgY29uc3QgYXZhdGFyID0gdXNlciA/IHVzZXIuYXZhdGFyIDogdm9pZCAwO1xuICAgIGNvbnN0IG5hbWUgPSB1c2VyID8gdXNlci5uYW1lIDogdm9pZCAwO1xuICAgIGZ1bmN0aW9uIEluaXRpYWxzKCkge1xuICAgICAgY29uc3QgaW5pdGlhbHMgPSBuYW1lID8gZ2V0SW5pdGlhbHMobmFtZSkgOiB2b2lkIDA7XG4gICAgICBpZiAoaW5pdGlhbHMpIHtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHtcbiAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcImxiLWF2YXRhci1mYWxsYmFja1wiLFxuICAgICAgICAgIGNoaWxkcmVuOiBpbml0aWFsc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xvYWRpbmcpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKHVzZXIgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwge1xuICAgICAgICBcImFyaWEtbGFiZWxcIjogdXNlcklkLFxuICAgICAgICB0aXRsZTogdXNlcklkLFxuICAgICAgICBjbGFzc05hbWU6IFwibGItYXZhdGFyLWZhbGxiYWNrXCIsXG4gICAgICAgIGNoaWxkcmVuOiBnZXRJbml0aWFscyh1c2VySWQpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwic3BhblwiLCB7XG4gICAgICBcImRhdGEtbG9hZGluZ1wiOiBpc0xvYWRpbmcgPyBcIlwiIDogdm9pZCAwLFxuICAgICAgLi4uc3BhblByb3BzLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKFwibGItYXZhdGFyXCIsIGNsYXNzTmFtZSksXG4gICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIGF2YXRhciAmJiAvKiBAX19QVVJFX18gKi8ganN4KFwiaW1nXCIsIHtcbiAgICAgICAgICBzcmM6IGF2YXRhcixcbiAgICAgICAgICBhbHQ6IG5hbWUsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcImxiLWF2YXRhci1pbWFnZVwiXG4gICAgICAgIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KEluaXRpYWxzLCB7fSlcbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuKTtcbmZ1bmN0aW9uIGdldEluaXRpYWxzKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUudHJpbSgpLnNwbGl0KFwiIFwiKS5yZWR1Y2UoKGluaXRpYWxzLCBuYW1lMiwgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSAwIHx8IGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICBpbml0aWFscyArPSBuYW1lMi5jaGFyQXQoMCkudG9Mb2NhbGVVcHBlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRpYWxzO1xuICB9LCBcIlwiKTtcbn1cblxuZXhwb3J0IHsgQXZhdGFyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdmF0YXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/Avatar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/Mention.js":
/*!************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/mentions/Mention.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mention: () => (/* binding */ Mention)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _tiptap_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/react */ \"(ssr)/./node_modules/@tiptap/react/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _classnames_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classnames.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/classnames.js\");\n/* harmony import */ var _MentionsList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MentionsList.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionsList.js\");\n\n\n\n\n\n\nconst MENTION_CHARACTER = \"@\";\nconst Mention = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef) => {\n  const id = props.node.attrs.id;\n  const classnames = (0,_classnames_js__WEBPACK_IMPORTED_MODULE_2__.classNames)(\n    \"lb-root\",\n    \"lb-tiptap-mention\",\n    props.selected ? \"lb-mention-selected\" : null\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_tiptap_react__WEBPACK_IMPORTED_MODULE_3__.NodeViewWrapper, {\n    className: classnames,\n    as: \"span\",\n    ref: forwardedRef,\n    children: [\n      MENTION_CHARACTER,\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_MentionsList_js__WEBPACK_IMPORTED_MODULE_4__.User, {\n        userId: id\n      })\n    ]\n  });\n});\n\n\n//# sourceMappingURL=Mention.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvbWVudGlvbnMvTWVudGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBOEM7QUFDRTtBQUNiO0FBQ1c7QUFDTDs7QUFFekM7QUFDQSxnQkFBZ0IsaURBQVU7QUFDMUI7QUFDQSxxQkFBcUIsMERBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdURBQUksQ0FBQywwREFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFHLENBQUMsa0RBQUk7QUFDOUI7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFa0I7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXRpcHRhcC9kaXN0L21lbnRpb25zL01lbnRpb24uanM/OTc2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3hzLCBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBOb2RlVmlld1dyYXBwZXIgfSBmcm9tICdAdGlwdGFwL3JlYWN0JztcbmltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSAnLi4vY2xhc3NuYW1lcy5qcyc7XG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi9NZW50aW9uc0xpc3QuanMnO1xuXG5jb25zdCBNRU5USU9OX0NIQVJBQ1RFUiA9IFwiQFwiO1xuY29uc3QgTWVudGlvbiA9IGZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgaWQgPSBwcm9wcy5ub2RlLmF0dHJzLmlkO1xuICBjb25zdCBjbGFzc25hbWVzID0gY2xhc3NOYW1lcyhcbiAgICBcImxiLXJvb3RcIixcbiAgICBcImxiLXRpcHRhcC1tZW50aW9uXCIsXG4gICAgcHJvcHMuc2VsZWN0ZWQgPyBcImxiLW1lbnRpb24tc2VsZWN0ZWRcIiA6IG51bGxcbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKE5vZGVWaWV3V3JhcHBlciwge1xuICAgIGNsYXNzTmFtZTogY2xhc3NuYW1lcyxcbiAgICBhczogXCJzcGFuXCIsXG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIE1FTlRJT05fQ0hBUkFDVEVSLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChVc2VyLCB7XG4gICAgICAgIHVzZXJJZDogaWRcbiAgICAgIH0pXG4gICAgXVxuICB9KTtcbn0pO1xuXG5leHBvcnQgeyBNZW50aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZW50aW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/Mention.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionExtension.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionExtension.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MentionExtension: () => (/* binding */ MentionExtension)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/model */ \"(ssr)/./node_modules/@tiptap/pm/model/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/react */ \"(ssr)/./node_modules/@tiptap/react/dist/index.js\");\n/* harmony import */ var _tiptap_suggestion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/suggestion */ \"(ssr)/./node_modules/@tiptap/suggestion/dist/index.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! y-prosemirror */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/types.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/utils.js\");\n/* harmony import */ var _MentionNode_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MentionNode.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionNode.js\");\n/* harmony import */ var _MentionsList_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./MentionsList.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionsList.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst mentionPasteHandler = () => {\n  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n    key: _types_js__WEBPACK_IMPORTED_MODULE_3__.LIVEBLOCKS_MENTION_PASTE_KEY,\n    props: {\n      transformPasted: (slice) => {\n        const getNewNotificationIds = (node) => {\n          if (node.type.name === _types_js__WEBPACK_IMPORTED_MODULE_3__.LIVEBLOCKS_MENTION_TYPE) {\n            return node.type.create(\n              { ...node.attrs, notificationId: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_4__.createInboxNotificationId)() },\n              node.content\n            );\n          }\n          return node.copy(node.content);\n        };\n        const fragment = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.mapFragment)(slice.content, getNewNotificationIds);\n        return new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fragment, slice.openStart, slice.openEnd);\n      }\n    }\n  });\n};\nconst notifier = ({\n  onCreateMention,\n  onDeleteMention\n}) => {\n  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n    key: _types_js__WEBPACK_IMPORTED_MODULE_3__.LIVEBLOCKS_MENTION_NOTIFIER_KEY,\n    appendTransaction: (transactions, oldState, newState) => {\n      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n      if (!docChanges) {\n        return;\n      }\n      if (transactions.some((transaction) => transaction.getMeta(y_prosemirror__WEBPACK_IMPORTED_MODULE_6__.ySyncPluginKey))) {\n        return;\n      }\n      const transform = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_7__.combineTransactionSteps)(oldState.doc, [\n        ...transactions\n      ]);\n      const changes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_7__.getChangedRanges)(transform);\n      changes.forEach(({ newRange, oldRange }) => {\n        const newMentions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getMentionsFromNode)(newState.doc, newRange);\n        const oldMentions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getMentionsFromNode)(oldState.doc, oldRange);\n        if (oldMentions.length || newMentions.length) {\n          newMentions.forEach((mention) => {\n            if (!oldMentions.includes(mention)) {\n              onCreateMention(mention.userId, mention.notificationId);\n            }\n          });\n          oldMentions.forEach((mention) => {\n            if (!newMentions.includes(mention)) {\n              onDeleteMention(mention.notificationId);\n            }\n          });\n        }\n      });\n      return void 0;\n    }\n  });\n};\nconst MentionExtension = _tiptap_core__WEBPACK_IMPORTED_MODULE_7__.Extension.create({\n  name: _types_js__WEBPACK_IMPORTED_MODULE_3__.LIVEBLOCKS_MENTION_EXTENSION,\n  priority: 101,\n  addOptions() {\n    return {\n      onCreateMention: () => {\n      },\n      onDeleteMention: () => {\n      }\n    };\n  },\n  addExtensions() {\n    return [_MentionNode_js__WEBPACK_IMPORTED_MODULE_8__.MentionNode];\n  },\n  addProseMirrorPlugins() {\n    return [\n      (0,_tiptap_suggestion__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        editor: this.editor,\n        char: \"@\",\n        pluginKey: _types_js__WEBPACK_IMPORTED_MODULE_3__.LIVEBLOCKS_MENTION_KEY,\n        command: ({ editor, range, props }) => {\n          const nodeAfter = editor.view.state.selection.$to.nodeAfter;\n          const overrideSpace = nodeAfter?.text?.startsWith(\" \");\n          if (overrideSpace) {\n            range.to += 1;\n          }\n          editor.chain().focus().insertContentAt(range, [\n            {\n              type: _types_js__WEBPACK_IMPORTED_MODULE_3__.LIVEBLOCKS_MENTION_TYPE,\n              attrs: props\n            },\n            {\n              type: \"text\",\n              text: \" \"\n            }\n          ]).run();\n          editor.view.dom.ownerDocument.defaultView?.getSelection()?.collapseToEnd();\n        },\n        allow: ({ state, range }) => {\n          const $from = state.doc.resolve(range.from);\n          const type = state.schema.nodes[_types_js__WEBPACK_IMPORTED_MODULE_3__.LIVEBLOCKS_MENTION_TYPE];\n          const allow = !!$from.parent.type.contentMatch.matchType(type);\n          return allow;\n        },\n        allowSpaces: true,\n        items: () => [],\n        render: () => {\n          let component;\n          return {\n            onStart: (props) => {\n              component = new _tiptap_react__WEBPACK_IMPORTED_MODULE_9__.ReactRenderer(_MentionsList_js__WEBPACK_IMPORTED_MODULE_10__.MentionsList, {\n                props,\n                editor: props.editor\n              });\n              if (!props.clientRect) {\n                return;\n              }\n              document.body.appendChild(component.element);\n            },\n            onUpdate(props) {\n              component.updateProps(props);\n            },\n            onKeyDown(props) {\n              if (props.event.key === \"Escape\") {\n                component.updateProps({\n                  ...props,\n                  hide: true\n                });\n                return true;\n              }\n              return component.ref?.onKeyDown(props) ?? false;\n            },\n            onExit() {\n              document.body.removeChild(component.element);\n              component.destroy();\n            }\n          };\n        }\n      }),\n      notifier(this.options),\n      mentionPasteHandler()\n    ];\n  }\n});\n\n\n//# sourceMappingURL=MentionExtension.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvbWVudGlvbnMvTWVudGlvbkV4dGVuc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBNkQ7QUFDdUI7QUFDM0M7QUFDQztBQUNJO0FBQ0Y7QUFDRztBQUM0SDtBQUM1RztBQUNoQjtBQUNFOztBQUVqRDtBQUNBLGFBQWEsb0RBQU07QUFDbkIsU0FBUyxtRUFBNEI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDhEQUF1QjtBQUN4RDtBQUNBLGdCQUFnQiwrQkFBK0IsMkVBQXlCLElBQUk7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBVztBQUNwQyxtQkFBbUIsbURBQUs7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxhQUFhLG9EQUFNO0FBQ25CLFNBQVMsc0VBQStCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUseURBQWM7QUFDL0U7QUFDQTtBQUNBLHdCQUF3QixxRUFBdUI7QUFDL0M7QUFDQTtBQUNBLHNCQUFzQiw4REFBZ0I7QUFDdEMseUJBQXlCLG9CQUFvQjtBQUM3Qyw0QkFBNEIsOERBQW1CO0FBQy9DLDRCQUE0Qiw4REFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUJBQXlCLG1EQUFTO0FBQ2xDLFFBQVEsbUVBQTRCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksd0RBQVc7QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDhEQUFVO0FBQ2hCO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQXNCO0FBQ3pDLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOERBQXVCO0FBQzNDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQkFBa0IsY0FBYztBQUNoQztBQUNBLDBDQUEwQyw4REFBdUI7QUFDakU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQWEsQ0FBQywyREFBWTtBQUN4RDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFMkI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXRpcHRhcC9kaXN0L21lbnRpb25zL01lbnRpb25FeHRlbnNpb24uanM/ZWQ2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVJbmJveE5vdGlmaWNhdGlvbklkIH0gZnJvbSAnQGxpdmVibG9ja3MvY29yZSc7XG5pbXBvcnQgeyBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcywgZ2V0Q2hhbmdlZFJhbmdlcywgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IFNsaWNlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCc7XG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB7IFJlYWN0UmVuZGVyZXIgfSBmcm9tICdAdGlwdGFwL3JlYWN0JztcbmltcG9ydCBTdWdnZXN0aW9uIGZyb20gJ0B0aXB0YXAvc3VnZ2VzdGlvbic7XG5pbXBvcnQgeyB5U3luY1BsdWdpbktleSB9IGZyb20gJ3ktcHJvc2VtaXJyb3InO1xuaW1wb3J0IHsgTElWRUJMT0NLU19NRU5USU9OX1BBU1RFX0tFWSwgTElWRUJMT0NLU19NRU5USU9OX1RZUEUsIExJVkVCTE9DS1NfTUVOVElPTl9OT1RJRklFUl9LRVksIExJVkVCTE9DS1NfTUVOVElPTl9FWFRFTlNJT04sIExJVkVCTE9DS1NfTUVOVElPTl9LRVkgfSBmcm9tICcuLi90eXBlcy5qcyc7XG5pbXBvcnQgeyBtYXBGcmFnbWVudCwgZ2V0TWVudGlvbnNGcm9tTm9kZSB9IGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCB7IE1lbnRpb25Ob2RlIH0gZnJvbSAnLi9NZW50aW9uTm9kZS5qcyc7XG5pbXBvcnQgeyBNZW50aW9uc0xpc3QgfSBmcm9tICcuL01lbnRpb25zTGlzdC5qcyc7XG5cbmNvbnN0IG1lbnRpb25QYXN0ZUhhbmRsZXIgPSAoKSA9PiB7XG4gIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IExJVkVCTE9DS1NfTUVOVElPTl9QQVNURV9LRVksXG4gICAgcHJvcHM6IHtcbiAgICAgIHRyYW5zZm9ybVBhc3RlZDogKHNsaWNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGdldE5ld05vdGlmaWNhdGlvbklkcyA9IChub2RlKSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUudHlwZS5uYW1lID09PSBMSVZFQkxPQ0tTX01FTlRJT05fVFlQRSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudHlwZS5jcmVhdGUoXG4gICAgICAgICAgICAgIHsgLi4ubm9kZS5hdHRycywgbm90aWZpY2F0aW9uSWQ6IGNyZWF0ZUluYm94Tm90aWZpY2F0aW9uSWQoKSB9LFxuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlLmNvcHkobm9kZS5jb250ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBtYXBGcmFnbWVudChzbGljZS5jb250ZW50LCBnZXROZXdOb3RpZmljYXRpb25JZHMpO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGZyYWdtZW50LCBzbGljZS5vcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuY29uc3Qgbm90aWZpZXIgPSAoe1xuICBvbkNyZWF0ZU1lbnRpb24sXG4gIG9uRGVsZXRlTWVudGlvblxufSkgPT4ge1xuICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAga2V5OiBMSVZFQkxPQ0tTX01FTlRJT05fTk9USUZJRVJfS0VZLFxuICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSB0cmFuc2FjdGlvbnMuc29tZSgodHJhbnNhY3Rpb24pID0+IHRyYW5zYWN0aW9uLmRvY0NoYW5nZWQpICYmICFvbGRTdGF0ZS5kb2MuZXEobmV3U3RhdGUuZG9jKTtcbiAgICAgIGlmICghZG9jQ2hhbmdlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNhY3Rpb25zLnNvbWUoKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5nZXRNZXRhKHlTeW5jUGx1Z2luS2V5KSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gY29tYmluZVRyYW5zYWN0aW9uU3RlcHMob2xkU3RhdGUuZG9jLCBbXG4gICAgICAgIC4uLnRyYW5zYWN0aW9uc1xuICAgICAgXSk7XG4gICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0Q2hhbmdlZFJhbmdlcyh0cmFuc2Zvcm0pO1xuICAgICAgY2hhbmdlcy5mb3JFYWNoKCh7IG5ld1JhbmdlLCBvbGRSYW5nZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld01lbnRpb25zID0gZ2V0TWVudGlvbnNGcm9tTm9kZShuZXdTdGF0ZS5kb2MsIG5ld1JhbmdlKTtcbiAgICAgICAgY29uc3Qgb2xkTWVudGlvbnMgPSBnZXRNZW50aW9uc0Zyb21Ob2RlKG9sZFN0YXRlLmRvYywgb2xkUmFuZ2UpO1xuICAgICAgICBpZiAob2xkTWVudGlvbnMubGVuZ3RoIHx8IG5ld01lbnRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIG5ld01lbnRpb25zLmZvckVhY2goKG1lbnRpb24pID0+IHtcbiAgICAgICAgICAgIGlmICghb2xkTWVudGlvbnMuaW5jbHVkZXMobWVudGlvbikpIHtcbiAgICAgICAgICAgICAgb25DcmVhdGVNZW50aW9uKG1lbnRpb24udXNlcklkLCBtZW50aW9uLm5vdGlmaWNhdGlvbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvbGRNZW50aW9ucy5mb3JFYWNoKChtZW50aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5ld01lbnRpb25zLmluY2x1ZGVzKG1lbnRpb24pKSB7XG4gICAgICAgICAgICAgIG9uRGVsZXRlTWVudGlvbihtZW50aW9uLm5vdGlmaWNhdGlvbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgTWVudGlvbkV4dGVuc2lvbiA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBMSVZFQkxPQ0tTX01FTlRJT05fRVhURU5TSU9OLFxuICBwcmlvcml0eTogMTAxLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNyZWF0ZU1lbnRpb246ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICBvbkRlbGV0ZU1lbnRpb246ICgpID0+IHtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRFeHRlbnNpb25zKCkge1xuICAgIHJldHVybiBbTWVudGlvbk5vZGVdO1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFN1Z2dlc3Rpb24oe1xuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICBjaGFyOiBcIkBcIixcbiAgICAgICAgcGx1Z2luS2V5OiBMSVZFQkxPQ0tTX01FTlRJT05fS0VZLFxuICAgICAgICBjb21tYW5kOiAoeyBlZGl0b3IsIHJhbmdlLCBwcm9wcyB9KSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZUFmdGVyID0gZWRpdG9yLnZpZXcuc3RhdGUuc2VsZWN0aW9uLiR0by5ub2RlQWZ0ZXI7XG4gICAgICAgICAgY29uc3Qgb3ZlcnJpZGVTcGFjZSA9IG5vZGVBZnRlcj8udGV4dD8uc3RhcnRzV2l0aChcIiBcIik7XG4gICAgICAgICAgaWYgKG92ZXJyaWRlU3BhY2UpIHtcbiAgICAgICAgICAgIHJhbmdlLnRvICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkaXRvci5jaGFpbigpLmZvY3VzKCkuaW5zZXJ0Q29udGVudEF0KHJhbmdlLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IExJVkVCTE9DS1NfTUVOVElPTl9UWVBFLFxuICAgICAgICAgICAgICBhdHRyczogcHJvcHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICB0ZXh0OiBcIiBcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0pLnJ1bigpO1xuICAgICAgICAgIGVkaXRvci52aWV3LmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Py5nZXRTZWxlY3Rpb24oKT8uY29sbGFwc2VUb0VuZCgpO1xuICAgICAgICB9LFxuICAgICAgICBhbGxvdzogKHsgc3RhdGUsIHJhbmdlIH0pID0+IHtcbiAgICAgICAgICBjb25zdCAkZnJvbSA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBzdGF0ZS5zY2hlbWEubm9kZXNbTElWRUJMT0NLU19NRU5USU9OX1RZUEVdO1xuICAgICAgICAgIGNvbnN0IGFsbG93ID0gISEkZnJvbS5wYXJlbnQudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICAgIHJldHVybiBhbGxvdztcbiAgICAgICAgfSxcbiAgICAgICAgYWxsb3dTcGFjZXM6IHRydWUsXG4gICAgICAgIGl0ZW1zOiAoKSA9PiBbXSxcbiAgICAgICAgcmVuZGVyOiAoKSA9PiB7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb25TdGFydDogKHByb3BzKSA9PiB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudCA9IG5ldyBSZWFjdFJlbmRlcmVyKE1lbnRpb25zTGlzdCwge1xuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIGVkaXRvcjogcHJvcHMuZWRpdG9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoIXByb3BzLmNsaWVudFJlY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb21wb25lbnQuZWxlbWVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25VcGRhdGUocHJvcHMpIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50LnVwZGF0ZVByb3BzKHByb3BzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbktleURvd24ocHJvcHMpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BzLmV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC51cGRhdGVQcm9wcyh7XG4gICAgICAgICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgICAgICAgIGhpZGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50LnJlZj8ub25LZXlEb3duKHByb3BzKSA/PyBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkV4aXQoKSB7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY29tcG9uZW50LmVsZW1lbnQpO1xuICAgICAgICAgICAgICBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgbm90aWZpZXIodGhpcy5vcHRpb25zKSxcbiAgICAgIG1lbnRpb25QYXN0ZUhhbmRsZXIoKVxuICAgIF07XG4gIH1cbn0pO1xuXG5leHBvcnQgeyBNZW50aW9uRXh0ZW5zaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZW50aW9uRXh0ZW5zaW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionExtension.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionNode.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionNode.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MentionNode: () => (/* binding */ MentionNode)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/react */ \"(ssr)/./node_modules/@tiptap/react/dist/index.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/types.js\");\n/* harmony import */ var _Mention_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Mention.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/Mention.js\");\n\n\n\n\n\nconst MentionNode = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: _types_js__WEBPACK_IMPORTED_MODULE_1__.LIVEBLOCKS_MENTION_TYPE,\n  group: \"inline\",\n  inline: true,\n  selectable: true,\n  atom: true,\n  priority: 101,\n  parseHTML() {\n    return [\n      {\n        tag: \"liveblocks-mention\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"liveblocks-mention\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(HTMLAttributes)];\n  },\n  addNodeView() {\n    return (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_2__.ReactNodeViewRenderer)(_Mention_js__WEBPACK_IMPORTED_MODULE_3__.Mention, {\n      contentDOMElementTag: \"span\"\n    });\n  },\n  addAttributes() {\n    return {\n      id: {\n        default: null,\n        parseHTML: (element) => element.getAttribute(\"data-id\"),\n        renderHTML: (attributes) => {\n          if (!attributes.id) {\n            return {};\n          }\n          return {\n            \"data-id\": attributes.id\n          };\n        }\n      },\n      notificationId: {\n        default: null,\n        parseHTML: (element) => element.getAttribute(\"data-notification-id\"),\n        renderHTML: (attributes) => {\n          if (!attributes.notificationId) {\n            return {};\n          }\n          return {\n            \"data-notification-id\": attributes.notificationId\n          };\n        }\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      Backspace: () => this.editor.commands.command(({ tr, state }) => {\n        let isMention = false;\n        const { selection } = state;\n        const { empty, anchor } = selection;\n        if (!empty) {\n          return false;\n        }\n        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {\n          if (node.type.name === this.name) {\n            isMention = true;\n            tr.insertText(\"\", pos, pos + node.nodeSize);\n          }\n        });\n        return isMention;\n      })\n    };\n  }\n});\n\n\n//# sourceMappingURL=MentionNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvbWVudGlvbnMvTWVudGlvbk5vZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUQ7QUFDQztBQUNBO0FBQ2Y7O0FBRXZDLG9CQUFvQiw4Q0FBSTtBQUN4QixRQUFRLDhEQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsZ0JBQWdCO0FBQy9CLGtDQUFrQyw2REFBZTtBQUNqRCxHQUFHO0FBQ0g7QUFDQSxXQUFXLG9FQUFxQixDQUFDLGdEQUFPO0FBQ3hDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRXNCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC10aXB0YXAvZGlzdC9tZW50aW9ucy9NZW50aW9uTm9kZS5qcz9kY2Y3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBSZWFjdE5vZGVWaWV3UmVuZGVyZXIgfSBmcm9tICdAdGlwdGFwL3JlYWN0JztcbmltcG9ydCB7IExJVkVCTE9DS1NfTUVOVElPTl9UWVBFIH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHsgTWVudGlvbiB9IGZyb20gJy4vTWVudGlvbi5qcyc7XG5cbmNvbnN0IE1lbnRpb25Ob2RlID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBMSVZFQkxPQ0tTX01FTlRJT05fVFlQRSxcbiAgZ3JvdXA6IFwiaW5saW5lXCIsXG4gIGlubGluZTogdHJ1ZSxcbiAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgYXRvbTogdHJ1ZSxcbiAgcHJpb3JpdHk6IDEwMSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJsaXZlYmxvY2tzLW1lbnRpb25cIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcImxpdmVibG9ja3MtbWVudGlvblwiLCBtZXJnZUF0dHJpYnV0ZXMoSFRNTEF0dHJpYnV0ZXMpXTtcbiAgfSxcbiAgYWRkTm9kZVZpZXcoKSB7XG4gICAgcmV0dXJuIFJlYWN0Tm9kZVZpZXdSZW5kZXJlcihNZW50aW9uLCB7XG4gICAgICBjb250ZW50RE9NRWxlbWVudFRhZzogXCJzcGFuXCJcbiAgICB9KTtcbiAgfSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlkXCIpLFxuICAgICAgICByZW5kZXJIVE1MOiAoYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgIGlmICghYXR0cmlidXRlcy5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJkYXRhLWlkXCI6IGF0dHJpYnV0ZXMuaWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbm90aWZpY2F0aW9uSWQ6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5vdGlmaWNhdGlvbi1pZFwiKSxcbiAgICAgICAgcmVuZGVySFRNTDogKGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMubm90aWZpY2F0aW9uSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwiZGF0YS1ub3RpZmljYXRpb24taWRcIjogYXR0cmlidXRlcy5ub3RpZmljYXRpb25JZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgQmFja3NwYWNlOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyLCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgIGxldCBpc01lbnRpb24gPSBmYWxzZTtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB7IGVtcHR5LCBhbmNob3IgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCFlbXB0eSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGFuY2hvciAtIDEsIGFuY2hvciwgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgIGlmIChub2RlLnR5cGUubmFtZSA9PT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICBpc01lbnRpb24gPSB0cnVlO1xuICAgICAgICAgICAgdHIuaW5zZXJ0VGV4dChcIlwiLCBwb3MsIHBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpc01lbnRpb247XG4gICAgICB9KVxuICAgIH07XG4gIH1cbn0pO1xuXG5leHBvcnQgeyBNZW50aW9uTm9kZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVudGlvbk5vZGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionsList.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionsList.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MentionsList: () => (/* binding */ MentionsList),\n/* harmony export */   SUGGESTIONS_COLLISION_PADDING: () => (/* binding */ SUGGESTIONS_COLLISION_PADDING),\n/* harmony export */   User: () => (/* binding */ User)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liveblocks/react */ \"(ssr)/./node_modules/@liveblocks/react/dist/chunk-5RVW253W.js\");\n/* harmony import */ var _liveblocks_react_private__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @liveblocks/react/_private */ \"(ssr)/./node_modules/@liveblocks/react/dist/_private.js\");\n/* harmony import */ var _liveblocks_react_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/react-ui */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _Avatar_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Avatar.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/Avatar.js\");\n\n\n\n\n\n\n\n\n\nconst User = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  function User2(props, forwardedRef) {\n    const { userId, className, ...spanProps } = props;\n    const { user, isLoading } = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_2__._useUser)(userId);\n    const $ = (0,_liveblocks_react_ui__WEBPACK_IMPORTED_MODULE_3__.useOverrides)();\n    const name = user === void 0 || user === null ? $.USER_UNKNOWN : user.name;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      className,\n      \"data-loading\": isLoading ? \"\" : void 0,\n      ref: forwardedRef,\n      ...spanProps,\n      children: isLoading ? null : name\n    });\n  }\n);\nconst SUGGESTIONS_COLLISION_PADDING = 10;\nconst MentionsList = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  (props, ref) => {\n    const [selectedIndex, setSelectedIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const room = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_2__._useRoom)();\n    const suggestions = (0,_liveblocks_react_private__WEBPACK_IMPORTED_MODULE_4__.useMentionSuggestions)(room.id, props.query);\n    const { onMouseEnter, onClick } = props;\n    const {\n      refs: { setReference, setFloating },\n      strategy,\n      x,\n      y\n    } = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.useFloating)({\n      strategy: \"fixed\",\n      placement: \"top-start\",\n      middleware: [\n        (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.flip)({ padding: SUGGESTIONS_COLLISION_PADDING, crossAxis: false }),\n        (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.offset)(10),\n        (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.hide)({ padding: SUGGESTIONS_COLLISION_PADDING }),\n        (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.shift)({\n          padding: SUGGESTIONS_COLLISION_PADDING,\n          limiter: (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.limitShift)()\n        }),\n        (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.size)({ padding: SUGGESTIONS_COLLISION_PADDING })\n      ],\n      whileElementsMounted: (...args) => {\n        return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_6__.autoUpdate)(...args, {\n          animationFrame: true\n        });\n      }\n    });\n    (0,_liveblocks_react_private__WEBPACK_IMPORTED_MODULE_4__.useLayoutEffect)(() => {\n      setReference({\n        getBoundingClientRect: props.clientRect\n      });\n    }, [setReference, props.clientRect]);\n    const selectItem = (index) => {\n      const item = (suggestions ?? [])[index];\n      if (item) {\n        props.command({\n          id: item,\n          notificationId: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_7__.createInboxNotificationId)()\n        });\n      }\n    };\n    const upHandler = () => {\n      setSelectedIndex(\n        (selectedIndex + (suggestions?.length ?? 0) - 1) % (suggestions?.length ?? 0)\n      );\n    };\n    const downHandler = () => {\n      setSelectedIndex((selectedIndex + 1) % (suggestions?.length ?? 0));\n    };\n    const enterHandler = () => {\n      selectItem(selectedIndex);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => setSelectedIndex(0), [suggestions]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(ref, () => ({\n      onKeyDown: ({ event }) => {\n        if (event.key === \"ArrowUp\") {\n          upHandler();\n          return true;\n        }\n        if (event.key === \"ArrowDown\") {\n          downHandler();\n          return true;\n        }\n        if (event.key === \"Enter\") {\n          enterHandler();\n          return true;\n        }\n        return false;\n      }\n    }));\n    const handleClick = (index) => (event) => {\n      onClick?.(event);\n      if (event.isDefaultPrevented())\n        return;\n      selectItem(index);\n    };\n    const handleMouseEnter = (index) => (event) => {\n      onMouseEnter?.(event);\n      if (event.isDefaultPrevented())\n        return;\n      setSelectedIndex(index);\n    };\n    if (suggestions === void 0 || suggestions.length === 0) {\n      return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      className: \"lb-root lb-portal lb-elevation lb-tiptap-suggestions lb-tiptap-mention-suggestions\",\n      ref: setFloating,\n      style: {\n        position: strategy,\n        top: 0,\n        left: 0,\n        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,\n        minWidth: \"max-content\",\n        display: props.hide ? \"none\" : \"block\"\n      },\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"lb-tiptap-suggestions-list lb-tiptap-mention-suggestions-list\",\n        children: suggestions.map((item, index) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n          className: \"lb-tiptap-suggestions-list-item lb-tiptap-mention-suggestion\",\n          role: \"option\",\n          \"data-highlighted\": index === selectedIndex || void 0,\n          onMouseEnter: handleMouseEnter(index),\n          onClick: handleClick(index),\n          children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Avatar_js__WEBPACK_IMPORTED_MODULE_8__.Avatar, {\n              userId: item,\n              className: \"lb-tiptap-mention-suggestion-avatar\"\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(User, {\n              userId: item,\n              className: \"lb-tiptap-mention-suggestion-user\"\n            })\n          ]\n        }, index))\n      })\n    });\n  }\n);\n\n\n//# sourceMappingURL=MentionsList.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvbWVudGlvbnMvTWVudGlvbnNMaXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNnRTtBQUNqRDtBQUNSO0FBQytCO0FBQ2hDO0FBQ3lCO0FBQ3hDOztBQUVyQyxhQUFhLGlEQUFVO0FBQ3ZCO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUMsWUFBWSxrQkFBa0IsRUFBRSwyREFBTztBQUN2QyxjQUFjLGtFQUFZO0FBQzFCO0FBQ0EsMkJBQTJCLHNEQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFVO0FBQy9CO0FBQ0EsOENBQThDLCtDQUFRO0FBQ3RELGlCQUFpQiwyREFBTztBQUN4Qix3QkFBd0IsZ0ZBQXFCO0FBQzdDLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFLG1FQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQUksR0FBRywwREFBMEQ7QUFDekUsUUFBUSw4REFBTTtBQUNkLFFBQVEsNERBQUksR0FBRyx3Q0FBd0M7QUFDdkQsUUFBUSw2REFBSztBQUNiO0FBQ0EsbUJBQW1CLGtFQUFVO0FBQzdCLFNBQVM7QUFDVCxRQUFRLDREQUFJLEdBQUcsd0NBQXdDO0FBQ3ZEO0FBQ0E7QUFDQSxlQUFlLGtFQUFVO0FBQ3pCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLElBQUksMEVBQWU7QUFDbkI7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyRUFBeUI7QUFDbkQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBUztBQUNiLElBQUksMERBQW1CO0FBQ3ZCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNEQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjLE1BQU0sY0FBYztBQUNwRTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdDQUFnQyxzREFBRztBQUNuQztBQUNBLG1FQUFtRSx1REFBSTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQUcsQ0FBQyw4Q0FBTTtBQUN0QztBQUNBO0FBQ0EsYUFBYTtBQUNiLDRCQUE0QixzREFBRztBQUMvQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFNkQ7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXRpcHRhcC9kaXN0L21lbnRpb25zL01lbnRpb25zTGlzdC5qcz80NzMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCwganN4cyB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IHVzZUZsb2F0aW5nLCBmbGlwLCBvZmZzZXQsIGhpZGUsIHNoaWZ0LCBsaW1pdFNoaWZ0LCBzaXplLCBhdXRvVXBkYXRlIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBjcmVhdGVJbmJveE5vdGlmaWNhdGlvbklkIH0gZnJvbSAnQGxpdmVibG9ja3MvY29yZSc7XG5pbXBvcnQgeyB1c2VVc2VyLCB1c2VSb29tIH0gZnJvbSAnQGxpdmVibG9ja3MvcmVhY3QnO1xuaW1wb3J0IHsgdXNlTWVudGlvblN1Z2dlc3Rpb25zLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdAbGl2ZWJsb2Nrcy9yZWFjdC9fcHJpdmF0ZSc7XG5pbXBvcnQgeyB1c2VPdmVycmlkZXMgfSBmcm9tICdAbGl2ZWJsb2Nrcy9yZWFjdC11aSc7XG5pbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQXZhdGFyIH0gZnJvbSAnLi9BdmF0YXIuanMnO1xuXG5jb25zdCBVc2VyID0gZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24gVXNlcjIocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICAgIGNvbnN0IHsgdXNlcklkLCBjbGFzc05hbWUsIC4uLnNwYW5Qcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyB1c2VyLCBpc0xvYWRpbmcgfSA9IHVzZVVzZXIodXNlcklkKTtcbiAgICBjb25zdCAkID0gdXNlT3ZlcnJpZGVzKCk7XG4gICAgY29uc3QgbmFtZSA9IHVzZXIgPT09IHZvaWQgMCB8fCB1c2VyID09PSBudWxsID8gJC5VU0VSX1VOS05PV04gOiB1c2VyLm5hbWU7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHtcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIFwiZGF0YS1sb2FkaW5nXCI6IGlzTG9hZGluZyA/IFwiXCIgOiB2b2lkIDAsXG4gICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgIC4uLnNwYW5Qcm9wcyxcbiAgICAgIGNoaWxkcmVuOiBpc0xvYWRpbmcgPyBudWxsIDogbmFtZVxuICAgIH0pO1xuICB9XG4pO1xuY29uc3QgU1VHR0VTVElPTlNfQ09MTElTSU9OX1BBRERJTkcgPSAxMDtcbmNvbnN0IE1lbnRpb25zTGlzdCA9IGZvcndhcmRSZWYoXG4gIChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3QgW3NlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXhdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzdWdnZXN0aW9ucyA9IHVzZU1lbnRpb25TdWdnZXN0aW9ucyhyb29tLmlkLCBwcm9wcy5xdWVyeSk7XG4gICAgY29uc3QgeyBvbk1vdXNlRW50ZXIsIG9uQ2xpY2sgfSA9IHByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZnM6IHsgc2V0UmVmZXJlbmNlLCBzZXRGbG9hdGluZyB9LFxuICAgICAgc3RyYXRlZ3ksXG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB1c2VGbG9hdGluZyh7XG4gICAgICBzdHJhdGVneTogXCJmaXhlZFwiLFxuICAgICAgcGxhY2VtZW50OiBcInRvcC1zdGFydFwiLFxuICAgICAgbWlkZGxld2FyZTogW1xuICAgICAgICBmbGlwKHsgcGFkZGluZzogU1VHR0VTVElPTlNfQ09MTElTSU9OX1BBRERJTkcsIGNyb3NzQXhpczogZmFsc2UgfSksXG4gICAgICAgIG9mZnNldCgxMCksXG4gICAgICAgIGhpZGUoeyBwYWRkaW5nOiBTVUdHRVNUSU9OU19DT0xMSVNJT05fUEFERElORyB9KSxcbiAgICAgICAgc2hpZnQoe1xuICAgICAgICAgIHBhZGRpbmc6IFNVR0dFU1RJT05TX0NPTExJU0lPTl9QQURESU5HLFxuICAgICAgICAgIGxpbWl0ZXI6IGxpbWl0U2hpZnQoKVxuICAgICAgICB9KSxcbiAgICAgICAgc2l6ZSh7IHBhZGRpbmc6IFNVR0dFU1RJT05TX0NPTExJU0lPTl9QQURESU5HIH0pXG4gICAgICBdLFxuICAgICAgd2hpbGVFbGVtZW50c01vdW50ZWQ6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiBhdXRvVXBkYXRlKC4uLmFyZ3MsIHtcbiAgICAgICAgICBhbmltYXRpb25GcmFtZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgc2V0UmVmZXJlbmNlKHtcbiAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBwcm9wcy5jbGllbnRSZWN0XG4gICAgICB9KTtcbiAgICB9LCBbc2V0UmVmZXJlbmNlLCBwcm9wcy5jbGllbnRSZWN0XSk7XG4gICAgY29uc3Qgc2VsZWN0SXRlbSA9IChpbmRleCkgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IChzdWdnZXN0aW9ucyA/PyBbXSlbaW5kZXhdO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgcHJvcHMuY29tbWFuZCh7XG4gICAgICAgICAgaWQ6IGl0ZW0sXG4gICAgICAgICAgbm90aWZpY2F0aW9uSWQ6IGNyZWF0ZUluYm94Tm90aWZpY2F0aW9uSWQoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHNldFNlbGVjdGVkSW5kZXgoXG4gICAgICAgIChzZWxlY3RlZEluZGV4ICsgKHN1Z2dlc3Rpb25zPy5sZW5ndGggPz8gMCkgLSAxKSAlIChzdWdnZXN0aW9ucz8ubGVuZ3RoID8/IDApXG4gICAgICApO1xuICAgIH07XG4gICAgY29uc3QgZG93bkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBzZXRTZWxlY3RlZEluZGV4KChzZWxlY3RlZEluZGV4ICsgMSkgJSAoc3VnZ2VzdGlvbnM/Lmxlbmd0aCA/PyAwKSk7XG4gICAgfTtcbiAgICBjb25zdCBlbnRlckhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBzZWxlY3RJdGVtKHNlbGVjdGVkSW5kZXgpO1xuICAgIH07XG4gICAgdXNlRWZmZWN0KCgpID0+IHNldFNlbGVjdGVkSW5kZXgoMCksIFtzdWdnZXN0aW9uc10pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiAoe1xuICAgICAgb25LZXlEb3duOiAoeyBldmVudCB9KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiQXJyb3dVcFwiKSB7XG4gICAgICAgICAgdXBIYW5kbGVyKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd0Rvd25cIikge1xuICAgICAgICAgIGRvd25IYW5kbGVyKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgZW50ZXJIYW5kbGVyKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBoYW5kbGVDbGljayA9IChpbmRleCkgPT4gKGV2ZW50KSA9PiB7XG4gICAgICBvbkNsaWNrPy4oZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKVxuICAgICAgICByZXR1cm47XG4gICAgICBzZWxlY3RJdGVtKGluZGV4KTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZU1vdXNlRW50ZXIgPSAoaW5kZXgpID0+IChldmVudCkgPT4ge1xuICAgICAgb25Nb3VzZUVudGVyPy4oZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKVxuICAgICAgICByZXR1cm47XG4gICAgICBzZXRTZWxlY3RlZEluZGV4KGluZGV4KTtcbiAgICB9O1xuICAgIGlmIChzdWdnZXN0aW9ucyA9PT0gdm9pZCAwIHx8IHN1Z2dlc3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJsYi1yb290IGxiLXBvcnRhbCBsYi1lbGV2YXRpb24gbGItdGlwdGFwLXN1Z2dlc3Rpb25zIGxiLXRpcHRhcC1tZW50aW9uLXN1Z2dlc3Rpb25zXCIsXG4gICAgICByZWY6IHNldEZsb2F0aW5nLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7TWF0aC5yb3VuZCh4KX1weCwgJHtNYXRoLnJvdW5kKHkpfXB4LCAwKWAsXG4gICAgICAgIG1pbldpZHRoOiBcIm1heC1jb250ZW50XCIsXG4gICAgICAgIGRpc3BsYXk6IHByb3BzLmhpZGUgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIlxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxiLXRpcHRhcC1zdWdnZXN0aW9ucy1saXN0IGxiLXRpcHRhcC1tZW50aW9uLXN1Z2dlc3Rpb25zLWxpc3RcIixcbiAgICAgICAgY2hpbGRyZW46IHN1Z2dlc3Rpb25zLm1hcCgoaXRlbSwgaW5kZXgpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwibGItdGlwdGFwLXN1Z2dlc3Rpb25zLWxpc3QtaXRlbSBsYi10aXB0YXAtbWVudGlvbi1zdWdnZXN0aW9uXCIsXG4gICAgICAgICAgcm9sZTogXCJvcHRpb25cIixcbiAgICAgICAgICBcImRhdGEtaGlnaGxpZ2h0ZWRcIjogaW5kZXggPT09IHNlbGVjdGVkSW5kZXggfHwgdm9pZCAwLFxuICAgICAgICAgIG9uTW91c2VFbnRlcjogaGFuZGxlTW91c2VFbnRlcihpbmRleCksXG4gICAgICAgICAgb25DbGljazogaGFuZGxlQ2xpY2soaW5kZXgpLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KEF2YXRhciwge1xuICAgICAgICAgICAgICB1c2VySWQ6IGl0ZW0sXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJsYi10aXB0YXAtbWVudGlvbi1zdWdnZXN0aW9uLWF2YXRhclwiXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goVXNlciwge1xuICAgICAgICAgICAgICB1c2VySWQ6IGl0ZW0sXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJsYi10aXB0YXAtbWVudGlvbi1zdWdnZXN0aW9uLXVzZXJcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdXG4gICAgICAgIH0sIGluZGV4KSlcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbik7XG5cbmV4cG9ydCB7IE1lbnRpb25zTGlzdCwgU1VHR0VTVElPTlNfQ09MTElTSU9OX1BBRERJTkcsIFVzZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lbnRpb25zTGlzdC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/mentions/MentionsList.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/toolbar/FloatingToolbar.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/toolbar/FloatingToolbar.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FLOATING_TOOLBAR_COLLISION_PADDING: () => (/* binding */ FLOATING_TOOLBAR_COLLISION_PADDING),\n/* harmony export */   FloatingToolbar: () => (/* binding */ FloatingToolbar)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _liveblocks_react_private__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @liveblocks/react/_private */ \"(ssr)/./node_modules/@liveblocks/react/dist/_private.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-initial.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-refs.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/node_modules/@radix-ui/react-tooltip/dist/index.mjs\");\n/* harmony import */ var _tiptap_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/react */ \"(ssr)/./node_modules/@tiptap/react/dist/index.js\");\n/* harmony import */ var _tiptap_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/react */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _classnames_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../classnames.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/classnames.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/context.js\");\n/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./shared.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/toolbar/shared.js\");\n/* harmony import */ var _Toolbar_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Toolbar.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/toolbar/Toolbar.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst FLOATING_TOOLBAR_COLLISION_PADDING = 10;\nconst FLOATING_TOOLBAR_OPEN_DELAY = 50;\nfunction DefaultFloatingToolbarContent({ editor }) {\n  const supportsThread = \"addPendingComment\" in editor.commands;\n  const supportsAi = \"askAi\" in editor.commands;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: [\n      supportsAi ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Toolbar_js__WEBPACK_IMPORTED_MODULE_3__.Toolbar.SectionAi, {}),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Toolbar_js__WEBPACK_IMPORTED_MODULE_3__.Toolbar.Separator, {})\n        ]\n      }) : null,\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Toolbar_js__WEBPACK_IMPORTED_MODULE_3__.Toolbar.BlockSelector, {}),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Toolbar_js__WEBPACK_IMPORTED_MODULE_3__.Toolbar.SectionInline, {}),\n      supportsThread ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Toolbar_js__WEBPACK_IMPORTED_MODULE_3__.Toolbar.Separator, {}),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Toolbar_js__WEBPACK_IMPORTED_MODULE_3__.Toolbar.SectionCollaboration, {})\n        ]\n      }) : null\n    ]\n  });\n}\nconst FloatingToolbar = Object.assign(\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n    ({\n      children = DefaultFloatingToolbarContent,\n      before,\n      after,\n      position = \"top\",\n      offset: sideOffset = 6,\n      editor,\n      onPointerDown,\n      onFocus,\n      onBlur,\n      className,\n      ...props\n    }, forwardedRef) => {\n      const toolbarRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n      const externalIds = (0,_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_4__.useInitial)(() => /* @__PURE__ */ new Set());\n      const [isPointerDown, setPointerDown] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n      const [isFocused, setFocused] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n      const [isManuallyClosed, setManuallyClosed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n      const hasSelectionRange = (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_5__.useEditorState)({\n        editor,\n        equalityFn: Object.is,\n        selector: (ctx) => {\n          const editor2 = ctx.editor;\n          if (!editor2) {\n            return false;\n          }\n          const { doc, selection } = editor2.state;\n          const { empty, ranges } = selection;\n          const from = Math.min(...ranges.map((range) => range.$from.pos));\n          const to = Math.max(...ranges.map((range) => range.$to.pos));\n          if (empty) {\n            return false;\n          }\n          return (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_6__.isTextSelection)(selection) && doc.textBetween(from, to).length > 0;\n        }\n      }) ?? false;\n      const isOpen = isFocused && !isPointerDown && hasSelectionRange && !isManuallyClosed;\n      const [delayedIsOpen, setDelayedIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(isOpen);\n      const delayedIsOpenTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n      (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        if (!editor) {\n          return;\n        }\n        setManuallyClosed(false);\n        const handleSelectionChange = () => {\n          setManuallyClosed(false);\n        };\n        editor.on(\"selectionUpdate\", handleSelectionChange);\n        return () => {\n          editor.off(\"selectionUpdate\", handleSelectionChange);\n        };\n      }, [isFocused, hasSelectionRange, editor]);\n      (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        if (!editor) {\n          return;\n        }\n        const handleFocus2 = () => {\n          setFocused(true);\n        };\n        const handleBlur2 = (event) => {\n          if (event.relatedTarget && toolbarRef.current?.contains(event.relatedTarget)) {\n            return;\n          }\n          if (event.relatedTarget === editor.view.dom) {\n            return;\n          }\n          for (const externalId of externalIds) {\n            if (document.getElementById(externalId)?.contains(event.relatedTarget)) {\n              return;\n            }\n          }\n          setFocused(false);\n        };\n        editor.view.dom.addEventListener(\"focus\", handleFocus2);\n        editor.view.dom.addEventListener(\"blur\", handleBlur2);\n        return () => {\n          editor.view.dom.removeEventListener(\"focus\", handleFocus2);\n          editor.view.dom.removeEventListener(\"blur\", handleBlur2);\n        };\n      }, [editor, externalIds]);\n      const handleFocus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n        (event) => {\n          onFocus?.(event);\n          if (!event.isDefaultPrevented()) {\n            setFocused(true);\n          }\n        },\n        [onFocus]\n      );\n      const handleBlur = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n        (event) => {\n          onBlur?.(event);\n          if (!event.isDefaultPrevented()) {\n            if (event.relatedTarget && toolbarRef.current?.contains(event.relatedTarget)) {\n              return;\n            }\n            if (event.relatedTarget === editor?.view.dom) {\n              return;\n            }\n            for (const externalId of externalIds) {\n              if (document.getElementById(externalId)?.contains(event.relatedTarget)) {\n                return;\n              }\n            }\n            setFocused(false);\n          }\n        },\n        [onBlur, editor, externalIds]\n      );\n      (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        if (isOpen) {\n          delayedIsOpenTimeoutRef.current = window.setTimeout(() => {\n            setDelayedIsOpen(true);\n          }, FLOATING_TOOLBAR_OPEN_DELAY);\n        } else {\n          setDelayedIsOpen(false);\n        }\n        return () => {\n          window.clearTimeout(delayedIsOpenTimeoutRef.current);\n        };\n      }, [isOpen]);\n      const floatingOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        const detectOverflowOptions = {\n          padding: FLOATING_TOOLBAR_COLLISION_PADDING\n        };\n        return {\n          strategy: \"fixed\",\n          placement: position,\n          middleware: [\n            (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_7__.inline)(detectOverflowOptions),\n            (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_7__.flip)({ ...detectOverflowOptions, crossAxis: false }),\n            (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_7__.hide)(detectOverflowOptions),\n            (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_7__.shift)({\n              ...detectOverflowOptions,\n              limiter: (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_7__.limitShift)()\n            }),\n            (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_7__.offset)(sideOffset),\n            (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_7__.size)(detectOverflowOptions)\n          ],\n          whileElementsMounted: (...args) => {\n            return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_8__.autoUpdate)(...args, {\n              animationFrame: true\n            });\n          }\n        };\n      }, [position, sideOffset]);\n      const {\n        refs: { setReference, setFloating },\n        strategy,\n        x,\n        y,\n        isPositioned\n      } = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_7__.useFloating)({\n        ...floatingOptions,\n        open: delayedIsOpen\n      });\n      const mergedRefs = (0,_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_9__.useRefs)(forwardedRef, toolbarRef, setFloating);\n      const handlePointerDown = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n        (event) => {\n          onPointerDown?.(event);\n          event.stopPropagation();\n          if (event.target === toolbarRef.current) {\n            event.preventDefault();\n          }\n        },\n        [onPointerDown]\n      );\n      (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        if (!editor) {\n          return;\n        }\n        const handlePointerDown2 = () => {\n          setPointerDown(true);\n        };\n        const handlePointerUp = () => {\n          setPointerDown(false);\n        };\n        editor.view.dom.addEventListener(\"pointerdown\", handlePointerDown2);\n        document.addEventListener(\"pointercancel\", handlePointerUp);\n        document.addEventListener(\"pointerup\", handlePointerUp);\n        return () => {\n          editor.view.dom.removeEventListener(\"pointerdown\", handlePointerDown2);\n          document.removeEventListener(\"pointercancel\", handlePointerUp);\n          document.removeEventListener(\"pointerup\", handlePointerUp);\n        };\n      }, [editor]);\n      (0,_liveblocks_react_private__WEBPACK_IMPORTED_MODULE_10__.useLayoutEffect)(() => {\n        if (!editor || !delayedIsOpen) {\n          return;\n        }\n        const updateSelectionReference = () => {\n          const domSelection = window.getSelection();\n          if (editor.state.selection.empty || !domSelection || !domSelection.rangeCount) {\n            setReference(null);\n          } else {\n            const domRange = domSelection.getRangeAt(0);\n            setReference(domRange);\n          }\n        };\n        editor.on(\"transaction\", updateSelectionReference);\n        updateSelectionReference();\n        return () => {\n          editor.off(\"transaction\", updateSelectionReference);\n        };\n      }, [editor, delayedIsOpen, setReference]);\n      (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        if (!editor || !delayedIsOpen) {\n          return;\n        }\n        const handleKeyDown = (event) => {\n          if (event.target !== editor.view.dom && event.defaultPrevented) {\n            return;\n          }\n          if (event.key === \"Escape\") {\n            event.preventDefault();\n            event.stopPropagation();\n            editor.commands.focus();\n            setManuallyClosed(true);\n          }\n        };\n        editor.view.dom.addEventListener(\"keydown\", handleKeyDown);\n        return () => {\n          editor.view.dom.removeEventListener(\"keydown\", handleKeyDown);\n        };\n      }, [editor, delayedIsOpen]);\n      const close = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n        setManuallyClosed(true);\n      }, [setManuallyClosed]);\n      const registerExternal = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n        (id) => {\n          externalIds.add(id);\n          return () => {\n            externalIds.delete(id);\n          };\n        },\n        [externalIds]\n      );\n      if (!editor || !delayedIsOpen) {\n        return null;\n      }\n      const slotProps = { editor };\n      return (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_11__.TooltipProvider, {\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_context_js__WEBPACK_IMPORTED_MODULE_12__.EditorProvider, {\n            editor,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_shared_js__WEBPACK_IMPORTED_MODULE_13__.FloatingToolbarContext.Provider, {\n              value: { close, registerExternal },\n              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                role: \"toolbar\",\n                \"aria-label\": \"Floating toolbar\",\n                \"aria-orientation\": \"horizontal\",\n                className: (0,_classnames_js__WEBPACK_IMPORTED_MODULE_14__.classNames)(\n                  \"lb-root lb-portal lb-elevation lb-tiptap-floating-toolbar lb-tiptap-toolbar\",\n                  className\n                ),\n                ref: mergedRefs,\n                style: {\n                  position: strategy,\n                  top: 0,\n                  left: 0,\n                  transform: isPositioned ? `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)` : \"translate3d(0, -200%, 0)\",\n                  minWidth: \"max-content\"\n                },\n                onPointerDown: handlePointerDown,\n                onFocus: handleFocus,\n                onBlur: handleBlur,\n                ...props,\n                children: [\n                  (0,_Toolbar_js__WEBPACK_IMPORTED_MODULE_3__.applyToolbarSlot)(before, slotProps),\n                  (0,_Toolbar_js__WEBPACK_IMPORTED_MODULE_3__.applyToolbarSlot)(children, slotProps),\n                  (0,_Toolbar_js__WEBPACK_IMPORTED_MODULE_3__.applyToolbarSlot)(after, slotProps)\n                ]\n              })\n            })\n          })\n        }),\n        document.body\n      );\n    }\n  ),\n  {\n    External: _shared_js__WEBPACK_IMPORTED_MODULE_13__.FloatingToolbarExternal\n  }\n);\n\n\n//# sourceMappingURL=FloatingToolbar.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvdG9vbGJhci9GbG9hdGluZ1Rvb2xiYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDOEQ7QUFDekQ7QUFDd0I7QUFDckI7QUFDc0I7QUFDN0M7QUFDSztBQUNDO0FBQytCO0FBQ3JCOztBQUV6RDtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBLHlCQUF5Qix1REFBSSxDQUFDLHVEQUFRO0FBQ3RDO0FBQ0EsbUNBQW1DLHVEQUFJLENBQUMsdURBQVE7QUFDaEQ7QUFDQSwwQkFBMEIsc0RBQUcsQ0FBQyxnREFBTyxjQUFjO0FBQ25ELDBCQUEwQixzREFBRyxDQUFDLGdEQUFPLGNBQWM7QUFDbkQ7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLHNEQUFHLENBQUMsZ0RBQU8sa0JBQWtCO0FBQ25ELHNCQUFzQixzREFBRyxDQUFDLGdEQUFPLGtCQUFrQjtBQUNuRCx1Q0FBdUMsdURBQUksQ0FBQyx1REFBUTtBQUNwRDtBQUNBLDBCQUEwQixzREFBRyxDQUFDLGdEQUFPLGNBQWM7QUFDbkQsMEJBQTBCLHNEQUFHLENBQUMsZ0RBQU8seUJBQXlCO0FBQzlEO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFLGlEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5Qiw2Q0FBTTtBQUMvQiwwQkFBMEIsd0VBQVU7QUFDcEMsOENBQThDLCtDQUFRO0FBQ3RELHNDQUFzQywrQ0FBUTtBQUM5QyxvREFBb0QsK0NBQVE7QUFDNUQsZ0NBQWdDLDZEQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQyxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFD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Q0E7QUFDQSxrQkFBa0IsNkRBQWdCO0FBQ2xDLGtCQUFrQiw2REFBZ0I7QUFDbEMsa0JBQWtCLDZEQUFnQjtBQUNsQztBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnRUFBdUI7QUFDckM7QUFDQTs7QUFFK0Q7QUFDL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXRpcHRhcC9kaXN0L3Rvb2xiYXIvRmxvYXRpbmdUb29sYmFyLmpzPzk3NmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4cywgRnJhZ21lbnQsIGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IGlubGluZSwgZmxpcCwgaGlkZSwgc2hpZnQsIGxpbWl0U2hpZnQsIG9mZnNldCwgc2l6ZSwgYXV0b1VwZGF0ZSwgdXNlRmxvYXRpbmcgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QtZG9tJztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ0BsaXZlYmxvY2tzL3JlYWN0L19wcml2YXRlJztcbmltcG9ydCB7IHVzZUluaXRpYWwsIHVzZVJlZnMsIFRvb2x0aXBQcm92aWRlciB9IGZyb20gJ0BsaXZlYmxvY2tzL3JlYWN0LXVpL19wcml2YXRlJztcbmltcG9ydCB7IHVzZUVkaXRvclN0YXRlLCBpc1RleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3JlYWN0JztcbmltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gJy4uL2NsYXNzbmFtZXMuanMnO1xuaW1wb3J0IHsgRWRpdG9yUHJvdmlkZXIgfSBmcm9tICcuLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IEZsb2F0aW5nVG9vbGJhckNvbnRleHQsIEZsb2F0aW5nVG9vbGJhckV4dGVybmFsIH0gZnJvbSAnLi9zaGFyZWQuanMnO1xuaW1wb3J0IHsgVG9vbGJhciwgYXBwbHlUb29sYmFyU2xvdCB9IGZyb20gJy4vVG9vbGJhci5qcyc7XG5cbmNvbnN0IEZMT0FUSU5HX1RPT0xCQVJfQ09MTElTSU9OX1BBRERJTkcgPSAxMDtcbmNvbnN0IEZMT0FUSU5HX1RPT0xCQVJfT1BFTl9ERUxBWSA9IDUwO1xuZnVuY3Rpb24gRGVmYXVsdEZsb2F0aW5nVG9vbGJhckNvbnRlbnQoeyBlZGl0b3IgfSkge1xuICBjb25zdCBzdXBwb3J0c1RocmVhZCA9IFwiYWRkUGVuZGluZ0NvbW1lbnRcIiBpbiBlZGl0b3IuY29tbWFuZHM7XG4gIGNvbnN0IHN1cHBvcnRzQWkgPSBcImFza0FpXCIgaW4gZWRpdG9yLmNvbW1hbmRzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW1xuICAgICAgc3VwcG9ydHNBaSA/IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChUb29sYmFyLlNlY3Rpb25BaSwge30pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhci5TZXBhcmF0b3IsIHt9KVxuICAgICAgICBdXG4gICAgICB9KSA6IG51bGwsXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFRvb2xiYXIuQmxvY2tTZWxlY3Rvciwge30pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChUb29sYmFyLlNlY3Rpb25JbmxpbmUsIHt9KSxcbiAgICAgIHN1cHBvcnRzVGhyZWFkID8gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFRvb2xiYXIuU2VwYXJhdG9yLCB7fSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChUb29sYmFyLlNlY3Rpb25Db2xsYWJvcmF0aW9uLCB7fSlcbiAgICAgICAgXVxuICAgICAgfSkgOiBudWxsXG4gICAgXVxuICB9KTtcbn1cbmNvbnN0IEZsb2F0aW5nVG9vbGJhciA9IE9iamVjdC5hc3NpZ24oXG4gIGZvcndhcmRSZWYoXG4gICAgKHtcbiAgICAgIGNoaWxkcmVuID0gRGVmYXVsdEZsb2F0aW5nVG9vbGJhckNvbnRlbnQsXG4gICAgICBiZWZvcmUsXG4gICAgICBhZnRlcixcbiAgICAgIHBvc2l0aW9uID0gXCJ0b3BcIixcbiAgICAgIG9mZnNldDogc2lkZU9mZnNldCA9IDYsXG4gICAgICBlZGl0b3IsXG4gICAgICBvblBvaW50ZXJEb3duLFxuICAgICAgb25Gb2N1cyxcbiAgICAgIG9uQmx1cixcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIC4uLnByb3BzXG4gICAgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgICBjb25zdCB0b29sYmFyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgICAgY29uc3QgZXh0ZXJuYWxJZHMgPSB1c2VJbml0aWFsKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgICAgY29uc3QgW2lzUG9pbnRlckRvd24sIHNldFBvaW50ZXJEb3duXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAgIGNvbnN0IFtpc0ZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgICAgY29uc3QgW2lzTWFudWFsbHlDbG9zZWQsIHNldE1hbnVhbGx5Q2xvc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAgIGNvbnN0IGhhc1NlbGVjdGlvblJhbmdlID0gdXNlRWRpdG9yU3RhdGUoe1xuICAgICAgICBlZGl0b3IsXG4gICAgICAgIGVxdWFsaXR5Rm46IE9iamVjdC5pcyxcbiAgICAgICAgc2VsZWN0b3I6IChjdHgpID0+IHtcbiAgICAgICAgICBjb25zdCBlZGl0b3IyID0gY3R4LmVkaXRvcjtcbiAgICAgICAgICBpZiAoIWVkaXRvcjIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gZWRpdG9yMi5zdGF0ZTtcbiAgICAgICAgICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICBjb25zdCBmcm9tID0gTWF0aC5taW4oLi4ucmFuZ2VzLm1hcCgocmFuZ2UpID0+IHJhbmdlLiRmcm9tLnBvcykpO1xuICAgICAgICAgIGNvbnN0IHRvID0gTWF0aC5tYXgoLi4ucmFuZ2VzLm1hcCgocmFuZ2UpID0+IHJhbmdlLiR0by5wb3MpKTtcbiAgICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzVGV4dFNlbGVjdGlvbihzZWxlY3Rpb24pICYmIGRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bykubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgfSkgPz8gZmFsc2U7XG4gICAgICBjb25zdCBpc09wZW4gPSBpc0ZvY3VzZWQgJiYgIWlzUG9pbnRlckRvd24gJiYgaGFzU2VsZWN0aW9uUmFuZ2UgJiYgIWlzTWFudWFsbHlDbG9zZWQ7XG4gICAgICBjb25zdCBbZGVsYXllZElzT3Blbiwgc2V0RGVsYXllZElzT3Blbl0gPSB1c2VTdGF0ZShpc09wZW4pO1xuICAgICAgY29uc3QgZGVsYXllZElzT3BlblRpbWVvdXRSZWYgPSB1c2VSZWYoKTtcbiAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldE1hbnVhbGx5Q2xvc2VkKGZhbHNlKTtcbiAgICAgICAgY29uc3QgaGFuZGxlU2VsZWN0aW9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgIHNldE1hbnVhbGx5Q2xvc2VkKGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLm9uKFwic2VsZWN0aW9uVXBkYXRlXCIsIGhhbmRsZVNlbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLm9mZihcInNlbGVjdGlvblVwZGF0ZVwiLCBoYW5kbGVTZWxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICB9O1xuICAgICAgfSwgW2lzRm9jdXNlZCwgaGFzU2VsZWN0aW9uUmFuZ2UsIGVkaXRvcl0pO1xuICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlRm9jdXMyID0gKCkgPT4ge1xuICAgICAgICAgIHNldEZvY3VzZWQodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZUJsdXIyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgdG9vbGJhclJlZi5jdXJyZW50Py5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCA9PT0gZWRpdG9yLnZpZXcuZG9tKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgZXh0ZXJuYWxJZCBvZiBleHRlcm5hbElkcykge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGV4dGVybmFsSWQpPy5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldEZvY3VzZWQoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBlZGl0b3Iudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGhhbmRsZUZvY3VzMik7XG4gICAgICAgIGVkaXRvci52aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBoYW5kbGVCbHVyMik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBoYW5kbGVGb2N1czIpO1xuICAgICAgICAgIGVkaXRvci52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBoYW5kbGVCbHVyMik7XG4gICAgICAgIH07XG4gICAgICB9LCBbZWRpdG9yLCBleHRlcm5hbElkc10pO1xuICAgICAgY29uc3QgaGFuZGxlRm9jdXMgPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgb25Gb2N1cz8uKGV2ZW50KTtcbiAgICAgICAgICBpZiAoIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICBzZXRGb2N1c2VkKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW29uRm9jdXNdXG4gICAgICApO1xuICAgICAgY29uc3QgaGFuZGxlQmx1ciA9IHVzZUNhbGxiYWNrKFxuICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICBvbkJsdXI/LihldmVudCk7XG4gICAgICAgICAgaWYgKCFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgdG9vbGJhclJlZi5jdXJyZW50Py5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCA9PT0gZWRpdG9yPy52aWV3LmRvbSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV4dGVybmFsSWQgb2YgZXh0ZXJuYWxJZHMpIHtcbiAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGV4dGVybmFsSWQpPy5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbb25CbHVyLCBlZGl0b3IsIGV4dGVybmFsSWRzXVxuICAgICAgKTtcbiAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgICBkZWxheWVkSXNPcGVuVGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc2V0RGVsYXllZElzT3Blbih0cnVlKTtcbiAgICAgICAgICB9LCBGTE9BVElOR19UT09MQkFSX09QRU5fREVMQVkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldERlbGF5ZWRJc09wZW4oZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChkZWxheWVkSXNPcGVuVGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgfTtcbiAgICAgIH0sIFtpc09wZW5dKTtcbiAgICAgIGNvbnN0IGZsb2F0aW5nT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBkZXRlY3RPdmVyZmxvd09wdGlvbnMgPSB7XG4gICAgICAgICAgcGFkZGluZzogRkxPQVRJTkdfVE9PTEJBUl9DT0xMSVNJT05fUEFERElOR1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cmF0ZWd5OiBcImZpeGVkXCIsXG4gICAgICAgICAgcGxhY2VtZW50OiBwb3NpdGlvbixcbiAgICAgICAgICBtaWRkbGV3YXJlOiBbXG4gICAgICAgICAgICBpbmxpbmUoZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKSxcbiAgICAgICAgICAgIGZsaXAoeyAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsIGNyb3NzQXhpczogZmFsc2UgfSksXG4gICAgICAgICAgICBoaWRlKGRldGVjdE92ZXJmbG93T3B0aW9ucyksXG4gICAgICAgICAgICBzaGlmdCh7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgbGltaXRlcjogbGltaXRTaGlmdCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9mZnNldChzaWRlT2Zmc2V0KSxcbiAgICAgICAgICAgIHNpemUoZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKVxuICAgICAgICAgIF0sXG4gICAgICAgICAgd2hpbGVFbGVtZW50c01vdW50ZWQ6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXV0b1VwZGF0ZSguLi5hcmdzLCB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbkZyYW1lOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LCBbcG9zaXRpb24sIHNpZGVPZmZzZXRdKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVmczogeyBzZXRSZWZlcmVuY2UsIHNldEZsb2F0aW5nIH0sXG4gICAgICAgIHN0cmF0ZWd5LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBpc1Bvc2l0aW9uZWRcbiAgICAgIH0gPSB1c2VGbG9hdGluZyh7XG4gICAgICAgIC4uLmZsb2F0aW5nT3B0aW9ucyxcbiAgICAgICAgb3BlbjogZGVsYXllZElzT3BlblxuICAgICAgfSk7XG4gICAgICBjb25zdCBtZXJnZWRSZWZzID0gdXNlUmVmcyhmb3J3YXJkZWRSZWYsIHRvb2xiYXJSZWYsIHNldEZsb2F0aW5nKTtcbiAgICAgIGNvbnN0IGhhbmRsZVBvaW50ZXJEb3duID0gdXNlQ2FsbGJhY2soXG4gICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgIG9uUG9pbnRlckRvd24/LihldmVudCk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdG9vbGJhclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW29uUG9pbnRlckRvd25dXG4gICAgICApO1xuICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlUG9pbnRlckRvd24yID0gKCkgPT4ge1xuICAgICAgICAgIHNldFBvaW50ZXJEb3duKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVQb2ludGVyVXAgPSAoKSA9PiB7XG4gICAgICAgICAgc2V0UG9pbnRlckRvd24oZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBlZGl0b3Iudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGhhbmRsZVBvaW50ZXJEb3duMik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIGhhbmRsZVBvaW50ZXJVcCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBlZGl0b3Iudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGhhbmRsZVBvaW50ZXJEb3duMik7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGhhbmRsZVBvaW50ZXJVcCk7XG4gICAgICAgIH07XG4gICAgICB9LCBbZWRpdG9yXSk7XG4gICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvciB8fCAhZGVsYXllZElzT3Blbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVTZWxlY3Rpb25SZWZlcmVuY2UgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZG9tU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmVtcHR5IHx8ICFkb21TZWxlY3Rpb24gfHwgIWRvbVNlbGVjdGlvbi5yYW5nZUNvdW50KSB7XG4gICAgICAgICAgICBzZXRSZWZlcmVuY2UobnVsbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRvbVJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICBzZXRSZWZlcmVuY2UoZG9tUmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLm9uKFwidHJhbnNhY3Rpb25cIiwgdXBkYXRlU2VsZWN0aW9uUmVmZXJlbmNlKTtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uUmVmZXJlbmNlKCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLm9mZihcInRyYW5zYWN0aW9uXCIsIHVwZGF0ZVNlbGVjdGlvblJlZmVyZW5jZSk7XG4gICAgICAgIH07XG4gICAgICB9LCBbZWRpdG9yLCBkZWxheWVkSXNPcGVuLCBzZXRSZWZlcmVuY2VdKTtcbiAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghZWRpdG9yIHx8ICFkZWxheWVkSXNPcGVuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBlZGl0b3Iudmlldy5kb20gJiYgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlZGl0b3IuY29tbWFuZHMuZm9jdXMoKTtcbiAgICAgICAgICAgIHNldE1hbnVhbGx5Q2xvc2VkKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgICAgfTtcbiAgICAgIH0sIFtlZGl0b3IsIGRlbGF5ZWRJc09wZW5dKTtcbiAgICAgIGNvbnN0IGNsb3NlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzZXRNYW51YWxseUNsb3NlZCh0cnVlKTtcbiAgICAgIH0sIFtzZXRNYW51YWxseUNsb3NlZF0pO1xuICAgICAgY29uc3QgcmVnaXN0ZXJFeHRlcm5hbCA9IHVzZUNhbGxiYWNrKFxuICAgICAgICAoaWQpID0+IHtcbiAgICAgICAgICBleHRlcm5hbElkcy5hZGQoaWQpO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBleHRlcm5hbElkcy5kZWxldGUoaWQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFtleHRlcm5hbElkc11cbiAgICAgICk7XG4gICAgICBpZiAoIWVkaXRvciB8fCAhZGVsYXllZElzT3Blbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNsb3RQcm9wcyA9IHsgZWRpdG9yIH07XG4gICAgICByZXR1cm4gY3JlYXRlUG9ydGFsKFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFRvb2x0aXBQcm92aWRlciwge1xuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KEVkaXRvclByb3ZpZGVyLCB7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChGbG9hdGluZ1Rvb2xiYXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB7IGNsb3NlLCByZWdpc3RlckV4dGVybmFsIH0sXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJ0b29sYmFyXCIsXG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IFwiRmxvYXRpbmcgdG9vbGJhclwiLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1vcmllbnRhdGlvblwiOiBcImhvcml6b250YWxcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoXG4gICAgICAgICAgICAgICAgICBcImxiLXJvb3QgbGItcG9ydGFsIGxiLWVsZXZhdGlvbiBsYi10aXB0YXAtZmxvYXRpbmctdG9vbGJhciBsYi10aXB0YXAtdG9vbGJhclwiLFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICByZWY6IG1lcmdlZFJlZnMsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGlzUG9zaXRpb25lZCA/IGB0cmFuc2xhdGUzZCgke01hdGgucm91bmQoeCl9cHgsICR7TWF0aC5yb3VuZCh5KX1weCwgMClgIDogXCJ0cmFuc2xhdGUzZCgwLCAtMjAwJSwgMClcIixcbiAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBcIm1heC1jb250ZW50XCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uUG9pbnRlckRvd246IGhhbmRsZVBvaW50ZXJEb3duLFxuICAgICAgICAgICAgICAgIG9uRm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgICAgICAgICAgICAgIG9uQmx1cjogaGFuZGxlQmx1cixcbiAgICAgICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgYXBwbHlUb29sYmFyU2xvdChiZWZvcmUsIHNsb3RQcm9wcyksXG4gICAgICAgICAgICAgICAgICBhcHBseVRvb2xiYXJTbG90KGNoaWxkcmVuLCBzbG90UHJvcHMpLFxuICAgICAgICAgICAgICAgICAgYXBwbHlUb29sYmFyU2xvdChhZnRlciwgc2xvdFByb3BzKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgICk7XG4gICAgfVxuICApLFxuICB7XG4gICAgRXh0ZXJuYWw6IEZsb2F0aW5nVG9vbGJhckV4dGVybmFsXG4gIH1cbik7XG5cbmV4cG9ydCB7IEZMT0FUSU5HX1RPT0xCQVJfQ09MTElTSU9OX1BBRERJTkcsIEZsb2F0aW5nVG9vbGJhciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmxvYXRpbmdUb29sYmFyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/toolbar/FloatingToolbar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/toolbar/Toolbar.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/toolbar/Toolbar.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLOCK_SELECT_SIDE_OFFSET: () => (/* binding */ BLOCK_SELECT_SIDE_OFFSET),\n/* harmony export */   FLOATING_ELEMENT_COLLISION_PADDING: () => (/* binding */ FLOATING_ELEMENT_COLLISION_PADDING),\n/* harmony export */   Toolbar: () => (/* binding */ Toolbar),\n/* harmony export */   applyToolbarSlot: () => (/* binding */ applyToolbarSlot)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Button.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Text.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/H1.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/H2.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/H3.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/ListUnordered.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/ListOrdered.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Blockquote.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Check.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Undo.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Redo.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Bold.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Italic.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Underline.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Strikethrough.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Code.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Comment.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Sparkles.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/QuestionMark.js\");\n/* harmony import */ var _liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @liveblocks/react-ui/_private */ \"(ssr)/./node_modules/@liveblocks/react-ui/node_modules/@radix-ui/react-tooltip/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_select__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @radix-ui/react-select */ \"(ssr)/./node_modules/@radix-ui/react-select/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_toggle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @radix-ui/react-toggle */ \"(ssr)/./node_modules/@radix-ui/react-toggle/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _classnames_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../classnames.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/classnames.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../context.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/context.js\");\n/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/toolbar/shared.js\");\n\n\n\n\n\n\n\n\n\nconst BLOCK_SELECT_SIDE_OFFSET = 10;\nconst FLOATING_ELEMENT_COLLISION_PADDING = 10;\nfunction applyToolbarSlot(slot, props) {\n  if (typeof slot === \"function\") {\n    const Component = slot;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Component, {\n      ...props\n    });\n  }\n  return slot;\n}\nconst ToolbarButton = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  ({ icon, children, name, shortcut, onKeyDown, ...props }, forwardedRef) => {\n    const floatingToolbarContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_shared_js__WEBPACK_IMPORTED_MODULE_2__.FloatingToolbarContext);\n    const closeFloatingToolbar = floatingToolbarContext?.close;\n    const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n      (event) => {\n        onKeyDown?.(event);\n        if (!event.isDefaultPrevented() && closeFloatingToolbar && event.key === \"Escape\") {\n          closeFloatingToolbar();\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      },\n      [onKeyDown, closeFloatingToolbar]\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_3__.ShortcutTooltip, {\n      content: name,\n      shortcut,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_4__.Button, {\n        type: \"button\",\n        variant: \"toolbar\",\n        ref: forwardedRef,\n        icon,\n        \"aria-label\": !children ? name : void 0,\n        ...props,\n        onKeyDown: handleKeyDown,\n        children: !children && !icon ? name : children\n      })\n    });\n  }\n);\nconst ToolbarToggle = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  ({ active, ...props }, forwardedRef) => {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_radix_ui_react_toggle__WEBPACK_IMPORTED_MODULE_5__.Root, {\n      asChild: true,\n      pressed: active,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarButton, {\n        ref: forwardedRef,\n        ...props\n      })\n    });\n  }\n);\nfunction createDefaultBlockSelectorItems(editor) {\n  const items = [\n    {\n      name: \"Text\",\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_6__.TextIcon, {}),\n      isActive: \"default\",\n      setActive: (editor2) => editor2.chain().focus().clearNodes().run()\n    },\n    \"toggleHeading\" in editor.commands ? {\n      name: \"Heading 1\",\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_7__.H1Icon, {}),\n      isActive: (editor2) => editor2.isActive(\"heading\", { level: 1 }),\n      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleHeading({ level: 1 }).run()\n    } : null,\n    \"toggleHeading\" in editor.commands ? {\n      name: \"Heading 2\",\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_8__.H2Icon, {}),\n      isActive: (editor2) => editor2.isActive(\"heading\", { level: 2 }),\n      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleHeading({ level: 2 }).run()\n    } : null,\n    \"toggleHeading\" in editor.commands ? {\n      name: \"Heading 3\",\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_9__.H3Icon, {}),\n      isActive: (editor2) => editor2.isActive(\"heading\", { level: 3 }),\n      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleHeading({ level: 3 }).run()\n    } : null,\n    \"toggleBulletList\" in editor.commands ? {\n      name: \"Bullet list\",\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_10__.ListUnorderedIcon, {}),\n      isActive: (editor2) => editor2.isActive(\"bulletList\"),\n      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleBulletList().run()\n    } : null,\n    \"toggleOrderedList\" in editor.commands ? {\n      name: \"Numbered list\",\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_11__.ListOrderedIcon, {}),\n      isActive: (editor2) => editor2.isActive(\"orderedList\"),\n      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleOrderedList().run()\n    } : null,\n    \"toggleBlockquote\" in editor.commands ? {\n      name: \"Blockquote\",\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_12__.BlockquoteIcon, {}),\n      isActive: (editor2) => editor2.isActive(\"blockquote\"),\n      setActive: (editor2) => editor2.chain().focus().clearNodes().toggleBlockquote().run()\n    } : null\n  ];\n  return items.filter(Boolean);\n}\nconst ToolbarBlockSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ items, onKeyDown, ...props }, forwardedRef) => {\n  const floatingToolbarContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_shared_js__WEBPACK_IMPORTED_MODULE_2__.FloatingToolbarContext);\n  const closeFloatingToolbar = floatingToolbarContext?.close;\n  const editor = (0,_context_js__WEBPACK_IMPORTED_MODULE_13__.useCurrentEditor)(\n    \"BlockSelector\",\n    \"Toolbar or FloatingToolbar\"\n  );\n  const resolvedItems = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    if (Array.isArray(items)) {\n      return items;\n    }\n    const defaultItems = createDefaultBlockSelectorItems(editor);\n    return items ? items(defaultItems) : defaultItems;\n  }, [editor, items]);\n  let defaultItem;\n  let activeItem = editor.isInitialized ? resolvedItems.find((item) => {\n    if (item.isActive === \"default\") {\n      defaultItem = item;\n      return false;\n    }\n    return item.isActive(editor);\n  }) : void 0;\n  if (!activeItem) {\n    activeItem = defaultItem;\n  }\n  const handleItemChange = (name) => {\n    const item = resolvedItems.find((item2) => item2.name === name);\n    if (item) {\n      item.setActive(editor);\n      floatingToolbarContext?.close();\n    }\n  };\n  const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (event) => {\n      onKeyDown?.(event);\n      if (!event.isDefaultPrevented() && closeFloatingToolbar && event.key === \"Escape\") {\n        closeFloatingToolbar();\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    },\n    [onKeyDown, closeFloatingToolbar]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_radix_ui_react_select__WEBPACK_IMPORTED_MODULE_14__.Root, {\n    value: activeItem?.name,\n    onValueChange: handleItemChange,\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_3__.ShortcutTooltip, {\n        content: \"Turn into\\u2026\",\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_radix_ui_react_select__WEBPACK_IMPORTED_MODULE_14__.Trigger, {\n          asChild: true,\n          ...props,\n          ref: forwardedRef,\n          onKeyDown: handleKeyDown,\n          disabled: resolvedItems.length === 0,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_4__.SelectButton, {\n            variant: \"toolbar\",\n            children: activeItem?.name ?? \"Turn into\\u2026\"\n          })\n        })\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_radix_ui_react_select__WEBPACK_IMPORTED_MODULE_14__.Portal, {\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_shared_js__WEBPACK_IMPORTED_MODULE_2__.FloatingToolbarExternal, {\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_radix_ui_react_select__WEBPACK_IMPORTED_MODULE_14__.Content, {\n            position: \"popper\",\n            sideOffset: BLOCK_SELECT_SIDE_OFFSET,\n            collisionPadding: FLOATING_ELEMENT_COLLISION_PADDING,\n            className: \"lb-root lb-portal lb-elevation lb-dropdown lb-select-dropdown lb-tiptap-block-selector-dropdown\",\n            children: resolvedItems.map((item) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_radix_ui_react_select__WEBPACK_IMPORTED_MODULE_14__.Item, {\n              value: item.name,\n              className: \"lb-dropdown-item\",\n              \"data-name\": item.name,\n              children: [\n                item.icon ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                  className: \"lb-dropdown-item-icon lb-icon-container\",\n                  children: item.icon\n                }) : null,\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                  className: \"lb-dropdown-item-label\",\n                  children: item.label ?? item.name\n                }),\n                item.name === activeItem?.name ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                  className: \"lb-dropdown-item-accessory lb-icon-container\",\n                  children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_15__.CheckIcon, {})\n                }) : null\n              ]\n            }, item.name))\n          })\n        })\n      })\n    ]\n  });\n});\nconst ToolbarSeparator = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  ({ className, ...props }, forwardedRef) => {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      ref: forwardedRef,\n      role: \"separator\",\n      \"aria-orientation\": \"vertical\",\n      className: (0,_classnames_js__WEBPACK_IMPORTED_MODULE_16__.classNames)(\"lb-tiptap-toolbar-separator\", className),\n      ...props\n    });\n  }\n);\nfunction ToolbarSectionHistory() {\n  const editor = (0,_context_js__WEBPACK_IMPORTED_MODULE_13__.useCurrentEditor)(\n    \"SectionHistory\",\n    \"Toolbar or FloatingToolbar\"\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarButton, {\n        name: \"Undo\",\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_17__.UndoIcon, {}),\n        shortcut: \"Mod-Z\",\n        onClick: () => editor.chain().focus().undo().run(),\n        disabled: !editor.can().chain().focus().undo().run()\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarButton, {\n        name: \"Redo\",\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_18__.RedoIcon, {}),\n        shortcut: \"Mod-Shift-Z\",\n        onClick: () => editor.chain().focus().redo().run(),\n        disabled: !editor.can().chain().focus().redo().run()\n      })\n    ]\n  });\n}\nfunction ToolbarSectionInline() {\n  const editor = (0,_context_js__WEBPACK_IMPORTED_MODULE_13__.useCurrentEditor)(\n    \"SectionInline\",\n    \"Toolbar or FloatingToolbar\"\n  );\n  const supportsBold = \"toggleBold\" in editor.commands;\n  const supportsItalic = \"toggleItalic\" in editor.commands;\n  const supportsUnderline = \"toggleUnderline\" in editor.commands;\n  const supportsStrike = \"toggleStrike\" in editor.commands;\n  const supportsCode = \"toggleCode\" in editor.commands;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: [\n      supportsBold && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarToggle, {\n        name: \"Bold\",\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_19__.BoldIcon, {}),\n        shortcut: \"Mod-B\",\n        onClick: () => editor.chain().focus().toggleBold().run(),\n        disabled: !editor.can().chain().focus().toggleBold().run(),\n        active: editor.isActive(\"bold\")\n      }),\n      supportsItalic && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarToggle, {\n        name: \"Italic\",\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_20__.ItalicIcon, {}),\n        shortcut: \"Mod-I\",\n        onClick: () => editor.chain().focus().toggleItalic().run(),\n        disabled: !editor.can().chain().focus().toggleItalic().run(),\n        active: editor.isActive(\"italic\")\n      }),\n      supportsUnderline && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarToggle, {\n        name: \"Underline\",\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_21__.UnderlineIcon, {}),\n        shortcut: \"Mod-U\",\n        onClick: () => editor.chain().focus().toggleUnderline().run(),\n        disabled: !editor.can().chain().focus().toggleUnderline().run(),\n        active: editor.isActive(\"underline\")\n      }),\n      supportsStrike && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarToggle, {\n        name: \"Strikethrough\",\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_22__.StrikethroughIcon, {}),\n        shortcut: \"Mod-U\",\n        onClick: () => editor.chain().focus().toggleStrike().run(),\n        disabled: !editor.can().chain().focus().toggleStrike().run(),\n        active: editor.isActive(\"strike\")\n      }),\n      supportsCode && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarToggle, {\n        name: \"Inline code\",\n        icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_23__.CodeIcon, {}),\n        shortcut: \"Mod-E\",\n        onClick: () => editor.chain().focus().toggleCode().run(),\n        disabled: !editor.can().chain().focus().toggleCode().run(),\n        active: editor.isActive(\"code\")\n      })\n    ]\n  });\n}\nfunction ToolbarSectionCollaboration() {\n  const editor = (0,_context_js__WEBPACK_IMPORTED_MODULE_13__.useCurrentEditor)(\n    \"SectionCollaboration\",\n    \"Toolbar or FloatingToolbar\"\n  );\n  const supportsThread = \"addPendingComment\" in editor.commands;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: supportsThread && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarButton, {\n      name: \"Add a comment\",\n      icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_24__.CommentIcon, {}),\n      onClick: () => editor.chain().focus().addPendingComment().run(),\n      children: \"Comment\"\n    })\n  });\n}\nfunction ToolbarSectionAi() {\n  const editor = (0,_context_js__WEBPACK_IMPORTED_MODULE_13__.useCurrentEditor)(\"SectionAi\", \"Toolbar or FloatingToolbar\");\n  const supportsAi = \"askAi\" in editor.commands;\n  const aiName = editor.storage.liveblocksAi?.name;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: supportsAi && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n      children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(ToolbarButton, {\n          name: `Ask ${aiName} anything\\u2026`,\n          icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_25__.SparklesIcon, {}),\n          onClick: () => editor.chain().focus().askAi(),\n          children: [\n            \"Ask \",\n            aiName\n          ]\n        }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarButton, {\n          name: \"Explain\",\n          icon: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_26__.QuestionMarkIcon, {}),\n          onClick: () => editor.chain().focus().askAi(\"Explain what the text is about\"),\n          children: \"Explain\"\n        })\n      ]\n    })\n  });\n}\nfunction DefaultToolbarContent({ editor }) {\n  const supportsThread = \"addPendingComment\" in editor.commands;\n  const supportsAi = \"askAi\" in editor.commands;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarSectionHistory, {}),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarSeparator, {}),\n      supportsAi ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarSectionAi, {}),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarSeparator, {})\n        ]\n      }) : null,\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarBlockSelector, {}),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarSectionInline, {}),\n      supportsThread ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarSeparator, {}),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ToolbarSectionCollaboration, {})\n        ]\n      }) : null\n    ]\n  });\n}\nconst Toolbar = Object.assign(\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n    ({\n      before,\n      after,\n      children = DefaultToolbarContent,\n      editor,\n      className,\n      ...props\n    }, forwardedRef) => {\n      if (!editor) {\n        return null;\n      }\n      const slotProps = { editor };\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_liveblocks_react_ui_private__WEBPACK_IMPORTED_MODULE_27__.TooltipProvider, {\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_context_js__WEBPACK_IMPORTED_MODULE_13__.EditorProvider, {\n          editor,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n            ref: forwardedRef,\n            role: \"toolbar\",\n            \"aria-label\": \"Toolbar\",\n            \"aria-orientation\": \"horizontal\",\n            className: (0,_classnames_js__WEBPACK_IMPORTED_MODULE_16__.classNames)(\"lb-root lb-tiptap-toolbar\", className),\n            ...props,\n            children: [\n              applyToolbarSlot(before, slotProps),\n              applyToolbarSlot(children, slotProps),\n              applyToolbarSlot(after, slotProps)\n            ]\n          })\n        })\n      });\n    }\n  ),\n  {\n    Button: ToolbarButton,\n    Toggle: ToolbarToggle,\n    BlockSelector: ToolbarBlockSelector,\n    Separator: ToolbarSeparator,\n    SectionHistory: ToolbarSectionHistory,\n    SectionInline: ToolbarSectionInline,\n    SectionCollaboration: ToolbarSectionCollaboration,\n    SectionAi: ToolbarSectionAi\n  }\n);\n\n\n//# sourceMappingURL=Toolbar.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvdG9vbGJhci9Ub29sYmFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdEO0FBQ21SO0FBQ2pSO0FBQ0E7QUFDVztBQUN2QjtBQUNtQjtBQUNhOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNEQUFHO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpREFBVTtBQUNoQyxLQUFLLHFEQUFxRDtBQUMxRCxtQ0FBbUMsaURBQVUsQ0FBQyw4REFBc0I7QUFDcEU7QUFDQSwwQkFBMEIsa0RBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDJCQUEyQixzREFBRyxDQUFDLHlFQUFlO0FBQzlDO0FBQ0E7QUFDQSxnQ0FBZ0Msc0RBQUcsQ0FBQyxnRUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCLGlEQUFVO0FBQ2hDLEtBQUssa0JBQWtCO0FBQ3ZCLDJCQUEyQixzREFBRyxDQUFDLHdEQUFvQjtBQUNuRDtBQUNBO0FBQ0EsZ0NBQWdDLHNEQUFHO0FBQ25DO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzREFBRyxDQUFDLGtFQUFRLElBQUk7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFHLENBQUMsZ0VBQU0sSUFBSTtBQUMxQywyREFBMkQsVUFBVTtBQUNyRSxtRkFBbUYsVUFBVTtBQUM3RixNQUFNO0FBQ047QUFDQTtBQUNBLDRCQUE0QixzREFBRyxDQUFDLGdFQUFNLElBQUk7QUFDMUMs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aUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBLHlCQUF5Qix1REFBSSxDQUFDLHVEQUFRO0FBQ3RDO0FBQ0Esc0JBQXNCLHNEQUFHLDBCQUEwQjtBQUNuRCxzQkFBc0Isc0RBQUcscUJBQXFCO0FBQzlDLG1DQUFtQyx1REFBSSxDQUFDLHVEQUFRO0FBQ2hEO0FBQ0EsMEJBQTBCLHNEQUFHLHFCQUFxQjtBQUNsRCwwQkFBMEIsc0RBQUcscUJBQXFCO0FBQ2xEO0FBQ0EsT0FBTztBQUNQLHNCQUFzQixzREFBRyx5QkFBeUI7QUFDbEQsc0JBQXNCLHNEQUFHLHlCQUF5QjtBQUNsRCx1Q0FBdUMsdURBQUksQ0FBQyx1REFBUTtBQUNwRDtBQUNBLDBCQUEwQixzREFBRyxxQkFBcUI7QUFDbEQsMEJBQTBCLHNEQUFHLGdDQUFnQztBQUM3RDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRSxpREFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiw2QkFBNkIsc0RBQUcsQ0FBQywwRUFBZTtBQUNoRCxrQ0FBa0Msc0RBQUcsQ0FBQyx3REFBYztBQUNwRDtBQUNBLG9DQUFvQyx1REFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyREFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUc7QUFDbkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXRpcHRhcC9kaXN0L3Rvb2xiYXIvVG9vbGJhci5qcz80MGZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCwganN4cywgRnJhZ21lbnQgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBTaG9ydGN1dFRvb2x0aXAsIEJ1dHRvbiwgVGV4dEljb24sIEgxSWNvbiwgSDJJY29uLCBIM0ljb24sIExpc3RVbm9yZGVyZWRJY29uLCBMaXN0T3JkZXJlZEljb24sIEJsb2NrcXVvdGVJY29uLCBTZWxlY3RCdXR0b24sIENoZWNrSWNvbiwgVW5kb0ljb24sIFJlZG9JY29uLCBCb2xkSWNvbiwgSXRhbGljSWNvbiwgVW5kZXJsaW5lSWNvbiwgU3RyaWtldGhyb3VnaEljb24sIENvZGVJY29uLCBDb21tZW50SWNvbiwgU3BhcmtsZXNJY29uLCBRdWVzdGlvbk1hcmtJY29uLCBUb29sdGlwUHJvdmlkZXIgfSBmcm9tICdAbGl2ZWJsb2Nrcy9yZWFjdC11aS9fcHJpdmF0ZSc7XG5pbXBvcnQgKiBhcyBTZWxlY3RQcmltaXRpdmUgZnJvbSAnQHJhZGl4LXVpL3JlYWN0LXNlbGVjdCc7XG5pbXBvcnQgKiBhcyBUb2dnbGVQcmltaXRpdmUgZnJvbSAnQHJhZGl4LXVpL3JlYWN0LXRvZ2dsZSc7XG5pbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VDb250ZXh0LCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tICcuLi9jbGFzc25hbWVzLmpzJztcbmltcG9ydCB7IHVzZUN1cnJlbnRFZGl0b3IsIEVkaXRvclByb3ZpZGVyIH0gZnJvbSAnLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBGbG9hdGluZ1Rvb2xiYXJDb250ZXh0LCBGbG9hdGluZ1Rvb2xiYXJFeHRlcm5hbCB9IGZyb20gJy4vc2hhcmVkLmpzJztcblxuY29uc3QgQkxPQ0tfU0VMRUNUX1NJREVfT0ZGU0VUID0gMTA7XG5jb25zdCBGTE9BVElOR19FTEVNRU5UX0NPTExJU0lPTl9QQURESU5HID0gMTA7XG5mdW5jdGlvbiBhcHBseVRvb2xiYXJTbG90KHNsb3QsIHByb3BzKSB7XG4gIGlmICh0eXBlb2Ygc2xvdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gc2xvdDtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChDb21wb25lbnQsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNsb3Q7XG59XG5jb25zdCBUb29sYmFyQnV0dG9uID0gZm9yd2FyZFJlZihcbiAgKHsgaWNvbiwgY2hpbGRyZW4sIG5hbWUsIHNob3J0Y3V0LCBvbktleURvd24sIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IGZsb2F0aW5nVG9vbGJhckNvbnRleHQgPSB1c2VDb250ZXh0KEZsb2F0aW5nVG9vbGJhckNvbnRleHQpO1xuICAgIGNvbnN0IGNsb3NlRmxvYXRpbmdUb29sYmFyID0gZmxvYXRpbmdUb29sYmFyQ29udGV4dD8uY2xvc2U7XG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgIG9uS2V5RG93bj8uKGV2ZW50KTtcbiAgICAgICAgaWYgKCFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiBjbG9zZUZsb2F0aW5nVG9vbGJhciAmJiBldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICBjbG9zZUZsb2F0aW5nVG9vbGJhcigpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbb25LZXlEb3duLCBjbG9zZUZsb2F0aW5nVG9vbGJhcl1cbiAgICApO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNob3J0Y3V0VG9vbHRpcCwge1xuICAgICAgY29udGVudDogbmFtZSxcbiAgICAgIHNob3J0Y3V0LFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goQnV0dG9uLCB7XG4gICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgIHZhcmlhbnQ6IFwidG9vbGJhclwiLFxuICAgICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgICAgaWNvbixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6ICFjaGlsZHJlbiA/IG5hbWUgOiB2b2lkIDAsXG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBvbktleURvd246IGhhbmRsZUtleURvd24sXG4gICAgICAgIGNoaWxkcmVuOiAhY2hpbGRyZW4gJiYgIWljb24gPyBuYW1lIDogY2hpbGRyZW5cbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbik7XG5jb25zdCBUb29sYmFyVG9nZ2xlID0gZm9yd2FyZFJlZihcbiAgKHsgYWN0aXZlLCAuLi5wcm9wcyB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChUb2dnbGVQcmltaXRpdmUuUm9vdCwge1xuICAgICAgYXNDaGlsZDogdHJ1ZSxcbiAgICAgIHByZXNzZWQ6IGFjdGl2ZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFRvb2xiYXJCdXR0b24sIHtcbiAgICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICAgIC4uLnByb3BzXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4pO1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdEJsb2NrU2VsZWN0b3JJdGVtcyhlZGl0b3IpIHtcbiAgY29uc3QgaXRlbXMgPSBbXG4gICAge1xuICAgICAgbmFtZTogXCJUZXh0XCIsXG4gICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8ganN4KFRleHRJY29uLCB7fSksXG4gICAgICBpc0FjdGl2ZTogXCJkZWZhdWx0XCIsXG4gICAgICBzZXRBY3RpdmU6IChlZGl0b3IyKSA9PiBlZGl0b3IyLmNoYWluKCkuZm9jdXMoKS5jbGVhck5vZGVzKCkucnVuKClcbiAgICB9LFxuICAgIFwidG9nZ2xlSGVhZGluZ1wiIGluIGVkaXRvci5jb21tYW5kcyA/IHtcbiAgICAgIG5hbWU6IFwiSGVhZGluZyAxXCIsXG4gICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8ganN4KEgxSWNvbiwge30pLFxuICAgICAgaXNBY3RpdmU6IChlZGl0b3IyKSA9PiBlZGl0b3IyLmlzQWN0aXZlKFwiaGVhZGluZ1wiLCB7IGxldmVsOiAxIH0pLFxuICAgICAgc2V0QWN0aXZlOiAoZWRpdG9yMikgPT4gZWRpdG9yMi5jaGFpbigpLmZvY3VzKCkuY2xlYXJOb2RlcygpLnRvZ2dsZUhlYWRpbmcoeyBsZXZlbDogMSB9KS5ydW4oKVxuICAgIH0gOiBudWxsLFxuICAgIFwidG9nZ2xlSGVhZGluZ1wiIGluIGVkaXRvci5jb21tYW5kcyA/IHtcbiAgICAgIG5hbWU6IFwiSGVhZGluZyAyXCIsXG4gICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8ganN4KEgySWNvbiwge30pLFxuICAgICAgaXNBY3RpdmU6IChlZGl0b3IyKSA9PiBlZGl0b3IyLmlzQWN0aXZlKFwiaGVhZGluZ1wiLCB7IGxldmVsOiAyIH0pLFxuICAgICAgc2V0QWN0aXZlOiAoZWRpdG9yMikgPT4gZWRpdG9yMi5jaGFpbigpLmZvY3VzKCkuY2xlYXJOb2RlcygpLnRvZ2dsZUhlYWRpbmcoeyBsZXZlbDogMiB9KS5ydW4oKVxuICAgIH0gOiBudWxsLFxuICAgIFwidG9nZ2xlSGVhZGluZ1wiIGluIGVkaXRvci5jb21tYW5kcyA/IHtcbiAgICAgIG5hbWU6IFwiSGVhZGluZyAzXCIsXG4gICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8ganN4KEgzSWNvbiwge30pLFxuICAgICAgaXNBY3RpdmU6IChlZGl0b3IyKSA9PiBlZGl0b3IyLmlzQWN0aXZlKFwiaGVhZGluZ1wiLCB7IGxldmVsOiAzIH0pLFxuICAgICAgc2V0QWN0aXZlOiAoZWRpdG9yMikgPT4gZWRpdG9yMi5jaGFpbigpLmZvY3VzKCkuY2xlYXJOb2RlcygpLnRvZ2dsZUhlYWRpbmcoeyBsZXZlbDogMyB9KS5ydW4oKVxuICAgIH0gOiBudWxsLFxuICAgIFwidG9nZ2xlQnVsbGV0TGlzdFwiIGluIGVkaXRvci5jb21tYW5kcyA/IHtcbiAgICAgIG5hbWU6IFwiQnVsbGV0IGxpc3RcIixcbiAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBqc3goTGlzdFVub3JkZXJlZEljb24sIHt9KSxcbiAgICAgIGlzQWN0aXZlOiAoZWRpdG9yMikgPT4gZWRpdG9yMi5pc0FjdGl2ZShcImJ1bGxldExpc3RcIiksXG4gICAgICBzZXRBY3RpdmU6IChlZGl0b3IyKSA9PiBlZGl0b3IyLmNoYWluKCkuZm9jdXMoKS5jbGVhck5vZGVzKCkudG9nZ2xlQnVsbGV0TGlzdCgpLnJ1bigpXG4gICAgfSA6IG51bGwsXG4gICAgXCJ0b2dnbGVPcmRlcmVkTGlzdFwiIGluIGVkaXRvci5jb21tYW5kcyA/IHtcbiAgICAgIG5hbWU6IFwiTnVtYmVyZWQgbGlzdFwiLFxuICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGpzeChMaXN0T3JkZXJlZEljb24sIHt9KSxcbiAgICAgIGlzQWN0aXZlOiAoZWRpdG9yMikgPT4gZWRpdG9yMi5pc0FjdGl2ZShcIm9yZGVyZWRMaXN0XCIpLFxuICAgICAgc2V0QWN0aXZlOiAoZWRpdG9yMikgPT4gZWRpdG9yMi5jaGFpbigpLmZvY3VzKCkuY2xlYXJOb2RlcygpLnRvZ2dsZU9yZGVyZWRMaXN0KCkucnVuKClcbiAgICB9IDogbnVsbCxcbiAgICBcInRvZ2dsZUJsb2NrcXVvdGVcIiBpbiBlZGl0b3IuY29tbWFuZHMgPyB7XG4gICAgICBuYW1lOiBcIkJsb2NrcXVvdGVcIixcbiAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBqc3goQmxvY2txdW90ZUljb24sIHt9KSxcbiAgICAgIGlzQWN0aXZlOiAoZWRpdG9yMikgPT4gZWRpdG9yMi5pc0FjdGl2ZShcImJsb2NrcXVvdGVcIiksXG4gICAgICBzZXRBY3RpdmU6IChlZGl0b3IyKSA9PiBlZGl0b3IyLmNoYWluKCkuZm9jdXMoKS5jbGVhck5vZGVzKCkudG9nZ2xlQmxvY2txdW90ZSgpLnJ1bigpXG4gICAgfSA6IG51bGxcbiAgXTtcbiAgcmV0dXJuIGl0ZW1zLmZpbHRlcihCb29sZWFuKTtcbn1cbmNvbnN0IFRvb2xiYXJCbG9ja1NlbGVjdG9yID0gZm9yd2FyZFJlZigoeyBpdGVtcywgb25LZXlEb3duLCAuLi5wcm9wcyB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgZmxvYXRpbmdUb29sYmFyQ29udGV4dCA9IHVzZUNvbnRleHQoRmxvYXRpbmdUb29sYmFyQ29udGV4dCk7XG4gIGNvbnN0IGNsb3NlRmxvYXRpbmdUb29sYmFyID0gZmxvYXRpbmdUb29sYmFyQ29udGV4dD8uY2xvc2U7XG4gIGNvbnN0IGVkaXRvciA9IHVzZUN1cnJlbnRFZGl0b3IoXG4gICAgXCJCbG9ja1NlbGVjdG9yXCIsXG4gICAgXCJUb29sYmFyIG9yIEZsb2F0aW5nVG9vbGJhclwiXG4gICk7XG4gIGNvbnN0IHJlc29sdmVkSXRlbXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdEl0ZW1zID0gY3JlYXRlRGVmYXVsdEJsb2NrU2VsZWN0b3JJdGVtcyhlZGl0b3IpO1xuICAgIHJldHVybiBpdGVtcyA/IGl0ZW1zKGRlZmF1bHRJdGVtcykgOiBkZWZhdWx0SXRlbXM7XG4gIH0sIFtlZGl0b3IsIGl0ZW1zXSk7XG4gIGxldCBkZWZhdWx0SXRlbTtcbiAgbGV0IGFjdGl2ZUl0ZW0gPSBlZGl0b3IuaXNJbml0aWFsaXplZCA/IHJlc29sdmVkSXRlbXMuZmluZCgoaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtLmlzQWN0aXZlID09PSBcImRlZmF1bHRcIikge1xuICAgICAgZGVmYXVsdEl0ZW0gPSBpdGVtO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbS5pc0FjdGl2ZShlZGl0b3IpO1xuICB9KSA6IHZvaWQgMDtcbiAgaWYgKCFhY3RpdmVJdGVtKSB7XG4gICAgYWN0aXZlSXRlbSA9IGRlZmF1bHRJdGVtO1xuICB9XG4gIGNvbnN0IGhhbmRsZUl0ZW1DaGFuZ2UgPSAobmFtZSkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSByZXNvbHZlZEl0ZW1zLmZpbmQoKGl0ZW0yKSA9PiBpdGVtMi5uYW1lID09PSBuYW1lKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgaXRlbS5zZXRBY3RpdmUoZWRpdG9yKTtcbiAgICAgIGZsb2F0aW5nVG9vbGJhckNvbnRleHQ/LmNsb3NlKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBoYW5kbGVLZXlEb3duID0gdXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICBvbktleURvd24/LihldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICYmIGNsb3NlRmxvYXRpbmdUb29sYmFyICYmIGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICBjbG9zZUZsb2F0aW5nVG9vbGJhcigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtvbktleURvd24sIGNsb3NlRmxvYXRpbmdUb29sYmFyXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoU2VsZWN0UHJpbWl0aXZlLlJvb3QsIHtcbiAgICB2YWx1ZTogYWN0aXZlSXRlbT8ubmFtZSxcbiAgICBvblZhbHVlQ2hhbmdlOiBoYW5kbGVJdGVtQ2hhbmdlLFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFNob3J0Y3V0VG9vbHRpcCwge1xuICAgICAgICBjb250ZW50OiBcIlR1cm4gaW50b1xcdTIwMjZcIixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goU2VsZWN0UHJpbWl0aXZlLlRyaWdnZXIsIHtcbiAgICAgICAgICBhc0NoaWxkOiB0cnVlLFxuICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICAgICAgICBkaXNhYmxlZDogcmVzb2x2ZWRJdGVtcy5sZW5ndGggPT09IDAsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goU2VsZWN0QnV0dG9uLCB7XG4gICAgICAgICAgICB2YXJpYW50OiBcInRvb2xiYXJcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBhY3RpdmVJdGVtPy5uYW1lID8/IFwiVHVybiBpbnRvXFx1MjAyNlwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChTZWxlY3RQcmltaXRpdmUuUG9ydGFsLCB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KEZsb2F0aW5nVG9vbGJhckV4dGVybmFsLCB7XG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goU2VsZWN0UHJpbWl0aXZlLkNvbnRlbnQsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcInBvcHBlclwiLFxuICAgICAgICAgICAgc2lkZU9mZnNldDogQkxPQ0tfU0VMRUNUX1NJREVfT0ZGU0VULFxuICAgICAgICAgICAgY29sbGlzaW9uUGFkZGluZzogRkxPQVRJTkdfRUxFTUVOVF9DT0xMSVNJT05fUEFERElORyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJsYi1yb290IGxiLXBvcnRhbCBsYi1lbGV2YXRpb24gbGItZHJvcGRvd24gbGItc2VsZWN0LWRyb3Bkb3duIGxiLXRpcHRhcC1ibG9jay1zZWxlY3Rvci1kcm9wZG93blwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IHJlc29sdmVkSXRlbXMubWFwKChpdGVtKSA9PiAvKiBAX19QVVJFX18gKi8ganN4cyhTZWxlY3RQcmltaXRpdmUuSXRlbSwge1xuICAgICAgICAgICAgICB2YWx1ZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwibGItZHJvcGRvd24taXRlbVwiLFxuICAgICAgICAgICAgICBcImRhdGEtbmFtZVwiOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgaXRlbS5pY29uID8gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwge1xuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImxiLWRyb3Bkb3duLWl0ZW0taWNvbiBsYi1pY29uLWNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGl0ZW0uaWNvblxuICAgICAgICAgICAgICAgIH0pIDogbnVsbCxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwibGItZHJvcGRvd24taXRlbS1sYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGl0ZW0ubGFiZWwgPz8gaXRlbS5uYW1lXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaXRlbS5uYW1lID09PSBhY3RpdmVJdGVtPy5uYW1lID8gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwge1xuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImxiLWRyb3Bkb3duLWl0ZW0tYWNjZXNzb3J5IGxiLWljb24tY29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChDaGVja0ljb24sIHt9KVxuICAgICAgICAgICAgICAgIH0pIDogbnVsbFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LCBpdGVtLm5hbWUpKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIF1cbiAgfSk7XG59KTtcbmNvbnN0IFRvb2xiYXJTZXBhcmF0b3IgPSBmb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgcm9sZTogXCJzZXBhcmF0b3JcIixcbiAgICAgIFwiYXJpYS1vcmllbnRhdGlvblwiOiBcInZlcnRpY2FsXCIsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoXCJsYi10aXB0YXAtdG9vbGJhci1zZXBhcmF0b3JcIiwgY2xhc3NOYW1lKSxcbiAgICAgIC4uLnByb3BzXG4gICAgfSk7XG4gIH1cbik7XG5mdW5jdGlvbiBUb29sYmFyU2VjdGlvbkhpc3RvcnkoKSB7XG4gIGNvbnN0IGVkaXRvciA9IHVzZUN1cnJlbnRFZGl0b3IoXG4gICAgXCJTZWN0aW9uSGlzdG9yeVwiLFxuICAgIFwiVG9vbGJhciBvciBGbG9hdGluZ1Rvb2xiYXJcIlxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChUb29sYmFyQnV0dG9uLCB7XG4gICAgICAgIG5hbWU6IFwiVW5kb1wiLFxuICAgICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8ganN4KFVuZG9JY29uLCB7fSksXG4gICAgICAgIHNob3J0Y3V0OiBcIk1vZC1aXCIsXG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IGVkaXRvci5jaGFpbigpLmZvY3VzKCkudW5kbygpLnJ1bigpLFxuICAgICAgICBkaXNhYmxlZDogIWVkaXRvci5jYW4oKS5jaGFpbigpLmZvY3VzKCkudW5kbygpLnJ1bigpXG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhckJ1dHRvbiwge1xuICAgICAgICBuYW1lOiBcIlJlZG9cIixcbiAgICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGpzeChSZWRvSWNvbiwge30pLFxuICAgICAgICBzaG9ydGN1dDogXCJNb2QtU2hpZnQtWlwiLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiBlZGl0b3IuY2hhaW4oKS5mb2N1cygpLnJlZG8oKS5ydW4oKSxcbiAgICAgICAgZGlzYWJsZWQ6ICFlZGl0b3IuY2FuKCkuY2hhaW4oKS5mb2N1cygpLnJlZG8oKS5ydW4oKVxuICAgICAgfSlcbiAgICBdXG4gIH0pO1xufVxuZnVuY3Rpb24gVG9vbGJhclNlY3Rpb25JbmxpbmUoKSB7XG4gIGNvbnN0IGVkaXRvciA9IHVzZUN1cnJlbnRFZGl0b3IoXG4gICAgXCJTZWN0aW9uSW5saW5lXCIsXG4gICAgXCJUb29sYmFyIG9yIEZsb2F0aW5nVG9vbGJhclwiXG4gICk7XG4gIGNvbnN0IHN1cHBvcnRzQm9sZCA9IFwidG9nZ2xlQm9sZFwiIGluIGVkaXRvci5jb21tYW5kcztcbiAgY29uc3Qgc3VwcG9ydHNJdGFsaWMgPSBcInRvZ2dsZUl0YWxpY1wiIGluIGVkaXRvci5jb21tYW5kcztcbiAgY29uc3Qgc3VwcG9ydHNVbmRlcmxpbmUgPSBcInRvZ2dsZVVuZGVybGluZVwiIGluIGVkaXRvci5jb21tYW5kcztcbiAgY29uc3Qgc3VwcG9ydHNTdHJpa2UgPSBcInRvZ2dsZVN0cmlrZVwiIGluIGVkaXRvci5jb21tYW5kcztcbiAgY29uc3Qgc3VwcG9ydHNDb2RlID0gXCJ0b2dnbGVDb2RlXCIgaW4gZWRpdG9yLmNvbW1hbmRzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW1xuICAgICAgc3VwcG9ydHNCb2xkICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhclRvZ2dsZSwge1xuICAgICAgICBuYW1lOiBcIkJvbGRcIixcbiAgICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGpzeChCb2xkSWNvbiwge30pLFxuICAgICAgICBzaG9ydGN1dDogXCJNb2QtQlwiLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiBlZGl0b3IuY2hhaW4oKS5mb2N1cygpLnRvZ2dsZUJvbGQoKS5ydW4oKSxcbiAgICAgICAgZGlzYWJsZWQ6ICFlZGl0b3IuY2FuKCkuY2hhaW4oKS5mb2N1cygpLnRvZ2dsZUJvbGQoKS5ydW4oKSxcbiAgICAgICAgYWN0aXZlOiBlZGl0b3IuaXNBY3RpdmUoXCJib2xkXCIpXG4gICAgICB9KSxcbiAgICAgIHN1cHBvcnRzSXRhbGljICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhclRvZ2dsZSwge1xuICAgICAgICBuYW1lOiBcIkl0YWxpY1wiLFxuICAgICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8ganN4KEl0YWxpY0ljb24sIHt9KSxcbiAgICAgICAgc2hvcnRjdXQ6IFwiTW9kLUlcIixcbiAgICAgICAgb25DbGljazogKCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS50b2dnbGVJdGFsaWMoKS5ydW4oKSxcbiAgICAgICAgZGlzYWJsZWQ6ICFlZGl0b3IuY2FuKCkuY2hhaW4oKS5mb2N1cygpLnRvZ2dsZUl0YWxpYygpLnJ1bigpLFxuICAgICAgICBhY3RpdmU6IGVkaXRvci5pc0FjdGl2ZShcIml0YWxpY1wiKVxuICAgICAgfSksXG4gICAgICBzdXBwb3J0c1VuZGVybGluZSAmJiAvKiBAX19QVVJFX18gKi8ganN4KFRvb2xiYXJUb2dnbGUsIHtcbiAgICAgICAgbmFtZTogXCJVbmRlcmxpbmVcIixcbiAgICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGpzeChVbmRlcmxpbmVJY29uLCB7fSksXG4gICAgICAgIHNob3J0Y3V0OiBcIk1vZC1VXCIsXG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IGVkaXRvci5jaGFpbigpLmZvY3VzKCkudG9nZ2xlVW5kZXJsaW5lKCkucnVuKCksXG4gICAgICAgIGRpc2FibGVkOiAhZWRpdG9yLmNhbigpLmNoYWluKCkuZm9jdXMoKS50b2dnbGVVbmRlcmxpbmUoKS5ydW4oKSxcbiAgICAgICAgYWN0aXZlOiBlZGl0b3IuaXNBY3RpdmUoXCJ1bmRlcmxpbmVcIilcbiAgICAgIH0pLFxuICAgICAgc3VwcG9ydHNTdHJpa2UgJiYgLyogQF9fUFVSRV9fICovIGpzeChUb29sYmFyVG9nZ2xlLCB7XG4gICAgICAgIG5hbWU6IFwiU3RyaWtldGhyb3VnaFwiLFxuICAgICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8ganN4KFN0cmlrZXRocm91Z2hJY29uLCB7fSksXG4gICAgICAgIHNob3J0Y3V0OiBcIk1vZC1VXCIsXG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IGVkaXRvci5jaGFpbigpLmZvY3VzKCkudG9nZ2xlU3RyaWtlKCkucnVuKCksXG4gICAgICAgIGRpc2FibGVkOiAhZWRpdG9yLmNhbigpLmNoYWluKCkuZm9jdXMoKS50b2dnbGVTdHJpa2UoKS5ydW4oKSxcbiAgICAgICAgYWN0aXZlOiBlZGl0b3IuaXNBY3RpdmUoXCJzdHJpa2VcIilcbiAgICAgIH0pLFxuICAgICAgc3VwcG9ydHNDb2RlICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhclRvZ2dsZSwge1xuICAgICAgICBuYW1lOiBcIklubGluZSBjb2RlXCIsXG4gICAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBqc3goQ29kZUljb24sIHt9KSxcbiAgICAgICAgc2hvcnRjdXQ6IFwiTW9kLUVcIixcbiAgICAgICAgb25DbGljazogKCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS50b2dnbGVDb2RlKCkucnVuKCksXG4gICAgICAgIGRpc2FibGVkOiAhZWRpdG9yLmNhbigpLmNoYWluKCkuZm9jdXMoKS50b2dnbGVDb2RlKCkucnVuKCksXG4gICAgICAgIGFjdGl2ZTogZWRpdG9yLmlzQWN0aXZlKFwiY29kZVwiKVxuICAgICAgfSlcbiAgICBdXG4gIH0pO1xufVxuZnVuY3Rpb24gVG9vbGJhclNlY3Rpb25Db2xsYWJvcmF0aW9uKCkge1xuICBjb25zdCBlZGl0b3IgPSB1c2VDdXJyZW50RWRpdG9yKFxuICAgIFwiU2VjdGlvbkNvbGxhYm9yYXRpb25cIixcbiAgICBcIlRvb2xiYXIgb3IgRmxvYXRpbmdUb29sYmFyXCJcbiAgKTtcbiAgY29uc3Qgc3VwcG9ydHNUaHJlYWQgPSBcImFkZFBlbmRpbmdDb21tZW50XCIgaW4gZWRpdG9yLmNvbW1hbmRzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBzdXBwb3J0c1RocmVhZCAmJiAvKiBAX19QVVJFX18gKi8ganN4KFRvb2xiYXJCdXR0b24sIHtcbiAgICAgIG5hbWU6IFwiQWRkIGEgY29tbWVudFwiLFxuICAgICAgaWNvbjogLyogQF9fUFVSRV9fICovIGpzeChDb21tZW50SWNvbiwge30pLFxuICAgICAgb25DbGljazogKCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS5hZGRQZW5kaW5nQ29tbWVudCgpLnJ1bigpLFxuICAgICAgY2hpbGRyZW46IFwiQ29tbWVudFwiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBUb29sYmFyU2VjdGlvbkFpKCkge1xuICBjb25zdCBlZGl0b3IgPSB1c2VDdXJyZW50RWRpdG9yKFwiU2VjdGlvbkFpXCIsIFwiVG9vbGJhciBvciBGbG9hdGluZ1Rvb2xiYXJcIik7XG4gIGNvbnN0IHN1cHBvcnRzQWkgPSBcImFza0FpXCIgaW4gZWRpdG9yLmNvbW1hbmRzO1xuICBjb25zdCBhaU5hbWUgPSBlZGl0b3Iuc3RvcmFnZS5saXZlYmxvY2tzQWk/Lm5hbWU7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IHN1cHBvcnRzQWkgJiYgLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHtcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFRvb2xiYXJCdXR0b24sIHtcbiAgICAgICAgICBuYW1lOiBgQXNrICR7YWlOYW1lfSBhbnl0aGluZ1xcdTIwMjZgLFxuICAgICAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBqc3goU3BhcmtsZXNJY29uLCB7fSksXG4gICAgICAgICAgb25DbGljazogKCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS5hc2tBaSgpLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBcIkFzayBcIixcbiAgICAgICAgICAgIGFpTmFtZVxuICAgICAgICAgIF1cbiAgICAgICAgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhckJ1dHRvbiwge1xuICAgICAgICAgIG5hbWU6IFwiRXhwbGFpblwiLFxuICAgICAgICAgIGljb246IC8qIEBfX1BVUkVfXyAqLyBqc3goUXVlc3Rpb25NYXJrSWNvbiwge30pLFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IGVkaXRvci5jaGFpbigpLmZvY3VzKCkuYXNrQWkoXCJFeHBsYWluIHdoYXQgdGhlIHRleHQgaXMgYWJvdXRcIiksXG4gICAgICAgICAgY2hpbGRyZW46IFwiRXhwbGFpblwiXG4gICAgICAgIH0pXG4gICAgICBdXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBEZWZhdWx0VG9vbGJhckNvbnRlbnQoeyBlZGl0b3IgfSkge1xuICBjb25zdCBzdXBwb3J0c1RocmVhZCA9IFwiYWRkUGVuZGluZ0NvbW1lbnRcIiBpbiBlZGl0b3IuY29tbWFuZHM7XG4gIGNvbnN0IHN1cHBvcnRzQWkgPSBcImFza0FpXCIgaW4gZWRpdG9yLmNvbW1hbmRzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChUb29sYmFyU2VjdGlvbkhpc3RvcnksIHt9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhclNlcGFyYXRvciwge30pLFxuICAgICAgc3VwcG9ydHNBaSA/IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChUb29sYmFyU2VjdGlvbkFpLCB7fSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChUb29sYmFyU2VwYXJhdG9yLCB7fSlcbiAgICAgICAgXVxuICAgICAgfSkgOiBudWxsLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChUb29sYmFyQmxvY2tTZWxlY3Rvciwge30pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChUb29sYmFyU2VjdGlvbklubGluZSwge30pLFxuICAgICAgc3VwcG9ydHNUaHJlYWQgPyAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwge1xuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhclNlcGFyYXRvciwge30pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhclNlY3Rpb25Db2xsYWJvcmF0aW9uLCB7fSlcbiAgICAgICAgXVxuICAgICAgfSkgOiBudWxsXG4gICAgXVxuICB9KTtcbn1cbmNvbnN0IFRvb2xiYXIgPSBPYmplY3QuYXNzaWduKFxuICBmb3J3YXJkUmVmKFxuICAgICh7XG4gICAgICBiZWZvcmUsXG4gICAgICBhZnRlcixcbiAgICAgIGNoaWxkcmVuID0gRGVmYXVsdFRvb2xiYXJDb250ZW50LFxuICAgICAgZWRpdG9yLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgLi4ucHJvcHNcbiAgICB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2xvdFByb3BzID0geyBlZGl0b3IgfTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFRvb2x0aXBQcm92aWRlciwge1xuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChFZGl0b3JQcm92aWRlciwge1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwge1xuICAgICAgICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICAgICAgICByb2xlOiBcInRvb2xiYXJcIixcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBcIlRvb2xiYXJcIixcbiAgICAgICAgICAgIFwiYXJpYS1vcmllbnRhdGlvblwiOiBcImhvcml6b250YWxcIixcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhcImxiLXJvb3QgbGItdGlwdGFwLXRvb2xiYXJcIiwgY2xhc3NOYW1lKSxcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgYXBwbHlUb29sYmFyU2xvdChiZWZvcmUsIHNsb3RQcm9wcyksXG4gICAgICAgICAgICAgIGFwcGx5VG9vbGJhclNsb3QoY2hpbGRyZW4sIHNsb3RQcm9wcyksXG4gICAgICAgICAgICAgIGFwcGx5VG9vbGJhclNsb3QoYWZ0ZXIsIHNsb3RQcm9wcylcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICApLFxuICB7XG4gICAgQnV0dG9uOiBUb29sYmFyQnV0dG9uLFxuICAgIFRvZ2dsZTogVG9vbGJhclRvZ2dsZSxcbiAgICBCbG9ja1NlbGVjdG9yOiBUb29sYmFyQmxvY2tTZWxlY3RvcixcbiAgICBTZXBhcmF0b3I6IFRvb2xiYXJTZXBhcmF0b3IsXG4gICAgU2VjdGlvbkhpc3Rvcnk6IFRvb2xiYXJTZWN0aW9uSGlzdG9yeSxcbiAgICBTZWN0aW9uSW5saW5lOiBUb29sYmFyU2VjdGlvbklubGluZSxcbiAgICBTZWN0aW9uQ29sbGFib3JhdGlvbjogVG9vbGJhclNlY3Rpb25Db2xsYWJvcmF0aW9uLFxuICAgIFNlY3Rpb25BaTogVG9vbGJhclNlY3Rpb25BaVxuICB9XG4pO1xuXG5leHBvcnQgeyBCTE9DS19TRUxFQ1RfU0lERV9PRkZTRVQsIEZMT0FUSU5HX0VMRU1FTlRfQ09MTElTSU9OX1BBRERJTkcsIFRvb2xiYXIsIGFwcGx5VG9vbGJhclNsb3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRvb2xiYXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/toolbar/Toolbar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/toolbar/shared.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/toolbar/shared.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FloatingToolbarContext: () => (/* binding */ FloatingToolbarContext),\n/* harmony export */   FloatingToolbarExternal: () => (/* binding */ FloatingToolbarExternal)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _liveblocks_react_private__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liveblocks/react/_private */ \"(ssr)/./node_modules/@liveblocks/react/dist/_private.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n\nconst FloatingToolbarContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst FloatingToolbarExternal = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ children, style, ...props }, forwardedRef) => {\n  const id = (0,react__WEBPACK_IMPORTED_MODULE_1__.useId)();\n  const externalId = `liveblocks-floating-toolbar-external-${id}`;\n  const floatingToolbarContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(FloatingToolbarContext);\n  const registerExternal = floatingToolbarContext?.registerExternal;\n  (0,_liveblocks_react_private__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(() => {\n    if (!registerExternal) {\n      return;\n    }\n    return registerExternal(externalId);\n  }, [registerExternal, externalId]);\n  if (!floatingToolbarContext || react__WEBPACK_IMPORTED_MODULE_1__.Children.count(children) === 0) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n      children\n    });\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    ref: forwardedRef,\n    style: { display: \"contents\", ...style },\n    \"data-liveblocks-floating-toolbar-external\": id,\n    ...props,\n    id: externalId,\n    children\n  });\n});\n\n\n//# sourceMappingURL=shared.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvdG9vbGJhci9zaGFyZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBa0Q7QUFDVztBQUNrQjs7QUFFL0UsK0JBQStCLG9EQUFhO0FBQzVDLGdDQUFnQyxpREFBVSxJQUFJLDJCQUEyQjtBQUN6RSxhQUFhLDRDQUFLO0FBQ2xCLDZEQUE2RCxHQUFHO0FBQ2hFLGlDQUFpQyxpREFBVTtBQUMzQztBQUNBLEVBQUUsMEVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUNBQWlDLDJDQUFRO0FBQ3pDLDJCQUEyQixzREFBRyxDQUFDLHVEQUFRO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCLHNEQUFHO0FBQzVCO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFMEQ7QUFDM0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXRpcHRhcC9kaXN0L3Rvb2xiYXIvc2hhcmVkLmpzP2U4NzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4LCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ0BsaXZlYmxvY2tzL3JlYWN0L19wcml2YXRlJztcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGZvcndhcmRSZWYsIHVzZUlkLCB1c2VDb250ZXh0LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgRmxvYXRpbmdUb29sYmFyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBGbG9hdGluZ1Rvb2xiYXJFeHRlcm5hbCA9IGZvcndhcmRSZWYoKHsgY2hpbGRyZW4sIHN0eWxlLCAuLi5wcm9wcyB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgaWQgPSB1c2VJZCgpO1xuICBjb25zdCBleHRlcm5hbElkID0gYGxpdmVibG9ja3MtZmxvYXRpbmctdG9vbGJhci1leHRlcm5hbC0ke2lkfWA7XG4gIGNvbnN0IGZsb2F0aW5nVG9vbGJhckNvbnRleHQgPSB1c2VDb250ZXh0KEZsb2F0aW5nVG9vbGJhckNvbnRleHQpO1xuICBjb25zdCByZWdpc3RlckV4dGVybmFsID0gZmxvYXRpbmdUb29sYmFyQ29udGV4dD8ucmVnaXN0ZXJFeHRlcm5hbDtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXJlZ2lzdGVyRXh0ZXJuYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lzdGVyRXh0ZXJuYWwoZXh0ZXJuYWxJZCk7XG4gIH0sIFtyZWdpc3RlckV4dGVybmFsLCBleHRlcm5hbElkXSk7XG4gIGlmICghZmxvYXRpbmdUb29sYmFyQ29udGV4dCB8fCBDaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDApIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChGcmFnbWVudCwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7XG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgc3R5bGU6IHsgZGlzcGxheTogXCJjb250ZW50c1wiLCAuLi5zdHlsZSB9LFxuICAgIFwiZGF0YS1saXZlYmxvY2tzLWZsb2F0aW5nLXRvb2xiYXItZXh0ZXJuYWxcIjogaWQsXG4gICAgLi4ucHJvcHMsXG4gICAgaWQ6IGV4dGVybmFsSWQsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59KTtcblxuZXhwb3J0IHsgRmxvYXRpbmdUb29sYmFyQ29udGV4dCwgRmxvYXRpbmdUb29sYmFyRXh0ZXJuYWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/toolbar/shared.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/types.js":
/*!*************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/types.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AI_TOOLBAR_SELECTION_PLUGIN: () => (/* binding */ AI_TOOLBAR_SELECTION_PLUGIN),\n/* harmony export */   LIVEBLOCKS_COMMENT_MARK_TYPE: () => (/* binding */ LIVEBLOCKS_COMMENT_MARK_TYPE),\n/* harmony export */   LIVEBLOCKS_MENTION_EXTENSION: () => (/* binding */ LIVEBLOCKS_MENTION_EXTENSION),\n/* harmony export */   LIVEBLOCKS_MENTION_KEY: () => (/* binding */ LIVEBLOCKS_MENTION_KEY),\n/* harmony export */   LIVEBLOCKS_MENTION_NOTIFIER_KEY: () => (/* binding */ LIVEBLOCKS_MENTION_NOTIFIER_KEY),\n/* harmony export */   LIVEBLOCKS_MENTION_PASTE_KEY: () => (/* binding */ LIVEBLOCKS_MENTION_PASTE_KEY),\n/* harmony export */   LIVEBLOCKS_MENTION_TYPE: () => (/* binding */ LIVEBLOCKS_MENTION_TYPE),\n/* harmony export */   THREADS_ACTIVE_SELECTION_PLUGIN: () => (/* binding */ THREADS_ACTIVE_SELECTION_PLUGIN),\n/* harmony export */   THREADS_PLUGIN_KEY: () => (/* binding */ THREADS_PLUGIN_KEY),\n/* harmony export */   ThreadPluginActions: () => (/* binding */ ThreadPluginActions)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\nconst LIVEBLOCKS_MENTION_KEY = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"lb-plugin-mention\");\nconst LIVEBLOCKS_MENTION_PASTE_KEY = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\n  \"lb-plugin-mention-paste\"\n);\nconst LIVEBLOCKS_MENTION_NOTIFIER_KEY = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\n  \"lb-plugin-mention-notify\"\n);\nconst LIVEBLOCKS_MENTION_EXTENSION = \"liveblocksMentionExt\";\nconst LIVEBLOCKS_MENTION_TYPE = \"liveblocksMention\";\nconst THREADS_ACTIVE_SELECTION_PLUGIN = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\n  \"lb-threads-active-selection-plugin\"\n);\nconst THREADS_PLUGIN_KEY = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\n  \"lb-threads-plugin\"\n);\nconst AI_TOOLBAR_SELECTION_PLUGIN = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\n  \"lb-ai-toolbar-selection-plugin\"\n);\nconst LIVEBLOCKS_COMMENT_MARK_TYPE = \"liveblocksCommentMark\";\nvar ThreadPluginActions = /* @__PURE__ */ ((ThreadPluginActions2) => {\n  ThreadPluginActions2[\"SET_SELECTED_THREAD_ID\"] = \"SET_SELECTED_THREAD_ID\";\n  return ThreadPluginActions2;\n})(ThreadPluginActions || {});\n\n\n//# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7O0FBRTdDLG1DQUFtQyx1REFBUztBQUM1Qyx5Q0FBeUMsdURBQVM7QUFDbEQ7QUFDQTtBQUNBLDRDQUE0Qyx1REFBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1REFBUztBQUNyRDtBQUNBO0FBQ0EsK0JBQStCLHVEQUFTO0FBQ3hDO0FBQ0E7QUFDQSx3Q0FBd0MsdURBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7O0FBRWlRO0FBQzdSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC10aXB0YXAvZGlzdC90eXBlcy5qcz83N2UxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnO1xuXG5jb25zdCBMSVZFQkxPQ0tTX01FTlRJT05fS0VZID0gbmV3IFBsdWdpbktleShcImxiLXBsdWdpbi1tZW50aW9uXCIpO1xuY29uc3QgTElWRUJMT0NLU19NRU5USU9OX1BBU1RFX0tFWSA9IG5ldyBQbHVnaW5LZXkoXG4gIFwibGItcGx1Z2luLW1lbnRpb24tcGFzdGVcIlxuKTtcbmNvbnN0IExJVkVCTE9DS1NfTUVOVElPTl9OT1RJRklFUl9LRVkgPSBuZXcgUGx1Z2luS2V5KFxuICBcImxiLXBsdWdpbi1tZW50aW9uLW5vdGlmeVwiXG4pO1xuY29uc3QgTElWRUJMT0NLU19NRU5USU9OX0VYVEVOU0lPTiA9IFwibGl2ZWJsb2Nrc01lbnRpb25FeHRcIjtcbmNvbnN0IExJVkVCTE9DS1NfTUVOVElPTl9UWVBFID0gXCJsaXZlYmxvY2tzTWVudGlvblwiO1xuY29uc3QgVEhSRUFEU19BQ1RJVkVfU0VMRUNUSU9OX1BMVUdJTiA9IG5ldyBQbHVnaW5LZXkoXG4gIFwibGItdGhyZWFkcy1hY3RpdmUtc2VsZWN0aW9uLXBsdWdpblwiXG4pO1xuY29uc3QgVEhSRUFEU19QTFVHSU5fS0VZID0gbmV3IFBsdWdpbktleShcbiAgXCJsYi10aHJlYWRzLXBsdWdpblwiXG4pO1xuY29uc3QgQUlfVE9PTEJBUl9TRUxFQ1RJT05fUExVR0lOID0gbmV3IFBsdWdpbktleShcbiAgXCJsYi1haS10b29sYmFyLXNlbGVjdGlvbi1wbHVnaW5cIlxuKTtcbmNvbnN0IExJVkVCTE9DS1NfQ09NTUVOVF9NQVJLX1RZUEUgPSBcImxpdmVibG9ja3NDb21tZW50TWFya1wiO1xudmFyIFRocmVhZFBsdWdpbkFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gKChUaHJlYWRQbHVnaW5BY3Rpb25zMikgPT4ge1xuICBUaHJlYWRQbHVnaW5BY3Rpb25zMltcIlNFVF9TRUxFQ1RFRF9USFJFQURfSURcIl0gPSBcIlNFVF9TRUxFQ1RFRF9USFJFQURfSURcIjtcbiAgcmV0dXJuIFRocmVhZFBsdWdpbkFjdGlvbnMyO1xufSkoVGhyZWFkUGx1Z2luQWN0aW9ucyB8fCB7fSk7XG5cbmV4cG9ydCB7IEFJX1RPT0xCQVJfU0VMRUNUSU9OX1BMVUdJTiwgTElWRUJMT0NLU19DT01NRU5UX01BUktfVFlQRSwgTElWRUJMT0NLU19NRU5USU9OX0VYVEVOU0lPTiwgTElWRUJMT0NLU19NRU5USU9OX0tFWSwgTElWRUJMT0NLU19NRU5USU9OX05PVElGSUVSX0tFWSwgTElWRUJMT0NLU19NRU5USU9OX1BBU1RFX0tFWSwgTElWRUJMT0NLU19NRU5USU9OX1RZUEUsIFRIUkVBRFNfQUNUSVZFX1NFTEVDVElPTl9QTFVHSU4sIFRIUkVBRFNfUExVR0lOX0tFWSwgVGhyZWFkUGx1Z2luQWN0aW9ucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-tiptap/dist/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/@liveblocks/react-tiptap/dist/utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareSelections: () => (/* binding */ compareSelections),\n/* harmony export */   getContextualPromptContext: () => (/* binding */ getContextualPromptContext),\n/* harmony export */   getDomRangeFromSelection: () => (/* binding */ getDomRangeFromSelection),\n/* harmony export */   getMentionsFromNode: () => (/* binding */ getMentionsFromNode),\n/* harmony export */   getRangeFromRelativeSelections: () => (/* binding */ getRangeFromRelativeSelections),\n/* harmony export */   getRectFromCoords: () => (/* binding */ getRectFromCoords),\n/* harmony export */   getRelativeSelectionFromState: () => (/* binding */ getRelativeSelectionFromState),\n/* harmony export */   mapFragment: () => (/* binding */ mapFragment)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/model */ \"(ssr)/./node_modules/@tiptap/pm/model/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-prosemirror */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! y-prosemirror */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! y-prosemirror */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/@liveblocks/react-tiptap/dist/types.js\");\n\n\n\n\n\nconst CONTEXT_TRUNCATION = \"[\\u2026]\";\nconst CONTEXT_BLOCK_SEPARATOR = \"\\n\";\nconst getRelativeSelectionFromState = (state) => {\n  const pluginState = y_prosemirror__WEBPACK_IMPORTED_MODULE_2__.ySyncPluginKey.getState(state);\n  if (!pluginState)\n    return null;\n  return (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_3__.getRelativeSelection)(pluginState.binding, state);\n};\nconst getRangeFromRelativeSelections = (pos, state) => {\n  const pluginState = y_prosemirror__WEBPACK_IMPORTED_MODULE_2__.ySyncPluginKey.getState(state);\n  if (!pluginState || !pluginState.binding)\n    return { from: 0, to: 0 };\n  const { doc, type, mapping } = pluginState.binding;\n  const anchor = (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_4__.relativePositionToAbsolutePosition)(doc, type, pos.anchor, mapping) ?? 0;\n  const head = (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_4__.relativePositionToAbsolutePosition)(doc, type, pos.head, mapping) ?? 0;\n  const from = anchor > head ? head : anchor;\n  const to = anchor > head ? anchor : head;\n  return { from, to };\n};\nconst getRectFromCoords = (coords) => {\n  return {\n    ...coords,\n    x: coords.left,\n    y: coords.top,\n    width: coords.right - coords.left,\n    height: coords.bottom - coords.top\n  };\n};\nconst getMentionsFromNode = (node, range) => {\n  const result = [];\n  node.nodesBetween(range.from, range.to, (child) => {\n    if (child.type.name === _types_js__WEBPACK_IMPORTED_MODULE_5__.LIVEBLOCKS_MENTION_TYPE) {\n      const mention = child.attrs;\n      if (mention.id && mention.notificationId) {\n        result.push({\n          notificationId: mention.notificationId,\n          userId: mention.id\n        });\n      }\n    }\n  });\n  return result;\n};\nconst mapFragment = (fragment, callback) => {\n  const content = [];\n  fragment.forEach((node) => {\n    if (node.content.childCount > 0) {\n      content.push(\n        node.type.create(node.attrs, mapFragment(node.content, callback))\n      );\n      return;\n    }\n    content.push(callback(node));\n  });\n  return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content);\n};\nfunction getDomRangeFromSelection(editor, selection) {\n  if (selection.from === selection.to) {\n    const { parent, parentOffset } = selection.$from;\n    if (parent.isBlock && parent.content.size === 0 || parent.isTextblock && parentOffset === parent.content.size) {\n      selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(\n        editor.state.doc,\n        selection.$from.before(),\n        selection.$from.after()\n      );\n    }\n  }\n  const from = editor.view.domAtPos(selection.from);\n  const to = editor.view.domAtPos(selection.to);\n  const domRange = document.createRange();\n  domRange.setStart(from.node, from.offset);\n  domRange.setEnd(to.node, to.offset);\n  return domRange;\n}\nfunction compareSelections(a, b) {\n  if (!a || !b) {\n    return false;\n  }\n  return a.eq(b);\n}\nfunction getContextualPromptContext(editor, maxLength = 1e4) {\n  const { selection, doc } = editor.state;\n  const selectionLength = selection.to - selection.from;\n  if (maxLength >= doc.content.size) {\n    return {\n      beforeSelection: doc.textBetween(\n        0,\n        selection.from,\n        CONTEXT_BLOCK_SEPARATOR\n      ),\n      selection: doc.textBetween(\n        selection.from,\n        selection.to,\n        CONTEXT_BLOCK_SEPARATOR\n      ),\n      afterSelection: doc.textBetween(\n        selection.to,\n        doc.content.size,\n        CONTEXT_BLOCK_SEPARATOR\n      )\n    };\n  } else if (selectionLength > maxLength) {\n    const selectionStart = doc.textBetween(\n      selection.from,\n      selection.from + Math.floor(maxLength / 2) - CONTEXT_TRUNCATION.length,\n      CONTEXT_BLOCK_SEPARATOR\n    );\n    const selectionEnd = doc.textBetween(\n      selection.to - Math.floor(maxLength / 2) + CONTEXT_TRUNCATION.length,\n      selection.to,\n      CONTEXT_BLOCK_SEPARATOR\n    );\n    return {\n      beforeSelection: \"\",\n      selection: `${selectionStart}${CONTEXT_TRUNCATION}${selectionEnd}`,\n      afterSelection: \"\"\n    };\n  } else {\n    let beforeLength = Math.min(\n      selection.from,\n      Math.floor((maxLength - selectionLength) / 2)\n    );\n    const afterLength = Math.min(\n      doc.content.size - selection.to,\n      maxLength - selectionLength - beforeLength\n    );\n    if (beforeLength + afterLength + selectionLength < maxLength) {\n      beforeLength = Math.min(\n        selection.from,\n        maxLength - selectionLength - afterLength\n      );\n    }\n    let beforeSelection = doc.textBetween(\n      Math.max(0, selection.from - beforeLength),\n      selection.from,\n      CONTEXT_BLOCK_SEPARATOR\n    );\n    let afterSelection = doc.textBetween(\n      selection.to,\n      Math.min(doc.content.size, selection.to + afterLength),\n      CONTEXT_BLOCK_SEPARATOR\n    );\n    if (selection.from - beforeLength > 0) {\n      beforeSelection = `${CONTEXT_TRUNCATION}${beforeSelection}`;\n    }\n    if (selection.to + afterLength < doc.content.size) {\n      afterSelection = `${afterSelection}${CONTEXT_TRUNCATION}`;\n    }\n    return {\n      beforeSelection,\n      selection: doc.textBetween(\n        selection.from,\n        selection.to,\n        CONTEXT_BLOCK_SEPARATOR\n      ),\n      afterSelection\n    };\n  }\n}\n\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdGlwdGFwL2Rpc3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEM7QUFDSztBQUN3RDtBQUNwRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlEQUFjO0FBQ3BDO0FBQ0E7QUFDQSxTQUFTLG1FQUFvQjtBQUM3QjtBQUNBO0FBQ0Esc0JBQXNCLHlEQUFjO0FBQ3BDO0FBQ0EsYUFBYTtBQUNiLFVBQVUscUJBQXFCO0FBQy9CLGlCQUFpQixpRkFBa0M7QUFDbkQsZUFBZSxpRkFBa0M7QUFDakQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4REFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLHNEQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0Esa0JBQWtCLDJEQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZSxFQUFFLG1CQUFtQixFQUFFLGFBQWE7QUFDdkU7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUIsRUFBRSxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUUsbUJBQW1CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdU07QUFDdk0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXRpcHRhcC9kaXN0L3V0aWxzLmpzPzIwYjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJztcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB7IHlTeW5jUGx1Z2luS2V5LCBnZXRSZWxhdGl2ZVNlbGVjdGlvbiwgcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbiB9IGZyb20gJ3ktcHJvc2VtaXJyb3InO1xuaW1wb3J0IHsgTElWRUJMT0NLU19NRU5USU9OX1RZUEUgfSBmcm9tICcuL3R5cGVzLmpzJztcblxuY29uc3QgQ09OVEVYVF9UUlVOQ0FUSU9OID0gXCJbXFx1MjAyNl1cIjtcbmNvbnN0IENPTlRFWFRfQkxPQ0tfU0VQQVJBVE9SID0gXCJcXG5cIjtcbmNvbnN0IGdldFJlbGF0aXZlU2VsZWN0aW9uRnJvbVN0YXRlID0gKHN0YXRlKSA9PiB7XG4gIGNvbnN0IHBsdWdpblN0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICBpZiAoIXBsdWdpblN0YXRlKVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gZ2V0UmVsYXRpdmVTZWxlY3Rpb24ocGx1Z2luU3RhdGUuYmluZGluZywgc3RhdGUpO1xufTtcbmNvbnN0IGdldFJhbmdlRnJvbVJlbGF0aXZlU2VsZWN0aW9ucyA9IChwb3MsIHN0YXRlKSA9PiB7XG4gIGNvbnN0IHBsdWdpblN0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICBpZiAoIXBsdWdpblN0YXRlIHx8ICFwbHVnaW5TdGF0ZS5iaW5kaW5nKVxuICAgIHJldHVybiB7IGZyb206IDAsIHRvOiAwIH07XG4gIGNvbnN0IHsgZG9jLCB0eXBlLCBtYXBwaW5nIH0gPSBwbHVnaW5TdGF0ZS5iaW5kaW5nO1xuICBjb25zdCBhbmNob3IgPSByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uKGRvYywgdHlwZSwgcG9zLmFuY2hvciwgbWFwcGluZykgPz8gMDtcbiAgY29uc3QgaGVhZCA9IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oZG9jLCB0eXBlLCBwb3MuaGVhZCwgbWFwcGluZykgPz8gMDtcbiAgY29uc3QgZnJvbSA9IGFuY2hvciA+IGhlYWQgPyBoZWFkIDogYW5jaG9yO1xuICBjb25zdCB0byA9IGFuY2hvciA+IGhlYWQgPyBhbmNob3IgOiBoZWFkO1xuICByZXR1cm4geyBmcm9tLCB0byB9O1xufTtcbmNvbnN0IGdldFJlY3RGcm9tQ29vcmRzID0gKGNvb3JkcykgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLmNvb3JkcyxcbiAgICB4OiBjb29yZHMubGVmdCxcbiAgICB5OiBjb29yZHMudG9wLFxuICAgIHdpZHRoOiBjb29yZHMucmlnaHQgLSBjb29yZHMubGVmdCxcbiAgICBoZWlnaHQ6IGNvb3Jkcy5ib3R0b20gLSBjb29yZHMudG9wXG4gIH07XG59O1xuY29uc3QgZ2V0TWVudGlvbnNGcm9tTm9kZSA9IChub2RlLCByYW5nZSkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbm9kZS5ub2Rlc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIChjaGlsZCkgPT4ge1xuICAgIGlmIChjaGlsZC50eXBlLm5hbWUgPT09IExJVkVCTE9DS1NfTUVOVElPTl9UWVBFKSB7XG4gICAgICBjb25zdCBtZW50aW9uID0gY2hpbGQuYXR0cnM7XG4gICAgICBpZiAobWVudGlvbi5pZCAmJiBtZW50aW9uLm5vdGlmaWNhdGlvbklkKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBub3RpZmljYXRpb25JZDogbWVudGlvbi5ub3RpZmljYXRpb25JZCxcbiAgICAgICAgICB1c2VySWQ6IG1lbnRpb24uaWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBtYXBGcmFnbWVudCA9IChmcmFnbWVudCwgY2FsbGJhY2spID0+IHtcbiAgY29uc3QgY29udGVudCA9IFtdO1xuICBmcmFnbWVudC5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgaWYgKG5vZGUuY29udGVudC5jaGlsZENvdW50ID4gMCkge1xuICAgICAgY29udGVudC5wdXNoKFxuICAgICAgICBub2RlLnR5cGUuY3JlYXRlKG5vZGUuYXR0cnMsIG1hcEZyYWdtZW50KG5vZGUuY29udGVudCwgY2FsbGJhY2spKVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGVudC5wdXNoKGNhbGxiYWNrKG5vZGUpKTtcbiAgfSk7XG4gIHJldHVybiBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xufTtcbmZ1bmN0aW9uIGdldERvbVJhbmdlRnJvbVNlbGVjdGlvbihlZGl0b3IsIHNlbGVjdGlvbikge1xuICBpZiAoc2VsZWN0aW9uLmZyb20gPT09IHNlbGVjdGlvbi50bykge1xuICAgIGNvbnN0IHsgcGFyZW50LCBwYXJlbnRPZmZzZXQgfSA9IHNlbGVjdGlvbi4kZnJvbTtcbiAgICBpZiAocGFyZW50LmlzQmxvY2sgJiYgcGFyZW50LmNvbnRlbnQuc2l6ZSA9PT0gMCB8fCBwYXJlbnQuaXNUZXh0YmxvY2sgJiYgcGFyZW50T2Zmc2V0ID09PSBwYXJlbnQuY29udGVudC5zaXplKSB7XG4gICAgICBzZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShcbiAgICAgICAgZWRpdG9yLnN0YXRlLmRvYyxcbiAgICAgICAgc2VsZWN0aW9uLiRmcm9tLmJlZm9yZSgpLFxuICAgICAgICBzZWxlY3Rpb24uJGZyb20uYWZ0ZXIoKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZnJvbSA9IGVkaXRvci52aWV3LmRvbUF0UG9zKHNlbGVjdGlvbi5mcm9tKTtcbiAgY29uc3QgdG8gPSBlZGl0b3Iudmlldy5kb21BdFBvcyhzZWxlY3Rpb24udG8pO1xuICBjb25zdCBkb21SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGRvbVJhbmdlLnNldFN0YXJ0KGZyb20ubm9kZSwgZnJvbS5vZmZzZXQpO1xuICBkb21SYW5nZS5zZXRFbmQodG8ubm9kZSwgdG8ub2Zmc2V0KTtcbiAgcmV0dXJuIGRvbVJhbmdlO1xufVxuZnVuY3Rpb24gY29tcGFyZVNlbGVjdGlvbnMoYSwgYikge1xuICBpZiAoIWEgfHwgIWIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGEuZXEoYik7XG59XG5mdW5jdGlvbiBnZXRDb250ZXh0dWFsUHJvbXB0Q29udGV4dChlZGl0b3IsIG1heExlbmd0aCA9IDFlNCkge1xuICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSBlZGl0b3Iuc3RhdGU7XG4gIGNvbnN0IHNlbGVjdGlvbkxlbmd0aCA9IHNlbGVjdGlvbi50byAtIHNlbGVjdGlvbi5mcm9tO1xuICBpZiAobWF4TGVuZ3RoID49IGRvYy5jb250ZW50LnNpemUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmVmb3JlU2VsZWN0aW9uOiBkb2MudGV4dEJldHdlZW4oXG4gICAgICAgIDAsXG4gICAgICAgIHNlbGVjdGlvbi5mcm9tLFxuICAgICAgICBDT05URVhUX0JMT0NLX1NFUEFSQVRPUlxuICAgICAgKSxcbiAgICAgIHNlbGVjdGlvbjogZG9jLnRleHRCZXR3ZWVuKFxuICAgICAgICBzZWxlY3Rpb24uZnJvbSxcbiAgICAgICAgc2VsZWN0aW9uLnRvLFxuICAgICAgICBDT05URVhUX0JMT0NLX1NFUEFSQVRPUlxuICAgICAgKSxcbiAgICAgIGFmdGVyU2VsZWN0aW9uOiBkb2MudGV4dEJldHdlZW4oXG4gICAgICAgIHNlbGVjdGlvbi50byxcbiAgICAgICAgZG9jLmNvbnRlbnQuc2l6ZSxcbiAgICAgICAgQ09OVEVYVF9CTE9DS19TRVBBUkFUT1JcbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKHNlbGVjdGlvbkxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ID0gZG9jLnRleHRCZXR3ZWVuKFxuICAgICAgc2VsZWN0aW9uLmZyb20sXG4gICAgICBzZWxlY3Rpb24uZnJvbSArIE1hdGguZmxvb3IobWF4TGVuZ3RoIC8gMikgLSBDT05URVhUX1RSVU5DQVRJT04ubGVuZ3RoLFxuICAgICAgQ09OVEVYVF9CTE9DS19TRVBBUkFUT1JcbiAgICApO1xuICAgIGNvbnN0IHNlbGVjdGlvbkVuZCA9IGRvYy50ZXh0QmV0d2VlbihcbiAgICAgIHNlbGVjdGlvbi50byAtIE1hdGguZmxvb3IobWF4TGVuZ3RoIC8gMikgKyBDT05URVhUX1RSVU5DQVRJT04ubGVuZ3RoLFxuICAgICAgc2VsZWN0aW9uLnRvLFxuICAgICAgQ09OVEVYVF9CTE9DS19TRVBBUkFUT1JcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBiZWZvcmVTZWxlY3Rpb246IFwiXCIsXG4gICAgICBzZWxlY3Rpb246IGAke3NlbGVjdGlvblN0YXJ0fSR7Q09OVEVYVF9UUlVOQ0FUSU9OfSR7c2VsZWN0aW9uRW5kfWAsXG4gICAgICBhZnRlclNlbGVjdGlvbjogXCJcIlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbGV0IGJlZm9yZUxlbmd0aCA9IE1hdGgubWluKFxuICAgICAgc2VsZWN0aW9uLmZyb20sXG4gICAgICBNYXRoLmZsb29yKChtYXhMZW5ndGggLSBzZWxlY3Rpb25MZW5ndGgpIC8gMilcbiAgICApO1xuICAgIGNvbnN0IGFmdGVyTGVuZ3RoID0gTWF0aC5taW4oXG4gICAgICBkb2MuY29udGVudC5zaXplIC0gc2VsZWN0aW9uLnRvLFxuICAgICAgbWF4TGVuZ3RoIC0gc2VsZWN0aW9uTGVuZ3RoIC0gYmVmb3JlTGVuZ3RoXG4gICAgKTtcbiAgICBpZiAoYmVmb3JlTGVuZ3RoICsgYWZ0ZXJMZW5ndGggKyBzZWxlY3Rpb25MZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgIGJlZm9yZUxlbmd0aCA9IE1hdGgubWluKFxuICAgICAgICBzZWxlY3Rpb24uZnJvbSxcbiAgICAgICAgbWF4TGVuZ3RoIC0gc2VsZWN0aW9uTGVuZ3RoIC0gYWZ0ZXJMZW5ndGhcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBiZWZvcmVTZWxlY3Rpb24gPSBkb2MudGV4dEJldHdlZW4oXG4gICAgICBNYXRoLm1heCgwLCBzZWxlY3Rpb24uZnJvbSAtIGJlZm9yZUxlbmd0aCksXG4gICAgICBzZWxlY3Rpb24uZnJvbSxcbiAgICAgIENPTlRFWFRfQkxPQ0tfU0VQQVJBVE9SXG4gICAgKTtcbiAgICBsZXQgYWZ0ZXJTZWxlY3Rpb24gPSBkb2MudGV4dEJldHdlZW4oXG4gICAgICBzZWxlY3Rpb24udG8sXG4gICAgICBNYXRoLm1pbihkb2MuY29udGVudC5zaXplLCBzZWxlY3Rpb24udG8gKyBhZnRlckxlbmd0aCksXG4gICAgICBDT05URVhUX0JMT0NLX1NFUEFSQVRPUlxuICAgICk7XG4gICAgaWYgKHNlbGVjdGlvbi5mcm9tIC0gYmVmb3JlTGVuZ3RoID4gMCkge1xuICAgICAgYmVmb3JlU2VsZWN0aW9uID0gYCR7Q09OVEVYVF9UUlVOQ0FUSU9OfSR7YmVmb3JlU2VsZWN0aW9ufWA7XG4gICAgfVxuICAgIGlmIChzZWxlY3Rpb24udG8gKyBhZnRlckxlbmd0aCA8IGRvYy5jb250ZW50LnNpemUpIHtcbiAgICAgIGFmdGVyU2VsZWN0aW9uID0gYCR7YWZ0ZXJTZWxlY3Rpb259JHtDT05URVhUX1RSVU5DQVRJT059YDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGJlZm9yZVNlbGVjdGlvbixcbiAgICAgIHNlbGVjdGlvbjogZG9jLnRleHRCZXR3ZWVuKFxuICAgICAgICBzZWxlY3Rpb24uZnJvbSxcbiAgICAgICAgc2VsZWN0aW9uLnRvLFxuICAgICAgICBDT05URVhUX0JMT0NLX1NFUEFSQVRPUlxuICAgICAgKSxcbiAgICAgIGFmdGVyU2VsZWN0aW9uXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgeyBjb21wYXJlU2VsZWN0aW9ucywgZ2V0Q29udGV4dHVhbFByb21wdENvbnRleHQsIGdldERvbVJhbmdlRnJvbVNlbGVjdGlvbiwgZ2V0TWVudGlvbnNGcm9tTm9kZSwgZ2V0UmFuZ2VGcm9tUmVsYXRpdmVTZWxlY3Rpb25zLCBnZXRSZWN0RnJvbUNvb3JkcywgZ2V0UmVsYXRpdmVTZWxlY3Rpb25Gcm9tU3RhdGUsIG1hcEZyYWdtZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-tiptap/dist/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components.js":
/*!**************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComponentsContext: () => (/* binding */ ComponentsContext),\n/* harmony export */   ComponentsProvider: () => (/* binding */ ComponentsProvider),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   useComponents: () => (/* binding */ useComponents)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ ComponentsContext,ComponentsProvider,defaultComponents,useComponents auto */ \n\nconst defaultComponents = {\n    Anchor: \"a\"\n};\nconst ComponentsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(void 0);\nfunction useComponents(components) {\n    const contextComponents = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ComponentsContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            ...defaultComponents,\n            ...contextComponents,\n            ...components\n        }), [\n        contextComponents,\n        components\n    ]);\n}\nfunction ComponentsProvider({ children, components: providerComponents }) {\n    const contextComponents = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ComponentsContext);\n    const components = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            ...defaultComponents,\n            ...contextComponents,\n            ...providerComponents\n        }), [\n        contextComponents,\n        providerComponents\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ComponentsContext.Provider, {\n        value: components,\n        children\n    });\n}\n //# sourceMappingURL=components.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBbUJPLE1BQUFBLG9CQUFBO0lBQXNDQyxRQUFBO0FBRTdDO0FBRU8sTUFBQUMsa0NBQUFDLG9EQUFBQSxDQUEwQjtBQUkxQixTQUFBQyxjQUFBQyxVQUFBO0lBQ0wsTUFBQUMsb0JBQUFDLGlEQUFBQSxDQUFBTDtJQUVBLE9BQUFNLDhDQUFBQSxDQUFPO1lBQ0UsR0FBQVIsaUJBQUE7WUFDRixHQUFBTSxpQkFBQTtZQUNBLEdBQUFELFVBQUE7UUFDQSxJQUNMO1FBQUFDO1FBQUFEO0tBQUE7QUFHSjtBQUVPLFNBQUFJLG1CQUFBLEVBQTRCQyxRQUFBLEVBQ2pDTCxZQUFBTSxrQkFBQSxFQUVGO0lBQ0UsTUFBQUwsb0JBQUFDLGlEQUFBQSxDQUFBTDtJQUNBLE1BQUFHLGFBQUFHLDhDQUFBQSxDQUFtQjtZQUNWLEdBQUFSLGlCQUFBO1lBQ0YsR0FBQU0saUJBQUE7WUFDQSxHQUFBSyxrQkFBQTtRQUNBLElBQ0w7UUFBQUw7UUFBQUs7S0FBQTtJQUlGLHVCQUFBQyxzREFBQUEsQ0FBQVYsa0JBQUFXLFFBQUE7UUFDR0MsT0FBQVQ7UUFBa0NLO0lBQ2hDO0FBR1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4uL3NyYy9jb21wb25lbnRzLnRzeD83MTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgdHlwZSB7XG4gIENvbXBvbmVudFByb3BzV2l0aG91dFJlZixcbiAgQ29tcG9uZW50VHlwZSxcbiAgUHJvcHNXaXRoQ2hpbGRyZW4sXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbENvbXBvbmVudHMge1xuICBBbmNob3I6IENvbXBvbmVudFR5cGU8Q29tcG9uZW50UHJvcHNXaXRob3V0UmVmPFwiYVwiPj4gfCBcImFcIjtcbn1cblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50cyA9IEdsb2JhbENvbXBvbmVudHM7XG5cbnR5cGUgQ29tcG9uZW50c1Byb3ZpZGVyUHJvcHMgPSBQcm9wc1dpdGhDaGlsZHJlbjx7XG4gIGNvbXBvbmVudHM/OiBQYXJ0aWFsPENvbXBvbmVudHM+O1xufT47XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0Q29tcG9uZW50czogQ29tcG9uZW50cyA9IHtcbiAgQW5jaG9yOiBcImFcIixcbn07XG5cbmV4cG9ydCBjb25zdCBDb21wb25lbnRzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Q29tcG9uZW50cyB8IHVuZGVmaW5lZD4oXG4gIHVuZGVmaW5lZFxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbXBvbmVudHMoY29tcG9uZW50cz86IFBhcnRpYWw8Q29tcG9uZW50cz4pOiBDb21wb25lbnRzIHtcbiAgY29uc3QgY29udGV4dENvbXBvbmVudHMgPSB1c2VDb250ZXh0KENvbXBvbmVudHNDb250ZXh0KTtcblxuICByZXR1cm4gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgLi4uZGVmYXVsdENvbXBvbmVudHMsXG4gICAgICAuLi5jb250ZXh0Q29tcG9uZW50cyxcbiAgICAgIC4uLmNvbXBvbmVudHMsXG4gICAgfSksXG4gICAgW2NvbnRleHRDb21wb25lbnRzLCBjb21wb25lbnRzXVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29tcG9uZW50c1Byb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIGNvbXBvbmVudHM6IHByb3ZpZGVyQ29tcG9uZW50cyxcbn06IENvbXBvbmVudHNQcm92aWRlclByb3BzKSB7XG4gIGNvbnN0IGNvbnRleHRDb21wb25lbnRzID0gdXNlQ29udGV4dChDb21wb25lbnRzQ29udGV4dCk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICAuLi5kZWZhdWx0Q29tcG9uZW50cyxcbiAgICAgIC4uLmNvbnRleHRDb21wb25lbnRzLFxuICAgICAgLi4ucHJvdmlkZXJDb21wb25lbnRzLFxuICAgIH0pLFxuICAgIFtjb250ZXh0Q29tcG9uZW50cywgcHJvdmlkZXJDb21wb25lbnRzXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPENvbXBvbmVudHNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb21wb25lbnRzfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NvbXBvbmVudHNDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuIl0sIm5hbWVzIjpbImRlZmF1bHRDb21wb25lbnRzIiwiQW5jaG9yIiwiQ29tcG9uZW50c0NvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJjb250ZXh0Q29tcG9uZW50cyIsInVzZUNvbnRleHQiLCJ1c2VNZW1vIiwiQ29tcG9uZW50c1Byb3ZpZGVyIiwiY2hpbGRyZW4iLCJwcm92aWRlckNvbXBvbmVudHMiLCJqc3giLCJQcm92aWRlciIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Button.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/Button.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ Button),\n/* harmony export */   CustomButton: () => (/* binding */ CustomButton),\n/* harmony export */   SelectButton: () => (/* binding */ SelectButton)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _icons_ChevronDown_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../icons/ChevronDown.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/ChevronDown.js\");\n/* harmony import */ var _utils_class_names_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/class-names.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.js\");\n/* __next_internal_client_entry_do_not_use__ Button,CustomButton,SelectButton auto */ \n\n\n\nconst CustomButton = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ variant = \"default\", size = \"default\", disableable = true, className, children, ...props }, forwardedRef)=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n        type: \"button\",\n        className: (0,_utils_class_names_js__WEBPACK_IMPORTED_MODULE_2__.classNames)(\"lb-button\", !disableable && \"lb-button:non-disableable\", className),\n        \"data-variant\": variant,\n        \"data-size\": size,\n        ...props,\n        ref: forwardedRef,\n        children\n    });\n});\nconst Button = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ icon, children, ...props }, forwardedRef)=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(CustomButton, {\n        ...props,\n        ref: forwardedRef,\n        children: [\n            icon ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                className: \"lb-icon-container\",\n                children: icon\n            }) : null,\n            children ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                className: \"lb-button-label\",\n                children\n            }) : null\n        ]\n    });\n});\nconst SelectButton = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ icon, children, className, ...props }, forwardedRef)=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(CustomButton, {\n        ...props,\n        type: \"button\",\n        className: (0,_utils_class_names_js__WEBPACK_IMPORTED_MODULE_2__.classNames)(\"lb-select-button\", className),\n        ref: forwardedRef,\n        children: [\n            icon ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                className: \"lb-icon-container\",\n                children: icon\n            }) : null,\n            children ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                className: \"lb-button-label\",\n                children\n            }) : null,\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                className: \"lb-select-button-chevron\",\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_icons_ChevronDown_js__WEBPACK_IMPORTED_MODULE_3__.ChevronDownIcon, {})\n            })\n        ]\n    });\n});\n //# sourceMappingURL=Button.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0J1dHRvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQWVPLE1BQUFBLDZCQUFBQyxpREFBQUEsQ0FBcUIsR0FLeEJDLFVBQUEsV0FDWUMsT0FBQSxXQUNIQyxjQUFBLE1BQ09DLFNBQUEsRUFDZEMsUUFBQSxFQUNBLEdBQUFDLE9BQ0csRUFBQUM7SUFJTCx1QkFBQUMsc0RBQUFBLENBQUE7UUFDR0MsTUFBQTtRQUNNTCxXQUFBTSxpRUFBQUEsQ0FDTSxhQUNULENBQUFQLGVBQUEsNkJBQ2dCQztRQUVsQixnQkFBQUg7UUFDYyxhQUFBQztRQUNILEdBQUFJLEtBQUE7UUFDUEssS0FBQUo7UUFDQ0Y7SUFFSjtBQUNIO0FBS0MsTUFBQU8sdUJBQUFaLGlEQUFBQSxDQUFlLEdBQUFhLElBQUEsRUFBQVIsUUFBQSxLQUFBQyxPQUFBLEVBQUFDO0lBRWxCLHVCQUFBTyx1REFBQUEsQ0FBQWYsY0FBQTtRQUNHLEdBQUFPLEtBQUE7UUFBaUJLLEtBQUFKO1FBQVlGLFVBQUE7WUFDM0JRLE9BQUEsZ0JBQUFMLHNEQUFBQSxDQUFBO2dCQUFRSixXQUFBO2dCQUFlQyxVQUFBUTtZQUFxQjtZQUFlUixXQUFBLGdCQUFBRyxzREFBQUEsQ0FBQTtnQkFDL0NKLFdBQUE7Z0JBQWVDO1lBQW1CO1NBQW1CO0lBQUE7QUFDcEU7QUFLQyxNQUFBVSw2QkFBQWYsaURBQUFBLENBQXFCLEdBQUFhLElBQUEsRUFBQVIsUUFBQSxFQUFBRCxTQUFBLEtBQUFFLE9BQUEsRUFBQUM7SUFFeEIsdUJBQUFPLHVEQUFBQSxDQUFBZixjQUFBO1FBQ0csR0FBQU8sS0FBQTtRQUNLRyxNQUFBO1FBQ0NMLFdBQUFNLGlFQUFBQSxDQUFBLG9CQUFBTjtRQUM4Q08sS0FBQUo7UUFDOUNGLFVBQUE7WUFFSlEsT0FBQSxnQkFBQUwsc0RBQUFBLENBQUE7Z0JBQVFKLFdBQUE7Z0JBQWVDLFVBQUFRO1lBQXFCO1lBQWVSLFdBQUEsZ0JBQUFHLHNEQUFBQSxDQUFBO2dCQUMvQ0osV0FBQTtnQkFBZUM7WUFBbUI7WUFBbUIsZ0JBQUFHLHNEQUFBQSxDQUFBO2dCQUNqRUosV0FBQTtnQkFBZUMsVUFBQSxnQkFBQUcsc0RBQUFBLENBQUFRLGtFQUFBQSxFQUFBO1lBQ0c7U0FDbkI7SUFBQTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9pbnRlcm5hbC9CdXR0b24udHN4PzQ5MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50UHJvcHMsIFJlYWN0Tm9kZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyBDaGV2cm9uRG93bkljb24gfSBmcm9tIFwiLi4vLi4vaWNvbnMvQ2hldnJvbkRvd25cIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvY2xhc3MtbmFtZXNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBCdXR0b25Qcm9wcyBleHRlbmRzIENvbXBvbmVudFByb3BzPFwiYnV0dG9uXCI+IHtcbiAgdmFyaWFudD86IFwiZGVmYXVsdFwiIHwgXCJ0b29sYmFyXCIgfCBcIm91dGxpbmVcIiB8IFwicHJpbWFyeVwiIHwgXCJzZWNvbmRhcnlcIjtcbiAgc2l6ZT86IFwiZGVmYXVsdFwiIHwgXCJsYXJnZVwiO1xuICBkaXNhYmxlYWJsZT86IGJvb2xlYW47XG4gIGljb24/OiBSZWFjdE5vZGU7XG59XG5cbmV4cG9ydCBjb25zdCBDdXN0b21CdXR0b24gPSBmb3J3YXJkUmVmPFxuICBIVE1MQnV0dG9uRWxlbWVudCxcbiAgT21pdDxCdXR0b25Qcm9wcywgXCJpY29uXCI+XG4+KFxuICAoXG4gICAge1xuICAgICAgdmFyaWFudCA9IFwiZGVmYXVsdFwiLFxuICAgICAgc2l6ZSA9IFwiZGVmYXVsdFwiLFxuICAgICAgZGlzYWJsZWFibGUgPSB0cnVlLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICAuLi5wcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgXCJsYi1idXR0b25cIixcbiAgICAgICAgICAhZGlzYWJsZWFibGUgJiYgXCJsYi1idXR0b246bm9uLWRpc2FibGVhYmxlXCIsXG4gICAgICAgICAgY2xhc3NOYW1lXG4gICAgICAgICl9XG4gICAgICAgIGRhdGEtdmFyaWFudD17dmFyaWFudH1cbiAgICAgICAgZGF0YS1zaXplPXtzaXplfVxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L2J1dHRvbj5cbiAgICApO1xuICB9XG4pO1xuXG5leHBvcnQgY29uc3QgQnV0dG9uID0gZm9yd2FyZFJlZjxIVE1MQnV0dG9uRWxlbWVudCwgQnV0dG9uUHJvcHM+KFxuICAoeyBpY29uLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxDdXN0b21CdXR0b24gey4uLnByb3BzfSByZWY9e2ZvcndhcmRlZFJlZn0+XG4gICAgICAgIHtpY29uID8gPHNwYW4gY2xhc3NOYW1lPVwibGItaWNvbi1jb250YWluZXJcIj57aWNvbn08L3NwYW4+IDogbnVsbH1cbiAgICAgICAge2NoaWxkcmVuID8gPHNwYW4gY2xhc3NOYW1lPVwibGItYnV0dG9uLWxhYmVsXCI+e2NoaWxkcmVufTwvc3Bhbj4gOiBudWxsfVxuICAgICAgPC9DdXN0b21CdXR0b24+XG4gICAgKTtcbiAgfVxuKTtcblxuZXhwb3J0IGNvbnN0IFNlbGVjdEJ1dHRvbiA9IGZvcndhcmRSZWY8SFRNTEJ1dHRvbkVsZW1lbnQsIEJ1dHRvblByb3BzPihcbiAgKHsgaWNvbiwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxDdXN0b21CdXR0b25cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwibGItc2VsZWN0LWJ1dHRvblwiLCBjbGFzc05hbWUpfVxuICAgICAgICByZWY9e2ZvcndhcmRlZFJlZn1cbiAgICAgID5cbiAgICAgICAge2ljb24gPyA8c3BhbiBjbGFzc05hbWU9XCJsYi1pY29uLWNvbnRhaW5lclwiPntpY29ufTwvc3Bhbj4gOiBudWxsfVxuICAgICAgICB7Y2hpbGRyZW4gPyA8c3BhbiBjbGFzc05hbWU9XCJsYi1idXR0b24tbGFiZWxcIj57Y2hpbGRyZW59PC9zcGFuPiA6IG51bGx9XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImxiLXNlbGVjdC1idXR0b24tY2hldnJvblwiPlxuICAgICAgICAgIDxDaGV2cm9uRG93bkljb24gLz5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9DdXN0b21CdXR0b24+XG4gICAgKTtcbiAgfVxuKTtcbiJdLCJuYW1lcyI6WyJDdXN0b21CdXR0b24iLCJmb3J3YXJkUmVmIiwidmFyaWFudCIsInNpemUiLCJkaXNhYmxlYWJsZSIsImNsYXNzTmFtZSIsImNoaWxkcmVuIiwicHJvcHMiLCJmb3J3YXJkZWRSZWYiLCJqc3giLCJ0eXBlIiwiY2xhc3NOYW1lcyIsInJlZiIsIkJ1dHRvbiIsImljb24iLCJqc3hzIiwiU2VsZWN0QnV0dG9uIiwiQ2hldnJvbkRvd25JY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Button.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Emoji.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/Emoji.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Emoji: () => (/* binding */ Emoji)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _primitives_internal_Emoji_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../primitives/internal/Emoji.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/internal/Emoji.js\");\n/* harmony import */ var _utils_class_names_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/class-names.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.js\");\n\n\n\n\n\nconst Emoji = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  ({ className, ...props }, forwardedRef) => {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_primitives_internal_Emoji_js__WEBPACK_IMPORTED_MODULE_2__.Emoji, {\n      className: (0,_utils_class_names_js__WEBPACK_IMPORTED_MODULE_3__.classNames)(\"lb-emoji\", className),\n      ...props,\n      ref: forwardedRef\n    });\n  }\n);\n\n\n//# sourceMappingURL=Emoji.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0Vtb2ppLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXdDO0FBQ0w7QUFDbUM7QUFDZDs7QUFFeEQsY0FBYyxpREFBVTtBQUN4QixLQUFLLHFCQUFxQjtBQUMxQiwyQkFBMkIsc0RBQUcsQ0FBQyxnRUFBTztBQUN0QyxpQkFBaUIsaUVBQVU7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0Vtb2ppLmpzPzMyZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVtb2ppIGFzIEVtb2ppJDEgfSBmcm9tICcuLi8uLi9wcmltaXRpdmVzL2ludGVybmFsL0Vtb2ppLmpzJztcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tICcuLi8uLi91dGlscy9jbGFzcy1uYW1lcy5qcyc7XG5cbmNvbnN0IEVtb2ppID0gZm9yd2FyZFJlZihcbiAgKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChFbW9qaSQxLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoXCJsYi1lbW9qaVwiLCBjbGFzc05hbWUpLFxuICAgICAgLi4ucHJvcHMsXG4gICAgICByZWY6IGZvcndhcmRlZFJlZlxuICAgIH0pO1xuICB9XG4pO1xuXG5leHBvcnQgeyBFbW9qaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW1vamkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Emoji.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ICON_HEIGHT: () => (/* binding */ ICON_HEIGHT),\n/* harmony export */   ICON_WIDTH: () => (/* binding */ ICON_WIDTH),\n/* harmony export */   Icon: () => (/* binding */ Icon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _utils_class_names_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/class-names.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.js\");\n\n\n\nconst ICON_WIDTH = 20;\nconst ICON_HEIGHT = 20;\nfunction Icon({ children, className, ...props }) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: ICON_WIDTH,\n    height: ICON_HEIGHT,\n    viewBox: `0 0 ${ICON_WIDTH} ${ICON_HEIGHT}`,\n    fill: \"none\",\n    stroke: \"currentColor\",\n    strokeWidth: 1.5,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    role: \"presentation\",\n    className: (0,_utils_class_names_js__WEBPACK_IMPORTED_MODULE_1__.classNames)(\"lb-icon\", className),\n    ...props,\n    children\n  });\n}\n\n\n//# sourceMappingURL=Icon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0ljb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBd0M7QUFDZ0I7O0FBRXhEO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLHlCQUF5QixzREFBRztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWSxFQUFFLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBVTtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUV5QztBQUN6QyIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL0ljb24uanM/ZjhlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2xhc3MtbmFtZXMuanMnO1xuXG5jb25zdCBJQ09OX1dJRFRIID0gMjA7XG5jb25zdCBJQ09OX0hFSUdIVCA9IDIwO1xuZnVuY3Rpb24gSWNvbih7IGNoaWxkcmVuLCBjbGFzc05hbWUsIC4uLnByb3BzIH0pIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzdmdcIiwge1xuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgd2lkdGg6IElDT05fV0lEVEgsXG4gICAgaGVpZ2h0OiBJQ09OX0hFSUdIVCxcbiAgICB2aWV3Qm94OiBgMCAwICR7SUNPTl9XSURUSH0gJHtJQ09OX0hFSUdIVH1gLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2VXaWR0aDogMS41LFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKFwibGItaWNvblwiLCBjbGFzc05hbWUpLFxuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufVxuXG5leHBvcnQgeyBJQ09OX0hFSUdIVCwgSUNPTl9XSURUSCwgSWNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWNvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShortcutTooltip: () => (/* binding */ ShortcutTooltip),\n/* harmony export */   Tooltip: () => (/* binding */ Tooltip),\n/* harmony export */   TooltipProvider: () => (/* reexport safe */ _radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_1__.TooltipProvider)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @radix-ui/react-tooltip */ \"(ssr)/./node_modules/@liveblocks/react-ui/node_modules/@radix-ui/react-tooltip/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../config.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/config.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../constants.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/constants.js\");\n/* harmony import */ var _utils_class_names_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/class-names.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.js\");\n/* harmony import */ var _utils_is_apple_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/is-apple.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/is-apple.js\");\n/* __next_internal_client_entry_do_not_use__ TooltipProvider,ShortcutTooltip,Tooltip auto */ \n\n\n\n\n\n\n\nconst ALT_KEY = {\n    title: \"Alt\",\n    key: \"⌥\"\n};\nconst COMMAND_KEY = {\n    title: \"Command\",\n    key: \"⌘\"\n};\nconst CONTROL_KEY = {\n    title: \"Ctrl\",\n    key: \"⌃\"\n};\nconst SHIFT_KEY = {\n    title: \"Shift\",\n    key: \"⇧\"\n};\nconst ENTER_KEY = {\n    title: \"Enter\",\n    key: \"⏎\"\n};\nconst SPACE_KEY = {\n    title: \"Space\",\n    key: \"␣\"\n};\nconst ESCAPE_KEY = {\n    title: \"Escape\",\n    key: \"⎋\"\n};\nconst KEYS = {\n    alt: ()=>ALT_KEY,\n    mod: ()=>(0,_utils_is_apple_js__WEBPACK_IMPORTED_MODULE_3__.isApple)() ? COMMAND_KEY : CONTROL_KEY,\n    control: ()=>CONTROL_KEY,\n    ctrl: ()=>CONTROL_KEY,\n    command: ()=>COMMAND_KEY,\n    cmd: ()=>COMMAND_KEY,\n    shift: ()=>SHIFT_KEY,\n    enter: ()=>ENTER_KEY,\n    \" \": ()=>SPACE_KEY,\n    space: ()=>SPACE_KEY,\n    escape: ()=>ESCAPE_KEY,\n    esc: ()=>ESCAPE_KEY\n};\nfunction getShortcutKbdFromKeymap(keymap) {\n    const keys = keymap.split(\"-\");\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: keys.map((key, index)=>{\n            const lowerKey = key.toLowerCase();\n            if (lowerKey in KEYS) {\n                return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ShortcutTooltipKey, {\n                    name: lowerKey\n                }, index);\n            }\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                children: key\n            }, index);\n        })\n    });\n}\nconst Tooltip = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.forwardRef)(({ children, content, multiline, className, ...props }, forwardedRef)=>{\n    const { portalContainer } = (0,_config_js__WEBPACK_IMPORTED_MODULE_4__.useLiveblocksUIConfig)();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_1__.Root, {\n        disableHoverableContent: true,\n        children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_1__.Trigger, {\n                asChild: true,\n                ref: forwardedRef,\n                children\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_1__.Portal, {\n                container: portalContainer,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_radix_ui_react_tooltip__WEBPACK_IMPORTED_MODULE_1__.Content, {\n                    className: (0,_utils_class_names_js__WEBPACK_IMPORTED_MODULE_5__.classNames)(\"lb-root lb-portal lb-tooltip\", multiline && \"lb-tooltip:multiline\", className),\n                    side: \"top\",\n                    align: \"center\",\n                    sideOffset: _constants_js__WEBPACK_IMPORTED_MODULE_6__.FLOATING_ELEMENT_SIDE_OFFSET,\n                    collisionPadding: _constants_js__WEBPACK_IMPORTED_MODULE_6__.FLOATING_ELEMENT_COLLISION_PADDING,\n                    ...props,\n                    children: content\n                })\n            })\n        ]\n    });\n});\nconst ShortcutTooltip = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.forwardRef)(({ children, content, shortcut, ...props }, forwardedRef)=>{\n    const shortcutKbd = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>{\n        return shortcut ? getShortcutKbdFromKeymap(shortcut) : null;\n    }, [\n        shortcut\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Tooltip, {\n        content: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                content,\n                shortcutKbd && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"kbd\", {\n                    className: \"lb-tooltip-shortcut\",\n                    children: shortcutKbd\n                })\n            ]\n        }),\n        ...props,\n        ref: forwardedRef,\n        children\n    });\n});\nfunction ShortcutTooltipKey({ name, ...props }) {\n    const { title, key } = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>KEYS[name]?.(), [\n        name\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"abbr\", {\n        title,\n        ...props,\n        children: key\n    });\n}\n //# sourceMappingURL=Tooltip.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb21wb25lbnRzL2ludGVybmFsL1Rvb2x0aXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBY0EsTUFBQUEsVUFBQTtJQUFBQyxPQUFBO0lBQUFDLEtBQUE7QUFBQTtBQUNBLE1BQUFDLGNBQUE7SUFBQUYsT0FBQTtJQUFBQyxLQUFBO0FBQUE7QUFDQSxNQUFBRSxjQUFBO0lBQUFILE9BQUE7SUFBQUMsS0FBQTtBQUFBO0FBQ0EsTUFBQUcsWUFBQTtJQUFBSixPQUFBO0lBQUFDLEtBQUE7QUFBQTtBQUNBLE1BQUFJLFlBQUE7SUFBQUwsT0FBQTtJQUFBQyxLQUFBO0FBQUE7QUFDQSxNQUFBSyxZQUFBO0lBQUFOLE9BQUE7SUFBQUMsS0FBQTtBQUFBO0FBQ0EsTUFBQU0sYUFBQTtJQUFBUCxPQUFBO0lBQUFDLEtBQUE7QUFBQTtBQUVBLE1BQUFPLE9BQUE7SUFBYUMsS0FBQSxJQUFBVjtJQUNBVyxLQUFBLElBQUFDLDJEQUFBQSxLQUFBVCxjQUFBQztJQUMyQlMsU0FBQSxJQUFBVDtJQUN2QlUsTUFBQSxJQUFBVjtJQUNIVyxTQUFBLElBQUFaO0lBQ0dhLEtBQUEsSUFBQWI7SUFDSmMsT0FBQSxJQUFBWjtJQUNFYSxPQUFBLElBQUFaO0lBQ0EsU0FBQUM7SUFDRlksT0FBQSxJQUFBWjtJQUNFYSxRQUFBLElBQUFaO0lBQ0NhLEtBQUEsSUFBQWI7QUFFaEI7QUFpQkEsU0FBQWMseUJBQUFDLE1BQUE7SUFDRSxNQUFBQyxPQUFBRCxPQUFBRSxLQUFBO0lBRUEsdUJBQUFDLHNEQUFBQSxDQUFBQyx1REFBQUEsRUFBQTtRQUNFQyxVQUFBSixLQUFBSyxHQUFBLEVBQUEzQixLQUFBNEI7WUFFSSxNQUFBQyxXQUFBN0IsSUFBQThCLFdBQUE7WUFFQSxJQUFBRCxZQUFBdEIsTUFBQTtnQkFDRSx1QkFBQWlCLHNEQUFBQSxDQUFBTyxvQkFBQTtvQkFDR0MsTUFBQUg7Z0JBRU8sR0FBQUQ7WUFDUjtZQUlKLHVCQUFBSixzREFBQUEsQ0FBQTtnQkFBUUUsVUFBQTFCO1lBQWtCLEdBQUE0QjtRQUFJO0lBQy9CO0FBR1A7QUFFTyxNQUFBSyx3QkFBQUMsaURBQUFBLENBQWdCLEdBQUFSLFFBQUEsRUFBQVMsT0FBQSxFQUFBQyxTQUFBLEVBQUFDLFNBQUEsS0FBQUMsT0FBQSxFQUFBQztJQUVuQixRQUFBQyxlQUFBLEtBQUFDLGlFQUFBQTtJQUVBLHVCQUFBQyx1REFBQUEsQ0FBQUMseURBQUE7UUFDR0UseUJBQUE7UUFBNkNuQixVQUFBO1lBQzVDLGdCQUFBRixzREFBQUEsQ0FBQW1CLDREQUFBO2dCQUFDSSxTQUFBO2dCQUFnQ0MsS0FBQVQ7Z0JBQU1iO1lBQ3BDO1lBQ0gsZ0JBQUFGLHNEQUFBQSxDQUFBbUIsMkRBQUE7Z0JBQ0NPLFdBQUFWO2dCQUFtQ2QsVUFBQSxnQkFBQUYsc0RBQUFBLENBQUFtQiw0REFBQTtvQkFDakNOLFdBQUFlLGlFQUFBQSxDQUNZLGdDQUNUaEIsYUFBQSx3QkFDYUM7b0JBRWZnQixNQUFBO29CQUNLQyxPQUFBO29CQUNDQyxZQUFBQyx1RUFBQUE7b0JBQ01DLGtCQUFBQyw2RUFBQUE7b0JBQ00sR0FBQXBCLEtBQUE7b0JBQ2RaLFVBQUFTO2dCQUVIO1lBQ0g7U0FDRjtJQUFBO0FBQ0Y7QUFLTyxNQUFBd0IsZ0NBQUF6QixpREFBQUEsQ0FBQSxHQUFBUixRQUFBLEVBQUFTLE9BQUEsRUFBQXlCLFFBQUEsS0FBQXRCLE9BQUEsRUFBQUM7SUFJWCxNQUFBc0IsY0FBQUMsOENBQUFBLENBQUE7UUFDRSxPQUFBRixXQUFBeEMseUJBQUF3QyxZQUFBO0lBQXVEO1FBQUFBO0tBQUE7SUFHekQsdUJBQUFwQyxzREFBQUEsQ0FBQVMsU0FBQTtRQUNHRSxTQUFBLGdCQUFBTyx1REFBQUEsQ0FBQWpCLHVEQUFBQSxFQUFBO1lBRUdDLFVBQUE7Z0JBQ0dTO2dCQUFBMEIsZUFBQSxnQkFBQXJDLHNEQUFBQSxDQUFBO29CQUVFYSxXQUFBO29CQUFjWCxVQUFBbUM7Z0JBQXVCO2FBQVk7UUFBQTtRQUV0RCxHQUFBdkIsS0FBQTtRQUVFVSxLQUFBVDtRQUNDYjtJQUVKO0FBR1A7QUFFQSxTQUFBSyxtQkFBQSxFQUFBQyxJQUFBLEtBQUFNLE9BQUE7SUFDRSxRQUFBdkMsS0FBQSxFQUFBQyxHQUFBLEtBQUE4RCw4Q0FBQUEsQ0FBQSxJQUFBdkQsSUFBQSxDQUFBeUIsS0FBQTtRQUFBQTtLQUFBO0lBRUEsdUJBQUFSLHNEQUFBQSxDQUFBO1FBQ0d6QjtRQUFLLEdBQUF1QyxLQUFBO1FBQWtCWixVQUFBMUI7SUFDckI7QUFHUCIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvaW50ZXJuYWwvVG9vbHRpcC50c3g/ZmMzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0ICogYXMgVG9vbHRpcFByaW1pdGl2ZSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXRvb2x0aXBcIjtcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50UHJvcHMsIFJlYWN0Tm9kZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyB1c2VMaXZlYmxvY2tzVUlDb25maWcgfSBmcm9tIFwiLi4vLi4vY29uZmlnXCI7XG5pbXBvcnQge1xuICBGTE9BVElOR19FTEVNRU5UX0NPTExJU0lPTl9QQURESU5HLFxuICBGTE9BVElOR19FTEVNRU5UX1NJREVfT0ZGU0VULFxufSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2NsYXNzLW5hbWVzXCI7XG5pbXBvcnQgeyBpc0FwcGxlIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2lzLWFwcGxlXCI7XG5cbmNvbnN0IEFMVF9LRVkgPSB7IHRpdGxlOiBcIkFsdFwiLCBrZXk6IFwi4oylXCIgfTtcbmNvbnN0IENPTU1BTkRfS0VZID0geyB0aXRsZTogXCJDb21tYW5kXCIsIGtleTogXCLijJhcIiB9O1xuY29uc3QgQ09OVFJPTF9LRVkgPSB7IHRpdGxlOiBcIkN0cmxcIiwga2V5OiBcIuKMg1wiIH07XG5jb25zdCBTSElGVF9LRVkgPSB7IHRpdGxlOiBcIlNoaWZ0XCIsIGtleTogXCLih6dcIiB9O1xuY29uc3QgRU5URVJfS0VZID0geyB0aXRsZTogXCJFbnRlclwiLCBrZXk6IFwi4o+OXCIgfTtcbmNvbnN0IFNQQUNFX0tFWSA9IHsgdGl0bGU6IFwiU3BhY2VcIiwga2V5OiBcIuKQo1wiIH07XG5jb25zdCBFU0NBUEVfS0VZID0geyB0aXRsZTogXCJFc2NhcGVcIiwga2V5OiBcIuKOi1wiIH07XG5cbmNvbnN0IEtFWVMgPSB7XG4gIGFsdDogKCkgPT4gQUxUX0tFWSxcbiAgbW9kOiAoKSA9PiAoaXNBcHBsZSgpID8gQ09NTUFORF9LRVkgOiBDT05UUk9MX0tFWSksXG4gIGNvbnRyb2w6ICgpID0+IENPTlRST0xfS0VZLFxuICBjdHJsOiAoKSA9PiBDT05UUk9MX0tFWSxcbiAgY29tbWFuZDogKCkgPT4gQ09NTUFORF9LRVksXG4gIGNtZDogKCkgPT4gQ09NTUFORF9LRVksXG4gIHNoaWZ0OiAoKSA9PiBTSElGVF9LRVksXG4gIGVudGVyOiAoKSA9PiBFTlRFUl9LRVksXG4gIFwiIFwiOiAoKSA9PiBTUEFDRV9LRVksXG4gIHNwYWNlOiAoKSA9PiBTUEFDRV9LRVksXG4gIGVzY2FwZTogKCkgPT4gRVNDQVBFX0tFWSxcbiAgZXNjOiAoKSA9PiBFU0NBUEVfS0VZLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGludGVyZmFjZSBUb29sdGlwUHJvcHNcbiAgZXh0ZW5kcyBQaWNrPFRvb2x0aXBQcmltaXRpdmUuVG9vbHRpcFRyaWdnZXJQcm9wcywgXCJjaGlsZHJlblwiPixcbiAgICBPbWl0PFRvb2x0aXBQcmltaXRpdmUuVG9vbHRpcENvbnRlbnRQcm9wcywgXCJjb250ZW50XCI+IHtcbiAgY29udGVudDogUmVhY3ROb2RlO1xuICBtdWx0aWxpbmU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNob3J0Y3V0VG9vbHRpcFByb3BzIGV4dGVuZHMgVG9vbHRpcFByb3BzIHtcbiAgc2hvcnRjdXQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hvcnRjdXRUb29sdGlwS2V5UHJvcHMgZXh0ZW5kcyBDb21wb25lbnRQcm9wczxcImFiYnJcIj4ge1xuICBuYW1lOiBrZXlvZiB0eXBlb2YgS0VZUztcbn1cblxuZnVuY3Rpb24gZ2V0U2hvcnRjdXRLYmRGcm9tS2V5bWFwKGtleW1hcDogc3RyaW5nKSB7XG4gIGNvbnN0IGtleXMgPSBrZXltYXAuc3BsaXQoXCItXCIpO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIHtrZXlzLm1hcCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsb3dlcktleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChsb3dlcktleSBpbiBLRVlTKSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxTaG9ydGN1dFRvb2x0aXBLZXlcbiAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgbmFtZT17bG93ZXJLZXkgYXMga2V5b2YgdHlwZW9mIEtFWVN9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPHNwYW4ga2V5PXtpbmRleH0+e2tleX08L3NwYW4+O1xuICAgICAgfSl9XG4gICAgPC8+XG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBUb29sdGlwID0gZm9yd2FyZFJlZjxIVE1MQnV0dG9uRWxlbWVudCwgVG9vbHRpcFByb3BzPihcbiAgKHsgY2hpbGRyZW4sIGNvbnRlbnQsIG11bHRpbGluZSwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IHBvcnRhbENvbnRhaW5lciB9ID0gdXNlTGl2ZWJsb2Nrc1VJQ29uZmlnKCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFRvb2x0aXBQcmltaXRpdmUuUm9vdCBkaXNhYmxlSG92ZXJhYmxlQ29udGVudD5cbiAgICAgICAgPFRvb2x0aXBQcmltaXRpdmUuVHJpZ2dlciBhc0NoaWxkIHJlZj17Zm9yd2FyZGVkUmVmfT5cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvVG9vbHRpcFByaW1pdGl2ZS5UcmlnZ2VyPlxuICAgICAgICA8VG9vbHRpcFByaW1pdGl2ZS5Qb3J0YWwgY29udGFpbmVyPXtwb3J0YWxDb250YWluZXJ9PlxuICAgICAgICAgIDxUb29sdGlwUHJpbWl0aXZlLkNvbnRlbnRcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgICAgICAgXCJsYi1yb290IGxiLXBvcnRhbCBsYi10b29sdGlwXCIsXG4gICAgICAgICAgICAgIG11bHRpbGluZSAmJiBcImxiLXRvb2x0aXA6bXVsdGlsaW5lXCIsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZVxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHNpZGU9XCJ0b3BcIlxuICAgICAgICAgICAgYWxpZ249XCJjZW50ZXJcIlxuICAgICAgICAgICAgc2lkZU9mZnNldD17RkxPQVRJTkdfRUxFTUVOVF9TSURFX09GRlNFVH1cbiAgICAgICAgICAgIGNvbGxpc2lvblBhZGRpbmc9e0ZMT0FUSU5HX0VMRU1FTlRfQ09MTElTSU9OX1BBRERJTkd9XG4gICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgPC9Ub29sdGlwUHJpbWl0aXZlLkNvbnRlbnQ+XG4gICAgICAgIDwvVG9vbHRpcFByaW1pdGl2ZS5Qb3J0YWw+XG4gICAgICA8L1Rvb2x0aXBQcmltaXRpdmUuUm9vdD5cbiAgICApO1xuICB9XG4pO1xuXG5leHBvcnQgY29uc3QgU2hvcnRjdXRUb29sdGlwID0gZm9yd2FyZFJlZjxcbiAgSFRNTEJ1dHRvbkVsZW1lbnQsXG4gIFNob3J0Y3V0VG9vbHRpcFByb3BzXG4+KCh7IGNoaWxkcmVuLCBjb250ZW50LCBzaG9ydGN1dCwgLi4ucHJvcHMgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHNob3J0Y3V0S2JkID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHNob3J0Y3V0ID8gZ2V0U2hvcnRjdXRLYmRGcm9tS2V5bWFwKHNob3J0Y3V0KSA6IG51bGw7XG4gIH0sIFtzaG9ydGN1dF0pO1xuXG4gIHJldHVybiAoXG4gICAgPFRvb2x0aXBcbiAgICAgIGNvbnRlbnQ9e1xuICAgICAgICA8PlxuICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgIHtzaG9ydGN1dEtiZCAmJiAoXG4gICAgICAgICAgICA8a2JkIGNsYXNzTmFtZT1cImxiLXRvb2x0aXAtc2hvcnRjdXRcIj57c2hvcnRjdXRLYmR9PC9rYmQ+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC8+XG4gICAgICB9XG4gICAgICB7Li4ucHJvcHN9XG4gICAgICByZWY9e2ZvcndhcmRlZFJlZn1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9Ub29sdGlwPlxuICApO1xufSk7XG5cbmZ1bmN0aW9uIFNob3J0Y3V0VG9vbHRpcEtleSh7IG5hbWUsIC4uLnByb3BzIH06IFNob3J0Y3V0VG9vbHRpcEtleVByb3BzKSB7XG4gIGNvbnN0IHsgdGl0bGUsIGtleSB9ID0gdXNlTWVtbygoKSA9PiBLRVlTW25hbWVdPy4oKSwgW25hbWVdKTtcblxuICByZXR1cm4gKFxuICAgIDxhYmJyIHRpdGxlPXt0aXRsZX0gey4uLnByb3BzfT5cbiAgICAgIHtrZXl9XG4gICAgPC9hYmJyPlxuICApO1xufVxuXG5leHBvcnQgeyBUb29sdGlwUHJvdmlkZXIgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXRvb2x0aXBcIjtcbiJdLCJuYW1lcyI6WyJBTFRfS0VZIiwidGl0bGUiLCJrZXkiLCJDT01NQU5EX0tFWSIsIkNPTlRST0xfS0VZIiwiU0hJRlRfS0VZIiwiRU5URVJfS0VZIiwiU1BBQ0VfS0VZIiwiRVNDQVBFX0tFWSIsIktFWVMiLCJhbHQiLCJtb2QiLCJpc0FwcGxlIiwiY29udHJvbCIsImN0cmwiLCJjb21tYW5kIiwiY21kIiwic2hpZnQiLCJlbnRlciIsInNwYWNlIiwiZXNjYXBlIiwiZXNjIiwiZ2V0U2hvcnRjdXRLYmRGcm9tS2V5bWFwIiwia2V5bWFwIiwia2V5cyIsInNwbGl0IiwianN4IiwiRnJhZ21lbnQiLCJjaGlsZHJlbiIsIm1hcCIsImluZGV4IiwibG93ZXJLZXkiLCJ0b0xvd2VyQ2FzZSIsIlNob3J0Y3V0VG9vbHRpcEtleSIsIm5hbWUiLCJUb29sdGlwIiwiZm9yd2FyZFJlZiIsImNvbnRlbnQiLCJtdWx0aWxpbmUiLCJjbGFzc05hbWUiLCJwcm9wcyIsImZvcndhcmRlZFJlZiIsInBvcnRhbENvbnRhaW5lciIsInVzZUxpdmVibG9ja3NVSUNvbmZpZyIsImpzeHMiLCJUb29sdGlwUHJpbWl0aXZlIiwiUm9vdCIsImRpc2FibGVIb3ZlcmFibGVDb250ZW50IiwiVHJpZ2dlciIsImFzQ2hpbGQiLCJyZWYiLCJQb3J0YWwiLCJjb250YWluZXIiLCJDb250ZW50IiwiY2xhc3NOYW1lcyIsInNpZGUiLCJhbGlnbiIsInNpZGVPZmZzZXQiLCJGTE9BVElOR19FTEVNRU5UX1NJREVfT0ZGU0VUIiwiY29sbGlzaW9uUGFkZGluZyIsIkZMT0FUSU5HX0VMRU1FTlRfQ09MTElTSU9OX1BBRERJTkciLCJTaG9ydGN1dFRvb2x0aXAiLCJzaG9ydGN1dCIsInNob3J0Y3V0S2JkIiwidXNlTWVtbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Tooltip.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/config.js":
/*!**********************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/config.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiveblocksUIConfig: () => (/* binding */ LiveblocksUIConfig),\n/* harmony export */   useLiveblocksUIConfig: () => (/* binding */ useLiveblocksUIConfig)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components.js\");\n/* harmony import */ var _overrides_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./overrides.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.js\");\n/* __next_internal_client_entry_do_not_use__ LiveblocksUIConfig,useLiveblocksUIConfig auto */ \n\n\n\nconst LiveblocksUIConfigContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\nfunction useLiveblocksUIConfig() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LiveblocksUIConfigContext);\n}\nfunction LiveblocksUIConfig({ overrides, components, portalContainer, preventUnsavedComposerChanges = true, children }) {\n    const liveblocksUIConfig = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            portalContainer,\n            preventUnsavedComposerChanges\n        }), [\n        portalContainer,\n        preventUnsavedComposerChanges\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LiveblocksUIConfigContext.Provider, {\n        value: liveblocksUIConfig,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_overrides_js__WEBPACK_IMPORTED_MODULE_2__.OverridesProvider, {\n            overrides,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_js__WEBPACK_IMPORTED_MODULE_3__.ComponentsProvider, {\n                components,\n                children\n            })\n        })\n    });\n}\n //# sourceMappingURL=config.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQTRDQSxNQUFBQSwwQ0FBQUMsb0RBQUFBLENBQUE7QUFFTyxTQUFBQztJQUNMLE9BQUFDLGlEQUFBQSxDQUFBSDtBQUNGO0FBVU8sU0FBQUksbUJBQUEsRUFBNEJDLFNBQUEsRUFDakNDLFVBQUEsRUFDQUMsZUFBQSxFQUNBQyxnQ0FBQSxNQUNnQ0MsUUFBQSxFQUVsQztJQUNFLE1BQUFDLHFCQUFBQyw4Q0FBQUEsQ0FBMkI7WUFBQUo7WUFBQUM7UUFBQSxJQUMrQjtRQUFBRDtRQUFBQztLQUFBO0lBSTFELHVCQUFBSSxzREFBQUEsQ0FBQVosMEJBQUFhLFFBQUE7UUFDR0MsT0FBQUo7UUFBMENELFVBQUEsZ0JBQUFHLHNEQUFBQSxDQUFBRyw0REFBQUEsRUFBQTtZQUN4Q1Y7WUFBa0JJLFVBQUEsZ0JBQUFHLHNEQUFBQSxDQUFBSSw4REFBQUEsRUFBQTtnQkFDaEJWO2dCQUFtQkc7WUFDakI7UUFDSDtJQUNGO0FBR04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4uL3NyYy9jb25maWcudHN4PzlmYzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB0eXBlIHsgUHJvcHNXaXRoQ2hpbGRyZW4gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgdHlwZSBDb21wb25lbnRzLCBDb21wb25lbnRzUHJvdmlkZXIgfSBmcm9tIFwiLi9jb21wb25lbnRzXCI7XG5pbXBvcnQgdHlwZSB7IE92ZXJyaWRlcyB9IGZyb20gXCIuL292ZXJyaWRlc1wiO1xuaW1wb3J0IHsgT3ZlcnJpZGVzUHJvdmlkZXIgfSBmcm9tIFwiLi9vdmVycmlkZXNcIjtcblxudHlwZSBMaXZlYmxvY2tzVUlDb25maWdQcm9wcyA9IFByb3BzV2l0aENoaWxkcmVuPHtcbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBjb21wb25lbnRzJyBzdHJpbmdzLlxuICAgKi9cbiAgb3ZlcnJpZGVzPzogUGFydGlhbDxPdmVycmlkZXM+O1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgY29tcG9uZW50cycgY29tcG9uZW50cy5cbiAgICovXG4gIGNvbXBvbmVudHM/OiBQYXJ0aWFsPENvbXBvbmVudHM+O1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGFpbmVyIHRvIHJlbmRlciB0aGUgcG9ydGFsIGludG8uXG4gICAqL1xuICBwb3J0YWxDb250YWluZXI/OiBIVE1MRWxlbWVudDtcblxuICAvKipcbiAgICogV2hlbiBgcHJldmVudFVuc2F2ZWRDaGFuZ2VzYCBpcyBzZXQgb24geW91ciBMaXZlYmxvY2tzIGNsaWVudCAob3Igc2V0IG9uXG4gICAqIDxMaXZlYmxvY2tzUHJvdmlkZXI+KSwgdGhlbiBjbG9zaW5nIGEgYnJvd3NlciB0YWIgd2lsbCBiZSBwcmV2ZW50ZWQgd2hlblxuICAgKiB0aGVyZSBhcmUgdW5zYXZlZCBjaGFuZ2VzLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGF0IHdpbGwgaW5jbHVkZSBkcmFmdCB0ZXh0cyBvciBhdHRhY2htZW50cyB0aGF0IGFyZSAoYmVpbmcpXG4gICAqIHVwbG9hZGVkIHZpYSBjb21tZW50cy90aHJlYWRzIGNvbXBvc2VycywgYnV0IG5vdCBzdWJtaXR0ZWQgeWV0LlxuICAgKlxuICAgKiBJZiB5b3Ugd2FudCB0byBwcmV2ZW50IHVuc2F2ZWQgY2hhbmdlcyB3aXRoIExpdmVibG9ja3MsIGJ1dCBub3QgZm9yXG4gICAqIGNvbXBvc2VycywgeW91IGNhbiBvcHQtb3V0IGJ5IHNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYC5cbiAgICovXG4gIHByZXZlbnRVbnNhdmVkQ29tcG9zZXJDaGFuZ2VzPzogYm9vbGVhbjtcbn0+O1xuXG5pbnRlcmZhY2UgTGl2ZWJsb2Nrc1VJQ29uZmlnQ29udGV4dCB7XG4gIHBvcnRhbENvbnRhaW5lcj86IEhUTUxFbGVtZW50O1xuICBwcmV2ZW50VW5zYXZlZENvbXBvc2VyQ2hhbmdlcz86IGJvb2xlYW47XG59XG5cbmNvbnN0IExpdmVibG9ja3NVSUNvbmZpZ0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PExpdmVibG9ja3NVSUNvbmZpZ0NvbnRleHQ+KHt9KTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpdmVibG9ja3NVSUNvbmZpZygpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoTGl2ZWJsb2Nrc1VJQ29uZmlnQ29udGV4dCk7XG59XG5cbi8qKlxuICogU2V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgYWxsIGNvbXBvbmVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIDxMaXZlYmxvY2tzVUlDb25maWcgb3ZlcnJpZGVzPXt7IGxvY2FsZTogXCJmclwiLCBVU0VSX1VOS05PV046IFwiQW5vbnltZVwiLCAuLi4gfX0+XG4gKiAgIDxBcHAgLz5cbiAqIDwvTGl2ZWJsb2Nrc1VJQ29uZmlnPlxuICovXG5leHBvcnQgZnVuY3Rpb24gTGl2ZWJsb2Nrc1VJQ29uZmlnKHtcbiAgb3ZlcnJpZGVzLFxuICBjb21wb25lbnRzLFxuICBwb3J0YWxDb250YWluZXIsXG4gIHByZXZlbnRVbnNhdmVkQ29tcG9zZXJDaGFuZ2VzID0gdHJ1ZSxcbiAgY2hpbGRyZW4sXG59OiBMaXZlYmxvY2tzVUlDb25maWdQcm9wcykge1xuICBjb25zdCBsaXZlYmxvY2tzVUlDb25maWcgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7IHBvcnRhbENvbnRhaW5lciwgcHJldmVudFVuc2F2ZWRDb21wb3NlckNoYW5nZXMgfSksXG4gICAgW3BvcnRhbENvbnRhaW5lciwgcHJldmVudFVuc2F2ZWRDb21wb3NlckNoYW5nZXNdXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8TGl2ZWJsb2Nrc1VJQ29uZmlnQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bGl2ZWJsb2Nrc1VJQ29uZmlnfT5cbiAgICAgIDxPdmVycmlkZXNQcm92aWRlciBvdmVycmlkZXM9e292ZXJyaWRlc30+XG4gICAgICAgIDxDb21wb25lbnRzUHJvdmlkZXIgY29tcG9uZW50cz17Y29tcG9uZW50c30+XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L0NvbXBvbmVudHNQcm92aWRlcj5cbiAgICAgIDwvT3ZlcnJpZGVzUHJvdmlkZXI+XG4gICAgPC9MaXZlYmxvY2tzVUlDb25maWdDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuIl0sIm5hbWVzIjpbIkxpdmVibG9ja3NVSUNvbmZpZ0NvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlTGl2ZWJsb2Nrc1VJQ29uZmlnIiwidXNlQ29udGV4dCIsIkxpdmVibG9ja3NVSUNvbmZpZyIsIm92ZXJyaWRlcyIsImNvbXBvbmVudHMiLCJwb3J0YWxDb250YWluZXIiLCJwcmV2ZW50VW5zYXZlZENvbXBvc2VyQ2hhbmdlcyIsImNoaWxkcmVuIiwibGl2ZWJsb2Nrc1VJQ29uZmlnIiwidXNlTWVtbyIsImpzeCIsIlByb3ZpZGVyIiwidmFsdWUiLCJPdmVycmlkZXNQcm92aWRlciIsIkNvbXBvbmVudHNQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EMOJI_FONT_FAMILY: () => (/* binding */ EMOJI_FONT_FAMILY),\n/* harmony export */   FLOATING_ELEMENT_COLLISION_PADDING: () => (/* binding */ FLOATING_ELEMENT_COLLISION_PADDING),\n/* harmony export */   FLOATING_ELEMENT_SIDE_OFFSET: () => (/* binding */ FLOATING_ELEMENT_SIDE_OFFSET)\n/* harmony export */ });\nconst FLOATING_ELEMENT_SIDE_OFFSET = 6;\nconst FLOATING_ELEMENT_COLLISION_PADDING = 10;\nconst EMOJI_FONT_FAMILY = \"'Apple Color Emoji', 'Noto Color Emoji', 'Twemoji Mozilla', 'Android Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', EmojiSymbols, sans-serif\";\n\n\n//# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUUrRjtBQUMvRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9jb25zdGFudHMuanM/MTZhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBGTE9BVElOR19FTEVNRU5UX1NJREVfT0ZGU0VUID0gNjtcbmNvbnN0IEZMT0FUSU5HX0VMRU1FTlRfQ09MTElTSU9OX1BBRERJTkcgPSAxMDtcbmNvbnN0IEVNT0pJX0ZPTlRfRkFNSUxZID0gXCInQXBwbGUgQ29sb3IgRW1vamknLCAnTm90byBDb2xvciBFbW9qaScsICdUd2Vtb2ppIE1vemlsbGEnLCAnQW5kcm9pZCBFbW9qaScsICdTZWdvZSBVSSBFbW9qaScsICdTZWdvZSBVSSBTeW1ib2wnLCBFbW9qaVN5bWJvbHMsIHNhbnMtc2VyaWZcIjtcblxuZXhwb3J0IHsgRU1PSklfRk9OVF9GQU1JTFksIEZMT0FUSU5HX0VMRU1FTlRfQ09MTElTSU9OX1BBRERJTkcsIEZMT0FUSU5HX0VMRU1FTlRfU0lERV9PRkZTRVQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Blockquote.js":
/*!********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Blockquote.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockquoteIcon: () => (/* binding */ BlockquoteIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction BlockquoteIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M16 14.25H9M16 10H9m7-4.25H4M4 10l2 2.13-2 2.12\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=Blockquote.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9CbG9ja3F1b3RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3QztBQUNjOztBQUV0RDtBQUNBLHlCQUF5QixzREFBRyxDQUFDLDhEQUFJO0FBQ2pDO0FBQ0EsOEJBQThCLHNEQUFHO0FBQ2pDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvaWNvbnMvQmxvY2txdW90ZS5qcz9hMGRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IEljb24gfSBmcm9tICcuLi9jb21wb25lbnRzL2ludGVybmFsL0ljb24uanMnO1xuXG5mdW5jdGlvbiBCbG9ja3F1b3RlSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE2IDE0LjI1SDlNMTYgMTBIOW03LTQuMjVINE00IDEwbDIgMi4xMy0yIDIuMTJcIlxuICAgIH0pXG4gIH0pO1xufVxuXG5leHBvcnQgeyBCbG9ja3F1b3RlSWNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmxvY2txdW90ZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Blockquote.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Bold.js":
/*!**************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Bold.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BoldIcon: () => (/* binding */ BoldIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction BoldIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M5.5 10h6.63m0 5.75H5.5V4.25h5.63M11.125 10a2.875 2.875 0 0 0 0-5.75m1 11.5a2.875 2.875 0 0 0 0-5.75\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=Bold.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9Cb2xkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3QztBQUNjOztBQUV0RDtBQUNBLHlCQUF5QixzREFBRyxDQUFDLDhEQUFJO0FBQ2pDO0FBQ0EsOEJBQThCLHNEQUFHO0FBQ2pDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvaWNvbnMvQm9sZC5qcz8zODIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IEljb24gfSBmcm9tICcuLi9jb21wb25lbnRzL2ludGVybmFsL0ljb24uanMnO1xuXG5mdW5jdGlvbiBCb2xkSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTUuNSAxMGg2LjYzbTAgNS43NUg1LjVWNC4yNWg1LjYzTTExLjEyNSAxMGEyLjg3NSAyLjg3NSAwIDAgMCAwLTUuNzVtMSAxMS41YTIuODc1IDIuODc1IDAgMCAwIDAtNS43NVwiXG4gICAgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IEJvbGRJY29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb2xkLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Bold.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Check.js":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Check.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CheckIcon: () => (/* binding */ CheckIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction CheckIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M16 6L8 14L4 10\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=Check.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9DaGVjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0M7QUFDYzs7QUFFdEQ7QUFDQSx5QkFBeUIsc0RBQUcsQ0FBQyw4REFBSTtBQUNqQztBQUNBLDhCQUE4QixzREFBRztBQUNqQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL0NoZWNrLmpzPzBlZjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5qcyc7XG5cbmZ1bmN0aW9uIENoZWNrSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE2IDZMOCAxNEw0IDEwXCJcbiAgICB9KVxuICB9KTtcbn1cblxuZXhwb3J0IHsgQ2hlY2tJY29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaGVjay5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Check.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/ChevronDown.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/ChevronDown.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChevronDownIcon: () => (/* binding */ ChevronDownIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction ChevronDownIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M14.5 8.5 10 13 5.5 8.5\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=ChevronDown.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9DaGV2cm9uRG93bi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0M7QUFDYzs7QUFFdEQ7QUFDQSx5QkFBeUIsc0RBQUcsQ0FBQyw4REFBSTtBQUNqQztBQUNBLDhCQUE4QixzREFBRztBQUNqQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL0NoZXZyb25Eb3duLmpzPzZhYjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5qcyc7XG5cbmZ1bmN0aW9uIENoZXZyb25Eb3duSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE0LjUgOC41IDEwIDEzIDUuNSA4LjVcIlxuICAgIH0pXG4gIH0pO1xufVxuXG5leHBvcnQgeyBDaGV2cm9uRG93bkljb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoZXZyb25Eb3duLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/ChevronDown.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Code.js":
/*!**************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Code.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeIcon: () => (/* binding */ CodeIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction CodeIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"m7.5 6-4 4 4 4m5-8 4 4-4 4\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=Code.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9Db2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3QztBQUNjOztBQUV0RDtBQUNBLHlCQUF5QixzREFBRyxDQUFDLDhEQUFJO0FBQ2pDO0FBQ0EsOEJBQThCLHNEQUFHO0FBQ2pDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvaWNvbnMvQ29kZS5qcz8xMmExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IEljb24gfSBmcm9tICcuLi9jb21wb25lbnRzL2ludGVybmFsL0ljb24uanMnO1xuXG5mdW5jdGlvbiBDb2RlSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwibTcuNSA2LTQgNCA0IDRtNS04IDQgNC00IDRcIlxuICAgIH0pXG4gIH0pO1xufVxuXG5leHBvcnQgeyBDb2RlSWNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29kZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Code.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Comment.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Comment.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommentIcon: () => (/* binding */ CommentIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction CommentIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M10 16a6 6 0 1 0-5.552-3.72c.094.229.12.482.052.719l-.753 2.636a.5.5 0 0 0 .618.618l2.636-.753a1.1 1.1 0 0 1 .719.052A6.002 6.002 0 0 0 10 16Z\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=Comment.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9Db21tZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3QztBQUNjOztBQUV0RDtBQUNBLHlCQUF5QixzREFBRyxDQUFDLDhEQUFJO0FBQ2pDO0FBQ0EsOEJBQThCLHNEQUFHO0FBQ2pDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvaWNvbnMvQ29tbWVudC5qcz9mOGNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IEljb24gfSBmcm9tICcuLi9jb21wb25lbnRzL2ludGVybmFsL0ljb24uanMnO1xuXG5mdW5jdGlvbiBDb21tZW50SWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTEwIDE2YTYgNiAwIDEgMC01LjU1Mi0zLjcyYy4wOTQuMjI5LjEyLjQ4Mi4wNTIuNzE5bC0uNzUzIDIuNjM2YS41LjUgMCAwIDAgLjYxOC42MThsMi42MzYtLjc1M2ExLjEgMS4xIDAgMCAxIC43MTkuMDUyQTYuMDAyIDYuMDAyIDAgMCAwIDEwIDE2WlwiXG4gICAgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IENvbW1lbnRJY29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21tZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Comment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/H1.js":
/*!************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/H1.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   H1Icon: () => (/* binding */ H1Icon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction H1Icon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M4 10h5m-5 4V6m5 8V6m3.5 1.5 2-1.5v8m0 0H13m1.5 0H16\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=H1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9IMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0M7QUFDYzs7QUFFdEQ7QUFDQSx5QkFBeUIsc0RBQUcsQ0FBQyw4REFBSTtBQUNqQztBQUNBLDhCQUE4QixzREFBRztBQUNqQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL0gxLmpzPzU3ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5qcyc7XG5cbmZ1bmN0aW9uIEgxSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTQgMTBoNW0tNSA0VjZtNSA4VjZtMy41IDEuNSAyLTEuNXY4bTAgMEgxM20xLjUgMEgxNlwiXG4gICAgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IEgxSWNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SDEuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/H1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/H2.js":
/*!************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/H2.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   H2Icon: () => (/* binding */ H2Icon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction H2Icon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M4 10h5m-5 4V6m5 8V6m3 1c.37-.6 1.21-1 2-1 1 0 2 .5 2 2 0 1.788-1.5 3-4 6h4\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=H2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9IMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0M7QUFDYzs7QUFFdEQ7QUFDQSx5QkFBeUIsc0RBQUcsQ0FBQyw4REFBSTtBQUNqQztBQUNBLDhCQUE4QixzREFBRztBQUNqQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL0gyLmpzP2JiZjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5qcyc7XG5cbmZ1bmN0aW9uIEgySWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTQgMTBoNW0tNSA0VjZtNSA4VjZtMyAxYy4zNy0uNiAxLjIxLTEgMi0xIDEgMCAyIC41IDIgMiAwIDEuNzg4LTEuNSAzLTQgNmg0XCJcbiAgICB9KVxuICB9KTtcbn1cblxuZXhwb3J0IHsgSDJJY29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IMi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/H2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/H3.js":
/*!************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/H3.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   H3Icon: () => (/* binding */ H3Icon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction H3Icon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M4 10h5m-5 4V6m5 8V6m3 1c.37-.6 1.2-1 2-1 .97 0 2 .5 2 2 0 1.79-1.47 2-2 2 .53 0 2 .21 2 2 0 1.5-1.03 2-2 2-.8 0-1.63-.4-2-1\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=H3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9IMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0M7QUFDYzs7QUFFdEQ7QUFDQSx5QkFBeUIsc0RBQUcsQ0FBQyw4REFBSTtBQUNqQztBQUNBLDhCQUE4QixzREFBRztBQUNqQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL0gzLmpzPzhhZDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5qcyc7XG5cbmZ1bmN0aW9uIEgzSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTQgMTBoNW0tNSA0VjZtNSA4VjZtMyAxYy4zNy0uNiAxLjItMSAyLTEgLjk3IDAgMiAuNSAyIDIgMCAxLjc5LTEuNDcgMi0yIDIgLjUzIDAgMiAuMjEgMiAyIDAgMS41LTEuMDMgMi0yIDItLjggMC0xLjYzLS40LTItMVwiXG4gICAgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IEgzSWNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SDMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/H3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Italic.js":
/*!****************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Italic.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ItalicIcon: () => (/* binding */ ItalicIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction ItalicIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M15 4.25H8m4 11.5H5m6.75-11.5-3.5 11.5\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=Italic.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9JdGFsaWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdDO0FBQ2M7O0FBRXREO0FBQ0EseUJBQXlCLHNEQUFHLENBQUMsOERBQUk7QUFDakM7QUFDQSw4QkFBOEIsc0RBQUc7QUFDakM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9JdGFsaWMuanM/OWRjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pbnRlcm5hbC9JY29uLmpzJztcblxuZnVuY3Rpb24gSXRhbGljSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE1IDQuMjVIOG00IDExLjVINW02Ljc1LTExLjUtMy41IDExLjVcIlxuICAgIH0pXG4gIH0pO1xufVxuXG5leHBvcnQgeyBJdGFsaWNJY29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JdGFsaWMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Italic.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/ListOrdered.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/ListOrdered.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListOrderedIcon: () => (/* binding */ ListOrderedIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction ListOrderedIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M16 14.25H9M16 10H9m7-4.25H9m-5 0 1-.5V8.5m0 0H4m1 0h1m-2 3.4c.18-.24.6-.4 1-.4.5 0 1 .2 1 .81 0 .73-.75 1.22-2 2.44h2\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=ListOrdered.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9MaXN0T3JkZXJlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0M7QUFDYzs7QUFFdEQ7QUFDQSx5QkFBeUIsc0RBQUcsQ0FBQyw4REFBSTtBQUNqQztBQUNBLDhCQUE4QixzREFBRztBQUNqQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL0xpc3RPcmRlcmVkLmpzPzE3ZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5qcyc7XG5cbmZ1bmN0aW9uIExpc3RPcmRlcmVkSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE2IDE0LjI1SDlNMTYgMTBIOW03LTQuMjVIOW0tNSAwIDEtLjVWOC41bTAgMEg0bTEgMGgxbS0yIDMuNGMuMTgtLjI0LjYtLjQgMS0uNC41IDAgMSAuMiAxIC44MSAwIC43My0uNzUgMS4yMi0yIDIuNDRoMlwiXG4gICAgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IExpc3RPcmRlcmVkSWNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlzdE9yZGVyZWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/ListOrdered.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/ListUnordered.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/ListUnordered.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListUnorderedIcon: () => (/* binding */ ListUnorderedIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction ListUnorderedIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"M16 14.25H8M16 10H8m8-4.25H8m-3.75 0h0\"\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: 4.25,\n        cy: 5.75,\n        r: 0.25\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"M4.25 14.25h0\"\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: 4.25,\n        cy: 14.25,\n        r: 0.25\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"M4.25 10h0\"\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: 4.25,\n        cy: 10,\n        r: 0.25\n      })\n    ]\n  });\n}\n\n\n//# sourceMappingURL=ListUnordered.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9MaXN0VW5vcmRlcmVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNROztBQUV0RDtBQUNBLHlCQUF5Qix1REFBSSxDQUFDLDhEQUFJO0FBQ2xDO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQUc7QUFDekI7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzQkFBc0Isc0RBQUc7QUFDekI7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzQkFBc0Isc0RBQUc7QUFDekI7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvaWNvbnMvTGlzdFVub3JkZXJlZC5qcz8yMzhjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeHMsIGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IEljb24gfSBmcm9tICcuLi9jb21wb25lbnRzL2ludGVybmFsL0ljb24uanMnO1xuXG5mdW5jdGlvbiBMaXN0VW5vcmRlcmVkSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoSWNvbiwge1xuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwicGF0aFwiLCB7XG4gICAgICAgIGQ6IFwiTTE2IDE0LjI1SDhNMTYgMTBIOG04LTQuMjVIOG0tMy43NSAwaDBcIlxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwiY2lyY2xlXCIsIHtcbiAgICAgICAgY3g6IDQuMjUsXG4gICAgICAgIGN5OiA1Ljc1LFxuICAgICAgICByOiAwLjI1XG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgICAgZDogXCJNNC4yNSAxNC4yNWgwXCJcbiAgICAgIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcImNpcmNsZVwiLCB7XG4gICAgICAgIGN4OiA0LjI1LFxuICAgICAgICBjeTogMTQuMjUsXG4gICAgICAgIHI6IDAuMjVcbiAgICAgIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcInBhdGhcIiwge1xuICAgICAgICBkOiBcIk00LjI1IDEwaDBcIlxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwiY2lyY2xlXCIsIHtcbiAgICAgICAgY3g6IDQuMjUsXG4gICAgICAgIGN5OiAxMCxcbiAgICAgICAgcjogMC4yNVxuICAgICAgfSlcbiAgICBdXG4gIH0pO1xufVxuXG5leHBvcnQgeyBMaXN0VW5vcmRlcmVkSWNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlzdFVub3JkZXJlZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/ListUnordered.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/QuestionMark.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/QuestionMark.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuestionMarkIcon: () => (/* binding */ QuestionMarkIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction QuestionMarkIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"M10 17a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0-3h.007\"\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"M8 7.5C8 7 8.5 6 10 6s2 1 2 2c0 1.5-2 2-2 3.5\"\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: 10,\n        cy: 14,\n        r: 0.25\n      })\n    ]\n  });\n}\n\n\n//# sourceMappingURL=QuestionMark.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9RdWVzdGlvbk1hcmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBQ1E7O0FBRXREO0FBQ0EseUJBQXlCLHVEQUFJLENBQUMsOERBQUk7QUFDbEM7QUFDQTtBQUNBLHNCQUFzQixzREFBRztBQUN6QjtBQUNBLE9BQU87QUFDUCxzQkFBc0Isc0RBQUc7QUFDekI7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvaWNvbnMvUXVlc3Rpb25NYXJrLmpzPzE5ZDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4cywganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5qcyc7XG5cbmZ1bmN0aW9uIFF1ZXN0aW9uTWFya0ljb24ocHJvcHMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKEljb24sIHtcbiAgICAuLi5wcm9wcyxcbiAgICBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcInBhdGhcIiwge1xuICAgICAgICBkOiBcIk0xMCAxN2E3IDcgMCAxIDAgMC0xNCA3IDcgMCAwIDAgMCAxNFptMC0zaC4wMDdcIlxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwicGF0aFwiLCB7XG4gICAgICAgIGQ6IFwiTTggNy41QzggNyA4LjUgNiAxMCA2czIgMSAyIDJjMCAxLjUtMiAyLTIgMy41XCJcbiAgICAgIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcImNpcmNsZVwiLCB7XG4gICAgICAgIGN4OiAxMCxcbiAgICAgICAgY3k6IDE0LFxuICAgICAgICByOiAwLjI1XG4gICAgICB9KVxuICAgIF1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IFF1ZXN0aW9uTWFya0ljb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1ZXN0aW9uTWFyay5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/QuestionMark.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Redo.js":
/*!**************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Redo.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RedoIcon: () => (/* binding */ RedoIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction RedoIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"M16 8H7.5A3.5 3.5 0 0 0 4 11.5v0A3.5 3.5 0 0 0 7.5 15H9\"\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"m13 5 3 3-3 3\"\n      })\n    ]\n  });\n}\n\n\n//# sourceMappingURL=Redo.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9SZWRvLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNROztBQUV0RDtBQUNBLHlCQUF5Qix1REFBSSxDQUFDLDhEQUFJO0FBQ2xDO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQUc7QUFDekI7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9SZWRvLmpzP2Q3MjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4cywganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5qcyc7XG5cbmZ1bmN0aW9uIFJlZG9JY29uKHByb3BzKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgICAgZDogXCJNMTYgOEg3LjVBMy41IDMuNSAwIDAgMCA0IDExLjV2MEEzLjUgMy41IDAgMCAwIDcuNSAxNUg5XCJcbiAgICAgIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcInBhdGhcIiwge1xuICAgICAgICBkOiBcIm0xMyA1IDMgMy0zIDNcIlxuICAgICAgfSlcbiAgICBdXG4gIH0pO1xufVxuXG5leHBvcnQgeyBSZWRvSWNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVkby5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Redo.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Sparkles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Sparkles.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SparklesIcon: () => (/* binding */ SparklesIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction SparklesIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M8.333 7.833a.333.333 0 0 0-.666 0 3.833 3.833 0 0 1-3.834 3.834.333.333 0 1 0 0 .666 3.833 3.833 0 0 1 3.834 3.834.333.333 0 0 0 .666 0 3.833 3.833 0 0 1 3.834-3.834.333.333 0 1 0 0-.666 3.833 3.833 0 0 1-3.834-3.834ZM16 6.5A2.5 2.5 0 0 1 13.5 4 2.5 2.5 0 0 1 11 6.5 2.5 2.5 0 0 1 13.5 9 2.5 2.5 0 0 1 16 6.5Z\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=Sparkles.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9TcGFya2xlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0M7QUFDYzs7QUFFdEQ7QUFDQSx5QkFBeUIsc0RBQUcsQ0FBQyw4REFBSTtBQUNqQztBQUNBLDhCQUE4QixzREFBRztBQUNqQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L2ljb25zL1NwYXJrbGVzLmpzP2U1OTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5qcyc7XG5cbmZ1bmN0aW9uIFNwYXJrbGVzSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTguMzMzIDcuODMzYS4zMzMuMzMzIDAgMCAwLS42NjYgMCAzLjgzMyAzLjgzMyAwIDAgMS0zLjgzNCAzLjgzNC4zMzMuMzMzIDAgMSAwIDAgLjY2NiAzLjgzMyAzLjgzMyAwIDAgMSAzLjgzNCAzLjgzNC4zMzMuMzMzIDAgMCAwIC42NjYgMCAzLjgzMyAzLjgzMyAwIDAgMSAzLjgzNC0zLjgzNC4zMzMuMzMzIDAgMSAwIDAtLjY2NiAzLjgzMyAzLjgzMyAwIDAgMS0zLjgzNC0zLjgzNFpNMTYgNi41QTIuNSAyLjUgMCAwIDEgMTMuNSA0IDIuNSAyLjUgMCAwIDEgMTEgNi41IDIuNSAyLjUgMCAwIDEgMTMuNSA5IDIuNSAyLjUgMCAwIDEgMTYgNi41WlwiXG4gICAgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IFNwYXJrbGVzSWNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3BhcmtsZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Sparkles.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Strikethrough.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Strikethrough.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StrikethroughIcon: () => (/* binding */ StrikethroughIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction StrikethroughIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M15.5 10h-11m4.669 0C7.599 9.44 6.5 8.484 6.5 7.125 6.5 5.537 7.79 4.25 10 4.25c1.654 0 2.793.721 3.261 1.75M6.74 14c.468 1.029 1.607 1.75 3.261 1.75 2 0 3.5-1 3.5-2.5 0-.085-.004-.169-.013-.25\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=Strikethrough.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9TdHJpa2V0aHJvdWdoLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3QztBQUNjOztBQUV0RDtBQUNBLHlCQUF5QixzREFBRyxDQUFDLDhEQUFJO0FBQ2pDO0FBQ0EsOEJBQThCLHNEQUFHO0FBQ2pDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvaWNvbnMvU3RyaWtldGhyb3VnaC5qcz9mNzA1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IEljb24gfSBmcm9tICcuLi9jb21wb25lbnRzL2ludGVybmFsL0ljb24uanMnO1xuXG5mdW5jdGlvbiBTdHJpa2V0aHJvdWdoSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE1LjUgMTBoLTExbTQuNjY5IDBDNy41OTkgOS40NCA2LjUgOC40ODQgNi41IDcuMTI1IDYuNSA1LjUzNyA3Ljc5IDQuMjUgMTAgNC4yNWMxLjY1NCAwIDIuNzkzLjcyMSAzLjI2MSAxLjc1TTYuNzQgMTRjLjQ2OCAxLjAyOSAxLjYwNyAxLjc1IDMuMjYxIDEuNzUgMiAwIDMuNS0xIDMuNS0yLjUgMC0uMDg1LS4wMDQtLjE2OS0uMDEzLS4yNVwiXG4gICAgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IFN0cmlrZXRocm91Z2hJY29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJpa2V0aHJvdWdoLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Strikethrough.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Text.js":
/*!**************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Text.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextIcon: () => (/* binding */ TextIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction TextIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M5 6V4.75h10V6m-6.5 9.25h3M10 4.75v10.5\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=Text.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9UZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3QztBQUNjOztBQUV0RDtBQUNBLHlCQUF5QixzREFBRyxDQUFDLDhEQUFJO0FBQ2pDO0FBQ0EsOEJBQThCLHNEQUFHO0FBQ2pDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvaWNvbnMvVGV4dC5qcz8yYWJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IEljb24gfSBmcm9tICcuLi9jb21wb25lbnRzL2ludGVybmFsL0ljb24uanMnO1xuXG5mdW5jdGlvbiBUZXh0SWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTUgNlY0Ljc1aDEwVjZtLTYuNSA5LjI1aDNNMTAgNC43NXYxMC41XCJcbiAgICB9KVxuICB9KTtcbn1cblxuZXhwb3J0IHsgVGV4dEljb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Text.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Underline.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Underline.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnderlineIcon: () => (/* binding */ UnderlineIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction UnderlineIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n      d: \"M6.5 4.5V9a3.5 3.5 0 0 0 3.5 3.5v0A3.5 3.5 0 0 0 13.5 9V4.5M15 16H5\"\n    })\n  });\n}\n\n\n//# sourceMappingURL=Underline.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9VbmRlcmxpbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdDO0FBQ2M7O0FBRXREO0FBQ0EseUJBQXlCLHNEQUFHLENBQUMsOERBQUk7QUFDakM7QUFDQSw4QkFBOEIsc0RBQUc7QUFDakM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUV5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9VbmRlcmxpbmUuanM/MDczYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pbnRlcm5hbC9JY29uLmpzJztcblxuZnVuY3Rpb24gVW5kZXJsaW5lSWNvbihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTYuNSA0LjVWOWEzLjUgMy41IDAgMCAwIDMuNSAzLjV2MEEzLjUgMy41IDAgMCAwIDEzLjUgOVY0LjVNMTUgMTZINVwiXG4gICAgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IFVuZGVybGluZUljb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuZGVybGluZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Underline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Undo.js":
/*!**************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/icons/Undo.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UndoIcon: () => (/* binding */ UndoIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/internal/Icon.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Icon.js\");\n\n\n\nfunction UndoIcon(props) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_internal_Icon_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n    ...props,\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"M4 8h8.5a3.5 3.5 0 0 1 3.5 3.5v0a3.5 3.5 0 0 1-3.5 3.5H11\"\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: \"M7 5 4 8l3 3\"\n      })\n    ]\n  });\n}\n\n\n//# sourceMappingURL=Undo.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9VbmRvLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNROztBQUV0RDtBQUNBLHlCQUF5Qix1REFBSSxDQUFDLDhEQUFJO0FBQ2xDO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQUc7QUFDekI7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9pY29ucy9VbmRvLmpzPzMxNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4cywganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW50ZXJuYWwvSWNvbi5qcyc7XG5cbmZ1bmN0aW9uIFVuZG9JY29uKHByb3BzKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhJY29uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwYXRoXCIsIHtcbiAgICAgICAgZDogXCJNNCA4aDguNWEzLjUgMy41IDAgMCAxIDMuNSAzLjV2MGEzLjUgMy41IDAgMCAxLTMuNSAzLjVIMTFcIlxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwicGF0aFwiLCB7XG4gICAgICAgIGQ6IFwiTTcgNSA0IDhsMyAzXCJcbiAgICAgIH0pXG4gICAgXVxuICB9KTtcbn1cblxuZXhwb3J0IHsgVW5kb0ljb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuZG8uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/icons/Undo.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.js":
/*!*************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/overrides.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OverridesContext: () => (/* binding */ OverridesContext),\n/* harmony export */   OverridesProvider: () => (/* binding */ OverridesProvider),\n/* harmony export */   defaultOverrides: () => (/* binding */ defaultOverrides),\n/* harmony export */   useOverrides: () => (/* binding */ useOverrides)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _components_internal_Emoji_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/internal/Emoji.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/components/internal/Emoji.js\");\n/* harmony import */ var _utils_pluralize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/pluralize.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/pluralize.js\");\n/* __next_internal_client_entry_do_not_use__ OverridesContext,OverridesProvider,defaultOverrides,useOverrides auto */ \n\n\n\n\nconst defaultOverrides = {\n    locale: \"en\",\n    dir: \"ltr\",\n    USER_SELF: \"you\",\n    USER_UNKNOWN: \"Anonymous\",\n    LIST_REMAINING: (count)=>`${count} more`,\n    LIST_REMAINING_USERS: (count)=>`${count} ${(0,_utils_pluralize_js__WEBPACK_IMPORTED_MODULE_2__.pluralize)(count, \"other\")}`,\n    LIST_REMAINING_COMMENTS: (count)=>`${count} more ${(0,_utils_pluralize_js__WEBPACK_IMPORTED_MODULE_2__.pluralize)(count, \"comment\")}`,\n    EMOJI_PICKER_SEARCH_PLACEHOLDER: \"Search…\",\n    EMOJI_PICKER_EMPTY: \"No emoji found.\",\n    EMOJI_PICKER_ERROR: ()=>\"There was an error while getting the list of emoji.\",\n    ATTACHMENT_TOO_LARGE: (maxSize)=>maxSize ? `The file is larger than ${maxSize}` : \"The file is too large\",\n    ATTACHMENT_ERROR: ()=>\"The file couldn’t be uploaded.\",\n    COMPOSER_INSERT_MENTION: \"Mention someone\",\n    COMPOSER_INSERT_EMOJI: \"Add emoji\",\n    COMPOSER_ATTACH_FILES: \"Attach files\",\n    COMPOSER_REMOVE_ATTACHMENT: \"Remove attachment\",\n    COMPOSER_PLACEHOLDER: \"Write a comment…\",\n    COMPOSER_SEND: \"Send\",\n    COMPOSER_TOGGLE_MARK: (format)=>{\n        switch(format){\n            case \"bold\":\n                return \"Bold\";\n            case \"italic\":\n                return \"Italic\";\n            case \"strikethrough\":\n                return \"Strikethrough\";\n            case \"code\":\n                return \"Inline code\";\n            default:\n                return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assertNever)(format, \"Unexpected mark\");\n        }\n    },\n    COMMENT_EDITED: \"(edited)\",\n    COMMENT_DELETED: \"This comment has been deleted.\",\n    COMMENT_MORE: \"More\",\n    COMMENT_EDIT: \"Edit comment\",\n    COMMENT_EDIT_COMPOSER_PLACEHOLDER: \"Edit comment…\",\n    COMMENT_EDIT_COMPOSER_CANCEL: \"Cancel\",\n    COMMENT_EDIT_COMPOSER_SAVE: \"Save\",\n    COMMENT_DELETE: \"Delete comment\",\n    COMMENT_DELETE_ATTACHMENT: \"Delete attachment\",\n    COMMENT_ADD_REACTION: \"Add reaction\",\n    COMMENT_REACTION_LIST: (list, emoji)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                list,\n                \" reacted with \",\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_internal_Emoji_js__WEBPACK_IMPORTED_MODULE_4__.Emoji, {\n                    emoji\n                })\n            ]\n        }),\n    COMMENT_REACTION_DESCRIPTION: (emoji, count)=>`${count} ${(0,_utils_pluralize_js__WEBPACK_IMPORTED_MODULE_2__.pluralize)(count, \"reaction\")}, react with ${emoji}`,\n    THREAD_RESOLVE: \"Resolve thread\",\n    THREAD_UNRESOLVE: \"Re-open thread\",\n    THREAD_NEW_INDICATOR: \"New\",\n    THREAD_NEW_INDICATOR_DESCRIPTION: \"New comments\",\n    THREAD_COMPOSER_PLACEHOLDER: \"Reply to thread…\",\n    THREAD_COMPOSER_SEND: \"Reply\",\n    INBOX_NOTIFICATION_MORE: \"More\",\n    INBOX_NOTIFICATION_MARK_AS_READ: \"Mark as read\",\n    INBOX_NOTIFICATION_DELETE: \"Delete notification\",\n    INBOX_NOTIFICATION_THREAD_COMMENTS_LIST: (list, room)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                list,\n                \" commented\",\n                room ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: [\n                        \" in \",\n                        room\n                    ]\n                }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: \" in a thread\"\n                })\n            ]\n        }),\n    INBOX_NOTIFICATION_THREAD_MENTION: (user, room)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                user,\n                \" mentioned you\",\n                room ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: [\n                        \" in \",\n                        room\n                    ]\n                }) : null\n            ]\n        }),\n    INBOX_NOTIFICATION_TEXT_MENTION: (user, room)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                user,\n                \" mentioned you\",\n                room ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: [\n                        \" in \",\n                        room\n                    ]\n                }) : null\n            ]\n        }),\n    HISTORY_VERSION_PREVIEW_AUTHORS_LIST: (list)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                \"Edits from \",\n                list\n            ]\n        }),\n    HISTORY_VERSION_PREVIEW_RESTORE: \"Restore\",\n    HISTORY_VERSION_PREVIEW_EMPTY: \"No content.\",\n    HISTORY_VERSION_PREVIEW_ERROR: ()=>\"There was an error while getting this version.\"\n};\nconst OverridesContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(void 0);\nfunction useOverrides(overrides) {\n    const contextOverrides = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(OverridesContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            ...defaultOverrides,\n            ...contextOverrides,\n            ...overrides\n        }), [\n        contextOverrides,\n        overrides\n    ]);\n}\nfunction OverridesProvider({ children, overrides: providerOverrides }) {\n    const contextOverrides = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(OverridesContext);\n    const overrides = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            ...defaultOverrides,\n            ...contextOverrides,\n            ...providerOverrides\n        }), [\n        contextOverrides,\n        providerOverrides\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(OverridesContext.Provider, {\n        value: overrides,\n        children\n    });\n}\n //# sourceMappingURL=overrides.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9vdmVycmlkZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3R08sTUFBQUEsbUJBQUE7SUFBb0NDLFFBQUE7SUFDakNDLEtBQUE7SUFDSEMsV0FBQTtJQUNNQyxjQUFBO0lBQ0dDLGdCQUFBLENBQUFDLFFBQUEsR0FBQUEsTUFBQTtJQUNnQkMsc0JBQUEsQ0FBQUQsUUFBQSxHQUFBQSxNQUFBLEdBQUFFLDhEQUFBQSxDQUFBRixPQUFBO0lBQ3VDRyx5QkFBQSxDQUFBSCxRQUFBLEdBQUFBLE1BQUEsUUFBQUUsOERBQUFBLENBQUFGLE9BQUE7SUFFeEJJLGlDQUFBO0lBQ1pDLG9CQUFBO0lBQ2JDLG9CQUFBO0lBRWxCQyxzQkFBQSxDQUFBQyxVQUFBQSxVQUFBLDJCQUFBQSxRQUFBO0lBRWlEQyxrQkFBQTtJQUMzQkMseUJBQUE7SUFDQ0MsdUJBQUE7SUFDRkMsdUJBQUE7SUFDQUMsNEJBQUE7SUFDS0Msc0JBQUE7SUFDTkMsZUFBQTtJQUNQQyxzQkFBQSxDQUFBQztRQUViLE9BQUFBO1lBQWdCO2dCQUVaO1lBQU87Z0JBRVA7WUFBTztnQkFFUDtZQUFPO2dCQUVQO1lBQU87Z0JBRVAsT0FBQUMsNkRBQUFBLENBQUFELFFBQUE7UUFBNEM7SUFDaEQ7SUFDRkUsZ0JBQUE7SUFDZ0JDLGlCQUFBO0lBQ0NDLGNBQUE7SUFDSEMsY0FBQTtJQUNBQyxtQ0FBQTtJQUNxQkMsOEJBQUE7SUFDTEMsNEJBQUE7SUFDRkMsZ0JBQUE7SUFDWkMsMkJBQUE7SUFDV0Msc0JBQUE7SUFDTEMsdUJBQUEsQ0FBQUMsTUFBQUMsUUFBQSxnQkFBQUMsdURBQUFBLENBQUFDLHVEQUFBQSxFQUFBO1lBRXBCQyxVQUFBO2dCQUNHSjtnQkFBQTtnQkFBSyxnQkFBQUssc0RBQUFBLENBQUFDLGdFQUFBQSxFQUFBO29CQUFlTDtnQkFBTTthQUFjO1FBQUE7SUFDM0NNLDhCQUFBLENBQUFOLE9BQUEvQixRQUFBLEdBQUFBLE1BQUEsR0FBQUUsOERBQUFBLENBQUFGLE9BQUEsMkJBQUErQixNQUFBO0lBR3dETyxnQkFBQTtJQUMxQ0Msa0JBQUE7SUFDRUMsc0JBQUE7SUFDSUMsa0NBQUE7SUFDWUMsNkJBQUE7SUFDTEMsc0JBQUE7SUFDUEMseUJBQUE7SUFDR0MsaUNBQUE7SUFDUUMsMkJBQUE7SUFDTkMseUNBQUEsQ0FBQWpCLE1BQUFrQixPQUFBLGdCQUFBaEIsdURBQUFBLENBQUFDLHVEQUFBQSxFQUFBO1lBS3pCQyxVQUFBO2dCQUNHSjtnQkFBQTtnQkFBS2tCLE9BQUEsZ0JBQUFoQix1REFBQUEsQ0FBQUMsdURBQUFBLEVBQUE7b0JBQ0VDLFVBQUE7d0JBQUU7d0JBQUFjO3FCQUFLO2dCQUFBLHFCQUFBYixzREFBQUEsQ0FBQUYsdURBQUFBLEVBQUE7b0JBQVdDLFVBQUE7Z0JBQUU7YUFBWTtRQUFBO0lBQzFDZSxtQ0FBQSxDQUFBQyxNQUFBRixPQUFBLGdCQUFBaEIsdURBQUFBLENBQUFDLHVEQUFBQSxFQUFBO1lBR0FDLFVBQUE7Z0JBQ0dnQjtnQkFBQTtnQkFBS0YsT0FBQSxnQkFBQWhCLHVEQUFBQSxDQUFBQyx1REFBQUEsRUFBQTtvQkFBc0JDLFVBQUE7d0JBQUU7d0JBQUFjO3FCQUFLO2dCQUFBO2FBQVc7UUFBQTtJQUNoREcsaUNBQUEsQ0FBQUQsTUFBQUYsT0FBQSxnQkFBQWhCLHVEQUFBQSxDQUFBQyx1REFBQUEsRUFBQTtZQUdBQyxVQUFBO2dCQUNHZ0I7Z0JBQUE7Z0JBQUtGLE9BQUEsZ0JBQUFoQix1REFBQUEsQ0FBQUMsdURBQUFBLEVBQUE7b0JBQXNCQyxVQUFBO3dCQUFFO3dCQUFBYztxQkFBSztnQkFBQTthQUFXO1FBQUE7SUFDaERJLHNDQUFBLENBQUF0QixPQUFBLGdCQUFBRSx1REFBQUEsQ0FBQUMsdURBQUFBLEVBQUE7WUFHQUMsVUFBQTtnQkFBRTtnQkFBQUo7YUFBWTtRQUFBO0lBQUt1QixpQ0FBQTtJQUVZQywrQkFBQTtJQUNGQywrQkFBQTtBQUdqQztBQUVhLE1BQUFDLGlDQUFBQyxvREFBQUEsQ0FBQTtBQUVOLFNBQUFDLGFBQUFDLFNBQUE7SUFDTCxNQUFBQyxtQkFBQUMsaURBQUFBLENBQUFMO0lBRUEsT0FBQU0sOENBQUFBLENBQU87WUFDRSxHQUFBcEUsZ0JBQUE7WUFDRixHQUFBa0UsZ0JBQUE7WUFDQSxHQUFBRCxTQUFBO1FBQ0EsSUFDTDtRQUFBQztRQUFBRDtLQUFBO0FBR0o7QUFFTyxTQUFBSSxrQkFBQSxFQUEyQjdCLFFBQUEsRUFDaEN5QixXQUFBSyxpQkFBQSxFQUVGO0lBQ0UsTUFBQUosbUJBQUFDLGlEQUFBQSxDQUFBTDtJQUNBLE1BQUFHLFlBQUFHLDhDQUFBQSxDQUFrQjtZQUNULEdBQUFwRSxnQkFBQTtZQUNGLEdBQUFrRSxnQkFBQTtZQUNBLEdBQUFJLGlCQUFBO1FBQ0EsSUFDTDtRQUFBSjtRQUFBSTtLQUFBO0lBSUYsdUJBQUE3QixzREFBQUEsQ0FBQXFCLGlCQUFBUyxRQUFBO1FBQ0dDLE9BQUFQO1FBQWlDekI7SUFDL0I7QUFHUCIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi4vc3JjL292ZXJyaWRlcy50c3g/MTMxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgYXNzZXJ0TmV2ZXIgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0IHR5cGUgeyBQcm9wc1dpdGhDaGlsZHJlbiwgUmVhY3ROb2RlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IEVtb2ppIH0gZnJvbSBcIi4vY29tcG9uZW50cy9pbnRlcm5hbC9FbW9qaVwiO1xuaW1wb3J0IHR5cGUgeyBDb21wb3NlckJvZHlNYXJrLCBEaXJlY3Rpb24gfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgcGx1cmFsaXplIH0gZnJvbSBcIi4vdXRpbHMvcGx1cmFsaXplXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxpemF0aW9uT3ZlcnJpZGVzIHtcbiAgbG9jYWxlOiBzdHJpbmc7XG4gIGRpcjogRGlyZWN0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbE92ZXJyaWRlcyB7XG4gIFVTRVJfU0VMRjogc3RyaW5nO1xuICBVU0VSX1VOS05PV046IHN0cmluZztcbiAgTElTVF9SRU1BSU5JTkc6IChjb3VudDogbnVtYmVyKSA9PiBzdHJpbmc7XG4gIExJU1RfUkVNQUlOSU5HX1VTRVJTOiAoY291bnQ6IG51bWJlcikgPT4gc3RyaW5nO1xuICBMSVNUX1JFTUFJTklOR19DT01NRU5UUzogKGNvdW50OiBudW1iZXIpID0+IHN0cmluZztcbiAgRU1PSklfUElDS0VSX1NFQVJDSF9QTEFDRUhPTERFUjogc3RyaW5nO1xuICBFTU9KSV9QSUNLRVJfRU1QVFk6IFJlYWN0Tm9kZTtcbiAgRU1PSklfUElDS0VSX0VSUk9SOiAoZXJyb3I6IEVycm9yKSA9PiBSZWFjdE5vZGU7XG4gIEFUVEFDSE1FTlRfVE9PX0xBUkdFOiAobWF4U2l6ZT86IHN0cmluZykgPT4gc3RyaW5nO1xuICBBVFRBQ0hNRU5UX0VSUk9SOiAoZXJyb3I6IEVycm9yKSA9PiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tbWVudE92ZXJyaWRlcyB7XG4gIENPTU1FTlRfRURJVEVEOiBSZWFjdE5vZGU7XG4gIENPTU1FTlRfREVMRVRFRDogUmVhY3ROb2RlO1xuICBDT01NRU5UX01PUkU6IHN0cmluZztcbiAgQ09NTUVOVF9FRElUOiBzdHJpbmc7XG4gIENPTU1FTlRfRURJVF9DT01QT1NFUl9QTEFDRUhPTERFUjogc3RyaW5nO1xuICBDT01NRU5UX0VESVRfQ09NUE9TRVJfQ0FOQ0VMOiBzdHJpbmc7XG4gIENPTU1FTlRfRURJVF9DT01QT1NFUl9TQVZFOiBzdHJpbmc7XG4gIENPTU1FTlRfREVMRVRFOiBzdHJpbmc7XG4gIENPTU1FTlRfREVMRVRFX0FUVEFDSE1FTlQ6IHN0cmluZztcbiAgQ09NTUVOVF9BRERfUkVBQ1RJT046IHN0cmluZztcbiAgQ09NTUVOVF9SRUFDVElPTl9MSVNUOiAoXG4gICAgbGlzdDogUmVhY3ROb2RlLFxuICAgIGVtb2ppOiBzdHJpbmcsXG4gICAgY291bnQ6IG51bWJlclxuICApID0+IFJlYWN0Tm9kZTtcbiAgQ09NTUVOVF9SRUFDVElPTl9ERVNDUklQVElPTjogKGVtb2ppOiBzdHJpbmcsIGNvdW50OiBudW1iZXIpID0+IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb3Nlck92ZXJyaWRlcyB7XG4gIENPTVBPU0VSX0lOU0VSVF9NRU5USU9OOiBzdHJpbmc7XG4gIENPTVBPU0VSX0lOU0VSVF9FTU9KSTogc3RyaW5nO1xuICBDT01QT1NFUl9BVFRBQ0hfRklMRVM6IHN0cmluZztcbiAgQ09NUE9TRVJfUkVNT1ZFX0FUVEFDSE1FTlQ6IHN0cmluZztcbiAgQ09NUE9TRVJfUExBQ0VIT0xERVI6IHN0cmluZztcbiAgQ09NUE9TRVJfU0VORDogc3RyaW5nO1xuICBDT01QT1NFUl9UT0dHTEVfTUFSSzogKG1hcms6IENvbXBvc2VyQm9keU1hcmspID0+IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaHJlYWRPdmVycmlkZXMge1xuICBUSFJFQURfUkVTT0xWRTogc3RyaW5nO1xuICBUSFJFQURfVU5SRVNPTFZFOiBzdHJpbmc7XG4gIFRIUkVBRF9ORVdfSU5ESUNBVE9SOiBzdHJpbmc7XG4gIFRIUkVBRF9ORVdfSU5ESUNBVE9SX0RFU0NSSVBUSU9OOiBzdHJpbmc7XG4gIFRIUkVBRF9DT01QT1NFUl9QTEFDRUhPTERFUjogc3RyaW5nO1xuICBUSFJFQURfQ09NUE9TRVJfU0VORDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluYm94Tm90aWZpY2F0aW9uT3ZlcnJpZGVzIHtcbiAgSU5CT1hfTk9USUZJQ0FUSU9OX01PUkU6IHN0cmluZztcbiAgSU5CT1hfTk9USUZJQ0FUSU9OX01BUktfQVNfUkVBRDogc3RyaW5nO1xuICBJTkJPWF9OT1RJRklDQVRJT05fREVMRVRFOiBzdHJpbmc7XG4gIElOQk9YX05PVElGSUNBVElPTl9USFJFQURfQ09NTUVOVFNfTElTVDogKFxuICAgIGxpc3Q6IFJlYWN0Tm9kZSxcbiAgICByb29tOiBSZWFjdE5vZGUgfCB1bmRlZmluZWQsXG4gICAgY291bnQ6IG51bWJlclxuICApID0+IFJlYWN0Tm9kZTtcbiAgSU5CT1hfTk9USUZJQ0FUSU9OX1RIUkVBRF9NRU5USU9OOiAoXG4gICAgdXNlcjogUmVhY3ROb2RlLFxuICAgIHJvb206IFJlYWN0Tm9kZSB8IHVuZGVmaW5lZFxuICApID0+IFJlYWN0Tm9kZTtcbiAgSU5CT1hfTk9USUZJQ0FUSU9OX1RFWFRfTUVOVElPTjogKFxuICAgIHVzZXI6IFJlYWN0Tm9kZSxcbiAgICByb29tOiBSZWFjdE5vZGUgfCB1bmRlZmluZWRcbiAgKSA9PiBSZWFjdE5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVZlcnNpb25QcmV2aWV3T3ZlcnJpZGVzIHtcbiAgSElTVE9SWV9WRVJTSU9OX1BSRVZJRVdfQVVUSE9SU19MSVNUOiAobGlzdDogUmVhY3ROb2RlKSA9PiBSZWFjdE5vZGU7XG4gIEhJU1RPUllfVkVSU0lPTl9QUkVWSUVXX1JFU1RPUkU6IHN0cmluZztcbiAgSElTVE9SWV9WRVJTSU9OX1BSRVZJRVdfRU1QVFk6IFJlYWN0Tm9kZTtcbiAgSElTVE9SWV9WRVJTSU9OX1BSRVZJRVdfRVJST1I6IChlcnJvcjogRXJyb3IpID0+IFJlYWN0Tm9kZTtcbn1cblxuZXhwb3J0IHR5cGUgT3ZlcnJpZGVzID0gTG9jYWxpemF0aW9uT3ZlcnJpZGVzICZcbiAgR2xvYmFsT3ZlcnJpZGVzICZcbiAgQ29tcG9zZXJPdmVycmlkZXMgJlxuICBDb21tZW50T3ZlcnJpZGVzICZcbiAgVGhyZWFkT3ZlcnJpZGVzICZcbiAgSW5ib3hOb3RpZmljYXRpb25PdmVycmlkZXMgJlxuICBIaXN0b3J5VmVyc2lvblByZXZpZXdPdmVycmlkZXM7XG5cbnR5cGUgT3ZlcnJpZGVzUHJvdmlkZXJQcm9wcyA9IFByb3BzV2l0aENoaWxkcmVuPHtcbiAgb3ZlcnJpZGVzPzogUGFydGlhbDxPdmVycmlkZXM+O1xufT47XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0T3ZlcnJpZGVzOiBPdmVycmlkZXMgPSB7XG4gIGxvY2FsZTogXCJlblwiLFxuICBkaXI6IFwibHRyXCIsXG4gIFVTRVJfU0VMRjogXCJ5b3VcIixcbiAgVVNFUl9VTktOT1dOOiBcIkFub255bW91c1wiLFxuICBMSVNUX1JFTUFJTklORzogKGNvdW50KSA9PiBgJHtjb3VudH0gbW9yZWAsXG4gIExJU1RfUkVNQUlOSU5HX1VTRVJTOiAoY291bnQpID0+IGAke2NvdW50fSAke3BsdXJhbGl6ZShjb3VudCwgXCJvdGhlclwiKX1gLFxuICBMSVNUX1JFTUFJTklOR19DT01NRU5UUzogKGNvdW50KSA9PlxuICAgIGAke2NvdW50fSBtb3JlICR7cGx1cmFsaXplKGNvdW50LCBcImNvbW1lbnRcIil9YCxcbiAgRU1PSklfUElDS0VSX1NFQVJDSF9QTEFDRUhPTERFUjogXCJTZWFyY2jigKZcIixcbiAgRU1PSklfUElDS0VSX0VNUFRZOiBcIk5vIGVtb2ppIGZvdW5kLlwiLFxuICBFTU9KSV9QSUNLRVJfRVJST1I6ICgpID0+XG4gICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgbGlzdCBvZiBlbW9qaS5cIixcbiAgQVRUQUNITUVOVF9UT09fTEFSR0U6IChtYXhTaXplKSA9PlxuICAgIG1heFNpemUgPyBgVGhlIGZpbGUgaXMgbGFyZ2VyIHRoYW4gJHttYXhTaXplfWAgOiBcIlRoZSBmaWxlIGlzIHRvbyBsYXJnZVwiLFxuICBBVFRBQ0hNRU5UX0VSUk9SOiAoKSA9PiBcIlRoZSBmaWxlIGNvdWxkbuKAmXQgYmUgdXBsb2FkZWQuXCIsXG4gIENPTVBPU0VSX0lOU0VSVF9NRU5USU9OOiBcIk1lbnRpb24gc29tZW9uZVwiLFxuICBDT01QT1NFUl9JTlNFUlRfRU1PSkk6IFwiQWRkIGVtb2ppXCIsXG4gIENPTVBPU0VSX0FUVEFDSF9GSUxFUzogXCJBdHRhY2ggZmlsZXNcIixcbiAgQ09NUE9TRVJfUkVNT1ZFX0FUVEFDSE1FTlQ6IFwiUmVtb3ZlIGF0dGFjaG1lbnRcIixcbiAgQ09NUE9TRVJfUExBQ0VIT0xERVI6IFwiV3JpdGUgYSBjb21tZW504oCmXCIsXG4gIENPTVBPU0VSX1NFTkQ6IFwiU2VuZFwiLFxuICBDT01QT1NFUl9UT0dHTEVfTUFSSzogKGZvcm1hdCkgPT4ge1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICBjYXNlIFwiYm9sZFwiOlxuICAgICAgICByZXR1cm4gXCJCb2xkXCI7XG4gICAgICBjYXNlIFwiaXRhbGljXCI6XG4gICAgICAgIHJldHVybiBcIkl0YWxpY1wiO1xuICAgICAgY2FzZSBcInN0cmlrZXRocm91Z2hcIjpcbiAgICAgICAgcmV0dXJuIFwiU3RyaWtldGhyb3VnaFwiO1xuICAgICAgY2FzZSBcImNvZGVcIjpcbiAgICAgICAgcmV0dXJuIFwiSW5saW5lIGNvZGVcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcihmb3JtYXQsIFwiVW5leHBlY3RlZCBtYXJrXCIpO1xuICAgIH1cbiAgfSxcbiAgQ09NTUVOVF9FRElURUQ6IFwiKGVkaXRlZClcIixcbiAgQ09NTUVOVF9ERUxFVEVEOiBcIlRoaXMgY29tbWVudCBoYXMgYmVlbiBkZWxldGVkLlwiLFxuICBDT01NRU5UX01PUkU6IFwiTW9yZVwiLFxuICBDT01NRU5UX0VESVQ6IFwiRWRpdCBjb21tZW50XCIsXG4gIENPTU1FTlRfRURJVF9DT01QT1NFUl9QTEFDRUhPTERFUjogXCJFZGl0IGNvbW1lbnTigKZcIixcbiAgQ09NTUVOVF9FRElUX0NPTVBPU0VSX0NBTkNFTDogXCJDYW5jZWxcIixcbiAgQ09NTUVOVF9FRElUX0NPTVBPU0VSX1NBVkU6IFwiU2F2ZVwiLFxuICBDT01NRU5UX0RFTEVURTogXCJEZWxldGUgY29tbWVudFwiLFxuICBDT01NRU5UX0RFTEVURV9BVFRBQ0hNRU5UOiBcIkRlbGV0ZSBhdHRhY2htZW50XCIsXG4gIENPTU1FTlRfQUREX1JFQUNUSU9OOiBcIkFkZCByZWFjdGlvblwiLFxuICBDT01NRU5UX1JFQUNUSU9OX0xJU1Q6IChsaXN0LCBlbW9qaSkgPT4gKFxuICAgIDw+XG4gICAgICB7bGlzdH0gcmVhY3RlZCB3aXRoIDxFbW9qaSBlbW9qaT17ZW1vaml9IC8+XG4gICAgPC8+XG4gICksXG4gIENPTU1FTlRfUkVBQ1RJT05fREVTQ1JJUFRJT046IChlbW9qaSwgY291bnQpID0+XG4gICAgYCR7Y291bnR9ICR7cGx1cmFsaXplKGNvdW50LCBcInJlYWN0aW9uXCIpfSwgcmVhY3Qgd2l0aCAke2Vtb2ppfWAsXG4gIFRIUkVBRF9SRVNPTFZFOiBcIlJlc29sdmUgdGhyZWFkXCIsXG4gIFRIUkVBRF9VTlJFU09MVkU6IFwiUmUtb3BlbiB0aHJlYWRcIixcbiAgVEhSRUFEX05FV19JTkRJQ0FUT1I6IFwiTmV3XCIsXG4gIFRIUkVBRF9ORVdfSU5ESUNBVE9SX0RFU0NSSVBUSU9OOiBcIk5ldyBjb21tZW50c1wiLFxuICBUSFJFQURfQ09NUE9TRVJfUExBQ0VIT0xERVI6IFwiUmVwbHkgdG8gdGhyZWFk4oCmXCIsXG4gIFRIUkVBRF9DT01QT1NFUl9TRU5EOiBcIlJlcGx5XCIsXG4gIElOQk9YX05PVElGSUNBVElPTl9NT1JFOiBcIk1vcmVcIixcbiAgSU5CT1hfTk9USUZJQ0FUSU9OX01BUktfQVNfUkVBRDogXCJNYXJrIGFzIHJlYWRcIixcbiAgSU5CT1hfTk9USUZJQ0FUSU9OX0RFTEVURTogXCJEZWxldGUgbm90aWZpY2F0aW9uXCIsXG4gIElOQk9YX05PVElGSUNBVElPTl9USFJFQURfQ09NTUVOVFNfTElTVDogKFxuICAgIGxpc3Q6IFJlYWN0Tm9kZSxcbiAgICByb29tOiBSZWFjdE5vZGVcbiAgKSA9PiAoXG4gICAgPD5cbiAgICAgIHtsaXN0fSBjb21tZW50ZWRcbiAgICAgIHtyb29tID8gPD4gaW4ge3Jvb219PC8+IDogPD4gaW4gYSB0aHJlYWQ8Lz59XG4gICAgPC8+XG4gICksXG4gIElOQk9YX05PVElGSUNBVElPTl9USFJFQURfTUVOVElPTjogKHVzZXI6IFJlYWN0Tm9kZSwgcm9vbTogUmVhY3ROb2RlKSA9PiAoXG4gICAgPD5cbiAgICAgIHt1c2VyfSBtZW50aW9uZWQgeW91e3Jvb20gPyA8PiBpbiB7cm9vbX08Lz4gOiBudWxsfVxuICAgIDwvPlxuICApLFxuICBJTkJPWF9OT1RJRklDQVRJT05fVEVYVF9NRU5USU9OOiAodXNlcjogUmVhY3ROb2RlLCByb29tOiBSZWFjdE5vZGUpID0+IChcbiAgICA8PlxuICAgICAge3VzZXJ9IG1lbnRpb25lZCB5b3V7cm9vbSA/IDw+IGluIHtyb29tfTwvPiA6IG51bGx9XG4gICAgPC8+XG4gICksXG4gIEhJU1RPUllfVkVSU0lPTl9QUkVWSUVXX0FVVEhPUlNfTElTVDogKGxpc3Q6IFJlYWN0Tm9kZSkgPT4gKFxuICAgIDw+RWRpdHMgZnJvbSB7bGlzdH08Lz5cbiAgKSxcbiAgSElTVE9SWV9WRVJTSU9OX1BSRVZJRVdfUkVTVE9SRTogXCJSZXN0b3JlXCIsXG4gIEhJU1RPUllfVkVSU0lPTl9QUkVWSUVXX0VNUFRZOiBcIk5vIGNvbnRlbnQuXCIsXG4gIEhJU1RPUllfVkVSU0lPTl9QUkVWSUVXX0VSUk9SOiAoKSA9PlxuICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhpcyB2ZXJzaW9uLlwiLFxufTtcblxuZXhwb3J0IGNvbnN0IE92ZXJyaWRlc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PE92ZXJyaWRlcyB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU92ZXJyaWRlcyhvdmVycmlkZXM/OiBQYXJ0aWFsPE92ZXJyaWRlcz4pOiBPdmVycmlkZXMge1xuICBjb25zdCBjb250ZXh0T3ZlcnJpZGVzID0gdXNlQ29udGV4dChPdmVycmlkZXNDb250ZXh0KTtcblxuICByZXR1cm4gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgLi4uZGVmYXVsdE92ZXJyaWRlcyxcbiAgICAgIC4uLmNvbnRleHRPdmVycmlkZXMsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgfSksXG4gICAgW2NvbnRleHRPdmVycmlkZXMsIG92ZXJyaWRlc11cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE92ZXJyaWRlc1Byb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIG92ZXJyaWRlczogcHJvdmlkZXJPdmVycmlkZXMsXG59OiBPdmVycmlkZXNQcm92aWRlclByb3BzKSB7XG4gIGNvbnN0IGNvbnRleHRPdmVycmlkZXMgPSB1c2VDb250ZXh0KE92ZXJyaWRlc0NvbnRleHQpO1xuICBjb25zdCBvdmVycmlkZXMgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICAuLi5kZWZhdWx0T3ZlcnJpZGVzLFxuICAgICAgLi4uY29udGV4dE92ZXJyaWRlcyxcbiAgICAgIC4uLnByb3ZpZGVyT3ZlcnJpZGVzLFxuICAgIH0pLFxuICAgIFtjb250ZXh0T3ZlcnJpZGVzLCBwcm92aWRlck92ZXJyaWRlc11cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxPdmVycmlkZXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtvdmVycmlkZXN9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvT3ZlcnJpZGVzQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJkZWZhdWx0T3ZlcnJpZGVzIiwibG9jYWxlIiwiZGlyIiwiVVNFUl9TRUxGIiwiVVNFUl9VTktOT1dOIiwiTElTVF9SRU1BSU5JTkciLCJjb3VudCIsIkxJU1RfUkVNQUlOSU5HX1VTRVJTIiwicGx1cmFsaXplIiwiTElTVF9SRU1BSU5JTkdfQ09NTUVOVFMiLCJFTU9KSV9QSUNLRVJfU0VBUkNIX1BMQUNFSE9MREVSIiwiRU1PSklfUElDS0VSX0VNUFRZIiwiRU1PSklfUElDS0VSX0VSUk9SIiwiQVRUQUNITUVOVF9UT09fTEFSR0UiLCJtYXhTaXplIiwiQVRUQUNITUVOVF9FUlJPUiIsIkNPTVBPU0VSX0lOU0VSVF9NRU5USU9OIiwiQ09NUE9TRVJfSU5TRVJUX0VNT0pJIiwiQ09NUE9TRVJfQVRUQUNIX0ZJTEVTIiwiQ09NUE9TRVJfUkVNT1ZFX0FUVEFDSE1FTlQiLCJDT01QT1NFUl9QTEFDRUhPTERFUiIsIkNPTVBPU0VSX1NFTkQiLCJDT01QT1NFUl9UT0dHTEVfTUFSSyIsImZvcm1hdCIsImFzc2VydE5ldmVyIiwiQ09NTUVOVF9FRElURUQiLCJDT01NRU5UX0RFTEVURUQiLCJDT01NRU5UX01PUkUiLCJDT01NRU5UX0VESVQiLCJDT01NRU5UX0VESVRfQ09NUE9TRVJfUExBQ0VIT0xERVIiLCJDT01NRU5UX0VESVRfQ09NUE9TRVJfQ0FOQ0VMIiwiQ09NTUVOVF9FRElUX0NPTVBPU0VSX1NBVkUiLCJDT01NRU5UX0RFTEVURSIsIkNPTU1FTlRfREVMRVRFX0FUVEFDSE1FTlQiLCJDT01NRU5UX0FERF9SRUFDVElPTiIsIkNPTU1FTlRfUkVBQ1RJT05fTElTVCIsImxpc3QiLCJlbW9qaSIsImpzeHMiLCJGcmFnbWVudCIsImNoaWxkcmVuIiwianN4IiwiRW1vamkiLCJDT01NRU5UX1JFQUNUSU9OX0RFU0NSSVBUSU9OIiwiVEhSRUFEX1JFU09MVkUiLCJUSFJFQURfVU5SRVNPTFZFIiwiVEhSRUFEX05FV19JTkRJQ0FUT1IiLCJUSFJFQURfTkVXX0lORElDQVRPUl9ERVNDUklQVElPTiIsIlRIUkVBRF9DT01QT1NFUl9QTEFDRUhPTERFUiIsIlRIUkVBRF9DT01QT1NFUl9TRU5EIiwiSU5CT1hfTk9USUZJQ0FUSU9OX01PUkUiLCJJTkJPWF9OT1RJRklDQVRJT05fTUFSS19BU19SRUFEIiwiSU5CT1hfTk9USUZJQ0FUSU9OX0RFTEVURSIsIklOQk9YX05PVElGSUNBVElPTl9USFJFQURfQ09NTUVOVFNfTElTVCIsInJvb20iLCJJTkJPWF9OT1RJRklDQVRJT05fVEhSRUFEX01FTlRJT04iLCJ1c2VyIiwiSU5CT1hfTk9USUZJQ0FUSU9OX1RFWFRfTUVOVElPTiIsIkhJU1RPUllfVkVSU0lPTl9QUkVWSUVXX0FVVEhPUlNfTElTVCIsIkhJU1RPUllfVkVSU0lPTl9QUkVWSUVXX1JFU1RPUkUiLCJISVNUT1JZX1ZFUlNJT05fUFJFVklFV19FTVBUWSIsIkhJU1RPUllfVkVSU0lPTl9QUkVWSUVXX0VSUk9SIiwiT3ZlcnJpZGVzQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VPdmVycmlkZXMiLCJvdmVycmlkZXMiLCJjb250ZXh0T3ZlcnJpZGVzIiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJPdmVycmlkZXNQcm92aWRlciIsInByb3ZpZGVyT3ZlcnJpZGVzIiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/overrides.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/internal/Emoji.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/primitives/internal/Emoji.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Emoji: () => (/* binding */ Emoji)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(ssr)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants.js */ \"(ssr)/./node_modules/@liveblocks/react-ui/dist/constants.js\");\n\n\n\n\n\nconst Emoji = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  ({ emoji, style, asChild, ...props }, forwardedRef) => {\n    const Component = asChild ? _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_2__.Slot : \"span\";\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Component, {\n      role: \"img\",\n      \"aria-label\": emoji,\n      \"data-emoji\": emoji,\n      style: {\n        ...style,\n        fontFamily: _constants_js__WEBPACK_IMPORTED_MODULE_3__.EMOJI_FONT_FAMILY,\n        display: \"inline-flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        width: \"1em\",\n        whiteSpace: \"nowrap\"\n      },\n      ...props,\n      ref: forwardedRef,\n      children: emoji\n    });\n  }\n);\n\n\n//# sourceMappingURL=Emoji.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC9wcmltaXRpdmVzL2ludGVybmFsL0Vtb2ppLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXdDO0FBQ0k7QUFDVDtBQUNvQjs7QUFFdkQsY0FBYyxpREFBVTtBQUN4QixLQUFLLGlDQUFpQztBQUN0QyxnQ0FBZ0Msc0RBQUk7QUFDcEMsMkJBQTJCLHNEQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3ByaW1pdGl2ZXMvaW50ZXJuYWwvRW1vamkuanM/ZWUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBTbG90IH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LXNsb3QnO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVNT0pJX0ZPTlRfRkFNSUxZIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcblxuY29uc3QgRW1vamkgPSBmb3J3YXJkUmVmKFxuICAoeyBlbW9qaSwgc3R5bGUsIGFzQ2hpbGQsIC4uLnByb3BzIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGFzQ2hpbGQgPyBTbG90IDogXCJzcGFuXCI7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29tcG9uZW50LCB7XG4gICAgICByb2xlOiBcImltZ1wiLFxuICAgICAgXCJhcmlhLWxhYmVsXCI6IGVtb2ppLFxuICAgICAgXCJkYXRhLWVtb2ppXCI6IGVtb2ppLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgIGZvbnRGYW1pbHk6IEVNT0pJX0ZPTlRfRkFNSUxZLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1mbGV4XCIsXG4gICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgICAgICB3aWR0aDogXCIxZW1cIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIlxuICAgICAgfSxcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICBjaGlsZHJlbjogZW1vamlcbiAgICB9KTtcbiAgfVxuKTtcblxuZXhwb3J0IHsgRW1vamkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtb2ppLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/primitives/internal/Emoji.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/class-names.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   classNames: () => (/* binding */ classNames)\n/* harmony export */ });\nfunction classNames(...args) {\n  return args.filter((arg) => typeof arg === \"string\" || typeof arg === \"number\").join(\" \");\n}\n\n\n//# sourceMappingURL=class-names.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9jbGFzcy1uYW1lcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBOztBQUVzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9jbGFzcy1uYW1lcy5qcz9mNGQ4Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGNsYXNzTmFtZXMoLi4uYXJncykge1xuICByZXR1cm4gYXJncy5maWx0ZXIoKGFyZykgPT4gdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKS5qb2luKFwiIFwiKTtcbn1cblxuZXhwb3J0IHsgY2xhc3NOYW1lcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xhc3MtbmFtZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/class-names.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/is-apple.js":
/*!******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/is-apple.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isApple: () => (/* binding */ isApple)\n/* harmony export */ });\nconst APPLE_REGEX = /Mac|iPod|iPhone|iPad/;\nfunction isApple() {\n  return typeof window !== \"undefined\" && APPLE_REGEX.test(window.navigator.platform);\n}\n\n\n//# sourceMappingURL=is-apple.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9pcy1hcHBsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL2lzLWFwcGxlLmpzPzM0ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQVBQTEVfUkVHRVggPSAvTWFjfGlQb2R8aVBob25lfGlQYWQvO1xuZnVuY3Rpb24gaXNBcHBsZSgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgQVBQTEVfUkVHRVgudGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKTtcbn1cblxuZXhwb3J0IHsgaXNBcHBsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtYXBwbGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/is-apple.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/pluralize.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/pluralize.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pluralize: () => (/* binding */ pluralize)\n/* harmony export */ });\nfunction pluralize(count, singular, plural) {\n  return count === 1 ? singular : plural ?? `${singular}s`;\n}\n\n\n//# sourceMappingURL=pluralize.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy9wbHVyYWxpemUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7O0FBRXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC11aS9kaXN0L3V0aWxzL3BsdXJhbGl6ZS5qcz81YTMzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHBsdXJhbGl6ZShjb3VudCwgc2luZ3VsYXIsIHBsdXJhbCkge1xuICByZXR1cm4gY291bnQgPT09IDEgPyBzaW5ndWxhciA6IHBsdXJhbCA/PyBgJHtzaW5ndWxhcn1zYDtcbn1cblxuZXhwb3J0IHsgcGx1cmFsaXplIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVyYWxpemUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/pluralize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-initial.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-initial.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useInitial: () => (/* binding */ useInitial)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nfunction useInitial(value) {\n  const [initialValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(value);\n  return initialValue;\n}\n\n\n//# sourceMappingURL=use-initial.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtaW5pdGlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQzs7QUFFakM7QUFDQSx5QkFBeUIsK0NBQVE7QUFDakM7QUFDQTs7QUFFc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0LXVpL2Rpc3QvdXRpbHMvdXNlLWluaXRpYWwuanM/YWQyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gdXNlSW5pdGlhbCh2YWx1ZSkge1xuICBjb25zdCBbaW5pdGlhbFZhbHVlXSA9IHVzZVN0YXRlKHZhbHVlKTtcbiAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbn1cblxuZXhwb3J0IHsgdXNlSW5pdGlhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWluaXRpYWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-initial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-refs.js":
/*!******************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/dist/utils/use-refs.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useRefs: () => (/* binding */ useRefs)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nfunction applyRef(ref, value) {\n  if (value) {\n    if (typeof ref === \"function\") {\n      ref(value);\n    } else if (ref && \"current\" in ref) {\n      ref.current = value;\n    }\n  }\n}\nfunction mergeRefs(value, ...refs) {\n  for (const ref of refs) {\n    applyRef(ref, value);\n  }\n}\nfunction useRefs(...refs) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value) => mergeRefs(value, ...refs), refs);\n}\n\n\n//# sourceMappingURL=use-refs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtcmVmcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtEQUFXO0FBQ3BCOztBQUVtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvZGlzdC91dGlscy91c2UtcmVmcy5qcz82NmVmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiBhcHBseVJlZihyZWYsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJlZih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChyZWYgJiYgXCJjdXJyZW50XCIgaW4gcmVmKSB7XG4gICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VSZWZzKHZhbHVlLCAuLi5yZWZzKSB7XG4gIGZvciAoY29uc3QgcmVmIG9mIHJlZnMpIHtcbiAgICBhcHBseVJlZihyZWYsIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlUmVmcyguLi5yZWZzKSB7XG4gIHJldHVybiB1c2VDYWxsYmFjaygodmFsdWUpID0+IG1lcmdlUmVmcyh2YWx1ZSwgLi4ucmVmcyksIHJlZnMpO1xufVxuXG5leHBvcnQgeyB1c2VSZWZzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtcmVmcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/dist/utils/use-refs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react-ui/node_modules/@radix-ui/react-tooltip/dist/index.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@liveblocks/react-ui/node_modules/@radix-ui/react-tooltip/dist/index.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Arrow: () => (/* binding */ Arrow2),\n/* harmony export */   Content: () => (/* binding */ Content2),\n/* harmony export */   Portal: () => (/* binding */ Portal),\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   Root: () => (/* binding */ Root3),\n/* harmony export */   Tooltip: () => (/* binding */ Tooltip),\n/* harmony export */   TooltipArrow: () => (/* binding */ TooltipArrow),\n/* harmony export */   TooltipContent: () => (/* binding */ TooltipContent),\n/* harmony export */   TooltipPortal: () => (/* binding */ TooltipPortal),\n/* harmony export */   TooltipProvider: () => (/* binding */ TooltipProvider),\n/* harmony export */   TooltipTrigger: () => (/* binding */ TooltipTrigger),\n/* harmony export */   Trigger: () => (/* binding */ Trigger),\n/* harmony export */   createTooltipScope: () => (/* binding */ createTooltipScope)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _radix_ui_primitive__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @radix-ui/primitive */ \"(ssr)/./node_modules/@radix-ui/primitive/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @radix-ui/react-compose-refs */ \"(ssr)/./node_modules/@radix-ui/react-compose-refs/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @radix-ui/react-context */ \"(ssr)/./node_modules/@radix-ui/react-context/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_dismissable_layer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @radix-ui/react-dismissable-layer */ \"(ssr)/./node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @radix-ui/react-id */ \"(ssr)/./node_modules/@radix-ui/react-id/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_popper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @radix-ui/react-popper */ \"(ssr)/./node_modules/@radix-ui/react-popper/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_portal__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @radix-ui/react-portal */ \"(ssr)/./node_modules/@radix-ui/react-portal/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_presence__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @radix-ui/react-presence */ \"(ssr)/./node_modules/@radix-ui/react-presence/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @radix-ui/react-primitive */ \"(ssr)/./node_modules/@radix-ui/react-primitive/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @radix-ui/react-slot */ \"(ssr)/./node_modules/@radix-ui/react-slot/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_use_controllable_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @radix-ui/react-use-controllable-state */ \"(ssr)/./node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs\");\n/* harmony import */ var _radix_ui_react_visually_hidden__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @radix-ui/react-visually-hidden */ \"(ssr)/./node_modules/@radix-ui/react-visually-hidden/dist/index.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ Arrow,Content,Portal,Provider,Root,Tooltip,TooltipArrow,TooltipContent,TooltipPortal,TooltipProvider,TooltipTrigger,Trigger,createTooltipScope auto */ // packages/react/tooltip/src/tooltip.tsx\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar [createTooltipContext, createTooltipScope] = (0,_radix_ui_react_context__WEBPACK_IMPORTED_MODULE_2__.createContextScope)(\"Tooltip\", [\n    _radix_ui_react_popper__WEBPACK_IMPORTED_MODULE_3__.createPopperScope\n]);\nvar usePopperScope = (0,_radix_ui_react_popper__WEBPACK_IMPORTED_MODULE_3__.createPopperScope)();\nvar PROVIDER_NAME = \"TooltipProvider\";\nvar DEFAULT_DELAY_DURATION = 700;\nvar TOOLTIP_OPEN = \"tooltip.open\";\nvar [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);\nvar TooltipProvider = (props)=>{\n    const { __scopeTooltip, delayDuration = DEFAULT_DELAY_DURATION, skipDelayDuration = 300, disableHoverableContent = false, children } = props;\n    const [isOpenDelayed, setIsOpenDelayed] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    const isPointerInTransitRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const skipDelayTimerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const skipDelayTimer = skipDelayTimerRef.current;\n        return ()=>window.clearTimeout(skipDelayTimer);\n    }, []);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TooltipProviderContextProvider, {\n        scope: __scopeTooltip,\n        isOpenDelayed,\n        delayDuration,\n        onOpen: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            window.clearTimeout(skipDelayTimerRef.current);\n            setIsOpenDelayed(false);\n        }, []),\n        onClose: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            window.clearTimeout(skipDelayTimerRef.current);\n            skipDelayTimerRef.current = window.setTimeout(()=>setIsOpenDelayed(true), skipDelayDuration);\n        }, [\n            skipDelayDuration\n        ]),\n        isPointerInTransitRef,\n        onPointerInTransitChange: react__WEBPACK_IMPORTED_MODULE_0__.useCallback((inTransit)=>{\n            isPointerInTransitRef.current = inTransit;\n        }, []),\n        disableHoverableContent,\n        children\n    });\n};\nTooltipProvider.displayName = PROVIDER_NAME;\nvar TOOLTIP_NAME = \"Tooltip\";\nvar [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);\nvar Tooltip = (props)=>{\n    const { __scopeTooltip, children, open: openProp, defaultOpen = false, onOpenChange, disableHoverableContent: disableHoverableContentProp, delayDuration: delayDurationProp } = props;\n    const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const [trigger, setTrigger] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const contentId = (0,_radix_ui_react_id__WEBPACK_IMPORTED_MODULE_4__.useId)();\n    const openTimerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;\n    const delayDuration = delayDurationProp ?? providerContext.delayDuration;\n    const wasOpenDelayedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const [open = false, setOpen] = (0,_radix_ui_react_use_controllable_state__WEBPACK_IMPORTED_MODULE_5__.useControllableState)({\n        prop: openProp,\n        defaultProp: defaultOpen,\n        onChange: (open2)=>{\n            if (open2) {\n                providerContext.onOpen();\n                document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));\n            } else {\n                providerContext.onClose();\n            }\n            onOpenChange?.(open2);\n        }\n    });\n    const stateAttribute = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return open ? wasOpenDelayedRef.current ? \"delayed-open\" : \"instant-open\" : \"closed\";\n    }, [\n        open\n    ]);\n    const handleOpen = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        window.clearTimeout(openTimerRef.current);\n        openTimerRef.current = 0;\n        wasOpenDelayedRef.current = false;\n        setOpen(true);\n    }, [\n        setOpen\n    ]);\n    const handleClose = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        window.clearTimeout(openTimerRef.current);\n        openTimerRef.current = 0;\n        setOpen(false);\n    }, [\n        setOpen\n    ]);\n    const handleDelayedOpen = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        window.clearTimeout(openTimerRef.current);\n        openTimerRef.current = window.setTimeout(()=>{\n            wasOpenDelayedRef.current = true;\n            setOpen(true);\n            openTimerRef.current = 0;\n        }, delayDuration);\n    }, [\n        delayDuration,\n        setOpen\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            if (openTimerRef.current) {\n                window.clearTimeout(openTimerRef.current);\n                openTimerRef.current = 0;\n            }\n        };\n    }, []);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_popper__WEBPACK_IMPORTED_MODULE_3__.Root, {\n        ...popperScope,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TooltipContextProvider, {\n            scope: __scopeTooltip,\n            contentId,\n            open,\n            stateAttribute,\n            trigger,\n            onTriggerChange: setTrigger,\n            onTriggerEnter: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n                if (providerContext.isOpenDelayed) handleDelayedOpen();\n                else handleOpen();\n            }, [\n                providerContext.isOpenDelayed,\n                handleDelayedOpen,\n                handleOpen\n            ]),\n            onTriggerLeave: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n                if (disableHoverableContent) {\n                    handleClose();\n                } else {\n                    window.clearTimeout(openTimerRef.current);\n                    openTimerRef.current = 0;\n                }\n            }, [\n                handleClose,\n                disableHoverableContent\n            ]),\n            onOpen: handleOpen,\n            onClose: handleClose,\n            disableHoverableContent,\n            children\n        })\n    });\n};\nTooltip.displayName = TOOLTIP_NAME;\nvar TRIGGER_NAME = \"TooltipTrigger\";\nvar TooltipTrigger = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{\n    const { __scopeTooltip, ...triggerProps } = props;\n    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);\n    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const composedRefs = (0,_radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_6__.useComposedRefs)(forwardedRef, ref, context.onTriggerChange);\n    const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const hasPointerMoveOpenedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const handlePointerUp = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>isPointerDownRef.current = false, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>document.removeEventListener(\"pointerup\", handlePointerUp);\n    }, [\n        handlePointerUp\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_popper__WEBPACK_IMPORTED_MODULE_3__.Anchor, {\n        asChild: true,\n        ...popperScope,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_7__.Primitive.button, {\n            \"aria-describedby\": context.open ? context.contentId : void 0,\n            \"data-state\": context.stateAttribute,\n            ...triggerProps,\n            ref: composedRefs,\n            onPointerMove: (0,_radix_ui_primitive__WEBPACK_IMPORTED_MODULE_8__.composeEventHandlers)(props.onPointerMove, (event)=>{\n                if (event.pointerType === \"touch\") return;\n                if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {\n                    context.onTriggerEnter();\n                    hasPointerMoveOpenedRef.current = true;\n                }\n            }),\n            onPointerLeave: (0,_radix_ui_primitive__WEBPACK_IMPORTED_MODULE_8__.composeEventHandlers)(props.onPointerLeave, ()=>{\n                context.onTriggerLeave();\n                hasPointerMoveOpenedRef.current = false;\n            }),\n            onPointerDown: (0,_radix_ui_primitive__WEBPACK_IMPORTED_MODULE_8__.composeEventHandlers)(props.onPointerDown, ()=>{\n                isPointerDownRef.current = true;\n                document.addEventListener(\"pointerup\", handlePointerUp, {\n                    once: true\n                });\n            }),\n            onFocus: (0,_radix_ui_primitive__WEBPACK_IMPORTED_MODULE_8__.composeEventHandlers)(props.onFocus, ()=>{\n                if (!isPointerDownRef.current) context.onOpen();\n            }),\n            onBlur: (0,_radix_ui_primitive__WEBPACK_IMPORTED_MODULE_8__.composeEventHandlers)(props.onBlur, context.onClose),\n            onClick: (0,_radix_ui_primitive__WEBPACK_IMPORTED_MODULE_8__.composeEventHandlers)(props.onClick, context.onClose)\n        })\n    });\n});\nTooltipTrigger.displayName = TRIGGER_NAME;\nvar PORTAL_NAME = \"TooltipPortal\";\nvar [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME, {\n    forceMount: void 0\n});\nvar TooltipPortal = (props)=>{\n    const { __scopeTooltip, forceMount, children, container } = props;\n    const context = useTooltipContext(PORTAL_NAME, __scopeTooltip);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortalProvider, {\n        scope: __scopeTooltip,\n        forceMount,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_presence__WEBPACK_IMPORTED_MODULE_9__.Presence, {\n            present: forceMount || context.open,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_portal__WEBPACK_IMPORTED_MODULE_10__.Portal, {\n                asChild: true,\n                container,\n                children\n            })\n        })\n    });\n};\nTooltipPortal.displayName = PORTAL_NAME;\nvar CONTENT_NAME = \"TooltipContent\";\nvar TooltipContent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip);\n    const { forceMount = portalContext.forceMount, side = \"top\", ...contentProps } = props;\n    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_presence__WEBPACK_IMPORTED_MODULE_9__.Presence, {\n        present: forceMount || context.open,\n        children: context.disableHoverableContent ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TooltipContentImpl, {\n            side,\n            ...contentProps,\n            ref: forwardedRef\n        }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TooltipContentHoverable, {\n            side,\n            ...contentProps,\n            ref: forwardedRef\n        })\n    });\n});\nvar TooltipContentHoverable = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{\n    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n    const providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip);\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const composedRefs = (0,_radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_6__.useComposedRefs)(forwardedRef, ref);\n    const [pointerGraceArea, setPointerGraceArea] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const { trigger, onClose } = context;\n    const content = ref.current;\n    const { onPointerInTransitChange } = providerContext;\n    const handleRemoveGraceArea = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        setPointerGraceArea(null);\n        onPointerInTransitChange(false);\n    }, [\n        onPointerInTransitChange\n    ]);\n    const handleCreateGraceArea = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event, hoverTarget)=>{\n        const currentTarget = event.currentTarget;\n        const exitPoint = {\n            x: event.clientX,\n            y: event.clientY\n        };\n        const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());\n        const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);\n        const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());\n        const graceArea = getHull([\n            ...paddedExitPoints,\n            ...hoverTargetPoints\n        ]);\n        setPointerGraceArea(graceArea);\n        onPointerInTransitChange(true);\n    }, [\n        onPointerInTransitChange\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>handleRemoveGraceArea();\n    }, [\n        handleRemoveGraceArea\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (trigger && content) {\n            const handleTriggerLeave = (event)=>handleCreateGraceArea(event, content);\n            const handleContentLeave = (event)=>handleCreateGraceArea(event, trigger);\n            trigger.addEventListener(\"pointerleave\", handleTriggerLeave);\n            content.addEventListener(\"pointerleave\", handleContentLeave);\n            return ()=>{\n                trigger.removeEventListener(\"pointerleave\", handleTriggerLeave);\n                content.removeEventListener(\"pointerleave\", handleContentLeave);\n            };\n        }\n    }, [\n        trigger,\n        content,\n        handleCreateGraceArea,\n        handleRemoveGraceArea\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (pointerGraceArea) {\n            const handleTrackPointerGrace = (event)=>{\n                const target = event.target;\n                const pointerPosition = {\n                    x: event.clientX,\n                    y: event.clientY\n                };\n                const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);\n                const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);\n                if (hasEnteredTarget) {\n                    handleRemoveGraceArea();\n                } else if (isPointerOutsideGraceArea) {\n                    handleRemoveGraceArea();\n                    onClose();\n                }\n            };\n            document.addEventListener(\"pointermove\", handleTrackPointerGrace);\n            return ()=>document.removeEventListener(\"pointermove\", handleTrackPointerGrace);\n        }\n    }, [\n        trigger,\n        content,\n        pointerGraceArea,\n        onClose,\n        handleRemoveGraceArea\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TooltipContentImpl, {\n        ...props,\n        ref: composedRefs\n    });\n});\nvar [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, {\n    isInside: false\n});\nvar TooltipContentImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{\n    const { __scopeTooltip, children, \"aria-label\": ariaLabel, onEscapeKeyDown, onPointerDownOutside, ...contentProps } = props;\n    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const { onClose } = context;\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        document.addEventListener(TOOLTIP_OPEN, onClose);\n        return ()=>document.removeEventListener(TOOLTIP_OPEN, onClose);\n    }, [\n        onClose\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (context.trigger) {\n            const handleScroll = (event)=>{\n                const target = event.target;\n                if (target?.contains(context.trigger)) onClose();\n            };\n            window.addEventListener(\"scroll\", handleScroll, {\n                capture: true\n            });\n            return ()=>window.removeEventListener(\"scroll\", handleScroll, {\n                    capture: true\n                });\n        }\n    }, [\n        context.trigger,\n        onClose\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_dismissable_layer__WEBPACK_IMPORTED_MODULE_11__.DismissableLayer, {\n        asChild: true,\n        disableOutsidePointerEvents: false,\n        onEscapeKeyDown,\n        onPointerDownOutside,\n        onFocusOutside: (event)=>event.preventDefault(),\n        onDismiss: onClose,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_radix_ui_react_popper__WEBPACK_IMPORTED_MODULE_3__.Content, {\n            \"data-state\": context.stateAttribute,\n            ...popperScope,\n            ...contentProps,\n            ref: forwardedRef,\n            style: {\n                ...contentProps.style,\n                // re-namespace exposed content custom properties\n                ...{\n                    \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n                    \"--radix-tooltip-content-available-width\": \"var(--radix-popper-available-width)\",\n                    \"--radix-tooltip-content-available-height\": \"var(--radix-popper-available-height)\",\n                    \"--radix-tooltip-trigger-width\": \"var(--radix-popper-anchor-width)\",\n                    \"--radix-tooltip-trigger-height\": \"var(--radix-popper-anchor-height)\"\n                }\n            },\n            children: [\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_slot__WEBPACK_IMPORTED_MODULE_12__.Slottable, {\n                    children\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VisuallyHiddenContentContextProvider, {\n                    scope: __scopeTooltip,\n                    isInside: true,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_visually_hidden__WEBPACK_IMPORTED_MODULE_13__.Root, {\n                        id: context.contentId,\n                        role: \"tooltip\",\n                        children: ariaLabel || children\n                    })\n                })\n            ]\n        })\n    });\n});\nTooltipContent.displayName = CONTENT_NAME;\nvar ARROW_NAME = \"TooltipArrow\";\nvar TooltipArrow = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{\n    const { __scopeTooltip, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeTooltip);\n    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(ARROW_NAME, __scopeTooltip);\n    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_popper__WEBPACK_IMPORTED_MODULE_3__.Arrow, {\n        ...popperScope,\n        ...arrowProps,\n        ref: forwardedRef\n    });\n});\nTooltipArrow.displayName = ARROW_NAME;\nfunction getExitSideFromRect(point, rect) {\n    const top = Math.abs(rect.top - point.y);\n    const bottom = Math.abs(rect.bottom - point.y);\n    const right = Math.abs(rect.right - point.x);\n    const left = Math.abs(rect.left - point.x);\n    switch(Math.min(top, bottom, right, left)){\n        case left:\n            return \"left\";\n        case right:\n            return \"right\";\n        case top:\n            return \"top\";\n        case bottom:\n            return \"bottom\";\n        default:\n            throw new Error(\"unreachable\");\n    }\n}\nfunction getPaddedExitPoints(exitPoint, exitSide, padding = 5) {\n    const paddedExitPoints = [];\n    switch(exitSide){\n        case \"top\":\n            paddedExitPoints.push({\n                x: exitPoint.x - padding,\n                y: exitPoint.y + padding\n            }, {\n                x: exitPoint.x + padding,\n                y: exitPoint.y + padding\n            });\n            break;\n        case \"bottom\":\n            paddedExitPoints.push({\n                x: exitPoint.x - padding,\n                y: exitPoint.y - padding\n            }, {\n                x: exitPoint.x + padding,\n                y: exitPoint.y - padding\n            });\n            break;\n        case \"left\":\n            paddedExitPoints.push({\n                x: exitPoint.x + padding,\n                y: exitPoint.y - padding\n            }, {\n                x: exitPoint.x + padding,\n                y: exitPoint.y + padding\n            });\n            break;\n        case \"right\":\n            paddedExitPoints.push({\n                x: exitPoint.x - padding,\n                y: exitPoint.y - padding\n            }, {\n                x: exitPoint.x - padding,\n                y: exitPoint.y + padding\n            });\n            break;\n    }\n    return paddedExitPoints;\n}\nfunction getPointsFromRect(rect) {\n    const { top, right, bottom, left } = rect;\n    return [\n        {\n            x: left,\n            y: top\n        },\n        {\n            x: right,\n            y: top\n        },\n        {\n            x: right,\n            y: bottom\n        },\n        {\n            x: left,\n            y: bottom\n        }\n    ];\n}\nfunction isPointInPolygon(point, polygon) {\n    const { x, y } = point;\n    let inside = false;\n    for(let i = 0, j = polygon.length - 1; i < polygon.length; j = i++){\n        const xi = polygon[i].x;\n        const yi = polygon[i].y;\n        const xj = polygon[j].x;\n        const yj = polygon[j].y;\n        const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n        if (intersect) inside = !inside;\n    }\n    return inside;\n}\nfunction getHull(points) {\n    const newPoints = points.slice();\n    newPoints.sort((a, b)=>{\n        if (a.x < b.x) return -1;\n        else if (a.x > b.x) return 1;\n        else if (a.y < b.y) return -1;\n        else if (a.y > b.y) return 1;\n        else return 0;\n    });\n    return getHullPresorted(newPoints);\n}\nfunction getHullPresorted(points) {\n    if (points.length <= 1) return points.slice();\n    const upperHull = [];\n    for(let i = 0; i < points.length; i++){\n        const p = points[i];\n        while(upperHull.length >= 2){\n            const q = upperHull[upperHull.length - 1];\n            const r = upperHull[upperHull.length - 2];\n            if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) upperHull.pop();\n            else break;\n        }\n        upperHull.push(p);\n    }\n    upperHull.pop();\n    const lowerHull = [];\n    for(let i = points.length - 1; i >= 0; i--){\n        const p = points[i];\n        while(lowerHull.length >= 2){\n            const q = lowerHull[lowerHull.length - 1];\n            const r = lowerHull[lowerHull.length - 2];\n            if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) lowerHull.pop();\n            else break;\n        }\n        lowerHull.push(p);\n    }\n    lowerHull.pop();\n    if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {\n        return upperHull;\n    } else {\n        return upperHull.concat(lowerHull);\n    }\n}\nvar Provider = TooltipProvider;\nvar Root3 = Tooltip;\nvar Trigger = TooltipTrigger;\nvar Portal = TooltipPortal;\nvar Content2 = TooltipContent;\nvar Arrow2 = TooltipArrow;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QtdWkvbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC10b29sdGlwL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUI7QUFDYztBQUNMO0FBQ0c7QUFDRjtBQUNYO0FBQ1c7QUFDQztBQUNRO0FBQ2pCO0FBQ0M7QUFDQTtBQUNXO0FBQ0k7QUFzRXJDO0FBakVKLElBQU0sQ0FBQ2lCLHNCQUFzQkMsbUJBQWtCLEdBQUlmLDJFQUFrQkEsQ0FBQyxXQUFXO0lBQy9FSSxxRUFBaUJBO0NBQ2xCO0FBQ0QsSUFBTVksaUJBQWlCWix5RUFBaUJBO0FBTXhDLElBQU1hLGdCQUFnQjtBQUN0QixJQUFNQyx5QkFBeUI7QUFDL0IsSUFBTUMsZUFBZTtBQVlyQixJQUFNLENBQUNDLGdDQUFnQ0MsMEJBQXlCLEdBQzlEUCxxQkFBa0RHO0FBcUJwRCxJQUFNSyxrQkFBa0QsQ0FDdERDO0lBRUEsTUFBTSxFQUNKQyxjQUFBLEVBQ0FDLGdCQUFnQlAsc0JBQUEsRUFDaEJRLG9CQUFvQixLQUNwQkMsMEJBQTBCLE9BQzFCQyxRQUFBLEVBQ0YsR0FBSUw7SUFDSixNQUFNLENBQUNNLGVBQWVDLGlCQUFnQixHQUFVakMsMkNBQUEsQ0FBUztJQUN6RCxNQUFNbUMsd0JBQThCbkMseUNBQUEsQ0FBTztJQUMzQyxNQUFNcUMsb0JBQTBCckMseUNBQUEsQ0FBTztJQUVqQ0EsNENBQUEsQ0FBVTtRQUNkLE1BQU11QyxpQkFBaUJGLGtCQUFrQkcsT0FBQTtRQUN6QyxPQUFPLElBQU1DLE9BQU9DLFlBQUEsQ0FBYUg7SUFDbkMsR0FBRyxFQUFFO0lBRUwsT0FDRSxnQkFBQXhCLHNEQUFBQSxDQUFDUSxnQ0FBQTtRQUNDb0IsT0FBT2hCO1FBQ1BLO1FBQ0FKO1FBQ0FnQixRQUFjNUMsOENBQUEsQ0FBWTtZQUN4QnlDLE9BQU9DLFlBQUEsQ0FBYUwsa0JBQWtCRyxP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LEtBQUtlLEVBQUUxRSxDQUFBLEdBQUkyRSxFQUFFM0UsQ0FBQSxJQUFNeUUsQ0FBQUEsRUFBRXZFLENBQUEsR0FBSXlFLEVBQUV6RSxDQUFBLE1BQU93RSxFQUFFeEUsQ0FBQSxHQUFJeUUsRUFBRXpFLENBQUEsSUFBTXVFLENBQUFBLEVBQUV6RSxDQUFBLEdBQUkyRSxFQUFFM0UsQ0FBQSxHQUFJNkUsVUFBVUQsR0FBQTtpQkFDakU7UUFDUDtRQUNBQyxVQUFVdkIsSUFBQSxDQUFLbUI7SUFDakI7SUFDQUksVUFBVUQsR0FBQTtJQUVWLElBQ0VKLFVBQVViLE1BQUEsS0FBVyxLQUNyQmtCLFVBQVVsQixNQUFBLEtBQVcsS0FDckJhLFNBQUEsQ0FBVSxFQUFDLENBQUV4RSxDQUFBLEtBQU02RSxTQUFBLENBQVUsRUFBQyxDQUFFN0UsQ0FBQSxJQUNoQ3dFLFNBQUEsQ0FBVSxFQUFDLENBQUV0RSxDQUFBLEtBQU0yRSxTQUFBLENBQVUsRUFBQyxDQUFFM0UsQ0FBQSxFQUNoQztRQUNBLE9BQU9zRTtJQUNULE9BQU87UUFDTCxPQUFPQSxVQUFVTSxNQUFBLENBQU9EO0lBQzFCO0FBQ0Y7QUFFQSxJQUFNRSxXQUFXekw7QUFDakIsSUFBTXVELFFBQU8xQjtBQUNiLElBQU02SixVQUFVOUg7QUFDaEIsSUFBTTdFLFNBQVN5RztBQUNmLElBQU1vRCxXQUFVaEQ7QUFDaEIsSUFBTXdELFNBQVFIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uLi9zcmMvdG9vbHRpcC50c3g/ZTI3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb21wb3NlRXZlbnRIYW5kbGVycyB9IGZyb20gJ0ByYWRpeC11aS9wcmltaXRpdmUnO1xuaW1wb3J0IHsgdXNlQ29tcG9zZWRSZWZzIH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LWNvbXBvc2UtcmVmcyc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0U2NvcGUgfSBmcm9tICdAcmFkaXgtdWkvcmVhY3QtY29udGV4dCc7XG5pbXBvcnQgeyBEaXNtaXNzYWJsZUxheWVyIH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LWRpc21pc3NhYmxlLWxheWVyJztcbmltcG9ydCB7IHVzZUlkIH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LWlkJztcbmltcG9ydCAqIGFzIFBvcHBlclByaW1pdGl2ZSBmcm9tICdAcmFkaXgtdWkvcmVhY3QtcG9wcGVyJztcbmltcG9ydCB7IGNyZWF0ZVBvcHBlclNjb3BlIH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LXBvcHBlcic7XG5pbXBvcnQgeyBQb3J0YWwgYXMgUG9ydGFsUHJpbWl0aXZlIH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LXBvcnRhbCc7XG5pbXBvcnQgeyBQcmVzZW5jZSB9IGZyb20gJ0ByYWRpeC11aS9yZWFjdC1wcmVzZW5jZSc7XG5pbXBvcnQgeyBQcmltaXRpdmUgfSBmcm9tICdAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlJztcbmltcG9ydCB7IFNsb3R0YWJsZSB9IGZyb20gJ0ByYWRpeC11aS9yZWFjdC1zbG90JztcbmltcG9ydCB7IHVzZUNvbnRyb2xsYWJsZVN0YXRlIH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LXVzZS1jb250cm9sbGFibGUtc3RhdGUnO1xuaW1wb3J0ICogYXMgVmlzdWFsbHlIaWRkZW5QcmltaXRpdmUgZnJvbSAnQHJhZGl4LXVpL3JlYWN0LXZpc3VhbGx5LWhpZGRlbic7XG5cbmltcG9ydCB0eXBlIHsgU2NvcGUgfSBmcm9tICdAcmFkaXgtdWkvcmVhY3QtY29udGV4dCc7XG5cbnR5cGUgU2NvcGVkUHJvcHM8UCA9IHt9PiA9IFAgJiB7IF9fc2NvcGVUb29sdGlwPzogU2NvcGUgfTtcbmNvbnN0IFtjcmVhdGVUb29sdGlwQ29udGV4dCwgY3JlYXRlVG9vbHRpcFNjb3BlXSA9IGNyZWF0ZUNvbnRleHRTY29wZSgnVG9vbHRpcCcsIFtcbiAgY3JlYXRlUG9wcGVyU2NvcGUsXG5dKTtcbmNvbnN0IHVzZVBvcHBlclNjb3BlID0gY3JlYXRlUG9wcGVyU2NvcGUoKTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVG9vbHRpcFByb3ZpZGVyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmNvbnN0IFBST1ZJREVSX05BTUUgPSAnVG9vbHRpcFByb3ZpZGVyJztcbmNvbnN0IERFRkFVTFRfREVMQVlfRFVSQVRJT04gPSA3MDA7XG5jb25zdCBUT09MVElQX09QRU4gPSAndG9vbHRpcC5vcGVuJztcblxudHlwZSBUb29sdGlwUHJvdmlkZXJDb250ZXh0VmFsdWUgPSB7XG4gIGlzT3BlbkRlbGF5ZWQ6IGJvb2xlYW47XG4gIGRlbGF5RHVyYXRpb246IG51bWJlcjtcbiAgb25PcGVuKCk6IHZvaWQ7XG4gIG9uQ2xvc2UoKTogdm9pZDtcbiAgb25Qb2ludGVySW5UcmFuc2l0Q2hhbmdlKGluVHJhbnNpdDogYm9vbGVhbik6IHZvaWQ7XG4gIGlzUG9pbnRlckluVHJhbnNpdFJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxib29sZWFuPjtcbiAgZGlzYWJsZUhvdmVyYWJsZUNvbnRlbnQ6IGJvb2xlYW47XG59O1xuXG5jb25zdCBbVG9vbHRpcFByb3ZpZGVyQ29udGV4dFByb3ZpZGVyLCB1c2VUb29sdGlwUHJvdmlkZXJDb250ZXh0XSA9XG4gIGNyZWF0ZVRvb2x0aXBDb250ZXh0PFRvb2x0aXBQcm92aWRlckNvbnRleHRWYWx1ZT4oUFJPVklERVJfTkFNRSk7XG5cbmludGVyZmFjZSBUb29sdGlwUHJvdmlkZXJQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gZnJvbSB3aGVuIHRoZSBwb2ludGVyIGVudGVycyB0aGUgdHJpZ2dlciB1bnRpbCB0aGUgdG9vbHRpcCBnZXRzIG9wZW5lZC5cbiAgICogQGRlZmF1bHRWYWx1ZSA3MDBcbiAgICovXG4gIGRlbGF5RHVyYXRpb24/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBIb3cgbXVjaCB0aW1lIGEgdXNlciBoYXMgdG8gZW50ZXIgYW5vdGhlciB0cmlnZ2VyIHdpdGhvdXQgaW5jdXJyaW5nIGEgZGVsYXkgYWdhaW4uXG4gICAqIEBkZWZhdWx0VmFsdWUgMzAwXG4gICAqL1xuICBza2lwRGVsYXlEdXJhdGlvbj86IG51bWJlcjtcbiAgLyoqXG4gICAqIFdoZW4gYHRydWVgLCB0cnlpbmcgdG8gaG92ZXIgdGhlIGNvbnRlbnQgd2lsbCByZXN1bHQgaW4gdGhlIHRvb2x0aXAgY2xvc2luZyBhcyB0aGUgcG9pbnRlciBsZWF2ZXMgdGhlIHRyaWdnZXIuXG4gICAqIEBkZWZhdWx0VmFsdWUgZmFsc2VcbiAgICovXG4gIGRpc2FibGVIb3ZlcmFibGVDb250ZW50PzogYm9vbGVhbjtcbn1cblxuY29uc3QgVG9vbHRpcFByb3ZpZGVyOiBSZWFjdC5GQzxUb29sdGlwUHJvdmlkZXJQcm9wcz4gPSAoXG4gIHByb3BzOiBTY29wZWRQcm9wczxUb29sdGlwUHJvdmlkZXJQcm9wcz5cbikgPT4ge1xuICBjb25zdCB7XG4gICAgX19zY29wZVRvb2x0aXAsXG4gICAgZGVsYXlEdXJhdGlvbiA9IERFRkFVTFRfREVMQVlfRFVSQVRJT04sXG4gICAgc2tpcERlbGF5RHVyYXRpb24gPSAzMDAsXG4gICAgZGlzYWJsZUhvdmVyYWJsZUNvbnRlbnQgPSBmYWxzZSxcbiAgICBjaGlsZHJlbixcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbaXNPcGVuRGVsYXllZCwgc2V0SXNPcGVuRGVsYXllZF0gPSBSZWFjdC51c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgaXNQb2ludGVySW5UcmFuc2l0UmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3Qgc2tpcERlbGF5VGltZXJSZWYgPSBSZWFjdC51c2VSZWYoMCk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBza2lwRGVsYXlUaW1lciA9IHNraXBEZWxheVRpbWVyUmVmLmN1cnJlbnQ7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5jbGVhclRpbWVvdXQoc2tpcERlbGF5VGltZXIpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8VG9vbHRpcFByb3ZpZGVyQ29udGV4dFByb3ZpZGVyXG4gICAgICBzY29wZT17X19zY29wZVRvb2x0aXB9XG4gICAgICBpc09wZW5EZWxheWVkPXtpc09wZW5EZWxheWVkfVxuICAgICAgZGVsYXlEdXJhdGlvbj17ZGVsYXlEdXJhdGlvbn1cbiAgICAgIG9uT3Blbj17UmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHNraXBEZWxheVRpbWVyUmVmLmN1cnJlbnQpO1xuICAgICAgICBzZXRJc09wZW5EZWxheWVkKGZhbHNlKTtcbiAgICAgIH0sIFtdKX1cbiAgICAgIG9uQ2xvc2U9e1JlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChza2lwRGVsYXlUaW1lclJlZi5jdXJyZW50KTtcbiAgICAgICAgc2tpcERlbGF5VGltZXJSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KFxuICAgICAgICAgICgpID0+IHNldElzT3BlbkRlbGF5ZWQodHJ1ZSksXG4gICAgICAgICAgc2tpcERlbGF5RHVyYXRpb25cbiAgICAgICAgKTtcbiAgICAgIH0sIFtza2lwRGVsYXlEdXJhdGlvbl0pfVxuICAgICAgaXNQb2ludGVySW5UcmFuc2l0UmVmPXtpc1BvaW50ZXJJblRyYW5zaXRSZWZ9XG4gICAgICBvblBvaW50ZXJJblRyYW5zaXRDaGFuZ2U9e1JlYWN0LnVzZUNhbGxiYWNrKChpblRyYW5zaXQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaXNQb2ludGVySW5UcmFuc2l0UmVmLmN1cnJlbnQgPSBpblRyYW5zaXQ7XG4gICAgICB9LCBbXSl9XG4gICAgICBkaXNhYmxlSG92ZXJhYmxlQ29udGVudD17ZGlzYWJsZUhvdmVyYWJsZUNvbnRlbnR9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvVG9vbHRpcFByb3ZpZGVyQ29udGV4dFByb3ZpZGVyPlxuICApO1xufTtcblxuVG9vbHRpcFByb3ZpZGVyLmRpc3BsYXlOYW1lID0gUFJPVklERVJfTkFNRTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVG9vbHRpcFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5jb25zdCBUT09MVElQX05BTUUgPSAnVG9vbHRpcCc7XG5cbnR5cGUgVG9vbHRpcENvbnRleHRWYWx1ZSA9IHtcbiAgY29udGVudElkOiBzdHJpbmc7XG4gIG9wZW46IGJvb2xlYW47XG4gIHN0YXRlQXR0cmlidXRlOiAnY2xvc2VkJyB8ICdkZWxheWVkLW9wZW4nIHwgJ2luc3RhbnQtb3Blbic7XG4gIHRyaWdnZXI6IFRvb2x0aXBUcmlnZ2VyRWxlbWVudCB8IG51bGw7XG4gIG9uVHJpZ2dlckNoYW5nZSh0cmlnZ2VyOiBUb29sdGlwVHJpZ2dlckVsZW1lbnQgfCBudWxsKTogdm9pZDtcbiAgb25UcmlnZ2VyRW50ZXIoKTogdm9pZDtcbiAgb25UcmlnZ2VyTGVhdmUoKTogdm9pZDtcbiAgb25PcGVuKCk6IHZvaWQ7XG4gIG9uQ2xvc2UoKTogdm9pZDtcbiAgZGlzYWJsZUhvdmVyYWJsZUNvbnRlbnQ6IGJvb2xlYW47XG59O1xuXG5jb25zdCBbVG9vbHRpcENvbnRleHRQcm92aWRlciwgdXNlVG9vbHRpcENvbnRleHRdID1cbiAgY3JlYXRlVG9vbHRpcENvbnRleHQ8VG9vbHRpcENvbnRleHRWYWx1ZT4oVE9PTFRJUF9OQU1FKTtcblxuaW50ZXJmYWNlIFRvb2x0aXBQcm9wcyB7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBvcGVuPzogYm9vbGVhbjtcbiAgZGVmYXVsdE9wZW4/OiBib29sZWFuO1xuICBvbk9wZW5DaGFuZ2U/OiAob3BlbjogYm9vbGVhbikgPT4gdm9pZDtcbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiBmcm9tIHdoZW4gdGhlIHBvaW50ZXIgZW50ZXJzIHRoZSB0cmlnZ2VyIHVudGlsIHRoZSB0b29sdGlwIGdldHMgb3BlbmVkLiBUaGlzIHdpbGxcbiAgICogb3ZlcnJpZGUgdGhlIHByb3Agd2l0aCB0aGUgc2FtZSBuYW1lIHBhc3NlZCB0byBQcm92aWRlci5cbiAgICogQGRlZmF1bHRWYWx1ZSA3MDBcbiAgICovXG4gIGRlbGF5RHVyYXRpb24/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBXaGVuIGB0cnVlYCwgdHJ5aW5nIHRvIGhvdmVyIHRoZSBjb250ZW50IHdpbGwgcmVzdWx0IGluIHRoZSB0b29sdGlwIGNsb3NpbmcgYXMgdGhlIHBvaW50ZXIgbGVhdmVzIHRoZSB0cmlnZ2VyLlxuICAgKiBAZGVmYXVsdFZhbHVlIGZhbHNlXG4gICAqL1xuICBkaXNhYmxlSG92ZXJhYmxlQ29udGVudD86IGJvb2xlYW47XG59XG5cbmNvbnN0IFRvb2x0aXA6IFJlYWN0LkZDPFRvb2x0aXBQcm9wcz4gPSAocHJvcHM6IFNjb3BlZFByb3BzPFRvb2x0aXBQcm9wcz4pID0+IHtcbiAgY29uc3Qge1xuICAgIF9fc2NvcGVUb29sdGlwLFxuICAgIGNoaWxkcmVuLFxuICAgIG9wZW46IG9wZW5Qcm9wLFxuICAgIGRlZmF1bHRPcGVuID0gZmFsc2UsXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRpc2FibGVIb3ZlcmFibGVDb250ZW50OiBkaXNhYmxlSG92ZXJhYmxlQ29udGVudFByb3AsXG4gICAgZGVsYXlEdXJhdGlvbjogZGVsYXlEdXJhdGlvblByb3AsXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcHJvdmlkZXJDb250ZXh0ID0gdXNlVG9vbHRpcFByb3ZpZGVyQ29udGV4dChUT09MVElQX05BTUUsIHByb3BzLl9fc2NvcGVUb29sdGlwKTtcbiAgY29uc3QgcG9wcGVyU2NvcGUgPSB1c2VQb3BwZXJTY29wZShfX3Njb3BlVG9vbHRpcCk7XG4gIGNvbnN0IFt0cmlnZ2VyLCBzZXRUcmlnZ2VyXSA9IFJlYWN0LnVzZVN0YXRlPEhUTUxCdXR0b25FbGVtZW50IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGNvbnRlbnRJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IG9wZW5UaW1lclJlZiA9IFJlYWN0LnVzZVJlZigwKTtcbiAgY29uc3QgZGlzYWJsZUhvdmVyYWJsZUNvbnRlbnQgPVxuICAgIGRpc2FibGVIb3ZlcmFibGVDb250ZW50UHJvcCA/PyBwcm92aWRlckNvbnRleHQuZGlzYWJsZUhvdmVyYWJsZUNvbnRlbnQ7XG4gIGNvbnN0IGRlbGF5RHVyYXRpb24gPSBkZWxheUR1cmF0aW9uUHJvcCA/PyBwcm92aWRlckNvbnRleHQuZGVsYXlEdXJhdGlvbjtcbiAgY29uc3Qgd2FzT3BlbkRlbGF5ZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBbb3BlbiA9IGZhbHNlLCBzZXRPcGVuXSA9IHVzZUNvbnRyb2xsYWJsZVN0YXRlKHtcbiAgICBwcm9wOiBvcGVuUHJvcCxcbiAgICBkZWZhdWx0UHJvcDogZGVmYXVsdE9wZW4sXG4gICAgb25DaGFuZ2U6IChvcGVuKSA9PiB7XG4gICAgICBpZiAob3Blbikge1xuICAgICAgICBwcm92aWRlckNvbnRleHQub25PcGVuKCk7XG5cbiAgICAgICAgLy8gYXMgYG9uQ2hhbmdlYCBpcyBjYWxsZWQgd2l0aGluIGEgbGlmZWN5Y2xlIG1ldGhvZCB3ZVxuICAgICAgICAvLyBhdm9pZCBkaXNwYXRjaGluZyB2aWEgYGRpc3BhdGNoRGlzY3JldGVDdXN0b21FdmVudGAuXG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFRPT0xUSVBfT1BFTikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdmlkZXJDb250ZXh0Lm9uQ2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIG9uT3BlbkNoYW5nZT8uKG9wZW4pO1xuICAgIH0sXG4gIH0pO1xuICBjb25zdCBzdGF0ZUF0dHJpYnV0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBvcGVuID8gKHdhc09wZW5EZWxheWVkUmVmLmN1cnJlbnQgPyAnZGVsYXllZC1vcGVuJyA6ICdpbnN0YW50LW9wZW4nKSA6ICdjbG9zZWQnO1xuICB9LCBbb3Blbl0pO1xuXG4gIGNvbnN0IGhhbmRsZU9wZW4gPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dChvcGVuVGltZXJSZWYuY3VycmVudCk7XG4gICAgb3BlblRpbWVyUmVmLmN1cnJlbnQgPSAwO1xuICAgIHdhc09wZW5EZWxheWVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBzZXRPcGVuKHRydWUpO1xuICB9LCBbc2V0T3Blbl0pO1xuXG4gIGNvbnN0IGhhbmRsZUNsb3NlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQob3BlblRpbWVyUmVmLmN1cnJlbnQpO1xuICAgIG9wZW5UaW1lclJlZi5jdXJyZW50ID0gMDtcbiAgICBzZXRPcGVuKGZhbHNlKTtcbiAgfSwgW3NldE9wZW5dKTtcblxuICBjb25zdCBoYW5kbGVEZWxheWVkT3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KG9wZW5UaW1lclJlZi5jdXJyZW50KTtcbiAgICBvcGVuVGltZXJSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHdhc09wZW5EZWxheWVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgc2V0T3Blbih0cnVlKTtcbiAgICAgIG9wZW5UaW1lclJlZi5jdXJyZW50ID0gMDtcbiAgICB9LCBkZWxheUR1cmF0aW9uKTtcbiAgfSwgW2RlbGF5RHVyYXRpb24sIHNldE9wZW5dKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAob3BlblRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChvcGVuVGltZXJSZWYuY3VycmVudCk7XG4gICAgICAgIG9wZW5UaW1lclJlZi5jdXJyZW50ID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8UG9wcGVyUHJpbWl0aXZlLlJvb3Qgey4uLnBvcHBlclNjb3BlfT5cbiAgICAgIDxUb29sdGlwQ29udGV4dFByb3ZpZGVyXG4gICAgICAgIHNjb3BlPXtfX3Njb3BlVG9vbHRpcH1cbiAgICAgICAgY29udGVudElkPXtjb250ZW50SWR9XG4gICAgICAgIG9wZW49e29wZW59XG4gICAgICAgIHN0YXRlQXR0cmlidXRlPXtzdGF0ZUF0dHJpYnV0ZX1cbiAgICAgICAgdHJpZ2dlcj17dHJpZ2dlcn1cbiAgICAgICAgb25UcmlnZ2VyQ2hhbmdlPXtzZXRUcmlnZ2VyfVxuICAgICAgICBvblRyaWdnZXJFbnRlcj17UmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgIGlmIChwcm92aWRlckNvbnRleHQuaXNPcGVuRGVsYXllZCkgaGFuZGxlRGVsYXllZE9wZW4oKTtcbiAgICAgICAgICBlbHNlIGhhbmRsZU9wZW4oKTtcbiAgICAgICAgfSwgW3Byb3ZpZGVyQ29udGV4dC5pc09wZW5EZWxheWVkLCBoYW5kbGVEZWxheWVkT3BlbiwgaGFuZGxlT3Blbl0pfVxuICAgICAgICBvblRyaWdnZXJMZWF2ZT17UmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgIGlmIChkaXNhYmxlSG92ZXJhYmxlQ29udGVudCkge1xuICAgICAgICAgICAgaGFuZGxlQ2xvc2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVyIGluIGNhc2UgdGhlIHBvaW50ZXIgbGVhdmVzIHRoZSB0cmlnZ2VyIGJlZm9yZSB0aGUgdG9vbHRpcCBpcyBvcGVuZWQuXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KG9wZW5UaW1lclJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIG9wZW5UaW1lclJlZi5jdXJyZW50ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFtoYW5kbGVDbG9zZSwgZGlzYWJsZUhvdmVyYWJsZUNvbnRlbnRdKX1cbiAgICAgICAgb25PcGVuPXtoYW5kbGVPcGVufVxuICAgICAgICBvbkNsb3NlPXtoYW5kbGVDbG9zZX1cbiAgICAgICAgZGlzYWJsZUhvdmVyYWJsZUNvbnRlbnQ9e2Rpc2FibGVIb3ZlcmFibGVDb250ZW50fVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L1Rvb2x0aXBDb250ZXh0UHJvdmlkZXI+XG4gICAgPC9Qb3BwZXJQcmltaXRpdmUuUm9vdD5cbiAgKTtcbn07XG5cblRvb2x0aXAuZGlzcGxheU5hbWUgPSBUT09MVElQX05BTUU7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRvb2x0aXBUcmlnZ2VyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmNvbnN0IFRSSUdHRVJfTkFNRSA9ICdUb29sdGlwVHJpZ2dlcic7XG5cbnR5cGUgVG9vbHRpcFRyaWdnZXJFbGVtZW50ID0gUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgUHJpbWl0aXZlLmJ1dHRvbj47XG50eXBlIFByaW1pdGl2ZUJ1dHRvblByb3BzID0gUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBQcmltaXRpdmUuYnV0dG9uPjtcbmludGVyZmFjZSBUb29sdGlwVHJpZ2dlclByb3BzIGV4dGVuZHMgUHJpbWl0aXZlQnV0dG9uUHJvcHMge31cblxuY29uc3QgVG9vbHRpcFRyaWdnZXIgPSBSZWFjdC5mb3J3YXJkUmVmPFRvb2x0aXBUcmlnZ2VyRWxlbWVudCwgVG9vbHRpcFRyaWdnZXJQcm9wcz4oXG4gIChwcm9wczogU2NvcGVkUHJvcHM8VG9vbHRpcFRyaWdnZXJQcm9wcz4sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVRvb2x0aXAsIC4uLnRyaWdnZXJQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVRvb2x0aXBDb250ZXh0KFRSSUdHRVJfTkFNRSwgX19zY29wZVRvb2x0aXApO1xuICAgIGNvbnN0IHByb3ZpZGVyQ29udGV4dCA9IHVzZVRvb2x0aXBQcm92aWRlckNvbnRleHQoVFJJR0dFUl9OQU1FLCBfX3Njb3BlVG9vbHRpcCk7XG4gICAgY29uc3QgcG9wcGVyU2NvcGUgPSB1c2VQb3BwZXJTY29wZShfX3Njb3BlVG9vbHRpcCk7XG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmPFRvb2x0aXBUcmlnZ2VyRWxlbWVudD4obnVsbCk7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgcmVmLCBjb250ZXh0Lm9uVHJpZ2dlckNoYW5nZSk7XG4gICAgY29uc3QgaXNQb2ludGVyRG93blJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgaGFzUG9pbnRlck1vdmVPcGVuZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGhhbmRsZVBvaW50ZXJVcCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IChpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQgPSBmYWxzZSksIFtdKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgaGFuZGxlUG9pbnRlclVwKTtcbiAgICB9LCBbaGFuZGxlUG9pbnRlclVwXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFBvcHBlclByaW1pdGl2ZS5BbmNob3IgYXNDaGlsZCB7Li4ucG9wcGVyU2NvcGV9PlxuICAgICAgICA8UHJpbWl0aXZlLmJ1dHRvblxuICAgICAgICAgIC8vIFdlIHB1cnBvc2VmdWxseSBhdm9pZCBhZGRpbmcgYHR5cGU9YnV0dG9uYCBoZXJlIGJlY2F1c2UgdG9vbHRpcCB0cmlnZ2VycyBhcmUgYWxzb1xuICAgICAgICAgIC8vIGNvbW1vbmx5IGFuY2hvcnMgYW5kIHRoZSBhbmNob3IgYHR5cGVgIGF0dHJpYnV0ZSBzaWduaWZpZXMgTUlNRSB0eXBlLlxuICAgICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9e2NvbnRleHQub3BlbiA/IGNvbnRleHQuY29udGVudElkIDogdW5kZWZpbmVkfVxuICAgICAgICAgIGRhdGEtc3RhdGU9e2NvbnRleHQuc3RhdGVBdHRyaWJ1dGV9XG4gICAgICAgICAgey4uLnRyaWdnZXJQcm9wc31cbiAgICAgICAgICByZWY9e2NvbXBvc2VkUmVmc31cbiAgICAgICAgICBvblBvaW50ZXJNb3ZlPXtjb21wb3NlRXZlbnRIYW5kbGVycyhwcm9wcy5vblBvaW50ZXJNb3ZlLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhaGFzUG9pbnRlck1vdmVPcGVuZWRSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgICAhcHJvdmlkZXJDb250ZXh0LmlzUG9pbnRlckluVHJhbnNpdFJlZi5jdXJyZW50XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGV4dC5vblRyaWdnZXJFbnRlcigpO1xuICAgICAgICAgICAgICBoYXNQb2ludGVyTW92ZU9wZW5lZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KX1cbiAgICAgICAgICBvblBvaW50ZXJMZWF2ZT17Y29tcG9zZUV2ZW50SGFuZGxlcnMocHJvcHMub25Qb2ludGVyTGVhdmUsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRleHQub25UcmlnZ2VyTGVhdmUoKTtcbiAgICAgICAgICAgIGhhc1BvaW50ZXJNb3ZlT3BlbmVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9KX1cbiAgICAgICAgICBvblBvaW50ZXJEb3duPXtjb21wb3NlRXZlbnRIYW5kbGVycyhwcm9wcy5vblBvaW50ZXJEb3duLCAoKSA9PiB7XG4gICAgICAgICAgICBpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgaGFuZGxlUG9pbnRlclVwLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgfSl9XG4gICAgICAgICAgb25Gb2N1cz17Y29tcG9zZUV2ZW50SGFuZGxlcnMocHJvcHMub25Gb2N1cywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQpIGNvbnRleHQub25PcGVuKCk7XG4gICAgICAgICAgfSl9XG4gICAgICAgICAgb25CbHVyPXtjb21wb3NlRXZlbnRIYW5kbGVycyhwcm9wcy5vbkJsdXIsIGNvbnRleHQub25DbG9zZSl9XG4gICAgICAgICAgb25DbGljaz17Y29tcG9zZUV2ZW50SGFuZGxlcnMocHJvcHMub25DbGljaywgY29udGV4dC5vbkNsb3NlKX1cbiAgICAgICAgLz5cbiAgICAgIDwvUG9wcGVyUHJpbWl0aXZlLkFuY2hvcj5cbiAgICApO1xuICB9XG4pO1xuXG5Ub29sdGlwVHJpZ2dlci5kaXNwbGF5TmFtZSA9IFRSSUdHRVJfTkFNRTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVG9vbHRpcFBvcnRhbFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5jb25zdCBQT1JUQUxfTkFNRSA9ICdUb29sdGlwUG9ydGFsJztcblxudHlwZSBQb3J0YWxDb250ZXh0VmFsdWUgPSB7IGZvcmNlTW91bnQ/OiB0cnVlIH07XG5jb25zdCBbUG9ydGFsUHJvdmlkZXIsIHVzZVBvcnRhbENvbnRleHRdID0gY3JlYXRlVG9vbHRpcENvbnRleHQ8UG9ydGFsQ29udGV4dFZhbHVlPihQT1JUQUxfTkFNRSwge1xuICBmb3JjZU1vdW50OiB1bmRlZmluZWQsXG59KTtcblxudHlwZSBQb3J0YWxQcm9wcyA9IFJlYWN0LkNvbXBvbmVudFByb3BzV2l0aG91dFJlZjx0eXBlb2YgUG9ydGFsUHJpbWl0aXZlPjtcbmludGVyZmFjZSBUb29sdGlwUG9ydGFsUHJvcHMge1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgLyoqXG4gICAqIFNwZWNpZnkgYSBjb250YWluZXIgZWxlbWVudCB0byBwb3J0YWwgdGhlIGNvbnRlbnQgaW50by5cbiAgICovXG4gIGNvbnRhaW5lcj86IFBvcnRhbFByb3BzWydjb250YWluZXInXTtcbiAgLyoqXG4gICAqIFVzZWQgdG8gZm9yY2UgbW91bnRpbmcgd2hlbiBtb3JlIGNvbnRyb2wgaXMgbmVlZGVkLiBVc2VmdWwgd2hlblxuICAgKiBjb250cm9sbGluZyBhbmltYXRpb24gd2l0aCBSZWFjdCBhbmltYXRpb24gbGlicmFyaWVzLlxuICAgKi9cbiAgZm9yY2VNb3VudD86IHRydWU7XG59XG5cbmNvbnN0IFRvb2x0aXBQb3J0YWw6IFJlYWN0LkZDPFRvb2x0aXBQb3J0YWxQcm9wcz4gPSAocHJvcHM6IFNjb3BlZFByb3BzPFRvb2x0aXBQb3J0YWxQcm9wcz4pID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlVG9vbHRpcCwgZm9yY2VNb3VudCwgY2hpbGRyZW4sIGNvbnRhaW5lciB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VUb29sdGlwQ29udGV4dChQT1JUQUxfTkFNRSwgX19zY29wZVRvb2x0aXApO1xuICByZXR1cm4gKFxuICAgIDxQb3J0YWxQcm92aWRlciBzY29wZT17X19zY29wZVRvb2x0aXB9IGZvcmNlTW91bnQ9e2ZvcmNlTW91bnR9PlxuICAgICAgPFByZXNlbmNlIHByZXNlbnQ9e2ZvcmNlTW91bnQgfHwgY29udGV4dC5vcGVufT5cbiAgICAgICAgPFBvcnRhbFByaW1pdGl2ZSBhc0NoaWxkIGNvbnRhaW5lcj17Y29udGFpbmVyfT5cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvUG9ydGFsUHJpbWl0aXZlPlxuICAgICAgPC9QcmVzZW5jZT5cbiAgICA8L1BvcnRhbFByb3ZpZGVyPlxuICApO1xufTtcblxuVG9vbHRpcFBvcnRhbC5kaXNwbGF5TmFtZSA9IFBPUlRBTF9OQU1FO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUb29sdGlwQ29udGVudFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5jb25zdCBDT05URU5UX05BTUUgPSAnVG9vbHRpcENvbnRlbnQnO1xuXG50eXBlIFRvb2x0aXBDb250ZW50RWxlbWVudCA9IFRvb2x0aXBDb250ZW50SW1wbEVsZW1lbnQ7XG5pbnRlcmZhY2UgVG9vbHRpcENvbnRlbnRQcm9wcyBleHRlbmRzIFRvb2x0aXBDb250ZW50SW1wbFByb3BzIHtcbiAgLyoqXG4gICAqIFVzZWQgdG8gZm9yY2UgbW91bnRpbmcgd2hlbiBtb3JlIGNvbnRyb2wgaXMgbmVlZGVkLiBVc2VmdWwgd2hlblxuICAgKiBjb250cm9sbGluZyBhbmltYXRpb24gd2l0aCBSZWFjdCBhbmltYXRpb24gbGlicmFyaWVzLlxuICAgKi9cbiAgZm9yY2VNb3VudD86IHRydWU7XG59XG5cbmNvbnN0IFRvb2x0aXBDb250ZW50ID0gUmVhY3QuZm9yd2FyZFJlZjxUb29sdGlwQ29udGVudEVsZW1lbnQsIFRvb2x0aXBDb250ZW50UHJvcHM+KFxuICAocHJvcHM6IFNjb3BlZFByb3BzPFRvb2x0aXBDb250ZW50UHJvcHM+LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dChDT05URU5UX05BTUUsIHByb3BzLl9fc2NvcGVUb29sdGlwKTtcbiAgICBjb25zdCB7IGZvcmNlTW91bnQgPSBwb3J0YWxDb250ZXh0LmZvcmNlTW91bnQsIHNpZGUgPSAndG9wJywgLi4uY29udGVudFByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlVG9vbHRpcENvbnRleHQoQ09OVEVOVF9OQU1FLCBwcm9wcy5fX3Njb3BlVG9vbHRpcCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFByZXNlbmNlIHByZXNlbnQ9e2ZvcmNlTW91bnQgfHwgY29udGV4dC5vcGVufT5cbiAgICAgICAge2NvbnRleHQuZGlzYWJsZUhvdmVyYWJsZUNvbnRlbnQgPyAoXG4gICAgICAgICAgPFRvb2x0aXBDb250ZW50SW1wbCBzaWRlPXtzaWRlfSB7Li4uY29udGVudFByb3BzfSByZWY9e2ZvcndhcmRlZFJlZn0gLz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8VG9vbHRpcENvbnRlbnRIb3ZlcmFibGUgc2lkZT17c2lkZX0gey4uLmNvbnRlbnRQcm9wc30gcmVmPXtmb3J3YXJkZWRSZWZ9IC8+XG4gICAgICAgICl9XG4gICAgICA8L1ByZXNlbmNlPlxuICAgICk7XG4gIH1cbik7XG5cbnR5cGUgUG9pbnQgPSB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG50eXBlIFBvbHlnb24gPSBQb2ludFtdO1xuXG50eXBlIFRvb2x0aXBDb250ZW50SG92ZXJhYmxlRWxlbWVudCA9IFRvb2x0aXBDb250ZW50SW1wbEVsZW1lbnQ7XG5pbnRlcmZhY2UgVG9vbHRpcENvbnRlbnRIb3ZlcmFibGVQcm9wcyBleHRlbmRzIFRvb2x0aXBDb250ZW50SW1wbFByb3BzIHt9XG5cbmNvbnN0IFRvb2x0aXBDb250ZW50SG92ZXJhYmxlID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgVG9vbHRpcENvbnRlbnRIb3ZlcmFibGVFbGVtZW50LFxuICBUb29sdGlwQ29udGVudEhvdmVyYWJsZVByb3BzXG4+KChwcm9wczogU2NvcGVkUHJvcHM8VG9vbHRpcENvbnRlbnRIb3ZlcmFibGVQcm9wcz4sIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlVG9vbHRpcENvbnRleHQoQ09OVEVOVF9OQU1FLCBwcm9wcy5fX3Njb3BlVG9vbHRpcCk7XG4gIGNvbnN0IHByb3ZpZGVyQ29udGV4dCA9IHVzZVRvb2x0aXBQcm92aWRlckNvbnRleHQoQ09OVEVOVF9OQU1FLCBwcm9wcy5fX3Njb3BlVG9vbHRpcCk7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZjxUb29sdGlwQ29udGVudEhvdmVyYWJsZUVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCByZWYpO1xuICBjb25zdCBbcG9pbnRlckdyYWNlQXJlYSwgc2V0UG9pbnRlckdyYWNlQXJlYV0gPSBSZWFjdC51c2VTdGF0ZTxQb2x5Z29uIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgeyB0cmlnZ2VyLCBvbkNsb3NlIH0gPSBjb250ZXh0O1xuICBjb25zdCBjb250ZW50ID0gcmVmLmN1cnJlbnQ7XG5cbiAgY29uc3QgeyBvblBvaW50ZXJJblRyYW5zaXRDaGFuZ2UgfSA9IHByb3ZpZGVyQ29udGV4dDtcblxuICBjb25zdCBoYW5kbGVSZW1vdmVHcmFjZUFyZWEgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0UG9pbnRlckdyYWNlQXJlYShudWxsKTtcbiAgICBvblBvaW50ZXJJblRyYW5zaXRDaGFuZ2UoZmFsc2UpO1xuICB9LCBbb25Qb2ludGVySW5UcmFuc2l0Q2hhbmdlXSk7XG5cbiAgY29uc3QgaGFuZGxlQ3JlYXRlR3JhY2VBcmVhID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50OiBQb2ludGVyRXZlbnQsIGhvdmVyVGFyZ2V0OiBIVE1MRWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICBjb25zdCBleGl0UG9pbnQgPSB7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfTtcbiAgICAgIGNvbnN0IGV4aXRTaWRlID0gZ2V0RXhpdFNpZGVGcm9tUmVjdChleGl0UG9pbnQsIGN1cnJlbnRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgY29uc3QgcGFkZGVkRXhpdFBvaW50cyA9IGdldFBhZGRlZEV4aXRQb2ludHMoZXhpdFBvaW50LCBleGl0U2lkZSk7XG4gICAgICBjb25zdCBob3ZlclRhcmdldFBvaW50cyA9IGdldFBvaW50c0Zyb21SZWN0KGhvdmVyVGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgIGNvbnN0IGdyYWNlQXJlYSA9IGdldEh1bGwoWy4uLnBhZGRlZEV4aXRQb2ludHMsIC4uLmhvdmVyVGFyZ2V0UG9pbnRzXSk7XG4gICAgICBzZXRQb2ludGVyR3JhY2VBcmVhKGdyYWNlQXJlYSk7XG4gICAgICBvblBvaW50ZXJJblRyYW5zaXRDaGFuZ2UodHJ1ZSk7XG4gICAgfSxcbiAgICBbb25Qb2ludGVySW5UcmFuc2l0Q2hhbmdlXVxuICApO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IGhhbmRsZVJlbW92ZUdyYWNlQXJlYSgpO1xuICB9LCBbaGFuZGxlUmVtb3ZlR3JhY2VBcmVhXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHJpZ2dlciAmJiBjb250ZW50KSB7XG4gICAgICBjb25zdCBoYW5kbGVUcmlnZ2VyTGVhdmUgPSAoZXZlbnQ6IFBvaW50ZXJFdmVudCkgPT4gaGFuZGxlQ3JlYXRlR3JhY2VBcmVhKGV2ZW50LCBjb250ZW50KTtcbiAgICAgIGNvbnN0IGhhbmRsZUNvbnRlbnRMZWF2ZSA9IChldmVudDogUG9pbnRlckV2ZW50KSA9PiBoYW5kbGVDcmVhdGVHcmFjZUFyZWEoZXZlbnQsIHRyaWdnZXIpO1xuXG4gICAgICB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIGhhbmRsZVRyaWdnZXJMZWF2ZSk7XG4gICAgICBjb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIGhhbmRsZUNvbnRlbnRMZWF2ZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0cmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIGhhbmRsZVRyaWdnZXJMZWF2ZSk7XG4gICAgICAgIGNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxlYXZlJywgaGFuZGxlQ29udGVudExlYXZlKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbdHJpZ2dlciwgY29udGVudCwgaGFuZGxlQ3JlYXRlR3JhY2VBcmVhLCBoYW5kbGVSZW1vdmVHcmFjZUFyZWFdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwb2ludGVyR3JhY2VBcmVhKSB7XG4gICAgICBjb25zdCBoYW5kbGVUcmFja1BvaW50ZXJHcmFjZSA9IChldmVudDogUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgY29uc3QgcG9pbnRlclBvc2l0aW9uID0geyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH07XG4gICAgICAgIGNvbnN0IGhhc0VudGVyZWRUYXJnZXQgPSB0cmlnZ2VyPy5jb250YWlucyh0YXJnZXQpIHx8IGNvbnRlbnQ/LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRlck91dHNpZGVHcmFjZUFyZWEgPSAhaXNQb2ludEluUG9seWdvbihwb2ludGVyUG9zaXRpb24sIHBvaW50ZXJHcmFjZUFyZWEpO1xuXG4gICAgICAgIGlmIChoYXNFbnRlcmVkVGFyZ2V0KSB7XG4gICAgICAgICAgaGFuZGxlUmVtb3ZlR3JhY2VBcmVhKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQb2ludGVyT3V0c2lkZUdyYWNlQXJlYSkge1xuICAgICAgICAgIGhhbmRsZVJlbW92ZUdyYWNlQXJlYSgpO1xuICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgaGFuZGxlVHJhY2tQb2ludGVyR3JhY2UpO1xuICAgICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgaGFuZGxlVHJhY2tQb2ludGVyR3JhY2UpO1xuICAgIH1cbiAgfSwgW3RyaWdnZXIsIGNvbnRlbnQsIHBvaW50ZXJHcmFjZUFyZWEsIG9uQ2xvc2UsIGhhbmRsZVJlbW92ZUdyYWNlQXJlYV0pO1xuXG4gIHJldHVybiA8VG9vbHRpcENvbnRlbnRJbXBsIHsuLi5wcm9wc30gcmVmPXtjb21wb3NlZFJlZnN9IC8+O1xufSk7XG5cbmNvbnN0IFtWaXN1YWxseUhpZGRlbkNvbnRlbnRDb250ZXh0UHJvdmlkZXIsIHVzZVZpc3VhbGx5SGlkZGVuQ29udGVudENvbnRleHRdID1cbiAgY3JlYXRlVG9vbHRpcENvbnRleHQoVE9PTFRJUF9OQU1FLCB7IGlzSW5zaWRlOiBmYWxzZSB9KTtcblxudHlwZSBUb29sdGlwQ29udGVudEltcGxFbGVtZW50ID0gUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgUG9wcGVyUHJpbWl0aXZlLkNvbnRlbnQ+O1xudHlwZSBEaXNtaXNzYWJsZUxheWVyUHJvcHMgPSBSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8dHlwZW9mIERpc21pc3NhYmxlTGF5ZXI+O1xudHlwZSBQb3BwZXJDb250ZW50UHJvcHMgPSBSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8dHlwZW9mIFBvcHBlclByaW1pdGl2ZS5Db250ZW50PjtcbmludGVyZmFjZSBUb29sdGlwQ29udGVudEltcGxQcm9wcyBleHRlbmRzIE9taXQ8UG9wcGVyQ29udGVudFByb3BzLCAnb25QbGFjZWQnPiB7XG4gIC8qKlxuICAgKiBBIG1vcmUgZGVzY3JpcHRpdmUgbGFiZWwgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZVxuICAgKi9cbiAgJ2FyaWEtbGFiZWwnPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGNhbGxlZCB3aGVuIHRoZSBlc2NhcGUga2V5IGlzIGRvd24uXG4gICAqIENhbiBiZSBwcmV2ZW50ZWQuXG4gICAqL1xuICBvbkVzY2FwZUtleURvd24/OiBEaXNtaXNzYWJsZUxheWVyUHJvcHNbJ29uRXNjYXBlS2V5RG93biddO1xuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBjYWxsZWQgd2hlbiB0aGUgYSBgcG9pbnRlcmRvd25gIGV2ZW50IGhhcHBlbnMgb3V0c2lkZSBvZiB0aGUgYFRvb2x0aXBgLlxuICAgKiBDYW4gYmUgcHJldmVudGVkLlxuICAgKi9cbiAgb25Qb2ludGVyRG93bk91dHNpZGU/OiBEaXNtaXNzYWJsZUxheWVyUHJvcHNbJ29uUG9pbnRlckRvd25PdXRzaWRlJ107XG59XG5cbmNvbnN0IFRvb2x0aXBDb250ZW50SW1wbCA9IFJlYWN0LmZvcndhcmRSZWY8VG9vbHRpcENvbnRlbnRJbXBsRWxlbWVudCwgVG9vbHRpcENvbnRlbnRJbXBsUHJvcHM+KFxuICAocHJvcHM6IFNjb3BlZFByb3BzPFRvb2x0aXBDb250ZW50SW1wbFByb3BzPiwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgX19zY29wZVRvb2x0aXAsXG4gICAgICBjaGlsZHJlbixcbiAgICAgICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsLFxuICAgICAgb25Fc2NhcGVLZXlEb3duLFxuICAgICAgb25Qb2ludGVyRG93bk91dHNpZGUsXG4gICAgICAuLi5jb250ZW50UHJvcHNcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVRvb2x0aXBDb250ZXh0KENPTlRFTlRfTkFNRSwgX19zY29wZVRvb2x0aXApO1xuICAgIGNvbnN0IHBvcHBlclNjb3BlID0gdXNlUG9wcGVyU2NvcGUoX19zY29wZVRvb2x0aXApO1xuICAgIGNvbnN0IHsgb25DbG9zZSB9ID0gY29udGV4dDtcblxuICAgIC8vIENsb3NlIHRoaXMgdG9vbHRpcCBpZiBhbm90aGVyIG9uZSBvcGVuc1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFRPT0xUSVBfT1BFTiwgb25DbG9zZSk7XG4gICAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihUT09MVElQX09QRU4sIG9uQ2xvc2UpO1xuICAgIH0sIFtvbkNsb3NlXSk7XG5cbiAgICAvLyBDbG9zZSB0aGUgdG9vbHRpcCBpZiB0aGUgdHJpZ2dlciBpcyBzY3JvbGxlZFxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoY29udGV4dC50cmlnZ2VyKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZVNjcm9sbCA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgaWYgKHRhcmdldD8uY29udGFpbnMoY29udGV4dC50cmlnZ2VyKSkgb25DbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfSwgW2NvbnRleHQudHJpZ2dlciwgb25DbG9zZV0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxEaXNtaXNzYWJsZUxheWVyXG4gICAgICAgIGFzQ2hpbGRcbiAgICAgICAgZGlzYWJsZU91dHNpZGVQb2ludGVyRXZlbnRzPXtmYWxzZX1cbiAgICAgICAgb25Fc2NhcGVLZXlEb3duPXtvbkVzY2FwZUtleURvd259XG4gICAgICAgIG9uUG9pbnRlckRvd25PdXRzaWRlPXtvblBvaW50ZXJEb3duT3V0c2lkZX1cbiAgICAgICAgb25Gb2N1c091dHNpZGU9eyhldmVudCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKX1cbiAgICAgICAgb25EaXNtaXNzPXtvbkNsb3NlfVxuICAgICAgPlxuICAgICAgICA8UG9wcGVyUHJpbWl0aXZlLkNvbnRlbnRcbiAgICAgICAgICBkYXRhLXN0YXRlPXtjb250ZXh0LnN0YXRlQXR0cmlidXRlfVxuICAgICAgICAgIHsuLi5wb3BwZXJTY29wZX1cbiAgICAgICAgICB7Li4uY29udGVudFByb3BzfVxuICAgICAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAuLi5jb250ZW50UHJvcHMuc3R5bGUsXG4gICAgICAgICAgICAvLyByZS1uYW1lc3BhY2UgZXhwb3NlZCBjb250ZW50IGN1c3RvbSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAuLi57XG4gICAgICAgICAgICAgICctLXJhZGl4LXRvb2x0aXAtY29udGVudC10cmFuc2Zvcm0tb3JpZ2luJzogJ3ZhcigtLXJhZGl4LXBvcHBlci10cmFuc2Zvcm0tb3JpZ2luKScsXG4gICAgICAgICAgICAgICctLXJhZGl4LXRvb2x0aXAtY29udGVudC1hdmFpbGFibGUtd2lkdGgnOiAndmFyKC0tcmFkaXgtcG9wcGVyLWF2YWlsYWJsZS13aWR0aCknLFxuICAgICAgICAgICAgICAnLS1yYWRpeC10b29sdGlwLWNvbnRlbnQtYXZhaWxhYmxlLWhlaWdodCc6ICd2YXIoLS1yYWRpeC1wb3BwZXItYXZhaWxhYmxlLWhlaWdodCknLFxuICAgICAgICAgICAgICAnLS1yYWRpeC10b29sdGlwLXRyaWdnZXItd2lkdGgnOiAndmFyKC0tcmFkaXgtcG9wcGVyLWFuY2hvci13aWR0aCknLFxuICAgICAgICAgICAgICAnLS1yYWRpeC10b29sdGlwLXRyaWdnZXItaGVpZ2h0JzogJ3ZhcigtLXJhZGl4LXBvcHBlci1hbmNob3ItaGVpZ2h0KScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICA8U2xvdHRhYmxlPntjaGlsZHJlbn08L1Nsb3R0YWJsZT5cbiAgICAgICAgICA8VmlzdWFsbHlIaWRkZW5Db250ZW50Q29udGV4dFByb3ZpZGVyIHNjb3BlPXtfX3Njb3BlVG9vbHRpcH0gaXNJbnNpZGU9e3RydWV9PlxuICAgICAgICAgICAgPFZpc3VhbGx5SGlkZGVuUHJpbWl0aXZlLlJvb3QgaWQ9e2NvbnRleHQuY29udGVudElkfSByb2xlPVwidG9vbHRpcFwiPlxuICAgICAgICAgICAgICB7YXJpYUxhYmVsIHx8IGNoaWxkcmVufVxuICAgICAgICAgICAgPC9WaXN1YWxseUhpZGRlblByaW1pdGl2ZS5Sb290PlxuICAgICAgICAgIDwvVmlzdWFsbHlIaWRkZW5Db250ZW50Q29udGV4dFByb3ZpZGVyPlxuICAgICAgICA8L1BvcHBlclByaW1pdGl2ZS5Db250ZW50PlxuICAgICAgPC9EaXNtaXNzYWJsZUxheWVyPlxuICAgICk7XG4gIH1cbik7XG5cblRvb2x0aXBDb250ZW50LmRpc3BsYXlOYW1lID0gQ09OVEVOVF9OQU1FO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUb29sdGlwQXJyb3dcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuY29uc3QgQVJST1dfTkFNRSA9ICdUb29sdGlwQXJyb3cnO1xuXG50eXBlIFRvb2x0aXBBcnJvd0VsZW1lbnQgPSBSZWFjdC5FbGVtZW50UmVmPHR5cGVvZiBQb3BwZXJQcmltaXRpdmUuQXJyb3c+O1xudHlwZSBQb3BwZXJBcnJvd1Byb3BzID0gUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBQb3BwZXJQcmltaXRpdmUuQXJyb3c+O1xuaW50ZXJmYWNlIFRvb2x0aXBBcnJvd1Byb3BzIGV4dGVuZHMgUG9wcGVyQXJyb3dQcm9wcyB7fVxuXG5jb25zdCBUb29sdGlwQXJyb3cgPSBSZWFjdC5mb3J3YXJkUmVmPFRvb2x0aXBBcnJvd0VsZW1lbnQsIFRvb2x0aXBBcnJvd1Byb3BzPihcbiAgKHByb3BzOiBTY29wZWRQcm9wczxUb29sdGlwQXJyb3dQcm9wcz4sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVRvb2x0aXAsIC4uLmFycm93UHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHBvcHBlclNjb3BlID0gdXNlUG9wcGVyU2NvcGUoX19zY29wZVRvb2x0aXApO1xuICAgIGNvbnN0IHZpc3VhbGx5SGlkZGVuQ29udGVudENvbnRleHQgPSB1c2VWaXN1YWxseUhpZGRlbkNvbnRlbnRDb250ZXh0KFxuICAgICAgQVJST1dfTkFNRSxcbiAgICAgIF9fc2NvcGVUb29sdGlwXG4gICAgKTtcbiAgICAvLyBpZiB0aGUgYXJyb3cgaXMgaW5zaWRlIHRoZSBgVmlzdWFsbHlIaWRkZW5gLCB3ZSBkb24ndCB3YW50IHRvIHJlbmRlciBpdCBhbGwgdG9cbiAgICAvLyBwcmV2ZW50IGlzc3VlcyBpbiBwb3NpdGlvbmluZyB0aGUgYXJyb3cgZHVlIHRvIHRoZSBkdXBsaWNhdGVcbiAgICByZXR1cm4gdmlzdWFsbHlIaWRkZW5Db250ZW50Q29udGV4dC5pc0luc2lkZSA/IG51bGwgOiAoXG4gICAgICA8UG9wcGVyUHJpbWl0aXZlLkFycm93IHsuLi5wb3BwZXJTY29wZX0gey4uLmFycm93UHJvcHN9IHJlZj17Zm9yd2FyZGVkUmVmfSAvPlxuICAgICk7XG4gIH1cbik7XG5cblRvb2x0aXBBcnJvdy5kaXNwbGF5TmFtZSA9IEFSUk9XX05BTUU7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxudHlwZSBTaWRlID0gTm9uTnVsbGFibGU8VG9vbHRpcENvbnRlbnRQcm9wc1snc2lkZSddPjtcblxuZnVuY3Rpb24gZ2V0RXhpdFNpZGVGcm9tUmVjdChwb2ludDogUG9pbnQsIHJlY3Q6IERPTVJlY3QpOiBTaWRlIHtcbiAgY29uc3QgdG9wID0gTWF0aC5hYnMocmVjdC50b3AgLSBwb2ludC55KTtcbiAgY29uc3QgYm90dG9tID0gTWF0aC5hYnMocmVjdC5ib3R0b20gLSBwb2ludC55KTtcbiAgY29uc3QgcmlnaHQgPSBNYXRoLmFicyhyZWN0LnJpZ2h0IC0gcG9pbnQueCk7XG4gIGNvbnN0IGxlZnQgPSBNYXRoLmFicyhyZWN0LmxlZnQgLSBwb2ludC54KTtcblxuICBzd2l0Y2ggKE1hdGgubWluKHRvcCwgYm90dG9tLCByaWdodCwgbGVmdCkpIHtcbiAgICBjYXNlIGxlZnQ6XG4gICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIGNhc2UgcmlnaHQ6XG4gICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICBjYXNlIHRvcDpcbiAgICAgIHJldHVybiAndG9wJztcbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIHJldHVybiAnYm90dG9tJztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhZGRlZEV4aXRQb2ludHMoZXhpdFBvaW50OiBQb2ludCwgZXhpdFNpZGU6IFNpZGUsIHBhZGRpbmcgPSA1KSB7XG4gIGNvbnN0IHBhZGRlZEV4aXRQb2ludHM6IFBvaW50W10gPSBbXTtcbiAgc3dpdGNoIChleGl0U2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBwYWRkZWRFeGl0UG9pbnRzLnB1c2goXG4gICAgICAgIHsgeDogZXhpdFBvaW50LnggLSBwYWRkaW5nLCB5OiBleGl0UG9pbnQueSArIHBhZGRpbmcgfSxcbiAgICAgICAgeyB4OiBleGl0UG9pbnQueCArIHBhZGRpbmcsIHk6IGV4aXRQb2ludC55ICsgcGFkZGluZyB9XG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHBhZGRlZEV4aXRQb2ludHMucHVzaChcbiAgICAgICAgeyB4OiBleGl0UG9pbnQueCAtIHBhZGRpbmcsIHk6IGV4aXRQb2ludC55IC0gcGFkZGluZyB9LFxuICAgICAgICB7IHg6IGV4aXRQb2ludC54ICsgcGFkZGluZywgeTogZXhpdFBvaW50LnkgLSBwYWRkaW5nIH1cbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHBhZGRlZEV4aXRQb2ludHMucHVzaChcbiAgICAgICAgeyB4OiBleGl0UG9pbnQueCArIHBhZGRpbmcsIHk6IGV4aXRQb2ludC55IC0gcGFkZGluZyB9LFxuICAgICAgICB7IHg6IGV4aXRQb2ludC54ICsgcGFkZGluZywgeTogZXhpdFBvaW50LnkgKyBwYWRkaW5nIH1cbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBwYWRkZWRFeGl0UG9pbnRzLnB1c2goXG4gICAgICAgIHsgeDogZXhpdFBvaW50LnggLSBwYWRkaW5nLCB5OiBleGl0UG9pbnQueSAtIHBhZGRpbmcgfSxcbiAgICAgICAgeyB4OiBleGl0UG9pbnQueCAtIHBhZGRpbmcsIHk6IGV4aXRQb2ludC55ICsgcGFkZGluZyB9XG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHBhZGRlZEV4aXRQb2ludHM7XG59XG5cbmZ1bmN0aW9uIGdldFBvaW50c0Zyb21SZWN0KHJlY3Q6IERPTVJlY3QpIHtcbiAgY29uc3QgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgfSA9IHJlY3Q7XG4gIHJldHVybiBbXG4gICAgeyB4OiBsZWZ0LCB5OiB0b3AgfSxcbiAgICB7IHg6IHJpZ2h0LCB5OiB0b3AgfSxcbiAgICB7IHg6IHJpZ2h0LCB5OiBib3R0b20gfSxcbiAgICB7IHg6IGxlZnQsIHk6IGJvdHRvbSB9LFxuICBdO1xufVxuXG4vLyBEZXRlcm1pbmUgaWYgYSBwb2ludCBpcyBpbnNpZGUgb2YgYSBwb2x5Z29uLlxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL3BvaW50LWluLXBvbHlnb25cbmZ1bmN0aW9uIGlzUG9pbnRJblBvbHlnb24ocG9pbnQ6IFBvaW50LCBwb2x5Z29uOiBQb2x5Z29uKSB7XG4gIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBwb2x5Z29uLmxlbmd0aCAtIDE7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaiA9IGkrKykge1xuICAgIGNvbnN0IHhpID0gcG9seWdvbltpXS54O1xuICAgIGNvbnN0IHlpID0gcG9seWdvbltpXS55O1xuICAgIGNvbnN0IHhqID0gcG9seWdvbltqXS54O1xuICAgIGNvbnN0IHlqID0gcG9seWdvbltqXS55O1xuXG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgaW50ZXJzZWN0ID0gKCh5aSA+IHkpICE9PSAoeWogPiB5KSkgJiYgKHggPCAoeGogLSB4aSkgKiAoeSAtIHlpKSAvICh5aiAtIHlpKSArIHhpKTtcbiAgICBpZiAoaW50ZXJzZWN0KSBpbnNpZGUgPSAhaW5zaWRlO1xuICB9XG5cbiAgcmV0dXJuIGluc2lkZTtcbn1cblxuLy8gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBwb2ludHMgcmVwcmVzZW50aW5nIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgZ2l2ZW4gc2V0IG9mIHBvaW50cy5cbi8vIGh0dHBzOi8vd3d3Lm5heXVraS5pby9wYWdlL2NvbnZleC1odWxsLWFsZ29yaXRobVxuZnVuY3Rpb24gZ2V0SHVsbDxQIGV4dGVuZHMgUG9pbnQ+KHBvaW50czogUmVhZG9ubHk8QXJyYXk8UD4+KTogQXJyYXk8UD4ge1xuICBjb25zdCBuZXdQb2ludHM6IEFycmF5PFA+ID0gcG9pbnRzLnNsaWNlKCk7XG4gIG5ld1BvaW50cy5zb3J0KChhOiBQb2ludCwgYjogUG9pbnQpID0+IHtcbiAgICBpZiAoYS54IDwgYi54KSByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYS54ID4gYi54KSByZXR1cm4gKzE7XG4gICAgZWxzZSBpZiAoYS55IDwgYi55KSByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYS55ID4gYi55KSByZXR1cm4gKzE7XG4gICAgZWxzZSByZXR1cm4gMDtcbiAgfSk7XG4gIHJldHVybiBnZXRIdWxsUHJlc29ydGVkKG5ld1BvaW50cyk7XG59XG5cbi8vIFJldHVybnMgdGhlIGNvbnZleCBodWxsLCBhc3N1bWluZyB0aGF0IGVhY2ggcG9pbnRzW2ldIDw9IHBvaW50c1tpICsgMV0uIFJ1bnMgaW4gTyhuKSB0aW1lLlxuZnVuY3Rpb24gZ2V0SHVsbFByZXNvcnRlZDxQIGV4dGVuZHMgUG9pbnQ+KHBvaW50czogUmVhZG9ubHk8QXJyYXk8UD4+KTogQXJyYXk8UD4ge1xuICBpZiAocG9pbnRzLmxlbmd0aCA8PSAxKSByZXR1cm4gcG9pbnRzLnNsaWNlKCk7XG5cbiAgY29uc3QgdXBwZXJIdWxsOiBBcnJheTxQPiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHAgPSBwb2ludHNbaV07XG4gICAgd2hpbGUgKHVwcGVySHVsbC5sZW5ndGggPj0gMikge1xuICAgICAgY29uc3QgcSA9IHVwcGVySHVsbFt1cHBlckh1bGwubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCByID0gdXBwZXJIdWxsW3VwcGVySHVsbC5sZW5ndGggLSAyXTtcbiAgICAgIGlmICgocS54IC0gci54KSAqIChwLnkgLSByLnkpID49IChxLnkgLSByLnkpICogKHAueCAtIHIueCkpIHVwcGVySHVsbC5wb3AoKTtcbiAgICAgIGVsc2UgYnJlYWs7XG4gICAgfVxuICAgIHVwcGVySHVsbC5wdXNoKHApO1xuICB9XG4gIHVwcGVySHVsbC5wb3AoKTtcblxuICBjb25zdCBsb3dlckh1bGw6IEFycmF5PFA+ID0gW107XG4gIGZvciAobGV0IGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBwID0gcG9pbnRzW2ldO1xuICAgIHdoaWxlIChsb3dlckh1bGwubGVuZ3RoID49IDIpIHtcbiAgICAgIGNvbnN0IHEgPSBsb3dlckh1bGxbbG93ZXJIdWxsLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgciA9IGxvd2VySHVsbFtsb3dlckh1bGwubGVuZ3RoIC0gMl07XG4gICAgICBpZiAoKHEueCAtIHIueCkgKiAocC55IC0gci55KSA+PSAocS55IC0gci55KSAqIChwLnggLSByLngpKSBsb3dlckh1bGwucG9wKCk7XG4gICAgICBlbHNlIGJyZWFrO1xuICAgIH1cbiAgICBsb3dlckh1bGwucHVzaChwKTtcbiAgfVxuICBsb3dlckh1bGwucG9wKCk7XG5cbiAgaWYgKFxuICAgIHVwcGVySHVsbC5sZW5ndGggPT09IDEgJiZcbiAgICBsb3dlckh1bGwubGVuZ3RoID09PSAxICYmXG4gICAgdXBwZXJIdWxsWzBdLnggPT09IGxvd2VySHVsbFswXS54ICYmXG4gICAgdXBwZXJIdWxsWzBdLnkgPT09IGxvd2VySHVsbFswXS55XG4gICkge1xuICAgIHJldHVybiB1cHBlckh1bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVwcGVySHVsbC5jb25jYXQobG93ZXJIdWxsKTtcbiAgfVxufVxuXG5jb25zdCBQcm92aWRlciA9IFRvb2x0aXBQcm92aWRlcjtcbmNvbnN0IFJvb3QgPSBUb29sdGlwO1xuY29uc3QgVHJpZ2dlciA9IFRvb2x0aXBUcmlnZ2VyO1xuY29uc3QgUG9ydGFsID0gVG9vbHRpcFBvcnRhbDtcbmNvbnN0IENvbnRlbnQgPSBUb29sdGlwQ29udGVudDtcbmNvbnN0IEFycm93ID0gVG9vbHRpcEFycm93O1xuXG5leHBvcnQge1xuICBjcmVhdGVUb29sdGlwU2NvcGUsXG4gIC8vXG4gIFRvb2x0aXBQcm92aWRlcixcbiAgVG9vbHRpcCxcbiAgVG9vbHRpcFRyaWdnZXIsXG4gIFRvb2x0aXBQb3J0YWwsXG4gIFRvb2x0aXBDb250ZW50LFxuICBUb29sdGlwQXJyb3csXG4gIC8vXG4gIFByb3ZpZGVyLFxuICBSb290LFxuICBUcmlnZ2VyLFxuICBQb3J0YWwsXG4gIENvbnRlbnQsXG4gIEFycm93LFxufTtcbmV4cG9ydCB0eXBlIHtcbiAgVG9vbHRpcFByb3ZpZGVyUHJvcHMsXG4gIFRvb2x0aXBQcm9wcyxcbiAgVG9vbHRpcFRyaWdnZXJQcm9wcyxcbiAgVG9vbHRpcFBvcnRhbFByb3BzLFxuICBUb29sdGlwQ29udGVudFByb3BzLFxuICBUb29sdGlwQXJyb3dQcm9wcyxcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjb21wb3NlRXZlbnRIYW5kbGVycyIsInVzZUNvbXBvc2VkUmVmcyIsImNyZWF0ZUNvbnRleHRTY29wZSIsIkRpc21pc3NhYmxlTGF5ZXIiLCJ1c2VJZCIsIlBvcHBlclByaW1pdGl2ZSIsImNyZWF0ZVBvcHBlclNjb3BlIiwiUG9ydGFsIiwiUG9ydGFsUHJpbWl0aXZlIiwiUHJlc2VuY2UiLCJQcmltaXRpdmUiLCJTbG90dGFibGUiLCJ1c2VDb250cm9sbGFibGVTdGF0ZSIsIlZpc3VhbGx5SGlkZGVuUHJpbWl0aXZlIiwianN4IiwianN4cyIsImNyZWF0ZVRvb2x0aXBDb250ZXh0IiwiY3JlYXRlVG9vbHRpcFNjb3BlIiwidXNlUG9wcGVyU2NvcGUiLCJQUk9WSURFUl9OQU1FIiwiREVGQVVMVF9ERUxBWV9EVVJBVElPTiIsIlRPT0xUSVBfT1BFTiIsIlRvb2x0aXBQcm92aWRlckNvbnRleHRQcm92aWRlciIsInVzZVRvb2x0aXBQcm92aWRlckNvbnRleHQiLCJUb29sdGlwUHJvdmlkZXIiLCJwcm9wcyIsIl9fc2NvcGVUb29sdGlwIiwiZGVsYXlEdXJhdGlvbiIsInNraXBEZWxheUR1cmF0aW9uIiwiZGlzYWJsZUhvdmVyYWJsZUNvbnRlbnQiLCJjaGlsZHJlbiIsImlzT3BlbkRlbGF5ZWQiLCJzZXRJc09wZW5EZWxheWVkIiwidXNlU3RhdGUiLCJpc1BvaW50ZXJJblRyYW5zaXRSZWYiLCJ1c2VSZWYiLCJza2lwRGVsYXlUaW1lclJlZiIsInVzZUVmZmVjdCIsInNraXBEZWxheVRpbWVyIiwiY3VycmVudCIsIndpbmRvdyIsImNsZWFyVGltZW91dCIsInNjb3BlIiwib25PcGVuIiwidXNlQ2FsbGJhY2siLCJvbkNsb3NlIiwic2V0VGltZW91dCIsIm9uUG9pbnRlckluVHJhbnNpdENoYW5nZSIsImluVHJhbnNpdCIsImRpc3BsYXlOYW1lIiwiVE9PTFRJUF9OQU1FIiwiVG9vbHRpcENvbnRleHRQcm92aWRlciIsInVzZVRvb2x0aXBDb250ZXh0IiwiVG9vbHRpcCIsIm9wZW4iLCJvcGVuUHJvcCIsImRlZmF1bHRPcGVuIiwib25PcGVuQ2hhbmdlIiwiZGlzYWJsZUhvdmVyYWJsZUNvbnRlbnRQcm9wIiwiZGVsYXlEdXJhdGlvblByb3AiLCJwcm92aWRlckNvbnRleHQiLCJwb3BwZXJTY29wZSIsInRyaWdnZXIiLCJzZXRUcmlnZ2VyIiwiY29udGVudElkIiwib3BlblRpbWVyUmVmIiwid2FzT3BlbkRlbGF5ZWRSZWYiLCJzZXRPcGVuIiwicHJvcCIsImRlZmF1bHRQcm9wIiwib25DaGFuZ2UiLCJkb2N1bWVudCIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsInN0YXRlQXR0cmlidXRlIiwidXNlTWVtbyIsImhhbmRsZU9wZW4iLCJoYW5kbGVDbG9zZSIsImhhbmRsZURlbGF5ZWRPcGVuIiwiUm9vdCIsIm9uVHJpZ2dlckNoYW5nZSIsIm9uVHJpZ2dlckVudGVyIiwib25UcmlnZ2VyTGVhdmUiLCJUUklHR0VSX05BTUUiLCJUb29sdGlwVHJpZ2dlciIsImZvcndhcmRSZWYiLCJmb3J3YXJkZWRSZWYiLCJ0cmlnZ2VyUHJvcHMiLCJjb250ZXh0IiwicmVmIiwiY29tcG9zZWRSZWZzIiwiaXNQb2ludGVyRG93blJlZiIsImhhc1BvaW50ZXJNb3ZlT3BlbmVkUmVmIiwiaGFuZGxlUG9pbnRlclVwIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkFuY2hvciIsImFzQ2hpbGQiLCJidXR0b24iLCJvblBvaW50ZXJNb3ZlIiwiZXZlbnQiLCJwb2ludGVyVHlwZSIsIm9uUG9pbnRlckxlYXZlIiwib25Qb2ludGVyRG93biIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwib25Gb2N1cyIsIm9uQmx1ciIsIm9uQ2xpY2siLCJQT1JUQUxfTkFNRSIsIlBvcnRhbFByb3ZpZGVyIiwidXNlUG9ydGFsQ29udGV4dCIsImZvcmNlTW91bnQiLCJUb29sdGlwUG9ydGFsIiwiY29udGFpbmVyIiwicHJlc2VudCIsIkNPTlRFTlRfTkFNRSIsIlRvb2x0aXBDb250ZW50IiwicG9ydGFsQ29udGV4dCIsInNpZGUiLCJjb250ZW50UHJvcHMiLCJUb29sdGlwQ29udGVudEltcGwiLCJUb29sdGlwQ29udGVudEhvdmVyYWJsZSIsInBvaW50ZXJHcmFjZUFyZWEiLCJzZXRQb2ludGVyR3JhY2VBcmVhIiwiY29udGVudCIsImhhbmRsZVJlbW92ZUdyYWNlQXJlYSIsImhhbmRsZUNyZWF0ZUdyYWNlQXJlYSIsImhvdmVyVGFyZ2V0IiwiY3VycmVudFRhcmdldCIsImV4aXRQb2ludCIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJleGl0U2lkZSIsImdldEV4aXRTaWRlRnJvbVJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYWRkZWRFeGl0UG9pbnRzIiwiZ2V0UGFkZGVkRXhpdFBvaW50cyIsImhvdmVyVGFyZ2V0UG9pbnRzIiwiZ2V0UG9pbnRzRnJvbVJlY3QiLCJncmFjZUFyZWEiLCJnZXRIdWxsIiwiaGFuZGxlVHJpZ2dlckxlYXZlIiwiaGFuZGxlQ29udGVudExlYXZlIiwiaGFuZGxlVHJhY2tQb2ludGVyR3JhY2UiLCJ0YXJnZXQiLCJwb2ludGVyUG9zaXRpb24iLCJoYXNFbnRlcmVkVGFyZ2V0IiwiY29udGFpbnMiLCJpc1BvaW50ZXJPdXRzaWRlR3JhY2VBcmVhIiwiaXNQb2ludEluUG9seWdvbiIsIlZpc3VhbGx5SGlkZGVuQ29udGVudENvbnRleHRQcm92aWRlciIsInVzZVZpc3VhbGx5SGlkZGVuQ29udGVudENvbnRleHQiLCJpc0luc2lkZSIsImFyaWFMYWJlbCIsIm9uRXNjYXBlS2V5RG93biIsIm9uUG9pbnRlckRvd25PdXRzaWRlIiwiaGFuZGxlU2Nyb2xsIiwiY2FwdHVyZSIsImRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50cyIsIm9uRm9jdXNPdXRzaWRlIiwicHJldmVudERlZmF1bHQiLCJvbkRpc21pc3MiLCJDb250ZW50Iiwic3R5bGUiLCJpZCIsInJvbGUiLCJBUlJPV19OQU1FIiwiVG9vbHRpcEFycm93IiwiYXJyb3dQcm9wcyIsInZpc3VhbGx5SGlkZGVuQ29udGVudENvbnRleHQiLCJBcnJvdyIsInBvaW50IiwicmVjdCIsInRvcCIsIk1hdGgiLCJhYnMiLCJib3R0b20iLCJyaWdodCIsImxlZnQiLCJtaW4iLCJFcnJvciIsInBhZGRpbmciLCJwdXNoIiwicG9seWdvbiIsImluc2lkZSIsImkiLCJqIiwibGVuZ3RoIiwieGkiLCJ5aSIsInhqIiwieWoiLCJpbnRlcnNlY3QiLCJwb2ludHMiLCJuZXdQb2ludHMiLCJzbGljZSIsInNvcnQiLCJhIiwiYiIsImdldEh1bGxQcmVzb3J0ZWQiLCJ1cHBlckh1bGwiLCJwIiwicSIsInIiLCJwb3AiLCJsb3dlckh1bGwiLCJjb25jYXQiLCJQcm92aWRlciIsIlRyaWdnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react-ui/node_modules/@radix-ui/react-tooltip/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/_private.js":
/*!*********************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/_private.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUmbrellaStoreForClient: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.getUmbrellaStoreForClient),\n/* harmony export */   useAddRoomCommentReaction: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useAddRoomCommentReaction),\n/* harmony export */   useClientOrNull: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useClientOrNull),\n/* harmony export */   useCreateRoomComment: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useCreateRoomComment),\n/* harmony export */   useCreateRoomThread: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useCreateRoomThread),\n/* harmony export */   useCreateTextMention: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useCreateTextMention),\n/* harmony export */   useDeleteRoomComment: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useDeleteRoomComment),\n/* harmony export */   useDeleteRoomThread: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useDeleteRoomThread),\n/* harmony export */   useDeleteTextMention: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useDeleteTextMention),\n/* harmony export */   useEditRoomComment: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useEditRoomComment),\n/* harmony export */   useEditRoomThreadMetadata: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useEditRoomThreadMetadata),\n/* harmony export */   useLayoutEffect: () => (/* binding */ useLayoutEffect),\n/* harmony export */   useMarkRoomThreadAsRead: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useMarkRoomThreadAsRead),\n/* harmony export */   useMarkRoomThreadAsResolved: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useMarkRoomThreadAsResolved),\n/* harmony export */   useMarkRoomThreadAsUnresolved: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useMarkRoomThreadAsUnresolved),\n/* harmony export */   useMentionSuggestions: () => (/* binding */ useMentionSuggestions),\n/* harmony export */   useMentionSuggestionsCache: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useMentionSuggestionsCache),\n/* harmony export */   useRemoveRoomCommentReaction: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useRemoveRoomCommentReaction),\n/* harmony export */   useReportTextEditor: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useReportTextEditor),\n/* harmony export */   useResolveMentionSuggestions: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useResolveMentionSuggestions),\n/* harmony export */   useRoomAttachmentUrl: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useRoomAttachmentUrl),\n/* harmony export */   useRoomOrNull: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useRoomOrNull),\n/* harmony export */   useRoomPermissions: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useRoomPermissions),\n/* harmony export */   useSignal: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useSignal),\n/* harmony export */   useSyncExternalStoreWithSelector: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector),\n/* harmony export */   useSyncSource: () => (/* binding */ useSyncSource),\n/* harmony export */   useYjsProvider: () => (/* reexport safe */ _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useYjsProvider)\n/* harmony export */ });\n/* harmony import */ var _chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-5RVW253W.js */ \"(ssr)/./node_modules/@liveblocks/react/dist/chunk-5RVW253W.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n\n\n// src/lib/use-layout-effect.ts\n\nvar useLayoutEffect = typeof window !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n// src/use-mention-suggestions.ts\n\n\nvar MENTION_SUGGESTIONS_DEBOUNCE = 500;\nfunction useMentionSuggestions(roomId, search) {\n  const [mentionSuggestions, setMentionSuggestions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  const lastInvokedAt = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  const resolveMentionSuggestions = (0,_chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useResolveMentionSuggestions)();\n  const mentionSuggestionsCache = (0,_chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useMentionSuggestionsCache)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (search === void 0 || !resolveMentionSuggestions) {\n      return;\n    }\n    const resolveMentionSuggestionsArgs = { text: search, roomId };\n    const mentionSuggestionsCacheKey = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_2__.stableStringify)(\n      resolveMentionSuggestionsArgs\n    );\n    let debounceTimeout;\n    let isCanceled = false;\n    const getMentionSuggestions = async () => {\n      try {\n        lastInvokedAt.current = performance.now();\n        const mentionSuggestions2 = await resolveMentionSuggestions(\n          resolveMentionSuggestionsArgs\n        );\n        if (!isCanceled) {\n          setMentionSuggestions(mentionSuggestions2);\n          mentionSuggestionsCache.set(\n            mentionSuggestionsCacheKey,\n            mentionSuggestions2\n          );\n        }\n      } catch (error) {\n        console.error(error?.message);\n      }\n    };\n    if (mentionSuggestionsCache.has(mentionSuggestionsCacheKey)) {\n      setMentionSuggestions(\n        mentionSuggestionsCache.get(mentionSuggestionsCacheKey)\n      );\n    } else if (!lastInvokedAt.current || Math.abs(performance.now() - lastInvokedAt.current) > MENTION_SUGGESTIONS_DEBOUNCE) {\n      void getMentionSuggestions();\n    } else {\n      debounceTimeout = window.setTimeout(() => {\n        void getMentionSuggestions();\n      }, MENTION_SUGGESTIONS_DEBOUNCE);\n    }\n    return () => {\n      isCanceled = true;\n      window.clearTimeout(debounceTimeout);\n    };\n  }, [search, roomId, resolveMentionSuggestions, mentionSuggestionsCache]);\n  return mentionSuggestions;\n}\n\n// src/use-sync-source.ts\n\n\nfunction useSyncSource() {\n  const client = (0,_chunk_5RVW253W_js__WEBPACK_IMPORTED_MODULE_1__.useClient)();\n  const createSyncSource = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_2__.kInternal].createSyncSource;\n  const [syncSource, setSyncSource] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const newSyncSource = createSyncSource();\n    setSyncSource(newSyncSource);\n    return () => newSyncSource.destroy();\n  }, [createSyncSource]);\n  return syncSource;\n}\n\n//# sourceMappingURL=_private.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9fcHJpdmF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQjZCOztBQUU3QjtBQUM4RTtBQUM5RSxzREFBc0Qsa0RBQXVCLEdBQUcsNENBQVM7O0FBRXpGO0FBQ21EO0FBQ2U7QUFDbEU7QUFDQTtBQUNBLHNEQUFzRCwrQ0FBUTtBQUM5RCx3QkFBd0IsNkNBQU07QUFDOUIsb0NBQW9DLGdGQUE0QjtBQUNoRSxrQ0FBa0MsOEVBQTBCO0FBQzVELEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsdUNBQXVDLGlFQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDNkM7QUFDMEI7QUFDdkU7QUFDQSxpQkFBaUIsNkRBQVM7QUFDMUIsa0NBQWtDLHVEQUFTO0FBQzNDLHNDQUFzQywrQ0FBUztBQUMvQyxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUE2QkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9fcHJpdmF0ZS5qcz9hNDdlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQsXG4gIHVzZUFkZFJvb21Db21tZW50UmVhY3Rpb24sXG4gIHVzZUNsaWVudCxcbiAgdXNlQ2xpZW50T3JOdWxsLFxuICB1c2VDcmVhdGVSb29tQ29tbWVudCxcbiAgdXNlQ3JlYXRlUm9vbVRocmVhZCxcbiAgdXNlQ3JlYXRlVGV4dE1lbnRpb24sXG4gIHVzZURlbGV0ZVJvb21Db21tZW50LFxuICB1c2VEZWxldGVSb29tVGhyZWFkLFxuICB1c2VEZWxldGVUZXh0TWVudGlvbixcbiAgdXNlRWRpdFJvb21Db21tZW50LFxuICB1c2VFZGl0Um9vbVRocmVhZE1ldGFkYXRhLFxuICB1c2VNYXJrUm9vbVRocmVhZEFzUmVhZCxcbiAgdXNlTWFya1Jvb21UaHJlYWRBc1Jlc29sdmVkLFxuICB1c2VNYXJrUm9vbVRocmVhZEFzVW5yZXNvbHZlZCxcbiAgdXNlTWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUsXG4gIHVzZVJlbW92ZVJvb21Db21tZW50UmVhY3Rpb24sXG4gIHVzZVJlcG9ydFRleHRFZGl0b3IsXG4gIHVzZVJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMsXG4gIHVzZVJvb21BdHRhY2htZW50VXJsLFxuICB1c2VSb29tT3JOdWxsLFxuICB1c2VSb29tUGVybWlzc2lvbnMsXG4gIHVzZVNpZ25hbCxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IsXG4gIHVzZVlqc1Byb3ZpZGVyXG59IGZyb20gXCIuL2NodW5rLTVSVlcyNTNXLmpzXCI7XG5cbi8vIHNyYy9saWIvdXNlLWxheW91dC1lZmZlY3QudHNcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZU9yaWdpbmFsTGF5b3V0RWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHVzZU9yaWdpbmFsTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vLyBzcmMvdXNlLW1lbnRpb24tc3VnZ2VzdGlvbnMudHNcbmltcG9ydCB7IHN0YWJsZVN0cmluZ2lmeSB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIE1FTlRJT05fU1VHR0VTVElPTlNfREVCT1VOQ0UgPSA1MDA7XG5mdW5jdGlvbiB1c2VNZW50aW9uU3VnZ2VzdGlvbnMocm9vbUlkLCBzZWFyY2gpIHtcbiAgY29uc3QgW21lbnRpb25TdWdnZXN0aW9ucywgc2V0TWVudGlvblN1Z2dlc3Rpb25zXSA9IHVzZVN0YXRlKCk7XG4gIGNvbnN0IGxhc3RJbnZva2VkQXQgPSB1c2VSZWYoKTtcbiAgY29uc3QgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyA9IHVzZVJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMoKTtcbiAgY29uc3QgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUgPSB1c2VNZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSgpO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAoc2VhcmNoID09PSB2b2lkIDAgfHwgIXJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uc0FyZ3MgPSB7IHRleHQ6IHNlYXJjaCwgcm9vbUlkIH07XG4gICAgY29uc3QgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGVLZXkgPSBzdGFibGVTdHJpbmdpZnkoXG4gICAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zQXJnc1xuICAgICk7XG4gICAgbGV0IGRlYm91bmNlVGltZW91dDtcbiAgICBsZXQgaXNDYW5jZWxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGdldE1lbnRpb25TdWdnZXN0aW9ucyA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxhc3RJbnZva2VkQXQuY3VycmVudCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCBtZW50aW9uU3VnZ2VzdGlvbnMyID0gYXdhaXQgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyhcbiAgICAgICAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zQXJnc1xuICAgICAgICApO1xuICAgICAgICBpZiAoIWlzQ2FuY2VsZWQpIHtcbiAgICAgICAgICBzZXRNZW50aW9uU3VnZ2VzdGlvbnMobWVudGlvblN1Z2dlc3Rpb25zMik7XG4gICAgICAgICAgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUuc2V0KFxuICAgICAgICAgICAgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGVLZXksXG4gICAgICAgICAgICBtZW50aW9uU3VnZ2VzdGlvbnMyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcj8ubWVzc2FnZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAobWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUuaGFzKG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlS2V5KSkge1xuICAgICAgc2V0TWVudGlvblN1Z2dlc3Rpb25zKFxuICAgICAgICBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZS5nZXQobWVudGlvblN1Z2dlc3Rpb25zQ2FjaGVLZXkpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWxhc3RJbnZva2VkQXQuY3VycmVudCB8fCBNYXRoLmFicyhwZXJmb3JtYW5jZS5ub3coKSAtIGxhc3RJbnZva2VkQXQuY3VycmVudCkgPiBNRU5USU9OX1NVR0dFU1RJT05TX0RFQk9VTkNFKSB7XG4gICAgICB2b2lkIGdldE1lbnRpb25TdWdnZXN0aW9ucygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJvdW5jZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZvaWQgZ2V0TWVudGlvblN1Z2dlc3Rpb25zKCk7XG4gICAgICB9LCBNRU5USU9OX1NVR0dFU1RJT05TX0RFQk9VTkNFKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzQ2FuY2VsZWQgPSB0cnVlO1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVvdXQpO1xuICAgIH07XG4gIH0sIFtzZWFyY2gsIHJvb21JZCwgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucywgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGVdKTtcbiAgcmV0dXJuIG1lbnRpb25TdWdnZXN0aW9ucztcbn1cblxuLy8gc3JjL3VzZS1zeW5jLXNvdXJjZS50c1xuaW1wb3J0IHsga0ludGVybmFsIH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVN5bmNTb3VyY2UoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCBjcmVhdGVTeW5jU291cmNlID0gY2xpZW50W2tJbnRlcm5hbF0uY3JlYXRlU3luY1NvdXJjZTtcbiAgY29uc3QgW3N5bmNTb3VyY2UsIHNldFN5bmNTb3VyY2VdID0gdXNlU3RhdGUyKCk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGNvbnN0IG5ld1N5bmNTb3VyY2UgPSBjcmVhdGVTeW5jU291cmNlKCk7XG4gICAgc2V0U3luY1NvdXJjZShuZXdTeW5jU291cmNlKTtcbiAgICByZXR1cm4gKCkgPT4gbmV3U3luY1NvdXJjZS5kZXN0cm95KCk7XG4gIH0sIFtjcmVhdGVTeW5jU291cmNlXSk7XG4gIHJldHVybiBzeW5jU291cmNlO1xufVxuZXhwb3J0IHtcbiAgZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudCxcbiAgdXNlQWRkUm9vbUNvbW1lbnRSZWFjdGlvbixcbiAgdXNlQ2xpZW50T3JOdWxsLFxuICB1c2VDcmVhdGVSb29tQ29tbWVudCxcbiAgdXNlQ3JlYXRlUm9vbVRocmVhZCxcbiAgdXNlQ3JlYXRlVGV4dE1lbnRpb24sXG4gIHVzZURlbGV0ZVJvb21Db21tZW50LFxuICB1c2VEZWxldGVSb29tVGhyZWFkLFxuICB1c2VEZWxldGVUZXh0TWVudGlvbixcbiAgdXNlRWRpdFJvb21Db21tZW50LFxuICB1c2VFZGl0Um9vbVRocmVhZE1ldGFkYXRhLFxuICB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZU1hcmtSb29tVGhyZWFkQXNSZWFkLFxuICB1c2VNYXJrUm9vbVRocmVhZEFzUmVzb2x2ZWQsXG4gIHVzZU1hcmtSb29tVGhyZWFkQXNVbnJlc29sdmVkLFxuICB1c2VNZW50aW9uU3VnZ2VzdGlvbnMsXG4gIHVzZU1lbnRpb25TdWdnZXN0aW9uc0NhY2hlLFxuICB1c2VSZW1vdmVSb29tQ29tbWVudFJlYWN0aW9uLFxuICB1c2VSZXBvcnRUZXh0RWRpdG9yLFxuICB1c2VSZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zLFxuICB1c2VSb29tQXR0YWNobWVudFVybCxcbiAgdXNlUm9vbU9yTnVsbCxcbiAgdXNlUm9vbVBlcm1pc3Npb25zLFxuICB1c2VTaWduYWwsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yLFxuICB1c2VTeW5jU291cmNlLFxuICB1c2VZanNQcm92aWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9wcml2YXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/_private.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/chunk-5RVW253W.js":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/chunk-5RVW253W.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientContext: () => (/* binding */ ClientContext),\n/* harmony export */   LiveblocksProvider: () => (/* binding */ LiveblocksProvider),\n/* harmony export */   RoomContext: () => (/* binding */ RoomContext),\n/* harmony export */   _RoomProvider: () => (/* binding */ _RoomProvider),\n/* harmony export */   _useAddReaction: () => (/* binding */ _useAddReaction),\n/* harmony export */   _useBroadcastEvent: () => (/* binding */ _useBroadcastEvent),\n/* harmony export */   _useCreateThread: () => (/* binding */ _useCreateThread),\n/* harmony export */   _useDeleteThread: () => (/* binding */ _useDeleteThread),\n/* harmony export */   _useEditThreadMetadata: () => (/* binding */ _useEditThreadMetadata),\n/* harmony export */   _useEventListener: () => (/* binding */ _useEventListener),\n/* harmony export */   _useHistoryVersions: () => (/* binding */ _useHistoryVersions),\n/* harmony export */   _useHistoryVersionsSuspense: () => (/* binding */ _useHistoryVersionsSuspense),\n/* harmony export */   _useInboxNotificationThread: () => (/* binding */ _useInboxNotificationThread),\n/* harmony export */   _useIsInsideRoom: () => (/* binding */ _useIsInsideRoom),\n/* harmony export */   _useMutation: () => (/* binding */ _useMutation),\n/* harmony export */   _useMyPresence: () => (/* binding */ _useMyPresence),\n/* harmony export */   _useOther: () => (/* binding */ _useOther),\n/* harmony export */   _useOtherSuspense: () => (/* binding */ _useOtherSuspense),\n/* harmony export */   _useOthers: () => (/* binding */ _useOthers),\n/* harmony export */   _useOthersListener: () => (/* binding */ _useOthersListener),\n/* harmony export */   _useOthersMapped: () => (/* binding */ _useOthersMapped),\n/* harmony export */   _useOthersMappedSuspense: () => (/* binding */ _useOthersMappedSuspense),\n/* harmony export */   _useOthersSuspense: () => (/* binding */ _useOthersSuspense),\n/* harmony export */   _useRoom: () => (/* binding */ _useRoom),\n/* harmony export */   _useRoomNotificationSettings: () => (/* binding */ _useRoomNotificationSettings),\n/* harmony export */   _useRoomNotificationSettingsSuspense: () => (/* binding */ _useRoomNotificationSettingsSuspense),\n/* harmony export */   _useSelf: () => (/* binding */ _useSelf),\n/* harmony export */   _useSelfSuspense: () => (/* binding */ _useSelfSuspense),\n/* harmony export */   _useStorage: () => (/* binding */ _useStorage),\n/* harmony export */   _useStorageRoot: () => (/* binding */ _useStorageRoot),\n/* harmony export */   _useStorageSuspense: () => (/* binding */ _useStorageSuspense),\n/* harmony export */   _useThreads: () => (/* binding */ _useThreads),\n/* harmony export */   _useThreadsSuspense: () => (/* binding */ _useThreadsSuspense),\n/* harmony export */   _useUpdateMyPresence: () => (/* binding */ _useUpdateMyPresence),\n/* harmony export */   _useUser: () => (/* binding */ _useUser),\n/* harmony export */   _useUserSuspense: () => (/* binding */ _useUserSuspense),\n/* harmony export */   _useUserThreadsSuspense_experimental: () => (/* binding */ _useUserThreadsSuspense_experimental),\n/* harmony export */   _useUserThreads_experimental: () => (/* binding */ _useUserThreads_experimental),\n/* harmony export */   createLiveblocksContext: () => (/* binding */ createLiveblocksContext),\n/* harmony export */   createRoomContext: () => (/* binding */ createRoomContext),\n/* harmony export */   getUmbrellaStoreForClient: () => (/* binding */ getUmbrellaStoreForClient),\n/* harmony export */   useAddRoomCommentReaction: () => (/* binding */ useAddRoomCommentReaction),\n/* harmony export */   useAttachmentUrl: () => (/* binding */ useAttachmentUrl),\n/* harmony export */   useAttachmentUrlSuspense: () => (/* binding */ useAttachmentUrlSuspense),\n/* harmony export */   useBatch: () => (/* binding */ useBatch),\n/* harmony export */   useCanRedo: () => (/* binding */ useCanRedo),\n/* harmony export */   useCanUndo: () => (/* binding */ useCanUndo),\n/* harmony export */   useClient: () => (/* binding */ useClient),\n/* harmony export */   useClientOrNull: () => (/* binding */ useClientOrNull),\n/* harmony export */   useCreateComment: () => (/* binding */ useCreateComment),\n/* harmony export */   useCreateRoomComment: () => (/* binding */ useCreateRoomComment),\n/* harmony export */   useCreateRoomThread: () => (/* binding */ useCreateRoomThread),\n/* harmony export */   useCreateTextMention: () => (/* binding */ useCreateTextMention),\n/* harmony export */   useDeleteAllInboxNotifications: () => (/* binding */ useDeleteAllInboxNotifications),\n/* harmony export */   useDeleteComment: () => (/* binding */ useDeleteComment),\n/* harmony export */   useDeleteInboxNotification: () => (/* binding */ useDeleteInboxNotification),\n/* harmony export */   useDeleteRoomComment: () => (/* binding */ useDeleteRoomComment),\n/* harmony export */   useDeleteRoomThread: () => (/* binding */ useDeleteRoomThread),\n/* harmony export */   useDeleteTextMention: () => (/* binding */ useDeleteTextMention),\n/* harmony export */   useEditComment: () => (/* binding */ useEditComment),\n/* harmony export */   useEditRoomComment: () => (/* binding */ useEditRoomComment),\n/* harmony export */   useEditRoomThreadMetadata: () => (/* binding */ useEditRoomThreadMetadata),\n/* harmony export */   useErrorListener: () => (/* binding */ useErrorListener),\n/* harmony export */   useHistory: () => (/* binding */ useHistory),\n/* harmony export */   useHistoryVersionData: () => (/* binding */ useHistoryVersionData),\n/* harmony export */   useInboxNotifications: () => (/* binding */ useInboxNotifications),\n/* harmony export */   useInboxNotificationsSuspense: () => (/* binding */ useInboxNotificationsSuspense),\n/* harmony export */   useLostConnectionListener: () => (/* binding */ useLostConnectionListener),\n/* harmony export */   useMarkAllInboxNotificationsAsRead: () => (/* binding */ useMarkAllInboxNotificationsAsRead),\n/* harmony export */   useMarkInboxNotificationAsRead: () => (/* binding */ useMarkInboxNotificationAsRead),\n/* harmony export */   useMarkRoomThreadAsRead: () => (/* binding */ useMarkRoomThreadAsRead),\n/* harmony export */   useMarkRoomThreadAsResolved: () => (/* binding */ useMarkRoomThreadAsResolved),\n/* harmony export */   useMarkRoomThreadAsUnresolved: () => (/* binding */ useMarkRoomThreadAsUnresolved),\n/* harmony export */   useMarkThreadAsRead: () => (/* binding */ useMarkThreadAsRead),\n/* harmony export */   useMarkThreadAsResolved: () => (/* binding */ useMarkThreadAsResolved),\n/* harmony export */   useMarkThreadAsUnresolved: () => (/* binding */ useMarkThreadAsUnresolved),\n/* harmony export */   useMentionSuggestionsCache: () => (/* binding */ useMentionSuggestionsCache),\n/* harmony export */   useNotificationSettings: () => (/* binding */ useNotificationSettings),\n/* harmony export */   useNotificationSettingsSuspense: () => (/* binding */ useNotificationSettingsSuspense),\n/* harmony export */   useOthersConnectionIds: () => (/* binding */ useOthersConnectionIds),\n/* harmony export */   useOthersConnectionIdsSuspense: () => (/* binding */ useOthersConnectionIdsSuspense),\n/* harmony export */   useRedo: () => (/* binding */ useRedo),\n/* harmony export */   useRemoveReaction: () => (/* binding */ useRemoveReaction),\n/* harmony export */   useRemoveRoomCommentReaction: () => (/* binding */ useRemoveRoomCommentReaction),\n/* harmony export */   useReportTextEditor: () => (/* binding */ useReportTextEditor),\n/* harmony export */   useResolveMentionSuggestions: () => (/* binding */ useResolveMentionSuggestions),\n/* harmony export */   useRoomAttachmentUrl: () => (/* binding */ useRoomAttachmentUrl),\n/* harmony export */   useRoomInfo: () => (/* binding */ useRoomInfo),\n/* harmony export */   useRoomInfoSuspense: () => (/* binding */ useRoomInfoSuspense),\n/* harmony export */   useRoomOrNull: () => (/* binding */ useRoomOrNull),\n/* harmony export */   useRoomPermissions: () => (/* binding */ useRoomPermissions),\n/* harmony export */   useSignal: () => (/* binding */ useSignal),\n/* harmony export */   useStatus: () => (/* binding */ useStatus),\n/* harmony export */   useStorageStatus: () => (/* binding */ useStorageStatus),\n/* harmony export */   useStorageStatusSuspense: () => (/* binding */ useStorageStatusSuspense),\n/* harmony export */   useSyncExternalStoreWithSelector: () => (/* binding */ useSyncExternalStoreWithSelector),\n/* harmony export */   useSyncStatus: () => (/* binding */ useSyncStatus),\n/* harmony export */   useThreadSubscription: () => (/* binding */ useThreadSubscription),\n/* harmony export */   useUndo: () => (/* binding */ useUndo),\n/* harmony export */   useUnreadInboxNotificationsCount: () => (/* binding */ useUnreadInboxNotificationsCount),\n/* harmony export */   useUnreadInboxNotificationsCountSuspense: () => (/* binding */ useUnreadInboxNotificationsCountSuspense),\n/* harmony export */   useUpdateNotificationSettings: () => (/* binding */ useUpdateNotificationSettings),\n/* harmony export */   useUpdateRoomNotificationSettings: () => (/* binding */ useUpdateRoomNotificationSettings),\n/* harmony export */   useYjsProvider: () => (/* binding */ useYjsProvider)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n// src/contexts.ts\n\nvar RoomContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useRoomOrNull() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RoomContext);\n}\nfunction useIsInsideRoom() {\n  const room = useRoomOrNull();\n  return room !== null;\n}\n\n// src/use-sync-external-store-with-selector.ts\n\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n}\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n  const instRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  let inst;\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n  const [getSelection, getServerSelection] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    let hasMemo = false;\n    let memoizedSnapshot;\n    let memoizedSelection;\n    const memoizedSelector = (nextSnapshot) => {\n      if (!hasMemo) {\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n        const nextSelection2 = selector(nextSnapshot);\n        if (isEqual !== void 0) {\n          if (inst.hasValue) {\n            const currentSelection = inst.value;\n            if (isEqual(currentSelection, nextSelection2)) {\n              memoizedSelection = currentSelection;\n              return currentSelection;\n            }\n          }\n        }\n        memoizedSelection = nextSelection2;\n        return nextSelection2;\n      }\n      const prevSnapshot = memoizedSnapshot;\n      const prevSelection = memoizedSelection;\n      if (is(prevSnapshot, nextSnapshot)) {\n        return prevSelection;\n      }\n      const nextSelection = selector(nextSnapshot);\n      if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {\n        memoizedSnapshot = nextSnapshot;\n        return prevSelection;\n      }\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    };\n    const maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;\n    const getSnapshotWithSelector = () => memoizedSelector(getSnapshot());\n    const getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : () => memoizedSelector(maybeGetServerSnapshot());\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]);\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    subscribe,\n    getSelection,\n    getServerSelection\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n  return value;\n}\n\n// src/use-signal.ts\nvar identity = (value) => value;\nfunction useSignal(signal, selector, isEqual) {\n  return useSyncExternalStoreWithSelector(\n    signal.subscribe,\n    signal.get,\n    signal.get,\n    selector ?? identity,\n    isEqual\n  );\n}\n\n// src/liveblocks.tsx\n\n\n\n\n// src/config.ts\nvar SECONDS = 1e3;\nvar MINUTES = 60 * SECONDS;\nvar config = {\n  SMOOTH_DELAY: 1 * SECONDS,\n  NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,\n  ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,\n  ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,\n  USER_THREADS_POLL_INTERVAL: 1 * MINUTES,\n  USER_THREADS_MAX_STALE_TIME: 30 * SECONDS,\n  HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,\n  HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,\n  NOTIFICATION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS,\n  USER_NOTIFICATION_SETTINGS_INTERVAL: 5 * MINUTES,\n  USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME: 1 * MINUTES\n};\n\n// src/lib/AsyncResult.ts\nvar ASYNC_LOADING = Object.freeze({ isLoading: true });\nvar ASYNC_ERR = (error) => Object.freeze({ isLoading: false, error });\nfunction ASYNC_OK(fieldOrData, data) {\n  if (arguments.length === 1) {\n    return Object.freeze({ isLoading: false, data: fieldOrData });\n  } else {\n    return Object.freeze({ isLoading: false, [fieldOrData]: data });\n  }\n}\n\n// src/lib/itertools.ts\nfunction find(it, predicate) {\n  for (const item of it) {\n    if (predicate(item)) return item;\n  }\n  return void 0;\n}\nfunction count(it, predicate) {\n  let total = 0;\n  for (const item of it) {\n    if (predicate(item)) total++;\n  }\n  return total;\n}\n\n// src/lib/ssr.ts\nfunction ensureNotServerSide() {\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"You cannot use the Suspense version of Liveblocks hooks server side. Make sure to only call them client side by using a ClientSideSuspense wrapper.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#ClientSideSuspense\"\n    );\n  }\n}\n\n// src/lib/use-initial.ts\n\n\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n\n// src/lib/use-initial.ts\nvar noop = (state) => state;\nfunction useInitial(value) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(noop, value)[0];\n}\nfunction useInitialUnlessFunction(latestValue) {\n  const frozenValue = useInitial(latestValue);\n  if (typeof frozenValue === \"function\") {\n    const ref = useLatest(latestValue);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args) => ref.current(...args), [\n      ref\n    ]);\n  } else {\n    return frozenValue;\n  }\n}\n\n// src/lib/use-polyfill.ts\nvar use = (\n  // React.use ||\n  (promise) => {\n    if (promise.status === \"pending\") {\n      throw promise;\n    } else if (promise.status === \"fulfilled\") {\n      return promise.value;\n    } else if (promise.status === \"rejected\") {\n      throw promise.reason;\n    } else {\n      promise.status = \"pending\";\n      promise.then(\n        (v) => {\n          promise.status = \"fulfilled\";\n          promise.value = v;\n        },\n        (e) => {\n          promise.status = \"rejected\";\n          promise.reason = e;\n        }\n      );\n      throw promise;\n    }\n  }\n);\n\n// src/umbrella-store.ts\n\n\n// src/lib/autobind.ts\nfunction autobind(self) {\n  const seen = /* @__PURE__ */ new Set();\n  seen.add(\"constructor\");\n  let obj = self.constructor.prototype;\n  do {\n    for (const key of Reflect.ownKeys(obj)) {\n      if (seen.has(key)) continue;\n      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);\n      if (typeof descriptor?.value === \"function\") {\n        seen.add(key);\n        self[key] = self[key].bind(self);\n      }\n    }\n  } while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype);\n}\n\n// src/lib/shallow2.ts\n\nfunction shallow2(a, b) {\n  if (!(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(a) || !(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(b)) {\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow)(a, b);\n  }\n  const keysA = Object.keys(a);\n  if (keysA.length !== Object.keys(b).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(b, key) && (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow)(a[key], b[key])\n  );\n}\n\n// src/ThreadDB.ts\n\n\n// src/lib/querying.ts\n\nfunction makeThreadsFilter(query) {\n  return (thread) => matchesQuery(thread, query) && matchesMetadata(thread, query);\n}\nfunction matchesQuery(thread, q) {\n  return q.resolved === void 0 || thread.resolved === q.resolved;\n}\nfunction matchesMetadata(thread, q) {\n  const metadata = thread.metadata;\n  return q.metadata === void 0 || Object.entries(q.metadata).every(\n    ([key, op]) => (\n      // Ignore explicit-undefined filters\n      // Boolean logic: op? => value matches the operator\n      op === void 0 || matchesOperator(metadata[key], op)\n    )\n  );\n}\nfunction matchesOperator(value, op) {\n  if (op === null) {\n    return value === void 0;\n  } else if ((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.isStartsWithOperator)(op)) {\n    return typeof value === \"string\" && value.startsWith(op.startsWith);\n  } else {\n    return value === op;\n  }\n}\n\n// src/ThreadDB.ts\nfunction sanitizeThread(thread) {\n  if (thread.deletedAt) {\n    if (thread.comments.length > 0) {\n      return { ...thread, comments: [] };\n    }\n  }\n  const hasComment = thread.comments.some((c) => !c.deletedAt);\n  if (!hasComment) {\n    return { ...thread, deletedAt: /* @__PURE__ */ new Date(), comments: [] };\n  }\n  return thread;\n}\nvar ThreadDB = class _ThreadDB {\n  #byId;\n  #asc;\n  #desc;\n  // This signal will be notified on every mutation\n  signal;\n  constructor() {\n    this.#asc = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.SortedList.from([], (t1, t2) => {\n      const d1 = t1.createdAt;\n      const d2 = t2.createdAt;\n      return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;\n    });\n    this.#desc = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.SortedList.from([], (t1, t2) => {\n      const d2 = t2.updatedAt;\n      const d1 = t1.updatedAt;\n      return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;\n    });\n    this.#byId = /* @__PURE__ */ new Map();\n    this.signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(this);\n  }\n  //\n  // Public APIs\n  //\n  clone() {\n    const newPool = new _ThreadDB();\n    newPool.#byId = new Map(this.#byId);\n    newPool.#asc = this.#asc.clone();\n    newPool.#desc = this.#desc.clone();\n    return newPool;\n  }\n  /** Returns an existing thread by ID. Will never return a deleted thread. */\n  get(threadId) {\n    const thread = this.getEvenIfDeleted(threadId);\n    return thread?.deletedAt ? void 0 : thread;\n  }\n  /** Returns the (possibly deleted) thread by ID. */\n  getEvenIfDeleted(threadId) {\n    return this.#byId.get(threadId);\n  }\n  /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */\n  upsert(thread) {\n    this.signal.mutate(() => {\n      thread = sanitizeThread(thread);\n      const id = thread.id;\n      const toRemove = this.#byId.get(id);\n      if (toRemove) {\n        if (toRemove.deletedAt) return false;\n        this.#asc.remove(toRemove);\n        this.#desc.remove(toRemove);\n      }\n      if (!thread.deletedAt) {\n        this.#asc.add(thread);\n        this.#desc.add(thread);\n      }\n      this.#byId.set(id, thread);\n      return true;\n    });\n  }\n  /** Like .upsert(), except it won't update if a thread by this ID already exists. */\n  // TODO Consider renaming this to just .upsert(). I'm not sure if we really\n  // TODO need the raw .upsert(). Would be nice if this behavior was the default.\n  upsertIfNewer(thread) {\n    const existing = this.get(thread.id);\n    if (!existing || thread.updatedAt >= existing.updatedAt) {\n      this.upsert(thread);\n    }\n  }\n  applyDelta(newThreads, deletedThreads) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      for (const thread of newThreads) {\n        this.upsertIfNewer(thread);\n      }\n      for (const { id, deletedAt } of deletedThreads) {\n        const existing = this.getEvenIfDeleted(id);\n        if (!existing) continue;\n        this.delete(id, deletedAt);\n      }\n    });\n  }\n  /**\n   * Marks a thread as deleted. It will no longer pop up in .findMany()\n   * queries, but it can still be accessed via `.getEvenIfDeleted()`.\n   */\n  delete(threadId, deletedAt) {\n    const existing = this.#byId.get(threadId);\n    if (existing && !existing.deletedAt) {\n      this.upsert({ ...existing, deletedAt, updatedAt: deletedAt });\n    }\n  }\n  /**\n   * Returns all threads matching a given roomId and query. If roomId is not\n   * specified, it will return all threads matching the query, across all\n   * rooms.\n   *\n   * Returns the results in the requested order. Please note:\n   *   'asc'  means by createdAt ASC\n   *   'desc' means by updatedAt DESC\n   *\n   * Will never return deleted threads in the result.\n   */\n  findMany(roomId, query, direction) {\n    const index = direction === \"desc\" ? this.#desc : this.#asc;\n    const crit = [];\n    if (roomId !== void 0) {\n      crit.push((t) => t.roomId === roomId);\n    }\n    crit.push(makeThreadsFilter(query));\n    return Array.from(index.filter((t) => crit.every((pred) => pred(t))));\n  }\n};\n\n// src/umbrella-store.ts\nfunction makeRoomThreadsQueryKey(roomId, query) {\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.stableStringify)([roomId, query ?? {}]);\n}\nfunction makeUserThreadsQueryKey(query) {\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.stableStringify)(query ?? {});\n}\nfunction usify(promise) {\n  if (\"status\" in promise) {\n    return promise;\n  }\n  const usable = promise;\n  usable.status = \"pending\";\n  usable.then(\n    (value) => {\n      usable.status = \"fulfilled\";\n      usable.value = value;\n    },\n    (err) => {\n      usable.status = \"rejected\";\n      usable.reason = err;\n    }\n  );\n  return usable;\n}\nvar noop2 = Promise.resolve();\nvar PaginatedResource = class {\n  #signal;\n  signal;\n  #fetchPage;\n  #pendingFetchMore;\n  constructor(fetchPage) {\n    this.#signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal(ASYNC_LOADING);\n    this.#fetchPage = fetchPage;\n    this.#pendingFetchMore = null;\n    this.signal = this.#signal.asReadonly();\n    autobind(this);\n  }\n  get() {\n    return this.#signal.get();\n  }\n  #patch(patch) {\n    const state = this.#signal.get();\n    if (state.data === void 0) return;\n    this.#signal.set(ASYNC_OK({ ...state.data, ...patch }));\n  }\n  async #fetchMore() {\n    const state = this.#signal.get();\n    if (!state.data?.cursor || state.data.isFetchingMore) {\n      return;\n    }\n    this.#patch({ isFetchingMore: true });\n    try {\n      const nextCursor = await this.#fetchPage(state.data.cursor);\n      this.#patch({\n        cursor: nextCursor,\n        hasFetchedAll: nextCursor === null,\n        fetchMoreError: void 0,\n        isFetchingMore: false\n      });\n    } catch (err) {\n      this.#patch({\n        isFetchingMore: false,\n        fetchMoreError: err\n      });\n    }\n  }\n  fetchMore() {\n    const state = this.#signal.get();\n    if (!state.data?.cursor) return noop2;\n    if (!this.#pendingFetchMore) {\n      this.#pendingFetchMore = this.#fetchMore().finally(() => {\n        this.#pendingFetchMore = null;\n      });\n    }\n    return this.#pendingFetchMore;\n  }\n  #cachedPromise = null;\n  waitUntilLoaded() {\n    if (this.#cachedPromise) {\n      return this.#cachedPromise;\n    }\n    const initialPageFetch$ = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.autoRetry)(\n      () => this.#fetchPage(\n        /* cursor */\n        void 0\n      ),\n      5,\n      [5e3, 5e3, 1e4, 15e3]\n    );\n    const promise = usify(initialPageFetch$);\n    promise.then(\n      (cursor) => {\n        this.#signal.set(\n          ASYNC_OK({\n            cursor,\n            hasFetchedAll: cursor === null,\n            isFetchingMore: false,\n            fetchMoreError: void 0,\n            fetchMore: this.fetchMore\n          })\n        );\n      },\n      (err) => {\n        this.#signal.set(ASYNC_ERR(err));\n        setTimeout(() => {\n          this.#cachedPromise = null;\n          this.#signal.set(ASYNC_LOADING);\n        }, 5e3);\n      }\n    );\n    this.#cachedPromise = promise;\n    return this.#cachedPromise;\n  }\n};\nvar SinglePageResource = class {\n  #signal;\n  signal;\n  #fetchPage;\n  constructor(fetchPage) {\n    this.#signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal(ASYNC_LOADING);\n    this.signal = this.#signal.asReadonly();\n    this.#fetchPage = fetchPage;\n    autobind(this);\n  }\n  get() {\n    return this.#signal.get();\n  }\n  #cachedPromise = null;\n  waitUntilLoaded() {\n    if (this.#cachedPromise) {\n      return this.#cachedPromise;\n    }\n    const initialFetcher$ = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.autoRetry)(\n      () => this.#fetchPage(),\n      5,\n      [5e3, 5e3, 1e4, 15e3]\n    );\n    const promise = usify(initialFetcher$);\n    promise.then(\n      () => {\n        this.#signal.set(ASYNC_OK(void 0));\n      },\n      (err) => {\n        this.#signal.set(ASYNC_ERR(err));\n        setTimeout(() => {\n          this.#cachedPromise = null;\n          this.#signal.set(ASYNC_LOADING);\n        }, 5e3);\n      }\n    );\n    this.#cachedPromise = promise;\n    return promise;\n  }\n};\nfunction createStore_forNotifications() {\n  const signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(/* @__PURE__ */ new Map());\n  function markRead(notificationId, readAt) {\n    signal.mutate((lut) => {\n      const existing = lut.get(notificationId);\n      if (!existing) {\n        return false;\n      }\n      lut.set(notificationId, { ...existing, readAt });\n      return true;\n    });\n  }\n  function markAllRead(readAt) {\n    signal.mutate((lut) => {\n      for (const n of lut.values()) {\n        n.readAt = readAt;\n      }\n    });\n  }\n  function deleteOne(inboxNotificationId) {\n    signal.mutate((lut) => lut.delete(inboxNotificationId));\n  }\n  function clear() {\n    signal.mutate((lut) => lut.clear());\n  }\n  function applyDelta(newNotifications, deletedNotifications) {\n    signal.mutate((lut) => {\n      let mutated = false;\n      for (const n of newNotifications) {\n        const existing = lut.get(n.id);\n        if (existing) {\n          const result = compareInboxNotifications(existing, n);\n          if (result === 1) continue;\n        }\n        lut.set(n.id, n);\n        mutated = true;\n      }\n      for (const n of deletedNotifications) {\n        lut.delete(n.id);\n        mutated = true;\n      }\n      return mutated;\n    });\n  }\n  function updateAssociatedNotification(newComment) {\n    signal.mutate((lut) => {\n      const existing = find(\n        lut.values(),\n        (notification) => notification.kind === \"thread\" && notification.threadId === newComment.threadId\n      );\n      if (!existing) return false;\n      lut.set(existing.id, {\n        ...existing,\n        notifiedAt: newComment.createdAt,\n        readAt: newComment.createdAt\n      });\n      return true;\n    });\n  }\n  function upsert(notification) {\n    signal.mutate((lut) => {\n      lut.set(notification.id, notification);\n    });\n  }\n  return {\n    signal: signal.asReadonly(),\n    // Mutations\n    markAllRead,\n    markRead,\n    delete: deleteOne,\n    applyDelta,\n    clear,\n    updateAssociatedNotification,\n    upsert\n  };\n}\nfunction createStore_forRoomNotificationSettings(updates) {\n  const baseSignal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(/* @__PURE__ */ new Map());\n  function update(roomId, settings) {\n    baseSignal.mutate((lut) => {\n      lut.set(roomId, settings);\n    });\n  }\n  return {\n    signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      baseSignal,\n      updates,\n      (base, updates2) => applyOptimisticUpdates_forSettings(base, updates2)\n    ),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forHistoryVersions() {\n  const baseSignal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(\n    new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(() => /* @__PURE__ */ new Map())\n  );\n  function update(roomId, versions) {\n    baseSignal.mutate((lut) => {\n      const versionsById = lut.getOrCreate(roomId);\n      for (const version of versions) {\n        versionsById.set(version.id, version);\n      }\n    });\n  }\n  return {\n    signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      baseSignal,\n      (hv) => Object.fromEntries(\n        [...hv].map(([roomId, versions]) => [\n          roomId,\n          Object.fromEntries(versions)\n        ])\n      )\n    ),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forPermissionHints() {\n  const signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(\n    new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(() => /* @__PURE__ */ new Set())\n  );\n  function update(newHints) {\n    signal.mutate((lut) => {\n      for (const [roomId, newPermissions] of Object.entries(newHints)) {\n        const existing = lut.getOrCreate(roomId);\n        for (const permission of newPermissions) {\n          existing.add(permission);\n        }\n      }\n    });\n  }\n  return {\n    signal: signal.asReadonly(),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forUserNotificationSettings(updates) {\n  const signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal({});\n  function update(settings) {\n    signal.set((prevSettings) => {\n      return {\n        ...prevSettings,\n        ...settings\n      };\n    });\n  }\n  return {\n    signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      signal,\n      updates,\n      (base, updates2) => applyOptimisticUpdates_forUserNotificationSettings(base, updates2)\n    ),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forOptimistic(client) {\n  const signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal([]);\n  const syncSource = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].createSyncSource();\n  signal.subscribe(\n    () => syncSource.setSyncStatus(\n      signal.get().length > 0 ? \"synchronizing\" : \"synchronized\"\n    )\n  );\n  function add(optimisticUpdate) {\n    const id = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nanoid)();\n    const newUpdate = { ...optimisticUpdate, id };\n    signal.set((state) => [...state, newUpdate]);\n    return id;\n  }\n  function remove(optimisticId) {\n    signal.set((state) => state.filter((ou) => ou.id !== optimisticId));\n  }\n  return {\n    signal: signal.asReadonly(),\n    // Mutations\n    add,\n    remove\n  };\n}\nvar UmbrellaStore = class {\n  #client;\n  //\n  // Internally, the UmbrellaStore keeps track of a few source signals that can\n  // be set and mutated individually. When any of those are mutated then the\n  // clean \"external state\" is recomputed.\n  //\n  //   Mutate inputs...                                             ...observe clean/consistent output!\n  //\n  //            .-> Base ThreadDB ---------+                 +----> Clean threads by ID           (Part 1)\n  //           /                           |                 |\n  //   mutate ----> Base Notifications --+ |                 | +--> Clean notifications           (Part 1)\n  //          \\                          | |                 | |    & notifications by ID\n  //         | \\                         | |      Apply      | |\n  //         |   `-> OptimisticUpdates --+--+--> Optimistic --+-+--> Room Notification Settings   (Part 2)\n  //          \\                          |        Updates    |  |\n  //           `------- etc etc ---------+                   |  +--> History Versions             (Part 3)\n  //                       ^                                 |\n  //                       |                                 +-----> User Notification Settings   (Part 4)\n  //                       |\n  //                       |\n  //                       |                        ^                  ^\n  //                    Signal                      |                  |\n  //                      or                   DerivedSignal      DerivedSignals\n  //                  MutableSignal\n  //\n  //\n  // Input signals.\n  // (Can be mutated directly.)\n  //\n  // XXX_vincent Now that we have createStore_forX, we should probably also change\n  // `threads` to this pattern, ie create a createStore_forThreads helper as\n  // well. It almost works like that already anyway!\n  threads;\n  // Exposes its signal under `.signal` prop\n  notifications;\n  roomNotificationSettings;\n  // prettier-ignore\n  historyVersions;\n  permissionHints;\n  userNotificationSettings;\n  optimisticUpdates;\n  //\n  // Output signals.\n  // (Readonly, clean, consistent. With optimistic updates applied.)\n  //\n  // Note that the output of threadifications signal is the same as the ones for\n  // threads and notifications separately, but the threadifications signal will\n  // be updated whenever either of them change.\n  //\n  outputs;\n  // Notifications\n  #notificationsLastRequestedAt = null;\n  // Keeps track of when we successfully requested an inbox notifications update for the last time. Will be `null` as long as the first successful fetch hasn't happened yet.\n  #notificationsPaginationState;\n  // Room Threads\n  #roomThreadsLastRequestedAtByRoom = /* @__PURE__ */ new Map();\n  // User Threads\n  #userThreadsLastRequestedAt = null;\n  // Room versions\n  #roomVersionsLastRequestedAtByRoom = /* @__PURE__ */ new Map();\n  // User Notification Settings\n  #userNotificationSettings;\n  constructor(client) {\n    this.#client = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].as();\n    this.optimisticUpdates = createStore_forOptimistic(this.#client);\n    this.permissionHints = createStore_forPermissionHints();\n    this.#notificationsPaginationState = new PaginatedResource(\n      async (cursor) => {\n        const result = await this.#client.getInboxNotifications({ cursor });\n        this.updateThreadifications(result.threads, result.inboxNotifications);\n        if (this.#notificationsLastRequestedAt === null) {\n          this.#notificationsLastRequestedAt = result.requestedAt;\n        }\n        const nextCursor = result.nextCursor;\n        return nextCursor;\n      }\n    );\n    const userNotificationSettingsFetcher = async () => {\n      const result = await this.#client.getNotificationSettings();\n      this.userNotificationSettings.update(result);\n    };\n    this.userNotificationSettings = createStore_forUserNotificationSettings(\n      this.optimisticUpdates.signal\n    );\n    this.#userNotificationSettings = new SinglePageResource(\n      userNotificationSettingsFetcher\n    );\n    this.threads = new ThreadDB();\n    this.notifications = createStore_forNotifications();\n    this.roomNotificationSettings = createStore_forRoomNotificationSettings(\n      this.optimisticUpdates.signal\n    );\n    this.historyVersions = createStore_forHistoryVersions();\n    const threadifications = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      this.threads.signal,\n      this.notifications.signal,\n      this.optimisticUpdates.signal,\n      (ts, ns, updates) => applyOptimisticUpdates_forThreadifications(ts, ns, updates)\n    );\n    const threads = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(threadifications, (s) => s.threadsDB);\n    const notifications = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      threadifications,\n      (s) => ({\n        sortedNotifications: s.sortedNotifications,\n        notificationsById: s.notificationsById\n      }),\n      _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n    );\n    const loadingUserThreads = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (queryKey) => {\n        const query = JSON.parse(queryKey);\n        const resource = new PaginatedResource(async (cursor) => {\n          const result = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getUserThreads_experimental({\n            cursor,\n            query\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications\n          );\n          this.permissionHints.update(result.permissionHints);\n          if (this.#userThreadsLastRequestedAt === null) {\n            this.#userThreadsLastRequestedAt = result.requestedAt;\n          }\n          return result.nextCursor;\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n          const threads2 = this.outputs.threads.get().findMany(\n            void 0,\n            // Do _not_ filter by roomId\n            query ?? {},\n            \"desc\"\n          );\n          const page = result.data;\n          return {\n            isLoading: false,\n            threads: threads2,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore\n          };\n        }, shallow2);\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n    const loadingRoomThreads = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (queryKey) => {\n        const [roomId, query] = JSON.parse(queryKey);\n        const resource = new PaginatedResource(async (cursor) => {\n          const result = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getThreads({\n            roomId,\n            cursor,\n            query\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications\n          );\n          this.permissionHints.update(result.permissionHints);\n          const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);\n          if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {\n            this.#roomThreadsLastRequestedAtByRoom.set(\n              roomId,\n              result.requestedAt\n            );\n          }\n          return result.nextCursor;\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n          const threads2 = this.outputs.threads.get().findMany(roomId, query ?? {}, \"asc\");\n          const page = result.data;\n          return {\n            isLoading: false,\n            threads: threads2,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore\n          };\n        }, shallow2);\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n    const loadingNotifications = {\n      signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n        const resource = this.#notificationsPaginationState;\n        const result = resource.get();\n        if (result.isLoading || result.error) {\n          return result;\n        }\n        const page = result.data;\n        return {\n          isLoading: false,\n          inboxNotifications: this.outputs.notifications.get().sortedNotifications,\n          hasFetchedAll: page.hasFetchedAll,\n          isFetchingMore: page.isFetchingMore,\n          fetchMoreError: page.fetchMoreError,\n          fetchMore: page.fetchMore\n        };\n      }),\n      waitUntilLoaded: this.#notificationsPaginationState.waitUntilLoaded\n    };\n    const settingsByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap((roomId) => {\n      const resource = new SinglePageResource(async () => {\n        const room = this.#client.getRoom(roomId);\n        if (room === null) {\n          throw new Error(`Room '${roomId}' is not available on client`);\n        }\n        const result = await room.getNotificationSettings();\n        this.roomNotificationSettings.update(roomId, result);\n      });\n      const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n        const result = resource.get();\n        if (result.isLoading || result.error) {\n          return result;\n        } else {\n          return ASYNC_OK(\n            \"settings\",\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(this.roomNotificationSettings.signal.get()[roomId])\n          );\n        }\n      }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n      return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n    });\n    const versionsByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (roomId) => {\n        const resource = new SinglePageResource(async () => {\n          const room = this.#client.getRoom(roomId);\n          if (room === null) {\n            throw new Error(`Room '${roomId}' is not available on client`);\n          }\n          const result = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].listTextVersions();\n          this.historyVersions.update(roomId, result.versions);\n          const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);\n          if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {\n            this.#roomVersionsLastRequestedAtByRoom.set(\n              roomId,\n              result.requestedAt\n            );\n          }\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          } else {\n            return ASYNC_OK(\n              \"versions\",\n              Object.values(this.historyVersions.signal.get()[roomId] ?? {})\n            );\n          }\n        }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n    const userNotificationSettings = {\n      signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n        const result = this.#userNotificationSettings.get();\n        if (result.isLoading || result.error) {\n          return result;\n        }\n        return ASYNC_OK(\n          \"settings\",\n          (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(this.userNotificationSettings.signal.get())\n        );\n      }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow),\n      waitUntilLoaded: this.#userNotificationSettings.waitUntilLoaded\n    };\n    this.outputs = {\n      threadifications,\n      threads,\n      loadingRoomThreads,\n      loadingUserThreads,\n      notifications,\n      loadingNotifications,\n      settingsByRoomId,\n      versionsByRoomId,\n      userNotificationSettings\n    };\n    autobind(this);\n  }\n  /**\n   * Updates an existing inbox notification with a new value, replacing the\n   * corresponding optimistic update.\n   *\n   * This will not update anything if the inbox notification ID isn't found.\n   */\n  markInboxNotificationRead(inboxNotificationId, readAt, optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.markRead(inboxNotificationId, readAt);\n    });\n  }\n  markAllInboxNotificationsRead(optimisticId, readAt) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.markAllRead(readAt);\n    });\n  }\n  /**\n   * Deletes an existing inbox notification, replacing the corresponding\n   * optimistic update.\n   */\n  deleteInboxNotification(inboxNotificationId, optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.delete(inboxNotificationId);\n    });\n  }\n  /**\n   * Deletes *all* inbox notifications, replacing the corresponding optimistic\n   * update.\n   */\n  deleteAllInboxNotifications(optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.clear();\n    });\n  }\n  /**\n   * Creates an new thread, replacing the corresponding optimistic update.\n   */\n  createThread(optimisticId, thread) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.threads.upsert(thread);\n    });\n  }\n  /**\n   * Updates an existing thread with a new value, replacing the corresponding\n   * optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found; or\n   * - The thread ID was already deleted; or\n   * - The thread ID was updated more recently than the optimistic update's\n   *   timestamp (if given)\n   */\n  #updateThread(threadId, optimisticId, callback, updatedAt) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      if (optimisticId !== null) {\n        this.optimisticUpdates.remove(optimisticId);\n      }\n      const db = this.threads;\n      const existing = db.get(threadId);\n      if (!existing) return;\n      if (!!updatedAt && existing.updatedAt > updatedAt) return;\n      db.upsert(callback(existing));\n    });\n  }\n  patchThread(threadId, optimisticId, patch, updatedAt) {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => ({ ...thread, ...(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.compactObject)(patch) }),\n      updatedAt\n    );\n  }\n  addReaction(threadId, optimisticId, commentId, reaction, createdAt) {\n    this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyAddReaction(thread, commentId, reaction),\n      createdAt\n    );\n  }\n  removeReaction(threadId, optimisticId, commentId, emoji, userId, removedAt) {\n    this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyRemoveReaction(thread, commentId, emoji, userId, removedAt),\n      removedAt\n    );\n  }\n  /**\n   * Soft-deletes an existing thread by setting its `deletedAt` value,\n   * replacing the corresponding optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found; or\n   * - The thread ID was already deleted\n   */\n  deleteThread(threadId, optimisticId) {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      // A deletion is actually an update of the deletedAt property internally\n      (thread) => ({ ...thread, updatedAt: /* @__PURE__ */ new Date(), deletedAt: /* @__PURE__ */ new Date() })\n    );\n  }\n  /**\n   * Creates an existing comment and ensures the associated notification is\n   * updated correctly, replacing the corresponding optimistic update.\n   */\n  createComment(newComment, optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      const existingThread = this.threads.get(newComment.threadId);\n      if (!existingThread) {\n        return;\n      }\n      this.threads.upsert(applyUpsertComment(existingThread, newComment));\n      this.notifications.updateAssociatedNotification(newComment);\n    });\n  }\n  editComment(threadId, optimisticId, editedComment) {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyUpsertComment(thread, editedComment)\n    );\n  }\n  deleteComment(threadId, optimisticId, commentId, deletedAt) {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyDeleteComment(thread, commentId, deletedAt),\n      deletedAt\n    );\n  }\n  updateThreadifications(threads, notifications, deletedThreads = [], deletedNotifications = []) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.threads.applyDelta(threads, deletedThreads);\n      this.notifications.applyDelta(notifications, deletedNotifications);\n    });\n  }\n  /**\n   * Updates existing notification setting for a room with a new value,\n   * replacing the corresponding optimistic update.\n   */\n  updateRoomNotificationSettings(roomId, optimisticId, settings) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.roomNotificationSettings.update(roomId, settings);\n    });\n  }\n  async fetchNotificationsDeltaUpdate(signal) {\n    const lastRequestedAt = this.#notificationsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n    const result = await this.#client.getInboxNotificationsSince({\n      since: lastRequestedAt,\n      signal\n    });\n    if (lastRequestedAt < result.requestedAt) {\n      this.#notificationsLastRequestedAt = result.requestedAt;\n    }\n    this.updateThreadifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted\n    );\n  }\n  async fetchRoomThreadsDeltaUpdate(roomId, signal) {\n    const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === void 0) {\n      return;\n    }\n    const updates = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getThreadsSince({\n      roomId,\n      since: lastRequestedAt,\n      signal\n    });\n    this.updateThreadifications(\n      updates.threads.updated,\n      updates.inboxNotifications.updated,\n      updates.threads.deleted,\n      updates.inboxNotifications.deleted\n    );\n    this.permissionHints.update(updates.permissionHints);\n    if (lastRequestedAt < updates.requestedAt) {\n      this.#roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n  async fetchUserThreadsDeltaUpdate(signal) {\n    const lastRequestedAt = this.#userThreadsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n    const result = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getUserThreadsSince_experimental({\n      since: lastRequestedAt,\n      signal\n    });\n    if (lastRequestedAt < result.requestedAt) {\n      this.#notificationsLastRequestedAt = result.requestedAt;\n    }\n    this.updateThreadifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted\n    );\n    this.permissionHints.update(result.permissionHints);\n  }\n  async fetchRoomVersionsDeltaUpdate(roomId, signal) {\n    const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === void 0) {\n      return;\n    }\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n      this.#client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const updates = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].listTextVersionsSince({\n      since: lastRequestedAt,\n      signal\n    });\n    this.historyVersions.update(roomId, updates.versions);\n    if (lastRequestedAt < updates.requestedAt) {\n      this.#roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n  async refreshRoomNotificationSettings(roomId, signal) {\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n      this.#client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const result = await room.getNotificationSettings({ signal });\n    this.roomNotificationSettings.update(roomId, result);\n  }\n  /**\n   * Refresh User Notification Settings from poller\n   */\n  async refreshUserNotificationSettings(signal) {\n    const result = await this.#client.getNotificationSettings({\n      signal\n    });\n    this.userNotificationSettings.update(result);\n  }\n  /**\n   * Updates user notification settings with a new value, replacing the\n   * corresponding optimistic update.\n   */\n  updateUserNotificationSettings_confirmOptimisticUpdate(settings, optimisticUpdateId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticUpdateId);\n      this.userNotificationSettings.update(settings);\n    });\n  }\n};\nfunction applyOptimisticUpdates_forThreadifications(baseThreadsDB, notificationsLUT, optimisticUpdates) {\n  const threadsDB = baseThreadsDB.clone();\n  let notificationsById = Object.fromEntries(notificationsLUT);\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        threadsDB.upsert(optimisticUpdate.thread);\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        if (thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        threadsDB.upsert({\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        });\n        break;\n      }\n      case \"mark-thread-as-resolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({ ...thread, resolved: true });\n        break;\n      }\n      case \"mark-thread-as-unresolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({ ...thread, resolved: false });\n        break;\n      }\n      case \"create-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        const inboxNotification = Object.values(notificationsById).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        notificationsById[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyDeleteComment(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.deletedAt\n          )\n        );\n        break;\n      }\n      case \"delete-thread\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({\n          ...thread,\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: []\n        });\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyAddReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.reaction\n          )\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyRemoveReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.emoji,\n            optimisticUpdate.userId,\n            optimisticUpdate.removedAt\n          )\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        const ibn = notificationsById[optimisticUpdate.inboxNotificationId];\n        if (ibn === void 0) {\n          break;\n        }\n        notificationsById[optimisticUpdate.inboxNotificationId] = {\n          ...ibn,\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-all-inbox-notifications-as-read\": {\n        for (const id in notificationsById) {\n          const ibn = notificationsById[id];\n          if (ibn === void 0) {\n            break;\n          }\n          notificationsById[id] = {\n            ...ibn,\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"delete-inbox-notification\": {\n        delete notificationsById[optimisticUpdate.inboxNotificationId];\n        break;\n      }\n      case \"delete-all-inbox-notifications\": {\n        notificationsById = {};\n        break;\n      }\n    }\n  }\n  const sortedNotifications = (\n    // Sort so that the most recent notifications are first\n    Object.values(notificationsById).filter(\n      (ibn) => ibn.kind === \"thread\" ? threadsDB.get(ibn.threadId) !== void 0 : true\n    ).sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime())\n  );\n  return {\n    sortedNotifications,\n    notificationsById,\n    threadsDB\n  };\n}\nfunction applyOptimisticUpdates_forSettings(settingsLUT, optimisticUpdates) {\n  const settingsByRoomId = Object.fromEntries(settingsLUT);\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"update-notification-settings\": {\n        const settings = settingsByRoomId[optimisticUpdate.roomId];\n        if (settings === void 0) {\n          break;\n        }\n        settingsByRoomId[optimisticUpdate.roomId] = {\n          ...settings,\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  return settingsByRoomId;\n}\nfunction applyOptimisticUpdates_forUserNotificationSettings(baseSettings, optimisticUpdates) {\n  const outcomingSettings = { ...baseSettings };\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"update-user-notification-settings\": {\n        const incomingSettings = optimisticUpdate.settings;\n        for (const channelKey of (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.keys)(incomingSettings)) {\n          const key = channelKey;\n          const channelUpdates = incomingSettings[key];\n          if (channelUpdates) {\n            const realChannelUpdates = Object.fromEntries(\n              (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.entries)(channelUpdates).filter(\n                ([_, value]) => value !== void 0\n              )\n            );\n            outcomingSettings[key] = {\n              ...outcomingSettings[key],\n              ...realChannelUpdates\n            };\n          }\n        }\n        break;\n      }\n    }\n  }\n  return outcomingSettings;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction applyUpsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt.getTime(),\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction applyDeleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      // We optimistically remove the comment body and attachments when marking it as deleted\n      body: void 0,\n      attachments: []\n    } : comment\n  );\n  if (updatedComments.every((comment) => comment.deletedAt !== void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction applyAddReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments\n  };\n}\nfunction applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/liveblocks.tsx\n\nvar ClientContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction missingUserError(userId) {\n  return new Error(`resolveUsers didn't return anything for user '${userId}'`);\n}\nfunction missingRoomInfoError(roomId) {\n  return new Error(\n    `resolveRoomsInfo didn't return anything for room '${roomId}'`\n  );\n}\nfunction identity2(x) {\n  return x;\n}\nvar _umbrellaStores = /* @__PURE__ */ new WeakMap();\nvar _extras = /* @__PURE__ */ new WeakMap();\nvar _bundles = /* @__PURE__ */ new WeakMap();\nfunction selectorFor_useUnreadInboxNotificationsCount(result) {\n  if (!result.inboxNotifications) {\n    return result;\n  }\n  return ASYNC_OK(\n    \"count\",\n    count(\n      result.inboxNotifications,\n      (n) => n.readAt === null || n.readAt < n.notifiedAt\n    )\n  );\n}\nfunction selectorFor_useUser(state, userId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingUserError(userId)\n    };\n  }\n  return {\n    isLoading: false,\n    user: state.data\n  };\n}\nfunction selectorFor_useRoomInfo(state, roomId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingRoomInfoError(roomId)\n    };\n  }\n  return {\n    isLoading: false,\n    info: state.data\n  };\n}\nfunction getOrCreateContextBundle(client) {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeLiveblocksContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getUmbrellaStoreForClient(client) {\n  let store = _umbrellaStores.get(client);\n  if (!store) {\n    store = new UmbrellaStore(client);\n    _umbrellaStores.set(client, store);\n  }\n  return store;\n}\nfunction getLiveblocksExtrasForClient(client) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeLiveblocksExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n  return extras;\n}\nfunction makeLiveblocksExtrasForClient(client) {\n  const store = getUmbrellaStoreForClient(client);\n  const notificationsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.fetchNotificationsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new inbox notifications failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.NOTIFICATIONS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }\n  );\n  const userThreadsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.fetchUserThreadsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new user threads failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.USER_THREADS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME }\n  );\n  const userNotificationSettingsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.refreshUserNotificationSettings(signal);\n      } catch (err) {\n        console.warn(\n          `Polling new user notification settings failed: ${String(err)}`\n        );\n        throw err;\n      }\n    },\n    config.USER_NOTIFICATION_SETTINGS_INTERVAL,\n    { maxStaleTimeMs: config.USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME }\n  );\n  return {\n    store,\n    notificationsPoller,\n    userThreadsPoller,\n    userNotificationSettingsPoller\n  };\n}\nfunction makeLiveblocksContextBundle(client) {\n  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);\n  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);\n  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);\n  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);\n  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);\n  const useUpdateNotificationSettings2 = () => useUpdateNotificationSettings_withClient(client);\n  function LiveblocksProvider2(props) {\n    useEnsureNoLiveblocksProvider();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ClientContext.Provider, { value: client, children: props.children });\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    LiveblocksProvider: LiveblocksProvider2,\n    useInboxNotifications: () => useInboxNotifications_withClient(client, identity2, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow),\n    useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCount_withClient(client),\n    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n    useDeleteInboxNotification: useDeleteInboxNotification2,\n    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n    useNotificationSettings: () => useNotificationSettings_withClient(client),\n    useUpdateNotificationSettings: useUpdateNotificationSettings2,\n    useInboxNotificationThread: useInboxNotificationThread2,\n    useUserThreads_experimental,\n    ...shared.classic,\n    suspense: {\n      LiveblocksProvider: LiveblocksProvider2,\n      useInboxNotifications: () => useInboxNotificationsSuspense_withClient(client),\n      useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCountSuspense_withClient(client),\n      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n      useDeleteInboxNotification: useDeleteInboxNotification2,\n      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n      useInboxNotificationThread: useInboxNotificationThread2,\n      useNotificationSettings: () => useNotificationSettingsSuspense_withClient(client),\n      useUpdateNotificationSettings: useUpdateNotificationSettings2,\n      useUserThreads_experimental: useUserThreadsSuspense_experimental,\n      ...shared.suspense\n    }\n  };\n  return bundle;\n}\nfunction useInboxNotifications_withClient(client, selector, isEqual) {\n  const { store, notificationsPoller: poller } = getLiveblocksExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.loadingNotifications.waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  return useSignal(\n    store.outputs.loadingNotifications.signal,\n    selector,\n    isEqual\n  );\n}\nfunction useInboxNotificationsSuspense_withClient(client) {\n  ensureNotServerSide();\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.outputs.loadingNotifications.waitUntilLoaded());\n  const result = useInboxNotifications_withClient(client, identity2, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUnreadInboxNotificationsCount_withClient(client) {\n  return useInboxNotifications_withClient(\n    client,\n    selectorFor_useUnreadInboxNotificationsCount,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n}\nfunction useUnreadInboxNotificationsCountSuspense_withClient(client) {\n  ensureNotServerSide();\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.outputs.loadingNotifications.waitUntilLoaded());\n  const result = useUnreadInboxNotificationsCount_withClient(client);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  return result;\n}\nfunction useMarkInboxNotificationAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const readAt = /* @__PURE__ */ new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId,\n        readAt\n      });\n      client.markInboxNotificationAsRead(inboxNotificationId).then(\n        () => {\n          store.markInboxNotificationRead(\n            inboxNotificationId,\n            readAt,\n            optimisticId\n          );\n        },\n        (err) => {\n          store.optimisticUpdates.remove(optimisticId);\n          client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n            {\n              type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\",\n              inboxNotificationId\n            },\n            err\n          );\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const readAt = /* @__PURE__ */ new Date();\n    const optimisticId = store.optimisticUpdates.add({\n      type: \"mark-all-inbox-notifications-as-read\",\n      readAt\n    });\n    client.markAllInboxNotificationsAsRead().then(\n      () => {\n        store.markAllInboxNotificationsRead(optimisticId, readAt);\n      },\n      (err) => {\n        store.optimisticUpdates.remove(optimisticId);\n        client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n          // No roomId, threadId, commentId to include for this error\n          { type: \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\" },\n          err\n        );\n      }\n    );\n  }, [client]);\n}\nfunction useDeleteInboxNotification_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const deletedAt = /* @__PURE__ */ new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-inbox-notification\",\n        inboxNotificationId,\n        deletedAt\n      });\n      client.deleteInboxNotification(inboxNotificationId).then(\n        () => {\n          store.deleteInboxNotification(inboxNotificationId, optimisticId);\n        },\n        (err) => {\n          store.optimisticUpdates.remove(optimisticId);\n          client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n            { type: \"DELETE_INBOX_NOTIFICATION_ERROR\", inboxNotificationId },\n            err\n          );\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useDeleteAllInboxNotifications_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const deletedAt = /* @__PURE__ */ new Date();\n    const optimisticId = store.optimisticUpdates.add({\n      type: \"delete-all-inbox-notifications\",\n      deletedAt\n    });\n    client.deleteAllInboxNotifications().then(\n      () => {\n        store.deleteAllInboxNotifications(optimisticId);\n      },\n      (err) => {\n        store.optimisticUpdates.remove(optimisticId);\n        client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n          { type: \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\" },\n          err\n        );\n      }\n    );\n  }, [client]);\n}\nfunction useInboxNotificationThread_withClient(client, inboxNotificationId) {\n  const { store } = getLiveblocksExtrasForClient(client);\n  return useSignal(\n    store.outputs.threadifications,\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (state) => {\n        const inboxNotification = state.notificationsById[inboxNotificationId] ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\n          `Inbox notification with ID \"${inboxNotificationId}\" not found`\n        );\n        if (inboxNotification.kind !== \"thread\") {\n          (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\n            `Inbox notification with ID \"${inboxNotificationId}\" is not of kind \"thread\"`\n          );\n        }\n        const thread = state.threadsDB.get(inboxNotification.threadId) ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\n          `Thread with ID \"${inboxNotification.threadId}\" not found, this inbox notification might not be of kind \"thread\"`\n        );\n        return thread;\n      },\n      [inboxNotificationId]\n    )\n  );\n}\nfunction useUpdateNotificationSettings_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (settings) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const optimisticUpdateId = store.optimisticUpdates.add({\n        type: \"update-user-notification-settings\",\n        settings\n      });\n      client.updateNotificationSettings(settings).then(\n        (settings2) => {\n          store.updateUserNotificationSettings_confirmOptimisticUpdate(\n            settings2,\n            optimisticUpdateId\n          );\n        },\n        (err) => {\n          store.optimisticUpdates.remove(optimisticUpdateId);\n          if (err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.HttpError) {\n            if (err.status === 422) {\n              const msg = [err.details?.error, err.details?.reason].filter(Boolean).join(\"\\n\");\n              console.error(msg);\n            }\n            client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n              {\n                type: \"UPDATE_USER_NOTIFICATION_SETTINGS_ERROR\"\n              },\n              err\n            );\n          } else {\n            throw err;\n          }\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useNotificationSettings_withClient(client) {\n  const updateNotificationSettings = useUpdateNotificationSettings_withClient(client);\n  const { store, userNotificationSettingsPoller: poller } = getLiveblocksExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void store.outputs.userNotificationSettings.waitUntilLoaded();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  const result = useSignal(store.outputs.userNotificationSettings.signal);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [result, updateNotificationSettings];\n  }, [result, updateNotificationSettings]);\n}\nfunction useNotificationSettingsSuspense_withClient(client) {\n  ensureNotServerSide();\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.outputs.userNotificationSettings.waitUntilLoaded());\n  const [result, updateNotificationSettings] = useNotificationSettings_withClient(client);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [result, updateNotificationSettings];\n  }, [result, updateNotificationSettings]);\n}\nfunction useUser_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getItemState(userId),\n    [usersStore, userId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useUser(state, userId),\n    [userId]\n  );\n  const result = useSyncExternalStoreWithSelector(\n    usersStore.subscribe,\n    getUserState,\n    getUserState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void usersStore.enqueue(userId)\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call usersStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the userId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the userId gets invalidated, the user would be fetched again.\n  );\n  return result;\n}\nfunction useUserSuspense_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getItemState(userId),\n    [usersStore, userId]\n  );\n  const userState = getUserState();\n  if (!userState || userState.isLoading) {\n    throw usersStore.enqueue(userId);\n  }\n  if (userState.error) {\n    throw userState.error;\n  }\n  if (!userState.data) {\n    throw missingUserError(userId);\n  }\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    usersStore.subscribe,\n    getUserState,\n    getUserState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    user: state.data,\n    error: void 0\n  };\n}\nfunction useRoomInfo_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getItemState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useRoomInfo(state, roomId),\n    [roomId]\n  );\n  const result = useSyncExternalStoreWithSelector(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void roomsInfoStore.enqueue(roomId)\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call roomsInfoStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the roomId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the roomId gets invalidated, the room info would be fetched again.\n  );\n  return result;\n}\nfunction useRoomInfoSuspense_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getItemState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const roomInfoState = getRoomInfoState();\n  if (!roomInfoState || roomInfoState.isLoading) {\n    throw roomsInfoStore.enqueue(roomId);\n  }\n  if (roomInfoState.error) {\n    throw roomInfoState.error;\n  }\n  if (!roomInfoState.data) {\n    throw missingRoomInfoError(roomId);\n  }\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state.data !== void 0, \"Unexpected missing room info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: void 0\n  };\n}\nfunction createSharedContext(client) {\n  const useClient2 = () => client;\n  function useSyncStatus2(options) {\n    return useSyncStatus_withClient(client, options);\n  }\n  return {\n    classic: {\n      useClient: useClient2,\n      useUser: (userId) => useUser_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId),\n      useIsInsideRoom,\n      useErrorListener,\n      useSyncStatus: useSyncStatus2\n    },\n    suspense: {\n      useClient: useClient2,\n      useUser: (userId) => useUserSuspense_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId),\n      useIsInsideRoom,\n      useErrorListener,\n      useSyncStatus: useSyncStatus2\n    }\n  };\n}\nfunction useEnsureNoLiveblocksProvider(options) {\n  const existing = useClientOrNull();\n  if (!options?.allowNesting && existing !== null) {\n    throw new Error(\n      \"You cannot nest multiple LiveblocksProvider instances in the same React tree.\"\n    );\n  }\n}\nfunction useClientOrNull() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ClientContext);\n}\nfunction useClient() {\n  return useClientOrNull() ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\"LiveblocksProvider is missing from the React tree.\");\n}\nfunction LiveblocksProviderWithClient(props) {\n  useEnsureNoLiveblocksProvider(props);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ClientContext.Provider, { value: props.client, children: props.children });\n}\nfunction LiveblocksProvider(props) {\n  const { children, ...o } = props;\n  const options = {\n    publicApiKey: useInitial(o.publicApiKey),\n    throttle: useInitial(o.throttle),\n    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),\n    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),\n    polyfills: useInitial(o.polyfills),\n    largeMessageStrategy: useInitial(o.largeMessageStrategy),\n    unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),\n    unstable_streamData: useInitial(o.unstable_streamData),\n    preventUnsavedChanges: useInitial(o.preventUnsavedChanges),\n    authEndpoint: useInitialUnlessFunction(o.authEndpoint),\n    resolveMentionSuggestions: useInitialUnlessFunction(\n      o.resolveMentionSuggestions\n    ),\n    resolveUsers: useInitialUnlessFunction(o.resolveUsers),\n    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),\n    baseUrl: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.baseUrl\n    ),\n    enableDebugLogging: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.enableDebugLogging\n    )\n  };\n  const client = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createClient)(options), []);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LiveblocksProviderWithClient, { client, children });\n}\nfunction createLiveblocksContext(client) {\n  return getOrCreateContextBundle(client);\n}\nfunction useUserThreads_experimental(options = {}) {\n  const client = useClient();\n  const { store, userThreadsPoller: poller } = getLiveblocksExtrasForClient(client);\n  const queryKey = makeUserThreadsQueryKey(options.query);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  return useSignal(\n    store.outputs.loadingUserThreads.getOrCreate(queryKey).signal\n  );\n}\nfunction useUserThreadsSuspense_experimental(options = {}) {\n  ensureNotServerSide();\n  const client = useClient();\n  const { store } = getLiveblocksExtrasForClient(client);\n  const queryKey = makeUserThreadsQueryKey(options.query);\n  use(store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded());\n  const result = useUserThreads_experimental(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useInboxNotifications() {\n  return useInboxNotifications_withClient(useClient(), identity2, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n}\nfunction useInboxNotificationsSuspense() {\n  return useInboxNotificationsSuspense_withClient(useClient());\n}\nfunction useInboxNotificationThread(inboxNotificationId) {\n  return useInboxNotificationThread_withClient(\n    useClient(),\n    inboxNotificationId\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead() {\n  return useMarkAllInboxNotificationsAsRead_withClient(useClient());\n}\nfunction useMarkInboxNotificationAsRead() {\n  return useMarkInboxNotificationAsRead_withClient(useClient());\n}\nfunction useDeleteAllInboxNotifications() {\n  return useDeleteAllInboxNotifications_withClient(useClient());\n}\nfunction useDeleteInboxNotification() {\n  return useDeleteInboxNotification_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCount() {\n  return useUnreadInboxNotificationsCount_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCountSuspense() {\n  return useUnreadInboxNotificationsCountSuspense_withClient(useClient());\n}\nfunction useNotificationSettings() {\n  return useNotificationSettings_withClient(useClient());\n}\nfunction useNotificationSettingsSuspense() {\n  return useNotificationSettingsSuspense_withClient(useClient());\n}\nfunction useUpdateNotificationSettings() {\n  return useUpdateNotificationSettings_withClient(useClient());\n}\nfunction useUser(userId) {\n  const client = useClient();\n  return useUser_withClient(client, userId);\n}\nfunction useUserSuspense(userId) {\n  const client = useClient();\n  return useUserSuspense_withClient(client, userId);\n}\nfunction useRoomInfo(roomId) {\n  return useRoomInfo_withClient(useClient(), roomId);\n}\nfunction useRoomInfoSuspense(roomId) {\n  return useRoomInfoSuspense_withClient(useClient(), roomId);\n}\nvar _useInboxNotificationThread = useInboxNotificationThread;\nvar _useUser = useUser;\nvar _useUserSuspense = useUserSuspense;\nvar _useUserThreads_experimental = useUserThreads_experimental;\nvar _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;\nfunction useSyncStatus_withClient(client, options) {\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useSyncStatusSmooth_withClient(client);\n  } else {\n    return useSyncStatusImmediate_withClient(client);\n  }\n}\nfunction useSyncStatusImmediate_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    client.events.syncStatus.subscribe,\n    client.getSyncStatus,\n    client.getSyncStatus\n  );\n}\nfunction useSyncStatusSmooth_withClient(client) {\n  const getter = client.getSyncStatus;\n  const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getter);\n  const oldStatus = useLatest(getter());\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    let timeoutId;\n    const unsub = client.events.syncStatus.subscribe(() => {\n      const newStatus = getter();\n      if (oldStatus.current === \"synchronizing\" && newStatus === \"synchronized\") {\n        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [client, getter, oldStatus]);\n  return status;\n}\nfunction useSyncStatus(options) {\n  return useSyncStatus_withClient(useClient(), options);\n}\nfunction useErrorListener(callback) {\n  const client = useClient();\n  const savedCallback = useLatest(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => client.events.error.subscribe((e) => savedCallback.current(e)),\n    [client, savedCallback]\n  );\n}\n\n// src/room.tsx\n\n\n\n\n// src/use-scroll-to-comment-on-load-effect.ts\n\nfunction handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {\n  if (shouldScrollOnLoad === false) return;\n  if (!state.threads) return;\n  const isWindowDefined = typeof window !== \"undefined\";\n  if (!isWindowDefined) return;\n  const hash = window.location.hash;\n  const commentId = hash.slice(1);\n  if (!commentId.startsWith(\"cm_\")) return;\n  const comment = document.getElementById(commentId);\n  if (comment === null) return;\n  const comments = state.threads.flatMap((thread) => thread.comments);\n  const isCommentInThreads = comments.some(\n    (comment2) => comment2.id === commentId\n  );\n  if (!isCommentInThreads) return;\n  comment.scrollIntoView();\n}\nfunction useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => {\n      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n    [state.isLoading]\n  );\n}\n\n// src/room.tsx\n\nvar noop3 = () => {\n};\nvar identity3 = (x) => x;\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n  return null;\n}\nfunction selectorFor_useOthersConnectionIds(others) {\n  return others.map((user) => user.connectionId);\n}\nfunction makeMutationContext(room) {\n  const cannotUseUntil = \"This mutation cannot be used until\";\n  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;\n  const needsStorage = `${cannotUseUntil} storage has been loaded`;\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(needsStorage);\n      }\n      return mutableRoot;\n    },\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(needsPresence);\n      }\n      return self;\n    },\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(needsPresence);\n      }\n      return others;\n    },\n    setMyPresence: room.updatePresence\n  };\n}\nfunction getCurrentUserId(client) {\n  const userId = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].currentUserId.get();\n  if (userId === void 0) {\n    return \"anonymous\";\n  }\n  return userId;\n}\nvar _extras2 = /* @__PURE__ */ new WeakMap();\nvar _bundles2 = /* @__PURE__ */ new WeakMap();\nfunction getOrCreateRoomContextBundle(client) {\n  let bundle = _bundles2.get(client);\n  if (!bundle) {\n    bundle = makeRoomContextBundle(client);\n    _bundles2.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getRoomExtrasForClient(client) {\n  let extras = _extras2.get(client);\n  if (!extras) {\n    extras = makeRoomExtrasForClient(client);\n    _extras2.set(client, extras);\n  }\n  return extras;\n}\nfunction makeRoomExtrasForClient(client) {\n  const store = getUmbrellaStoreForClient(client);\n  function onMutationFailure(optimisticId, context, innerError) {\n    store.optimisticUpdates.remove(optimisticId);\n    if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.HttpError) {\n      if (innerError.status === 403) {\n        const detailedMessage = [\n          innerError.message,\n          innerError.details?.suggestion,\n          innerError.details?.docs\n        ].filter(Boolean).join(\"\\n\");\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(detailedMessage);\n      }\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(context, innerError);\n    } else {\n      throw innerError;\n    }\n  }\n  const threadsPollersByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n    (roomId) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n      async (signal) => {\n        try {\n          return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);\n        } catch (err) {\n          _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`);\n          throw err;\n        }\n      },\n      config.ROOM_THREADS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME }\n    )\n  );\n  const versionsPollersByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n    (roomId) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n      async (signal) => {\n        try {\n          return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);\n        } catch (err) {\n          _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`);\n          throw err;\n        }\n      },\n      config.HISTORY_VERSIONS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME }\n    )\n  );\n  const roomNotificationSettingsPollersByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n    (roomId) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n      async (signal) => {\n        try {\n          return await store.refreshRoomNotificationSettings(roomId, signal);\n        } catch (err) {\n          _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(`Polling notification settings for '${roomId}' failed: ${String(err)}`);\n          throw err;\n        }\n      },\n      config.NOTIFICATION_SETTINGS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.NOTIFICATION_SETTINGS_MAX_STALE_TIME }\n    )\n  );\n  return {\n    store,\n    onMutationFailure,\n    getOrCreateThreadsPollerForRoomId: threadsPollersByRoomId.getOrCreate.bind(\n      threadsPollersByRoomId\n    ),\n    getOrCreateVersionsPollerForRoomId: versionsPollersByRoomId.getOrCreate.bind(versionsPollersByRoomId),\n    getOrCreateNotificationsSettingsPollerForRoomId: roomNotificationSettingsPollersByRoomId.getOrCreate.bind(\n      roomNotificationSettingsPollersByRoomId\n    )\n  };\n}\nfunction makeRoomContextBundle(client) {\n  function RoomProvider_withImplicitLiveblocksProvider(props) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LiveblocksProviderWithClient, { client, allowNesting: true, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RoomProvider, { ...props }) });\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    RoomContext,\n    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n    useRoom,\n    useStatus,\n    useStorageStatus,\n    useBatch,\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useEventListener,\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n    useStorageRoot,\n    useStorage,\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n    useMutation,\n    useThreads,\n    useCreateThread,\n    useDeleteThread,\n    useEditThreadMetadata,\n    useMarkThreadAsResolved,\n    useMarkThreadAsUnresolved,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n    useMarkThreadAsRead,\n    useThreadSubscription,\n    useAttachmentUrl,\n    useHistoryVersions,\n    useHistoryVersionData,\n    useRoomNotificationSettings,\n    useUpdateRoomNotificationSettings,\n    ...shared.classic,\n    suspense: {\n      RoomContext,\n      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n      useRoom,\n      useStatus,\n      useStorageStatus: useStorageStatusSuspense,\n      useBatch,\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useEventListener,\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n      useMutation,\n      useThreads: useThreadsSuspense,\n      useCreateThread,\n      useDeleteThread,\n      useEditThreadMetadata,\n      useMarkThreadAsResolved,\n      useMarkThreadAsUnresolved,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n      useMarkThreadAsRead,\n      useThreadSubscription,\n      useAttachmentUrl: useAttachmentUrlSuspense,\n      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,\n      useHistoryVersions: useHistoryVersionsSuspense,\n      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,\n      useUpdateRoomNotificationSettings,\n      ...shared.suspense\n    }\n  };\n  return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal, {\n    enumerable: false\n  });\n}\nfunction RoomProvider(props) {\n  const client = useClient();\n  const [cache] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => /* @__PURE__ */ new Map()\n  );\n  const stableEnterRoom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (roomId, options) => {\n      const cached = cache.get(roomId);\n      if (cached) return cached;\n      const rv = client.enterRoom(roomId, options);\n      const origLeave = rv.leave;\n      rv.leave = () => {\n        origLeave();\n        cache.delete(roomId);\n      };\n      cache.set(roomId, rv);\n      return rv;\n    },\n    [client, cache]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\n    RoomProviderInner,\n    {\n      ...props,\n      stableEnterRoom\n    }\n  );\n}\nfunction RoomProviderInner(props) {\n  const client = useClient();\n  const { id: roomId, stableEnterRoom } = props;\n  if (true) {\n    if (!roomId) {\n      throw new Error(\n        \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n      );\n    }\n    if (typeof roomId !== \"string\") {\n      throw new Error(\"RoomProvider id property should be a string.\");\n    }\n    const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n    const requiredVersion = 18;\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.errorIf)(\n      majorReactVersion < requiredVersion,\n      `React ${requiredVersion} or higher is required (you\\u2019re on ${react__WEBPACK_IMPORTED_MODULE_0__.version})`\n    );\n  }\n  const frozenProps = useInitial({\n    initialPresence: props.initialPresence,\n    initialStorage: props.initialStorage,\n    autoConnect: props.autoConnect ?? typeof window !== \"undefined\"\n  });\n  const [{ room }, setRoomLeavePair] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => stableEnterRoom(roomId, {\n      ...frozenProps,\n      autoConnect: false\n      // Deliberately using false here on the first render, see below\n    })\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { store } = getRoomExtrasForClient(client);\n    async function handleCommentEvent(message) {\n      if (message.type === _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.THREAD_DELETED) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const info = await room.getThread(message.threadId);\n      if (!info.thread) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const { thread, inboxNotification: maybeNotification } = info;\n      const existingThread = store.outputs.threads.get().getEvenIfDeleted(message.threadId);\n      switch (message.type) {\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_EDITED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.THREAD_METADATA_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.THREAD_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_REACTION_ADDED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_DELETED:\n          if (!existingThread) break;\n          store.updateThreadifications(\n            [thread],\n            maybeNotification ? [maybeNotification] : []\n          );\n          break;\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_CREATED:\n          store.updateThreadifications(\n            [thread],\n            maybeNotification ? [maybeNotification] : []\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return room.events.comments.subscribe(\n      (message) => void handleCommentEvent(message)\n    );\n  }, [client, room]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const pair = stableEnterRoom(roomId, frozenProps);\n    setRoomLeavePair(pair);\n    const { room: room2, leave } = pair;\n    if (frozenProps.autoConnect) {\n      room2.connect();\n    }\n    return () => {\n      leave();\n    };\n  }, [roomId, frozenProps, stableEnterRoom]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RoomContext.Provider, { value: room, children: props.children });\n}\nfunction useRoom() {\n  const room = useRoomOrNull();\n  if (room === null) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return room;\n}\nfunction useStatus() {\n  const room = useRoom();\n  const subscribe = room.events.status.subscribe;\n  const getSnapshot = room.getStatus;\n  const getServerSnapshot = room.getStatus;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useReportTextEditor(editor, rootKey) {\n  const isReported = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const room = useRoom();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (isReported.current) {\n      return;\n    }\n    const unsubscribe = room.events.status.subscribe((status) => {\n      if (status === \"connected\" && !isReported.current) {\n        isReported.current = true;\n        void room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].reportTextEditor(editor, rootKey);\n      }\n    });\n    return unsubscribe;\n  }, [room, editor, rootKey]);\n}\nfunction useYjsProvider() {\n  const room = useRoom();\n  const subscribe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (onStoreChange) => {\n      return room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].yjsProviderDidChange.subscribe(onStoreChange);\n    },\n    [room]\n  );\n  const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    return room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].getYjsProvider();\n  }, [room]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);\n}\nfunction useCreateTextMention() {\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (userId, mentionId) => {\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].createTextMention(userId, mentionId).catch((err) => {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(\n          `Cannot create text mention for user '${userId}' and mention '${mentionId}'`,\n          err\n        );\n      });\n    },\n    [room]\n  );\n}\nfunction useDeleteTextMention() {\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (mentionId) => {\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].deleteTextMention(mentionId).catch((err) => {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(`Cannot delete text mention '${mentionId}'`, err);\n      });\n    },\n    [room]\n  );\n}\nfunction useResolveMentionSuggestions() {\n  const client = useClient();\n  return client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].resolveMentionSuggestions;\n}\nfunction useMentionSuggestionsCache() {\n  const client = useClient();\n  return client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].mentionSuggestionsCache;\n}\nfunction useStorageStatus(options) {\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useStorageStatusSmooth();\n  } else {\n    return useStorageStatusImmediate();\n  }\n}\nfunction useStorageStatusImmediate() {\n  const room = useRoom();\n  const subscribe = room.events.storageStatus.subscribe;\n  const getSnapshot = room.getStorageStatus;\n  const getServerSnapshot = room.getStorageStatus;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageStatusSmooth() {\n  const room = useRoom();\n  const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(room.getStorageStatus);\n  const oldStatus = useLatest(room.getStorageStatus());\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    let timeoutId;\n    const unsub = room.events.storageStatus.subscribe((newStatus) => {\n      if (oldStatus.current === \"synchronizing\" && newStatus === \"synchronized\") {\n        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [room, oldStatus]);\n  return status;\n}\nfunction useBatch() {\n  return useRoom().batch;\n}\nfunction useBroadcastEvent() {\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (event, options = { shouldQueueEventIfNotReady: false }) => {\n      room.broadcastEvent(event, options);\n    },\n    [room]\n  );\n}\nfunction useOthersListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => room.events.others.subscribe((event) => savedCallback.current(event)),\n    [room, savedCallback]\n  );\n}\nfunction useLostConnectionListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => room.events.lostConnection.subscribe(\n      (event) => savedCallback.current(event)\n    ),\n    [room, savedCallback]\n  );\n}\nfunction useEventListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const listener = (eventData) => {\n      savedCallback.current(eventData);\n    };\n    return room.events.customEvent.subscribe(listener);\n  }, [room, savedCallback]);\n}\nfunction useHistory() {\n  return useRoom().history;\n}\nfunction useUndo() {\n  return useHistory().undo;\n}\nfunction useRedo() {\n  return useHistory().redo;\n}\nfunction useCanUndo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canUndo = room.history.canUndo;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, canUndo, canUndo);\n}\nfunction useCanRedo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canRedo = room.history.canRedo;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, canRedo, canRedo);\n}\nfunction useSelf(maybeSelector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.self.subscribe;\n  const getSnapshot = room.getSelf;\n  const selector = maybeSelector ?? identity3;\n  const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (me) => me !== null ? selector(me) : null,\n    [selector]\n  );\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMyPresence() {\n  const room = useRoom();\n  const subscribe = room.events.myPresence.subscribe;\n  const getSnapshot = room.getPresence;\n  const presence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);\n  const setPresence = room.updatePresence;\n  return [presence, setPresence];\n}\nfunction useUpdateMyPresence() {\n  return useRoom().updatePresence;\n}\nfunction useOthers(selector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.others.subscribe;\n  const getSnapshot = room.getOthers;\n  const getServerSnapshot = alwaysEmptyList;\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    selector ?? identity3,\n    isEqual\n  );\n}\nfunction useOthersMapped(itemSelector, itemIsEqual) {\n  const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),\n    [itemSelector]\n  );\n  const wrappedIsEqual = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (a, b) => {\n      const eq = itemIsEqual ?? Object.is;\n      return a.length === b.length && a.every((atuple, index) => {\n        const btuple = b[index];\n        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n      });\n    },\n    [itemIsEqual]\n  );\n  return useOthers(wrappedSelector, wrappedIsEqual);\n}\nfunction useOthersConnectionIds() {\n  return useOthers(selectorFor_useOthersConnectionIds, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n}\nvar NOT_FOUND = Symbol();\nfunction useOther(connectionId, selector, isEqual) {\n  const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (others) => {\n      const other2 = others.find((other3) => other3.connectionId === connectionId);\n      return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n    },\n    [connectionId, selector]\n  );\n  const wrappedIsEqual = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (prev, curr) => {\n      if (prev === NOT_FOUND || curr === NOT_FOUND) {\n        return prev === curr;\n      }\n      const eq = isEqual ?? Object.is;\n      return eq(prev, curr);\n    },\n    [isEqual]\n  );\n  const other = useOthers(wrappedSelector, wrappedIsEqual);\n  if (other === NOT_FOUND) {\n    throw new Error(\n      `No such other user with connection id ${connectionId} exists`\n    );\n  }\n  return other;\n}\nfunction useMutableStorageRoot() {\n  const room = useRoom();\n  const subscribe = room.events.storageDidLoad.subscribeOnce;\n  const getSnapshot = room.getStorageSnapshot;\n  const getServerSnapshot = alwaysNull;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageRoot() {\n  return [useMutableStorageRoot()];\n}\nfunction useStorage(selector, isEqual) {\n  const room = useRoom();\n  const rootOrNull = useMutableStorageRoot();\n  const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,\n    [selector]\n  );\n  const subscribe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop3,\n    [room, rootOrNull]\n  );\n  const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      const root = rootOrNull;\n      const imm = root.toImmutable();\n      return imm;\n    }\n  }, [rootOrNull]);\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMutation(callback, deps) {\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => {\n      return (...args) => (\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        room.batch(\n          () => (\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            callback(\n              makeMutationContext(room),\n              ...args\n            )\n          )\n        )\n      );\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [room, ...deps]\n  );\n}\nfunction useThreads(options = {}) {\n  const { scrollOnLoad = true } = options;\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateThreadsPollerForRoomId } = getRoomExtrasForClient(client);\n  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);\n  const poller = getOrCreateThreadsPollerForRoomId(room.id);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n  const result = useSignal(\n    store.outputs.loadingRoomThreads.getOrCreate(queryKey).signal\n  );\n  useScrollToCommentOnLoadEffect(scrollOnLoad, result);\n  return result;\n}\nfunction useCreateThread() {\n  return useCreateRoomThread(useRoom().id);\n}\nfunction useCreateRoomThread(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (options) => {\n      const body = options.body;\n      const metadata = options.metadata ?? {};\n      const attachments = options.attachments;\n      const threadId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createThreadId)();\n      const commentId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createCommentId)();\n      const createdAt = /* @__PURE__ */ new Date();\n      const newComment = {\n        id: commentId,\n        threadId,\n        roomId,\n        createdAt,\n        type: \"comment\",\n        userId: getCurrentUserId(client),\n        body,\n        reactions: [],\n        attachments: attachments ?? []\n      };\n      const newThread = {\n        id: threadId,\n        type: \"thread\",\n        createdAt,\n        updatedAt: createdAt,\n        roomId,\n        metadata,\n        comments: [newComment],\n        resolved: false\n      };\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"create-thread\",\n        thread: newThread,\n        roomId\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.createThread({\n        roomId,\n        threadId,\n        commentId,\n        body,\n        metadata,\n        attachmentIds\n      }).then(\n        (thread) => {\n          store.createThread(optimisticId, thread);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"CREATE_THREAD_ERROR\",\n            roomId,\n            threadId,\n            commentId,\n            body,\n            metadata\n          },\n          err\n        )\n      );\n      return newThread;\n    },\n    [client, roomId]\n  );\n}\nfunction useDeleteThread() {\n  return useDeleteRoomThread(useRoom().id);\n}\nfunction useDeleteRoomThread(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const userId = getCurrentUserId(client);\n      const existing = store.outputs.threads.get().get(threadId);\n      if (existing?.comments?.[0]?.userId !== userId) {\n        throw new Error(\"Only the thread creator can delete the thread\");\n      }\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-thread\",\n        roomId,\n        threadId,\n        deletedAt: /* @__PURE__ */ new Date()\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.deleteThread({ roomId, threadId }).then(\n        () => {\n          store.deleteThread(threadId, optimisticId);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"DELETE_THREAD_ERROR\", roomId, threadId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useEditThreadMetadata() {\n  return useEditRoomThreadMetadata(useRoom().id);\n}\nfunction useEditRoomThreadMetadata(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (options) => {\n      if (!options.metadata) {\n        return;\n      }\n      const threadId = options.threadId;\n      const metadata = options.metadata;\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-thread-metadata\",\n        metadata,\n        threadId,\n        updatedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.editThreadMetadata({ roomId, threadId, metadata }).then(\n        (metadata2) => (\n          // Replace the optimistic update by the real thing\n          store.patchThread(threadId, optimisticId, { metadata: metadata2 }, updatedAt)\n        ),\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"EDIT_THREAD_METADATA_ERROR\",\n            roomId,\n            threadId,\n            metadata\n          },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useCreateComment() {\n  return useCreateRoomComment(useRoom().id);\n}\nfunction useCreateRoomComment(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, body, attachments }) => {\n      const commentId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createCommentId)();\n      const createdAt = /* @__PURE__ */ new Date();\n      const comment = {\n        id: commentId,\n        threadId,\n        roomId,\n        type: \"comment\",\n        createdAt,\n        userId: getCurrentUserId(client),\n        body,\n        reactions: [],\n        attachments: attachments ?? []\n      };\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"create-comment\",\n        comment\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.createComment({ roomId, threadId, commentId, body, attachmentIds }).then(\n        (newComment) => {\n          store.createComment(newComment, optimisticId);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"CREATE_COMMENT_ERROR\",\n            roomId,\n            threadId,\n            commentId,\n            body\n          },\n          err\n        )\n      );\n      return comment;\n    },\n    [client, roomId]\n  );\n}\nfunction useEditComment() {\n  return useEditRoomComment(useRoom().id);\n}\nfunction useEditRoomComment(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, commentId, body, attachments }) => {\n      const editedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const existing = store.outputs.threads.get().getEvenIfDeleted(threadId);\n      if (existing === void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`\n        );\n        return;\n      }\n      const comment = existing.comments.find(\n        (comment2) => comment2.id === commentId\n      );\n      if (comment === void 0 || comment.deletedAt !== void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`\n        );\n        return;\n      }\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-comment\",\n        comment: {\n          ...comment,\n          editedAt,\n          body,\n          attachments: attachments ?? []\n        }\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.editComment({ roomId, threadId, commentId, body, attachmentIds }).then(\n        (editedComment) => {\n          store.editComment(threadId, optimisticId, editedComment);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"EDIT_COMMENT_ERROR\", roomId, threadId, commentId, body },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useDeleteComment() {\n  return useDeleteRoomComment(useRoom().id);\n}\nfunction useDeleteRoomComment(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, commentId }) => {\n      const deletedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-comment\",\n        threadId,\n        commentId,\n        deletedAt,\n        roomId\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.deleteComment({ roomId, threadId, commentId }).then(\n        () => {\n          store.deleteComment(threadId, optimisticId, commentId, deletedAt);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"DELETE_COMMENT_ERROR\", roomId, threadId, commentId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useAddReaction() {\n  return useAddRoomCommentReaction(useRoom().id);\n}\nfunction useAddRoomCommentReaction(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, commentId, emoji }) => {\n      const createdAt = /* @__PURE__ */ new Date();\n      const userId = getCurrentUserId(client);\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"add-reaction\",\n        threadId,\n        commentId,\n        reaction: {\n          emoji,\n          userId,\n          createdAt\n        }\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.addReaction({ roomId, threadId, commentId, emoji }).then(\n        (addedReaction) => {\n          store.addReaction(\n            threadId,\n            optimisticId,\n            commentId,\n            addedReaction,\n            createdAt\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"ADD_REACTION_ERROR\",\n            roomId,\n            threadId,\n            commentId,\n            emoji\n          },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useRemoveReaction() {\n  return useRemoveRoomCommentReaction(useRoom().id);\n}\nfunction useRemoveRoomCommentReaction(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, commentId, emoji }) => {\n      const userId = getCurrentUserId(client);\n      const removedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"remove-reaction\",\n        threadId,\n        commentId,\n        emoji,\n        userId,\n        removedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.removeReaction({ roomId, threadId, commentId, emoji }).then(\n        () => {\n          store.removeReaction(\n            threadId,\n            optimisticId,\n            commentId,\n            emoji,\n            userId,\n            removedAt\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"REMOVE_REACTION_ERROR\",\n            roomId,\n            threadId,\n            commentId,\n            emoji\n          },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useMarkThreadAsRead() {\n  return useMarkRoomThreadAsRead(useRoom().id);\n}\nfunction useMarkRoomThreadAsRead(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const inboxNotification = Object.values(\n        store.outputs.notifications.get().notificationsById\n      ).find(\n        (inboxNotification2) => inboxNotification2.kind === \"thread\" && inboxNotification2.threadId === threadId\n      );\n      if (!inboxNotification) return;\n      const now = /* @__PURE__ */ new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId: inboxNotification.id,\n        readAt: now\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.markRoomInboxNotificationAsRead({\n        roomId,\n        inboxNotificationId: inboxNotification.id\n      }).then(\n        () => {\n          store.markInboxNotificationRead(\n            inboxNotification.id,\n            now,\n            optimisticId\n          );\n        },\n        (err) => {\n          onMutationFailure(\n            optimisticId,\n            {\n              type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\",\n              roomId,\n              inboxNotificationId: inboxNotification.id\n            },\n            err\n          );\n          return;\n        }\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useMarkThreadAsResolved() {\n  return useMarkRoomThreadAsResolved(useRoom().id);\n}\nfunction useMarkRoomThreadAsResolved(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-thread-as-resolved\",\n        threadId,\n        updatedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.markThreadAsResolved({ roomId, threadId }).then(\n        () => {\n          store.patchThread(\n            threadId,\n            optimisticId,\n            { resolved: true },\n            updatedAt\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"MARK_THREAD_AS_RESOLVED_ERROR\", roomId, threadId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useMarkThreadAsUnresolved() {\n  return useMarkRoomThreadAsUnresolved(useRoom().id);\n}\nfunction useMarkRoomThreadAsUnresolved(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-thread-as-unresolved\",\n        threadId,\n        updatedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.markThreadAsUnresolved({ roomId, threadId }).then(\n        () => {\n          store.patchThread(\n            threadId,\n            optimisticId,\n            { resolved: false },\n            updatedAt\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"MARK_THREAD_AS_UNRESOLVED_ERROR\", roomId, threadId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useThreadSubscription(threadId) {\n  const client = useClient();\n  const { store } = getRoomExtrasForClient(client);\n  const signal = store.outputs.threadifications;\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => {\n      const notification = state.sortedNotifications.find(\n        (inboxNotification) => inboxNotification.kind === \"thread\" && inboxNotification.threadId === threadId\n      );\n      const thread = state.threadsDB.get(threadId);\n      if (notification === void 0 || thread === void 0) {\n        return { status: \"not-subscribed\" };\n      }\n      return {\n        status: \"subscribed\",\n        unreadSince: notification.readAt\n      };\n    },\n    [threadId]\n  );\n  return useSignal(signal, selector, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n}\nfunction useRoomNotificationSettings() {\n  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateNotificationsSettingsPollerForRoomId } = getRoomExtrasForClient(client);\n  const poller = getOrCreateNotificationsSettingsPollerForRoomId(room.id);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.settingsByRoomId.getOrCreate(room.id).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  const settings = useSignal(\n    store.outputs.settingsByRoomId.getOrCreate(room.id).signal\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useRoomNotificationSettingsSuspense() {\n  ensureNotServerSide();\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  const room = useRoom();\n  use(store.outputs.settingsByRoomId.getOrCreate(room.id).waitUntilLoaded());\n  const [settings, updateRoomNotificationSettings] = useRoomNotificationSettings();\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!settings.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!settings.isLoading, \"Did not expect loading\");\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useHistoryVersionData(versionId) {\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n    isLoading: true\n  });\n  const room = useRoom();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    setState({ isLoading: true });\n    const load = async () => {\n      try {\n        const response = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].getTextVersion(versionId);\n        const buffer = await response.arrayBuffer();\n        const data = new Uint8Array(buffer);\n        setState({\n          isLoading: false,\n          data\n        });\n      } catch (error) {\n        setState({\n          isLoading: false,\n          error: error instanceof Error ? error : new Error(\n            \"An unknown error occurred while loading this version\"\n          )\n        });\n      }\n    };\n    void load();\n  }, [room, versionId]);\n  return state;\n}\nfunction useHistoryVersions() {\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateVersionsPollerForRoomId } = getRoomExtrasForClient(client);\n  const poller = getOrCreateVersionsPollerForRoomId(room.id);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  return useSignal(store.outputs.versionsByRoomId.getOrCreate(room.id).signal);\n}\nfunction useHistoryVersionsSuspense() {\n  ensureNotServerSide();\n  const client = useClient();\n  const room = useRoom();\n  const store = getRoomExtrasForClient(client).store;\n  use(store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded());\n  const result = useHistoryVersions();\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUpdateRoomNotificationSettings() {\n  const client = useClient();\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (settings) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"update-notification-settings\",\n        roomId: room.id,\n        settings\n      });\n      room.updateNotificationSettings(settings).then(\n        (settings2) => {\n          store.updateRoomNotificationSettings(room.id, optimisticId, settings2);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"UPDATE_NOTIFICATION_SETTINGS_ERROR\", roomId: room.id },\n          err\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useSuspendUntilPresenceReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilPresenceReady());\n}\nfunction useSelfSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useSelf(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthers(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersConnectionIdsSuspense() {\n  useSuspendUntilPresenceReady();\n  return useOthersConnectionIds();\n}\nfunction useOthersMappedSuspense(itemSelector, itemIsEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthersMapped(itemSelector, itemIsEqual);\n}\nfunction useOtherSuspense(connectionId, selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOther(connectionId, selector, isEqual);\n}\nfunction useSuspendUntilStorageReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilStorageReady());\n}\nfunction useStorageSuspense(selector, isEqual) {\n  useSuspendUntilStorageReady();\n  return useStorage(\n    selector,\n    isEqual\n  );\n}\nfunction useStorageStatusSuspense(options) {\n  useSuspendUntilStorageReady();\n  return useStorageStatus(options);\n}\nfunction useThreadsSuspense(options = {}) {\n  ensureNotServerSide();\n  const client = useClient();\n  const room = useRoom();\n  const { store } = getRoomExtrasForClient(client);\n  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);\n  use(store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded());\n  const result = useThreads(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction selectorFor_useAttachmentUrl(state) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state.data !== void 0, \"Unexpected missing attachment URL\");\n  return {\n    isLoading: false,\n    url: state.data\n  };\n}\nfunction useAttachmentUrl(attachmentId) {\n  const room = useRoom();\n  return useRoomAttachmentUrl(attachmentId, room.id);\n}\nfunction useRoomAttachmentUrl(attachmentId, roomId) {\n  const client = useClient();\n  const store = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getOrCreateAttachmentUrlsStore(roomId);\n  const getAttachmentUrlState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => store.getItemState(attachmentId),\n    [store, attachmentId]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void store.enqueue(attachmentId);\n  }, [store, attachmentId]);\n  return useSyncExternalStoreWithSelector(\n    store.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState,\n    selectorFor_useAttachmentUrl,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n}\nfunction useAttachmentUrlSuspense(attachmentId) {\n  const room = useRoom();\n  const { attachmentUrlsStore } = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal];\n  const getAttachmentUrlState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => attachmentUrlsStore.getItemState(attachmentId),\n    [attachmentUrlsStore, attachmentId]\n  );\n  const attachmentUrlState = getAttachmentUrlState();\n  if (!attachmentUrlState || attachmentUrlState.isLoading) {\n    throw attachmentUrlsStore.enqueue(attachmentId);\n  }\n  if (attachmentUrlState.error) {\n    throw attachmentUrlState.error;\n  }\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    attachmentUrlsStore.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    url: state.data,\n    error: void 0\n  };\n}\nvar NO_PERMISSIONS = /* @__PURE__ */ new Set();\nfunction useRoomPermissions(roomId) {\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  return useSignal(\n    store.permissionHints.signal,\n    (hints) => hints.get(roomId) ?? NO_PERMISSIONS\n  );\n}\nfunction createRoomContext(client) {\n  return getOrCreateRoomContextBundle(client);\n}\nvar _RoomProvider = RoomProvider;\nvar _useBroadcastEvent = useBroadcastEvent;\nvar _useOthersListener = useOthersListener;\nvar _useRoom = useRoom;\nvar _useIsInsideRoom = useIsInsideRoom;\nvar _useAddReaction = useAddReaction;\nvar _useMutation = useMutation;\nvar _useCreateThread = useCreateThread;\nvar _useDeleteThread = useDeleteThread;\nvar _useEditThreadMetadata = useEditThreadMetadata;\nvar _useEventListener = useEventListener;\nvar _useMyPresence = useMyPresence;\nvar _useOthersMapped = useOthersMapped;\nvar _useOthersMappedSuspense = useOthersMappedSuspense;\nvar _useThreads = useThreads;\nvar _useThreadsSuspense = useThreadsSuspense;\nvar _useRoomNotificationSettings = useRoomNotificationSettings;\nvar _useRoomNotificationSettingsSuspense = useRoomNotificationSettingsSuspense;\nvar _useHistoryVersions = useHistoryVersions;\nvar _useHistoryVersionsSuspense = useHistoryVersionsSuspense;\nvar _useOther = useOther;\nfunction _useOthers(...args) {\n  return useOthers(...args);\n}\nvar _useOtherSuspense = useOtherSuspense;\nfunction _useOthersSuspense(...args) {\n  return useOthersSuspense(...args);\n}\nvar _useStorage = useStorage;\nvar _useStorageSuspense = useStorageSuspense;\nfunction _useSelf(...args) {\n  return useSelf(...args);\n}\nfunction _useSelfSuspense(...args) {\n  return useSelfSuspense(...args);\n}\nvar _useStorageRoot = useStorageRoot;\nvar _useUpdateMyPresence = useUpdateMyPresence;\n\n\n//# sourceMappingURL=chunk-5RVW253W.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9jaHVuay01UlZXMjUzVy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2tEO0FBQ2xELGtCQUFrQixvREFBYTtBQUMvQjtBQUNBLFNBQVMsaURBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQU9lO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkNBQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDZDQUE2Qyw4Q0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGdCQUFnQiwyREFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLG9EQUFhO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRzBCO0FBUUE7QUFTWDs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsaUJB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LG9EQUFFO0FBQ25CO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQSx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1REFBTTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlEQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFRO0FBQ1osaUJBQWlCLFlBQVksNEJBQTRCLFVBQVU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QU87QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTJHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC9kaXN0L2NodW5rLTVSVlcyNTNXLmpzPzAwNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvbnRleHRzLnRzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgUm9vbUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gdXNlUm9vbU9yTnVsbCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoUm9vbUNvbnRleHQpO1xufVxuZnVuY3Rpb24gdXNlSXNJbnNpZGVSb29tKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbU9yTnVsbCgpO1xuICByZXR1cm4gcm9vbSAhPT0gbnVsbDtcbn1cblxuLy8gc3JjL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IudHNcbmltcG9ydCB7XG4gIHVzZURlYnVnVmFsdWUsXG4gIHVzZUVmZmVjdCxcbiAgdXNlTWVtbyxcbiAgdXNlUmVmLFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZVxufSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHk7XG59XG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgY29uc3QgaW5zdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgbGV0IGluc3Q7XG4gIGlmIChpbnN0UmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICBpbnN0ID0ge1xuICAgICAgaGFzVmFsdWU6IGZhbHNlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9O1xuICAgIGluc3RSZWYuY3VycmVudCA9IGluc3Q7XG4gIH0gZWxzZSB7XG4gICAgaW5zdCA9IGluc3RSZWYuY3VycmVudDtcbiAgfVxuICBjb25zdCBbZ2V0U2VsZWN0aW9uLCBnZXRTZXJ2ZXJTZWxlY3Rpb25dID0gdXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IGhhc01lbW8gPSBmYWxzZTtcbiAgICBsZXQgbWVtb2l6ZWRTbmFwc2hvdDtcbiAgICBsZXQgbWVtb2l6ZWRTZWxlY3Rpb247XG4gICAgY29uc3QgbWVtb2l6ZWRTZWxlY3RvciA9IChuZXh0U25hcHNob3QpID0+IHtcbiAgICAgIGlmICghaGFzTWVtbykge1xuICAgICAgICBoYXNNZW1vID0gdHJ1ZTtcbiAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcbiAgICAgICAgY29uc3QgbmV4dFNlbGVjdGlvbjIgPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuICAgICAgICBpZiAoaXNFcXVhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKGluc3QuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24gPSBpbnN0LnZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzRXF1YWwoY3VycmVudFNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbjIpKSB7XG4gICAgICAgICAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNlbGVjdGlvbjI7XG4gICAgICAgIHJldHVybiBuZXh0U2VsZWN0aW9uMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZTbmFwc2hvdCA9IG1lbW9pemVkU25hcHNob3Q7XG4gICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gbWVtb2l6ZWRTZWxlY3Rpb247XG4gICAgICBpZiAoaXMocHJldlNuYXBzaG90LCBuZXh0U25hcHNob3QpKSB7XG4gICAgICAgIHJldHVybiBwcmV2U2VsZWN0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7XG4gICAgICBpZiAoaXNFcXVhbCAhPT0gdm9pZCAwICYmIGlzRXF1YWwocHJldlNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbikpIHtcbiAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcbiAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG4gICAgICB9XG4gICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBuZXh0U2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIG5leHRTZWxlY3Rpb247XG4gICAgfTtcbiAgICBjb25zdCBtYXliZUdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QgPT09IHZvaWQgMCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICBjb25zdCBnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciA9ICgpID0+IG1lbW9pemVkU2VsZWN0b3IoZ2V0U25hcHNob3QoKSk7XG4gICAgY29uc3QgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3IgPSBtYXliZUdldFNlcnZlclNuYXBzaG90ID09PSBudWxsID8gdm9pZCAwIDogKCkgPT4gbWVtb2l6ZWRTZWxlY3RvcihtYXliZUdldFNlcnZlclNuYXBzaG90KCkpO1xuICAgIHJldHVybiBbZ2V0U25hcHNob3RXaXRoU2VsZWN0b3IsIGdldFNlcnZlclNuYXBzaG90V2l0aFNlbGVjdG9yXTtcbiAgfSwgW2dldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWxdKTtcbiAgY29uc3QgdmFsdWUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U2VsZWN0aW9uLFxuICAgIGdldFNlcnZlclNlbGVjdGlvblxuICApO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGluc3QuaGFzVmFsdWUgPSB0cnVlO1xuICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy91c2Utc2lnbmFsLnRzXG52YXIgaWRlbnRpdHkgPSAodmFsdWUpID0+IHZhbHVlO1xuZnVuY3Rpb24gdXNlU2lnbmFsKHNpZ25hbCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHNpZ25hbC5zdWJzY3JpYmUsXG4gICAgc2lnbmFsLmdldCxcbiAgICBzaWduYWwuZ2V0LFxuICAgIHNlbGVjdG9yID8/IGlkZW50aXR5LFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG5pbXBvcnQge1xuICBIdHRwRXJyb3Jcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7XG4gIGFzc2VydCxcbiAgY3JlYXRlQ2xpZW50LFxuICBrSW50ZXJuYWwgYXMga0ludGVybmFsMixcbiAgbWFrZVBvbGxlcixcbiAgcmFpc2UsXG4gIHNoYWxsb3cgYXMgc2hhbGxvdzRcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDIsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMixcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MixcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzIsXG4gIHVzZVN0YXRlLFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZTJcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jb25maWcudHNcbnZhciBTRUNPTkRTID0gMWUzO1xudmFyIE1JTlVURVMgPSA2MCAqIFNFQ09ORFM7XG52YXIgY29uZmlnID0ge1xuICBTTU9PVEhfREVMQVk6IDEgKiBTRUNPTkRTLFxuICBOT1RJRklDQVRJT05TX1BPTExfSU5URVJWQUw6IDEgKiBNSU5VVEVTLFxuICBOT1RJRklDQVRJT05TX01BWF9TVEFMRV9USU1FOiA1ICogU0VDT05EUyxcbiAgUk9PTV9USFJFQURTX1BPTExfSU5URVJWQUw6IDUgKiBNSU5VVEVTLFxuICBST09NX1RIUkVBRFNfTUFYX1NUQUxFX1RJTUU6IDUgKiBTRUNPTkRTLFxuICBVU0VSX1RIUkVBRFNfUE9MTF9JTlRFUlZBTDogMSAqIE1JTlVURVMsXG4gIFVTRVJfVEhSRUFEU19NQVhfU1RBTEVfVElNRTogMzAgKiBTRUNPTkRTLFxuICBISVNUT1JZX1ZFUlNJT05TX1BPTExfSU5URVJWQUw6IDEgKiBNSU5VVEVTLFxuICBISVNUT1JZX1ZFUlNJT05TX01BWF9TVEFMRV9USU1FOiA1ICogU0VDT05EUyxcbiAgTk9USUZJQ0FUSU9OX1NFVFRJTkdTX1BPTExfSU5URVJWQUw6IDEgKiBNSU5VVEVTLFxuICBOT1RJRklDQVRJT05fU0VUVElOR1NfTUFYX1NUQUxFX1RJTUU6IDUgKiBTRUNPTkRTLFxuICBVU0VSX05PVElGSUNBVElPTl9TRVRUSU5HU19JTlRFUlZBTDogNSAqIE1JTlVURVMsXG4gIFVTRVJfTk9USUZJQ0FUSU9OX1NFVFRJTkdTX01BWF9TVEFMRV9USU1FOiAxICogTUlOVVRFU1xufTtcblxuLy8gc3JjL2xpYi9Bc3luY1Jlc3VsdC50c1xudmFyIEFTWU5DX0xPQURJTkcgPSBPYmplY3QuZnJlZXplKHsgaXNMb2FkaW5nOiB0cnVlIH0pO1xudmFyIEFTWU5DX0VSUiA9IChlcnJvcikgPT4gT2JqZWN0LmZyZWV6ZSh7IGlzTG9hZGluZzogZmFsc2UsIGVycm9yIH0pO1xuZnVuY3Rpb24gQVNZTkNfT0soZmllbGRPckRhdGEsIGRhdGEpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGlzTG9hZGluZzogZmFsc2UsIGRhdGE6IGZpZWxkT3JEYXRhIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgaXNMb2FkaW5nOiBmYWxzZSwgW2ZpZWxkT3JEYXRhXTogZGF0YSB9KTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL2l0ZXJ0b29scy50c1xuZnVuY3Rpb24gZmluZChpdCwgcHJlZGljYXRlKSB7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBpdCkge1xuICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHJldHVybiBpdGVtO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBjb3VudChpdCwgcHJlZGljYXRlKSB7XG4gIGxldCB0b3RhbCA9IDA7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBpdCkge1xuICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHRvdGFsKys7XG4gIH1cbiAgcmV0dXJuIHRvdGFsO1xufVxuXG4vLyBzcmMvbGliL3Nzci50c1xuZnVuY3Rpb24gZW5zdXJlTm90U2VydmVyU2lkZSgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3QgdXNlIHRoZSBTdXNwZW5zZSB2ZXJzaW9uIG9mIExpdmVibG9ja3MgaG9va3Mgc2VydmVyIHNpZGUuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgdGhlbSBjbGllbnQgc2lkZSBieSB1c2luZyBhIENsaWVudFNpZGVTdXNwZW5zZSB3cmFwcGVyLlxcbkZvciB0aXBzLCBzZWUgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLXJlYWN0I0NsaWVudFNpZGVTdXNwZW5zZVwiXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL3VzZS1pbml0aWFsLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVkdWNlciB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvbGliL3VzZS1sYXRlc3QudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLCB1c2VSZWYgYXMgdXNlUmVmMiB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlTGF0ZXN0KHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZjIodmFsdWUpO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuLy8gc3JjL2xpYi91c2UtaW5pdGlhbC50c1xudmFyIG5vb3AgPSAoc3RhdGUpID0+IHN0YXRlO1xuZnVuY3Rpb24gdXNlSW5pdGlhbCh2YWx1ZSkge1xuICByZXR1cm4gdXNlUmVkdWNlcihub29wLCB2YWx1ZSlbMF07XG59XG5mdW5jdGlvbiB1c2VJbml0aWFsVW5sZXNzRnVuY3Rpb24obGF0ZXN0VmFsdWUpIHtcbiAgY29uc3QgZnJvemVuVmFsdWUgPSB1c2VJbml0aWFsKGxhdGVzdFZhbHVlKTtcbiAgaWYgKHR5cGVvZiBmcm96ZW5WYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgcmVmID0gdXNlTGF0ZXN0KGxhdGVzdFZhbHVlKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKC4uLmFyZ3MpID0+IHJlZi5jdXJyZW50KC4uLmFyZ3MpLCBbXG4gICAgICByZWZcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJvemVuVmFsdWU7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi91c2UtcG9seWZpbGwudHNcbnZhciB1c2UgPSAoXG4gIC8vIFJlYWN0LnVzZSB8fFxuICAocHJvbWlzZSkgPT4ge1xuICAgIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgIHRocm93IHByb21pc2U7XG4gICAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gICAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICB0aHJvdyBwcm9taXNlLnJlYXNvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgIHByb21pc2UudGhlbihcbiAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHY7XG4gICAgICAgIH0sXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgcHJvbWlzZS5yZWFzb24gPSBlO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGhyb3cgcHJvbWlzZTtcbiAgICB9XG4gIH1cbik7XG5cbi8vIHNyYy91bWJyZWxsYS1zdG9yZS50c1xuaW1wb3J0IHtcbiAgYXV0b1JldHJ5LFxuICBiYXRjaCBhcyBiYXRjaDIsXG4gIGNvbXBhY3RPYmplY3QsXG4gIGNvbnNvbGUgYXMgY29uc29sZTIsXG4gIERlZmF1bHRNYXAsXG4gIERlcml2ZWRTaWduYWwsXG4gIGVudHJpZXMsXG4gIGtleXMsXG4gIGtJbnRlcm5hbCxcbiAgTXV0YWJsZVNpZ25hbCBhcyBNdXRhYmxlU2lnbmFsMixcbiAgbmFub2lkLFxuICBubixcbiAgc2hhbGxvdyBhcyBzaGFsbG93MyxcbiAgU2lnbmFsLFxuICBzdGFibGVTdHJpbmdpZnlcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcblxuLy8gc3JjL2xpYi9hdXRvYmluZC50c1xuZnVuY3Rpb24gYXV0b2JpbmQoc2VsZikge1xuICBjb25zdCBzZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgc2Vlbi5hZGQoXCJjb25zdHJ1Y3RvclwiKTtcbiAgbGV0IG9iaiA9IHNlbGYuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICBkbyB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdC5vd25LZXlzKG9iaikpIHtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3I/LnZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgc2VsZltrZXldID0gc2VsZltrZXldLmJpbmQoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgob2JqID0gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihvYmopKSAmJiBvYmogIT09IE9iamVjdC5wcm90b3R5cGUpO1xufVxuXG4vLyBzcmMvbGliL3NoYWxsb3cyLnRzXG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0LCBzaGFsbG93IH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmZ1bmN0aW9uIHNoYWxsb3cyKGEsIGIpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGEpIHx8ICFpc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgcmV0dXJuIHNoYWxsb3coYSwgYik7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBrZXlzQS5ldmVyeShcbiAgICAoa2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSAmJiBzaGFsbG93KGFba2V5XSwgYltrZXldKVxuICApO1xufVxuXG4vLyBzcmMvVGhyZWFkREIudHNcbmltcG9ydCB7IGJhdGNoLCBNdXRhYmxlU2lnbmFsLCBTb3J0ZWRMaXN0IH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcblxuLy8gc3JjL2xpYi9xdWVyeWluZy50c1xuaW1wb3J0IHsgaXNTdGFydHNXaXRoT3BlcmF0b3IgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuZnVuY3Rpb24gbWFrZVRocmVhZHNGaWx0ZXIocXVlcnkpIHtcbiAgcmV0dXJuICh0aHJlYWQpID0+IG1hdGNoZXNRdWVyeSh0aHJlYWQsIHF1ZXJ5KSAmJiBtYXRjaGVzTWV0YWRhdGEodGhyZWFkLCBxdWVyeSk7XG59XG5mdW5jdGlvbiBtYXRjaGVzUXVlcnkodGhyZWFkLCBxKSB7XG4gIHJldHVybiBxLnJlc29sdmVkID09PSB2b2lkIDAgfHwgdGhyZWFkLnJlc29sdmVkID09PSBxLnJlc29sdmVkO1xufVxuZnVuY3Rpb24gbWF0Y2hlc01ldGFkYXRhKHRocmVhZCwgcSkge1xuICBjb25zdCBtZXRhZGF0YSA9IHRocmVhZC5tZXRhZGF0YTtcbiAgcmV0dXJuIHEubWV0YWRhdGEgPT09IHZvaWQgMCB8fCBPYmplY3QuZW50cmllcyhxLm1ldGFkYXRhKS5ldmVyeShcbiAgICAoW2tleSwgb3BdKSA9PiAoXG4gICAgICAvLyBJZ25vcmUgZXhwbGljaXQtdW5kZWZpbmVkIGZpbHRlcnNcbiAgICAgIC8vIEJvb2xlYW4gbG9naWM6IG9wPyA9PiB2YWx1ZSBtYXRjaGVzIHRoZSBvcGVyYXRvclxuICAgICAgb3AgPT09IHZvaWQgMCB8fCBtYXRjaGVzT3BlcmF0b3IobWV0YWRhdGFba2V5XSwgb3ApXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gbWF0Y2hlc09wZXJhdG9yKHZhbHVlLCBvcCkge1xuICBpZiAob3AgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMDtcbiAgfSBlbHNlIGlmIChpc1N0YXJ0c1dpdGhPcGVyYXRvcihvcCkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgob3Auc3RhcnRzV2l0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBvcDtcbiAgfVxufVxuXG4vLyBzcmMvVGhyZWFkREIudHNcbmZ1bmN0aW9uIHNhbml0aXplVGhyZWFkKHRocmVhZCkge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCkge1xuICAgIGlmICh0aHJlYWQuY29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHsgLi4udGhyZWFkLCBjb21tZW50czogW10gfTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGFzQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5zb21lKChjKSA9PiAhYy5kZWxldGVkQXQpO1xuICBpZiAoIWhhc0NvbW1lbnQpIHtcbiAgICByZXR1cm4geyAuLi50aHJlYWQsIGRlbGV0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGNvbW1lbnRzOiBbXSB9O1xuICB9XG4gIHJldHVybiB0aHJlYWQ7XG59XG52YXIgVGhyZWFkREIgPSBjbGFzcyBfVGhyZWFkREIge1xuICAjYnlJZDtcbiAgI2FzYztcbiAgI2Rlc2M7XG4gIC8vIFRoaXMgc2lnbmFsIHdpbGwgYmUgbm90aWZpZWQgb24gZXZlcnkgbXV0YXRpb25cbiAgc2lnbmFsO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLiNhc2MgPSBTb3J0ZWRMaXN0LmZyb20oW10sICh0MSwgdDIpID0+IHtcbiAgICAgIGNvbnN0IGQxID0gdDEuY3JlYXRlZEF0O1xuICAgICAgY29uc3QgZDIgPSB0Mi5jcmVhdGVkQXQ7XG4gICAgICByZXR1cm4gZDEgPCBkMiA/IHRydWUgOiBkMSA9PT0gZDIgPyB0MS5pZCA8IHQyLmlkIDogZmFsc2U7XG4gICAgfSk7XG4gICAgdGhpcy4jZGVzYyA9IFNvcnRlZExpc3QuZnJvbShbXSwgKHQxLCB0MikgPT4ge1xuICAgICAgY29uc3QgZDIgPSB0Mi51cGRhdGVkQXQ7XG4gICAgICBjb25zdCBkMSA9IHQxLnVwZGF0ZWRBdDtcbiAgICAgIHJldHVybiBkMiA8IGQxID8gdHJ1ZSA6IGQyID09PSBkMSA/IHQyLmlkIDwgdDEuaWQgOiBmYWxzZTtcbiAgICB9KTtcbiAgICB0aGlzLiNieUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnNpZ25hbCA9IG5ldyBNdXRhYmxlU2lnbmFsKHRoaXMpO1xuICB9XG4gIC8vXG4gIC8vIFB1YmxpYyBBUElzXG4gIC8vXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IG5ld1Bvb2wgPSBuZXcgX1RocmVhZERCKCk7XG4gICAgbmV3UG9vbC4jYnlJZCA9IG5ldyBNYXAodGhpcy4jYnlJZCk7XG4gICAgbmV3UG9vbC4jYXNjID0gdGhpcy4jYXNjLmNsb25lKCk7XG4gICAgbmV3UG9vbC4jZGVzYyA9IHRoaXMuI2Rlc2MuY2xvbmUoKTtcbiAgICByZXR1cm4gbmV3UG9vbDtcbiAgfVxuICAvKiogUmV0dXJucyBhbiBleGlzdGluZyB0aHJlYWQgYnkgSUQuIFdpbGwgbmV2ZXIgcmV0dXJuIGEgZGVsZXRlZCB0aHJlYWQuICovXG4gIGdldCh0aHJlYWRJZCkge1xuICAgIGNvbnN0IHRocmVhZCA9IHRoaXMuZ2V0RXZlbklmRGVsZXRlZCh0aHJlYWRJZCk7XG4gICAgcmV0dXJuIHRocmVhZD8uZGVsZXRlZEF0ID8gdm9pZCAwIDogdGhyZWFkO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSAocG9zc2libHkgZGVsZXRlZCkgdGhyZWFkIGJ5IElELiAqL1xuICBnZXRFdmVuSWZEZWxldGVkKHRocmVhZElkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2J5SWQuZ2V0KHRocmVhZElkKTtcbiAgfVxuICAvKiogQWRkcyBvciB1cGRhdGVzIGEgdGhyZWFkIGluIHRoZSBEQi4gSWYgdGhlIG5ld2x5IGdpdmVuIHRocmVhZCBpcyBhIGRlbGV0ZWQgb25lLCBpdCB3aWxsIGdldCBkZWxldGVkLiAqL1xuICB1cHNlcnQodGhyZWFkKSB7XG4gICAgdGhpcy5zaWduYWwubXV0YXRlKCgpID0+IHtcbiAgICAgIHRocmVhZCA9IHNhbml0aXplVGhyZWFkKHRocmVhZCk7XG4gICAgICBjb25zdCBpZCA9IHRocmVhZC5pZDtcbiAgICAgIGNvbnN0IHRvUmVtb3ZlID0gdGhpcy4jYnlJZC5nZXQoaWQpO1xuICAgICAgaWYgKHRvUmVtb3ZlKSB7XG4gICAgICAgIGlmICh0b1JlbW92ZS5kZWxldGVkQXQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy4jYXNjLnJlbW92ZSh0b1JlbW92ZSk7XG4gICAgICAgIHRoaXMuI2Rlc2MucmVtb3ZlKHRvUmVtb3ZlKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhyZWFkLmRlbGV0ZWRBdCkge1xuICAgICAgICB0aGlzLiNhc2MuYWRkKHRocmVhZCk7XG4gICAgICAgIHRoaXMuI2Rlc2MuYWRkKHRocmVhZCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNieUlkLnNldChpZCwgdGhyZWFkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIC8qKiBMaWtlIC51cHNlcnQoKSwgZXhjZXB0IGl0IHdvbid0IHVwZGF0ZSBpZiBhIHRocmVhZCBieSB0aGlzIElEIGFscmVhZHkgZXhpc3RzLiAqL1xuICAvLyBUT0RPIENvbnNpZGVyIHJlbmFtaW5nIHRoaXMgdG8ganVzdCAudXBzZXJ0KCkuIEknbSBub3Qgc3VyZSBpZiB3ZSByZWFsbHlcbiAgLy8gVE9ETyBuZWVkIHRoZSByYXcgLnVwc2VydCgpLiBXb3VsZCBiZSBuaWNlIGlmIHRoaXMgYmVoYXZpb3Igd2FzIHRoZSBkZWZhdWx0LlxuICB1cHNlcnRJZk5ld2VyKHRocmVhZCkge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5nZXQodGhyZWFkLmlkKTtcbiAgICBpZiAoIWV4aXN0aW5nIHx8IHRocmVhZC51cGRhdGVkQXQgPj0gZXhpc3RpbmcudXBkYXRlZEF0KSB7XG4gICAgICB0aGlzLnVwc2VydCh0aHJlYWQpO1xuICAgIH1cbiAgfVxuICBhcHBseURlbHRhKG5ld1RocmVhZHMsIGRlbGV0ZWRUaHJlYWRzKSB7XG4gICAgYmF0Y2goKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCB0aHJlYWQgb2YgbmV3VGhyZWFkcykge1xuICAgICAgICB0aGlzLnVwc2VydElmTmV3ZXIodGhyZWFkKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgeyBpZCwgZGVsZXRlZEF0IH0gb2YgZGVsZXRlZFRocmVhZHMpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmdldEV2ZW5JZkRlbGV0ZWQoaWQpO1xuICAgICAgICBpZiAoIWV4aXN0aW5nKSBjb250aW51ZTtcbiAgICAgICAgdGhpcy5kZWxldGUoaWQsIGRlbGV0ZWRBdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmtzIGEgdGhyZWFkIGFzIGRlbGV0ZWQuIEl0IHdpbGwgbm8gbG9uZ2VyIHBvcCB1cCBpbiAuZmluZE1hbnkoKVxuICAgKiBxdWVyaWVzLCBidXQgaXQgY2FuIHN0aWxsIGJlIGFjY2Vzc2VkIHZpYSBgLmdldEV2ZW5JZkRlbGV0ZWQoKWAuXG4gICAqL1xuICBkZWxldGUodGhyZWFkSWQsIGRlbGV0ZWRBdCkge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy4jYnlJZC5nZXQodGhyZWFkSWQpO1xuICAgIGlmIChleGlzdGluZyAmJiAhZXhpc3RpbmcuZGVsZXRlZEF0KSB7XG4gICAgICB0aGlzLnVwc2VydCh7IC4uLmV4aXN0aW5nLCBkZWxldGVkQXQsIHVwZGF0ZWRBdDogZGVsZXRlZEF0IH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhyZWFkcyBtYXRjaGluZyBhIGdpdmVuIHJvb21JZCBhbmQgcXVlcnkuIElmIHJvb21JZCBpcyBub3RcbiAgICogc3BlY2lmaWVkLCBpdCB3aWxsIHJldHVybiBhbGwgdGhyZWFkcyBtYXRjaGluZyB0aGUgcXVlcnksIGFjcm9zcyBhbGxcbiAgICogcm9vbXMuXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHJlc3VsdHMgaW4gdGhlIHJlcXVlc3RlZCBvcmRlci4gUGxlYXNlIG5vdGU6XG4gICAqICAgJ2FzYycgIG1lYW5zIGJ5IGNyZWF0ZWRBdCBBU0NcbiAgICogICAnZGVzYycgbWVhbnMgYnkgdXBkYXRlZEF0IERFU0NcbiAgICpcbiAgICogV2lsbCBuZXZlciByZXR1cm4gZGVsZXRlZCB0aHJlYWRzIGluIHRoZSByZXN1bHQuXG4gICAqL1xuICBmaW5kTWFueShyb29tSWQsIHF1ZXJ5LCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBpbmRleCA9IGRpcmVjdGlvbiA9PT0gXCJkZXNjXCIgPyB0aGlzLiNkZXNjIDogdGhpcy4jYXNjO1xuICAgIGNvbnN0IGNyaXQgPSBbXTtcbiAgICBpZiAocm9vbUlkICE9PSB2b2lkIDApIHtcbiAgICAgIGNyaXQucHVzaCgodCkgPT4gdC5yb29tSWQgPT09IHJvb21JZCk7XG4gICAgfVxuICAgIGNyaXQucHVzaChtYWtlVGhyZWFkc0ZpbHRlcihxdWVyeSkpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGluZGV4LmZpbHRlcigodCkgPT4gY3JpdC5ldmVyeSgocHJlZCkgPT4gcHJlZCh0KSkpKTtcbiAgfVxufTtcblxuLy8gc3JjL3VtYnJlbGxhLXN0b3JlLnRzXG5mdW5jdGlvbiBtYWtlUm9vbVRocmVhZHNRdWVyeUtleShyb29tSWQsIHF1ZXJ5KSB7XG4gIHJldHVybiBzdGFibGVTdHJpbmdpZnkoW3Jvb21JZCwgcXVlcnkgPz8ge31dKTtcbn1cbmZ1bmN0aW9uIG1ha2VVc2VyVGhyZWFkc1F1ZXJ5S2V5KHF1ZXJ5KSB7XG4gIHJldHVybiBzdGFibGVTdHJpbmdpZnkocXVlcnkgPz8ge30pO1xufVxuZnVuY3Rpb24gdXNpZnkocHJvbWlzZSkge1xuICBpZiAoXCJzdGF0dXNcIiBpbiBwcm9taXNlKSB7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgY29uc3QgdXNhYmxlID0gcHJvbWlzZTtcbiAgdXNhYmxlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICB1c2FibGUudGhlbihcbiAgICAodmFsdWUpID0+IHtcbiAgICAgIHVzYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgdXNhYmxlLnZhbHVlID0gdmFsdWU7XG4gICAgfSxcbiAgICAoZXJyKSA9PiB7XG4gICAgICB1c2FibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgdXNhYmxlLnJlYXNvbiA9IGVycjtcbiAgICB9XG4gICk7XG4gIHJldHVybiB1c2FibGU7XG59XG52YXIgbm9vcDIgPSBQcm9taXNlLnJlc29sdmUoKTtcbnZhciBQYWdpbmF0ZWRSZXNvdXJjZSA9IGNsYXNzIHtcbiAgI3NpZ25hbDtcbiAgc2lnbmFsO1xuICAjZmV0Y2hQYWdlO1xuICAjcGVuZGluZ0ZldGNoTW9yZTtcbiAgY29uc3RydWN0b3IoZmV0Y2hQYWdlKSB7XG4gICAgdGhpcy4jc2lnbmFsID0gbmV3IFNpZ25hbChBU1lOQ19MT0FESU5HKTtcbiAgICB0aGlzLiNmZXRjaFBhZ2UgPSBmZXRjaFBhZ2U7XG4gICAgdGhpcy4jcGVuZGluZ0ZldGNoTW9yZSA9IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSB0aGlzLiNzaWduYWwuYXNSZWFkb25seSgpO1xuICAgIGF1dG9iaW5kKHRoaXMpO1xuICB9XG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2lnbmFsLmdldCgpO1xuICB9XG4gICNwYXRjaChwYXRjaCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jc2lnbmFsLmdldCgpO1xuICAgIGlmIChzdGF0ZS5kYXRhID09PSB2b2lkIDApIHJldHVybjtcbiAgICB0aGlzLiNzaWduYWwuc2V0KEFTWU5DX09LKHsgLi4uc3RhdGUuZGF0YSwgLi4ucGF0Y2ggfSkpO1xuICB9XG4gIGFzeW5jICNmZXRjaE1vcmUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLiNzaWduYWwuZ2V0KCk7XG4gICAgaWYgKCFzdGF0ZS5kYXRhPy5jdXJzb3IgfHwgc3RhdGUuZGF0YS5pc0ZldGNoaW5nTW9yZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNwYXRjaCh7IGlzRmV0Y2hpbmdNb3JlOiB0cnVlIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXh0Q3Vyc29yID0gYXdhaXQgdGhpcy4jZmV0Y2hQYWdlKHN0YXRlLmRhdGEuY3Vyc29yKTtcbiAgICAgIHRoaXMuI3BhdGNoKHtcbiAgICAgICAgY3Vyc29yOiBuZXh0Q3Vyc29yLFxuICAgICAgICBoYXNGZXRjaGVkQWxsOiBuZXh0Q3Vyc29yID09PSBudWxsLFxuICAgICAgICBmZXRjaE1vcmVFcnJvcjogdm9pZCAwLFxuICAgICAgICBpc0ZldGNoaW5nTW9yZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy4jcGF0Y2goe1xuICAgICAgICBpc0ZldGNoaW5nTW9yZTogZmFsc2UsXG4gICAgICAgIGZldGNoTW9yZUVycm9yOiBlcnJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmZXRjaE1vcmUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLiNzaWduYWwuZ2V0KCk7XG4gICAgaWYgKCFzdGF0ZS5kYXRhPy5jdXJzb3IpIHJldHVybiBub29wMjtcbiAgICBpZiAoIXRoaXMuI3BlbmRpbmdGZXRjaE1vcmUpIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdGZXRjaE1vcmUgPSB0aGlzLiNmZXRjaE1vcmUoKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0ZldGNoTW9yZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI3BlbmRpbmdGZXRjaE1vcmU7XG4gIH1cbiAgI2NhY2hlZFByb21pc2UgPSBudWxsO1xuICB3YWl0VW50aWxMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsUGFnZUZldGNoJCA9IGF1dG9SZXRyeShcbiAgICAgICgpID0+IHRoaXMuI2ZldGNoUGFnZShcbiAgICAgICAgLyogY3Vyc29yICovXG4gICAgICAgIHZvaWQgMFxuICAgICAgKSxcbiAgICAgIDUsXG4gICAgICBbNWUzLCA1ZTMsIDFlNCwgMTVlM11cbiAgICApO1xuICAgIGNvbnN0IHByb21pc2UgPSB1c2lmeShpbml0aWFsUGFnZUZldGNoJCk7XG4gICAgcHJvbWlzZS50aGVuKFxuICAgICAgKGN1cnNvcikgPT4ge1xuICAgICAgICB0aGlzLiNzaWduYWwuc2V0KFxuICAgICAgICAgIEFTWU5DX09LKHtcbiAgICAgICAgICAgIGN1cnNvcixcbiAgICAgICAgICAgIGhhc0ZldGNoZWRBbGw6IGN1cnNvciA9PT0gbnVsbCxcbiAgICAgICAgICAgIGlzRmV0Y2hpbmdNb3JlOiBmYWxzZSxcbiAgICAgICAgICAgIGZldGNoTW9yZUVycm9yOiB2b2lkIDAsXG4gICAgICAgICAgICBmZXRjaE1vcmU6IHRoaXMuZmV0Y2hNb3JlXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuI3NpZ25hbC5zZXQoQVNZTkNfRVJSKGVycikpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLiNjYWNoZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiNzaWduYWwuc2V0KEFTWU5DX0xPQURJTkcpO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy4jY2FjaGVkUHJvbWlzZSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlZFByb21pc2U7XG4gIH1cbn07XG52YXIgU2luZ2xlUGFnZVJlc291cmNlID0gY2xhc3Mge1xuICAjc2lnbmFsO1xuICBzaWduYWw7XG4gICNmZXRjaFBhZ2U7XG4gIGNvbnN0cnVjdG9yKGZldGNoUGFnZSkge1xuICAgIHRoaXMuI3NpZ25hbCA9IG5ldyBTaWduYWwoQVNZTkNfTE9BRElORyk7XG4gICAgdGhpcy5zaWduYWwgPSB0aGlzLiNzaWduYWwuYXNSZWFkb25seSgpO1xuICAgIHRoaXMuI2ZldGNoUGFnZSA9IGZldGNoUGFnZTtcbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NpZ25hbC5nZXQoKTtcbiAgfVxuICAjY2FjaGVkUHJvbWlzZSA9IG51bGw7XG4gIHdhaXRVbnRpbExvYWRlZCgpIHtcbiAgICBpZiAodGhpcy4jY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2NhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWxGZXRjaGVyJCA9IGF1dG9SZXRyeShcbiAgICAgICgpID0+IHRoaXMuI2ZldGNoUGFnZSgpLFxuICAgICAgNSxcbiAgICAgIFs1ZTMsIDVlMywgMWU0LCAxNWUzXVxuICAgICk7XG4gICAgY29uc3QgcHJvbWlzZSA9IHVzaWZ5KGluaXRpYWxGZXRjaGVyJCk7XG4gICAgcHJvbWlzZS50aGVuKFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLiNzaWduYWwuc2V0KEFTWU5DX09LKHZvaWQgMCkpO1xuICAgICAgfSxcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy4jc2lnbmFsLnNldChBU1lOQ19FUlIoZXJyKSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuI2NhY2hlZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgIHRoaXMuI3NpZ25hbC5zZXQoQVNZTkNfTE9BRElORyk7XG4gICAgICAgIH0sIDVlMyk7XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLiNjYWNoZWRQcm9taXNlID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlX2Zvck5vdGlmaWNhdGlvbnMoKSB7XG4gIGNvbnN0IHNpZ25hbCA9IG5ldyBNdXRhYmxlU2lnbmFsMigvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgZnVuY3Rpb24gbWFya1JlYWQobm90aWZpY2F0aW9uSWQsIHJlYWRBdCkge1xuICAgIHNpZ25hbC5tdXRhdGUoKGx1dCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBsdXQuZ2V0KG5vdGlmaWNhdGlvbklkKTtcbiAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbHV0LnNldChub3RpZmljYXRpb25JZCwgeyAuLi5leGlzdGluZywgcmVhZEF0IH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gbWFya0FsbFJlYWQocmVhZEF0KSB7XG4gICAgc2lnbmFsLm11dGF0ZSgobHV0KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG4gb2YgbHV0LnZhbHVlcygpKSB7XG4gICAgICAgIG4ucmVhZEF0ID0gcmVhZEF0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZU9uZShpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgc2lnbmFsLm11dGF0ZSgobHV0KSA9PiBsdXQuZGVsZXRlKGluYm94Tm90aWZpY2F0aW9uSWQpKTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBzaWduYWwubXV0YXRlKChsdXQpID0+IGx1dC5jbGVhcigpKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseURlbHRhKG5ld05vdGlmaWNhdGlvbnMsIGRlbGV0ZWROb3RpZmljYXRpb25zKSB7XG4gICAgc2lnbmFsLm11dGF0ZSgobHV0KSA9PiB7XG4gICAgICBsZXQgbXV0YXRlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBuIG9mIG5ld05vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBsdXQuZ2V0KG4uaWQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJlSW5ib3hOb3RpZmljYXRpb25zKGV4aXN0aW5nLCBuKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSAxKSBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsdXQuc2V0KG4uaWQsIG4pO1xuICAgICAgICBtdXRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbiBvZiBkZWxldGVkTm90aWZpY2F0aW9ucykge1xuICAgICAgICBsdXQuZGVsZXRlKG4uaWQpO1xuICAgICAgICBtdXRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtdXRhdGVkO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUFzc29jaWF0ZWROb3RpZmljYXRpb24obmV3Q29tbWVudCkge1xuICAgIHNpZ25hbC5tdXRhdGUoKGx1dCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBmaW5kKFxuICAgICAgICBsdXQudmFsdWVzKCksXG4gICAgICAgIChub3RpZmljYXRpb24pID0+IG5vdGlmaWNhdGlvbi5raW5kID09PSBcInRocmVhZFwiICYmIG5vdGlmaWNhdGlvbi50aHJlYWRJZCA9PT0gbmV3Q29tbWVudC50aHJlYWRJZFxuICAgICAgKTtcbiAgICAgIGlmICghZXhpc3RpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgIGx1dC5zZXQoZXhpc3RpbmcuaWQsIHtcbiAgICAgICAgLi4uZXhpc3RpbmcsXG4gICAgICAgIG5vdGlmaWVkQXQ6IG5ld0NvbW1lbnQuY3JlYXRlZEF0LFxuICAgICAgICByZWFkQXQ6IG5ld0NvbW1lbnQuY3JlYXRlZEF0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydChub3RpZmljYXRpb24pIHtcbiAgICBzaWduYWwubXV0YXRlKChsdXQpID0+IHtcbiAgICAgIGx1dC5zZXQobm90aWZpY2F0aW9uLmlkLCBub3RpZmljYXRpb24pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2lnbmFsOiBzaWduYWwuYXNSZWFkb25seSgpLFxuICAgIC8vIE11dGF0aW9uc1xuICAgIG1hcmtBbGxSZWFkLFxuICAgIG1hcmtSZWFkLFxuICAgIGRlbGV0ZTogZGVsZXRlT25lLFxuICAgIGFwcGx5RGVsdGEsXG4gICAgY2xlYXIsXG4gICAgdXBkYXRlQXNzb2NpYXRlZE5vdGlmaWNhdGlvbixcbiAgICB1cHNlcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlX2ZvclJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyh1cGRhdGVzKSB7XG4gIGNvbnN0IGJhc2VTaWduYWwgPSBuZXcgTXV0YWJsZVNpZ25hbDIoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIGZ1bmN0aW9uIHVwZGF0ZShyb29tSWQsIHNldHRpbmdzKSB7XG4gICAgYmFzZVNpZ25hbC5tdXRhdGUoKGx1dCkgPT4ge1xuICAgICAgbHV0LnNldChyb29tSWQsIHNldHRpbmdzKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNpZ25hbDogRGVyaXZlZFNpZ25hbC5mcm9tKFxuICAgICAgYmFzZVNpZ25hbCxcbiAgICAgIHVwZGF0ZXMsXG4gICAgICAoYmFzZSwgdXBkYXRlczIpID0+IGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXNfZm9yU2V0dGluZ3MoYmFzZSwgdXBkYXRlczIpXG4gICAgKSxcbiAgICAvLyBNdXRhdGlvbnNcbiAgICB1cGRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlX2Zvckhpc3RvcnlWZXJzaW9ucygpIHtcbiAgY29uc3QgYmFzZVNpZ25hbCA9IG5ldyBNdXRhYmxlU2lnbmFsMihcbiAgICBuZXcgRGVmYXVsdE1hcCgoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKVxuICApO1xuICBmdW5jdGlvbiB1cGRhdGUocm9vbUlkLCB2ZXJzaW9ucykge1xuICAgIGJhc2VTaWduYWwubXV0YXRlKChsdXQpID0+IHtcbiAgICAgIGNvbnN0IHZlcnNpb25zQnlJZCA9IGx1dC5nZXRPckNyZWF0ZShyb29tSWQpO1xuICAgICAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHZlcnNpb25zKSB7XG4gICAgICAgIHZlcnNpb25zQnlJZC5zZXQodmVyc2lvbi5pZCwgdmVyc2lvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzaWduYWw6IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICAgIGJhc2VTaWduYWwsXG4gICAgICAoaHYpID0+IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgWy4uLmh2XS5tYXAoKFtyb29tSWQsIHZlcnNpb25zXSkgPT4gW1xuICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICBPYmplY3QuZnJvbUVudHJpZXModmVyc2lvbnMpXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKSxcbiAgICAvLyBNdXRhdGlvbnNcbiAgICB1cGRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlX2ZvclBlcm1pc3Npb25IaW50cygpIHtcbiAgY29uc3Qgc2lnbmFsID0gbmV3IE11dGFibGVTaWduYWwyKFxuICAgIG5ldyBEZWZhdWx0TWFwKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpXG4gICk7XG4gIGZ1bmN0aW9uIHVwZGF0ZShuZXdIaW50cykge1xuICAgIHNpZ25hbC5tdXRhdGUoKGx1dCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBbcm9vbUlkLCBuZXdQZXJtaXNzaW9uc10gb2YgT2JqZWN0LmVudHJpZXMobmV3SGludHMpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gbHV0LmdldE9yQ3JlYXRlKHJvb21JZCk7XG4gICAgICAgIGZvciAoY29uc3QgcGVybWlzc2lvbiBvZiBuZXdQZXJtaXNzaW9ucykge1xuICAgICAgICAgIGV4aXN0aW5nLmFkZChwZXJtaXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2lnbmFsOiBzaWduYWwuYXNSZWFkb25seSgpLFxuICAgIC8vIE11dGF0aW9uc1xuICAgIHVwZGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RvcmVfZm9yVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKHVwZGF0ZXMpIHtcbiAgY29uc3Qgc2lnbmFsID0gbmV3IFNpZ25hbCh7fSk7XG4gIGZ1bmN0aW9uIHVwZGF0ZShzZXR0aW5ncykge1xuICAgIHNpZ25hbC5zZXQoKHByZXZTZXR0aW5ncykgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJldlNldHRpbmdzLFxuICAgICAgICAuLi5zZXR0aW5nc1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNpZ25hbDogRGVyaXZlZFNpZ25hbC5mcm9tKFxuICAgICAgc2lnbmFsLFxuICAgICAgdXBkYXRlcyxcbiAgICAgIChiYXNlLCB1cGRhdGVzMikgPT4gYXBwbHlPcHRpbWlzdGljVXBkYXRlc19mb3JVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MoYmFzZSwgdXBkYXRlczIpXG4gICAgKSxcbiAgICAvLyBNdXRhdGlvbnNcbiAgICB1cGRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlX2Zvck9wdGltaXN0aWMoY2xpZW50KSB7XG4gIGNvbnN0IHNpZ25hbCA9IG5ldyBTaWduYWwoW10pO1xuICBjb25zdCBzeW5jU291cmNlID0gY2xpZW50W2tJbnRlcm5hbF0uY3JlYXRlU3luY1NvdXJjZSgpO1xuICBzaWduYWwuc3Vic2NyaWJlKFxuICAgICgpID0+IHN5bmNTb3VyY2Uuc2V0U3luY1N0YXR1cyhcbiAgICAgIHNpZ25hbC5nZXQoKS5sZW5ndGggPiAwID8gXCJzeW5jaHJvbml6aW5nXCIgOiBcInN5bmNocm9uaXplZFwiXG4gICAgKVxuICApO1xuICBmdW5jdGlvbiBhZGQob3B0aW1pc3RpY1VwZGF0ZSkge1xuICAgIGNvbnN0IGlkID0gbmFub2lkKCk7XG4gICAgY29uc3QgbmV3VXBkYXRlID0geyAuLi5vcHRpbWlzdGljVXBkYXRlLCBpZCB9O1xuICAgIHNpZ25hbC5zZXQoKHN0YXRlKSA9PiBbLi4uc3RhdGUsIG5ld1VwZGF0ZV0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmUob3B0aW1pc3RpY0lkKSB7XG4gICAgc2lnbmFsLnNldCgoc3RhdGUpID0+IHN0YXRlLmZpbHRlcigob3UpID0+IG91LmlkICE9PSBvcHRpbWlzdGljSWQpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNpZ25hbDogc2lnbmFsLmFzUmVhZG9ubHkoKSxcbiAgICAvLyBNdXRhdGlvbnNcbiAgICBhZGQsXG4gICAgcmVtb3ZlXG4gIH07XG59XG52YXIgVW1icmVsbGFTdG9yZSA9IGNsYXNzIHtcbiAgI2NsaWVudDtcbiAgLy9cbiAgLy8gSW50ZXJuYWxseSwgdGhlIFVtYnJlbGxhU3RvcmUga2VlcHMgdHJhY2sgb2YgYSBmZXcgc291cmNlIHNpZ25hbHMgdGhhdCBjYW5cbiAgLy8gYmUgc2V0IGFuZCBtdXRhdGVkIGluZGl2aWR1YWxseS4gV2hlbiBhbnkgb2YgdGhvc2UgYXJlIG11dGF0ZWQgdGhlbiB0aGVcbiAgLy8gY2xlYW4gXCJleHRlcm5hbCBzdGF0ZVwiIGlzIHJlY29tcHV0ZWQuXG4gIC8vXG4gIC8vICAgTXV0YXRlIGlucHV0cy4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9ic2VydmUgY2xlYW4vY29uc2lzdGVudCBvdXRwdXQhXG4gIC8vXG4gIC8vICAgICAgICAgICAgLi0+IEJhc2UgVGhyZWFkREIgLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgKy0tLS0+IENsZWFuIHRocmVhZHMgYnkgSUQgICAgICAgICAgIChQYXJ0IDEpXG4gIC8vICAgICAgICAgICAvICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuICAvLyAgIG11dGF0ZSAtLS0tPiBCYXNlIE5vdGlmaWNhdGlvbnMgLS0rIHwgICAgICAgICAgICAgICAgIHwgKy0tPiBDbGVhbiBub3RpZmljYXRpb25zICAgICAgICAgICAoUGFydCAxKVxuICAvLyAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgICAgICB8IHwgICAgJiBub3RpZmljYXRpb25zIGJ5IElEXG4gIC8vICAgICAgICAgfCBcXCAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgICAgICBBcHBseSAgICAgIHwgfFxuICAvLyAgICAgICAgIHwgICBgLT4gT3B0aW1pc3RpY1VwZGF0ZXMgLS0rLS0rLS0+IE9wdGltaXN0aWMgLS0rLSstLT4gUm9vbSBOb3RpZmljYXRpb24gU2V0dGluZ3MgICAoUGFydCAyKVxuICAvLyAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgVXBkYXRlcyAgICB8ICB8XG4gIC8vICAgICAgICAgICBgLS0tLS0tLSBldGMgZXRjIC0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgfCAgKy0tPiBIaXN0b3J5IFZlcnNpb25zICAgICAgICAgICAgIChQYXJ0IDMpXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLT4gVXNlciBOb3RpZmljYXRpb24gU2V0dGluZ3MgICAoUGFydCA0KVxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgfFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgfFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgICAgICAgICBeXG4gIC8vICAgICAgICAgICAgICAgICAgICBTaWduYWwgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgIHxcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgb3IgICAgICAgICAgICAgICAgICAgRGVyaXZlZFNpZ25hbCAgICAgIERlcml2ZWRTaWduYWxzXG4gIC8vICAgICAgICAgICAgICAgICAgTXV0YWJsZVNpZ25hbFxuICAvL1xuICAvL1xuICAvLyBJbnB1dCBzaWduYWxzLlxuICAvLyAoQ2FuIGJlIG11dGF0ZWQgZGlyZWN0bHkuKVxuICAvL1xuICAvLyBYWFhfdmluY2VudCBOb3cgdGhhdCB3ZSBoYXZlIGNyZWF0ZVN0b3JlX2ZvclgsIHdlIHNob3VsZCBwcm9iYWJseSBhbHNvIGNoYW5nZVxuICAvLyBgdGhyZWFkc2AgdG8gdGhpcyBwYXR0ZXJuLCBpZSBjcmVhdGUgYSBjcmVhdGVTdG9yZV9mb3JUaHJlYWRzIGhlbHBlciBhc1xuICAvLyB3ZWxsLiBJdCBhbG1vc3Qgd29ya3MgbGlrZSB0aGF0IGFscmVhZHkgYW55d2F5IVxuICB0aHJlYWRzO1xuICAvLyBFeHBvc2VzIGl0cyBzaWduYWwgdW5kZXIgYC5zaWduYWxgIHByb3BcbiAgbm90aWZpY2F0aW9ucztcbiAgcm9vbU5vdGlmaWNhdGlvblNldHRpbmdzO1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgaGlzdG9yeVZlcnNpb25zO1xuICBwZXJtaXNzaW9uSGludHM7XG4gIHVzZXJOb3RpZmljYXRpb25TZXR0aW5ncztcbiAgb3B0aW1pc3RpY1VwZGF0ZXM7XG4gIC8vXG4gIC8vIE91dHB1dCBzaWduYWxzLlxuICAvLyAoUmVhZG9ubHksIGNsZWFuLCBjb25zaXN0ZW50LiBXaXRoIG9wdGltaXN0aWMgdXBkYXRlcyBhcHBsaWVkLilcbiAgLy9cbiAgLy8gTm90ZSB0aGF0IHRoZSBvdXRwdXQgb2YgdGhyZWFkaWZpY2F0aW9ucyBzaWduYWwgaXMgdGhlIHNhbWUgYXMgdGhlIG9uZXMgZm9yXG4gIC8vIHRocmVhZHMgYW5kIG5vdGlmaWNhdGlvbnMgc2VwYXJhdGVseSwgYnV0IHRoZSB0aHJlYWRpZmljYXRpb25zIHNpZ25hbCB3aWxsXG4gIC8vIGJlIHVwZGF0ZWQgd2hlbmV2ZXIgZWl0aGVyIG9mIHRoZW0gY2hhbmdlLlxuICAvL1xuICBvdXRwdXRzO1xuICAvLyBOb3RpZmljYXRpb25zXG4gICNub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0ID0gbnVsbDtcbiAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hlbiB3ZSBzdWNjZXNzZnVsbHkgcmVxdWVzdGVkIGFuIGluYm94IG5vdGlmaWNhdGlvbnMgdXBkYXRlIGZvciB0aGUgbGFzdCB0aW1lLiBXaWxsIGJlIGBudWxsYCBhcyBsb25nIGFzIHRoZSBmaXJzdCBzdWNjZXNzZnVsIGZldGNoIGhhc24ndCBoYXBwZW5lZCB5ZXQuXG4gICNub3RpZmljYXRpb25zUGFnaW5hdGlvblN0YXRlO1xuICAvLyBSb29tIFRocmVhZHNcbiAgI3Jvb21UaHJlYWRzTGFzdFJlcXVlc3RlZEF0QnlSb29tID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLy8gVXNlciBUaHJlYWRzXG4gICN1c2VyVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdCA9IG51bGw7XG4gIC8vIFJvb20gdmVyc2lvbnNcbiAgI3Jvb21WZXJzaW9uc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8vIFVzZXIgTm90aWZpY2F0aW9uIFNldHRpbmdzXG4gICN1c2VyTm90aWZpY2F0aW9uU2V0dGluZ3M7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudFtrSW50ZXJuYWxdLmFzKCk7XG4gICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcyA9IGNyZWF0ZVN0b3JlX2Zvck9wdGltaXN0aWModGhpcy4jY2xpZW50KTtcbiAgICB0aGlzLnBlcm1pc3Npb25IaW50cyA9IGNyZWF0ZVN0b3JlX2ZvclBlcm1pc3Npb25IaW50cygpO1xuICAgIHRoaXMuI25vdGlmaWNhdGlvbnNQYWdpbmF0aW9uU3RhdGUgPSBuZXcgUGFnaW5hdGVkUmVzb3VyY2UoXG4gICAgICBhc3luYyAoY3Vyc29yKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnMoeyBjdXJzb3IgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlVGhyZWFkaWZpY2F0aW9ucyhyZXN1bHQudGhyZWFkcywgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLiNub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy4jbm90aWZpY2F0aW9uc0xhc3RSZXF1ZXN0ZWRBdCA9IHJlc3VsdC5yZXF1ZXN0ZWRBdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0Q3Vyc29yID0gcmVzdWx0Lm5leHRDdXJzb3I7XG4gICAgICAgIHJldHVybiBuZXh0Q3Vyc29yO1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgdXNlck5vdGlmaWNhdGlvblNldHRpbmdzRmV0Y2hlciA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NsaWVudC5nZXROb3RpZmljYXRpb25TZXR0aW5ncygpO1xuICAgICAgdGhpcy51c2VyTm90aWZpY2F0aW9uU2V0dGluZ3MudXBkYXRlKHJlc3VsdCk7XG4gICAgfTtcbiAgICB0aGlzLnVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyA9IGNyZWF0ZVN0b3JlX2ZvclVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhcbiAgICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMuc2lnbmFsXG4gICAgKTtcbiAgICB0aGlzLiN1c2VyTm90aWZpY2F0aW9uU2V0dGluZ3MgPSBuZXcgU2luZ2xlUGFnZVJlc291cmNlKFxuICAgICAgdXNlck5vdGlmaWNhdGlvblNldHRpbmdzRmV0Y2hlclxuICAgICk7XG4gICAgdGhpcy50aHJlYWRzID0gbmV3IFRocmVhZERCKCk7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zID0gY3JlYXRlU3RvcmVfZm9yTm90aWZpY2F0aW9ucygpO1xuICAgIHRoaXMucm9vbU5vdGlmaWNhdGlvblNldHRpbmdzID0gY3JlYXRlU3RvcmVfZm9yUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKFxuICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5zaWduYWxcbiAgICApO1xuICAgIHRoaXMuaGlzdG9yeVZlcnNpb25zID0gY3JlYXRlU3RvcmVfZm9ySGlzdG9yeVZlcnNpb25zKCk7XG4gICAgY29uc3QgdGhyZWFkaWZpY2F0aW9ucyA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICAgIHRoaXMudGhyZWFkcy5zaWduYWwsXG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMuc2lnbmFsLFxuICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5zaWduYWwsXG4gICAgICAodHMsIG5zLCB1cGRhdGVzKSA9PiBhcHBseU9wdGltaXN0aWNVcGRhdGVzX2ZvclRocmVhZGlmaWNhdGlvbnModHMsIG5zLCB1cGRhdGVzKVxuICAgICk7XG4gICAgY29uc3QgdGhyZWFkcyA9IERlcml2ZWRTaWduYWwuZnJvbSh0aHJlYWRpZmljYXRpb25zLCAocykgPT4gcy50aHJlYWRzREIpO1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBEZXJpdmVkU2lnbmFsLmZyb20oXG4gICAgICB0aHJlYWRpZmljYXRpb25zLFxuICAgICAgKHMpID0+ICh7XG4gICAgICAgIHNvcnRlZE5vdGlmaWNhdGlvbnM6IHMuc29ydGVkTm90aWZpY2F0aW9ucyxcbiAgICAgICAgbm90aWZpY2F0aW9uc0J5SWQ6IHMubm90aWZpY2F0aW9uc0J5SWRcbiAgICAgIH0pLFxuICAgICAgc2hhbGxvdzNcbiAgICApO1xuICAgIGNvbnN0IGxvYWRpbmdVc2VyVGhyZWFkcyA9IG5ldyBEZWZhdWx0TWFwKFxuICAgICAgKHF1ZXJ5S2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gSlNPTi5wYXJzZShxdWVyeUtleSk7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFBhZ2luYXRlZFJlc291cmNlKGFzeW5jIChjdXJzb3IpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnRba0ludGVybmFsXS5odHRwQ2xpZW50LmdldFVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCh7XG4gICAgICAgICAgICBjdXJzb3IsXG4gICAgICAgICAgICBxdWVyeVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMudXBkYXRlVGhyZWFkaWZpY2F0aW9ucyhcbiAgICAgICAgICAgIHJlc3VsdC50aHJlYWRzLFxuICAgICAgICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5wZXJtaXNzaW9uSGludHMudXBkYXRlKHJlc3VsdC5wZXJtaXNzaW9uSGludHMpO1xuICAgICAgICAgIGlmICh0aGlzLiN1c2VyVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdXNlclRocmVhZHNMYXN0UmVxdWVzdGVkQXQgPSByZXN1bHQucmVxdWVzdGVkQXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQubmV4dEN1cnNvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb3VyY2UuZ2V0KCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc0xvYWRpbmcgfHwgcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0aHJlYWRzMiA9IHRoaXMub3V0cHV0cy50aHJlYWRzLmdldCgpLmZpbmRNYW55KFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgLy8gRG8gX25vdF8gZmlsdGVyIGJ5IHJvb21JZFxuICAgICAgICAgICAgcXVlcnkgPz8ge30sXG4gICAgICAgICAgICBcImRlc2NcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcGFnZSA9IHJlc3VsdC5kYXRhO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgdGhyZWFkczogdGhyZWFkczIsXG4gICAgICAgICAgICBoYXNGZXRjaGVkQWxsOiBwYWdlLmhhc0ZldGNoZWRBbGwsXG4gICAgICAgICAgICBpc0ZldGNoaW5nTW9yZTogcGFnZS5pc0ZldGNoaW5nTW9yZSxcbiAgICAgICAgICAgIGZldGNoTW9yZUVycm9yOiBwYWdlLmZldGNoTW9yZUVycm9yLFxuICAgICAgICAgICAgZmV0Y2hNb3JlOiBwYWdlLmZldGNoTW9yZVxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHNoYWxsb3cyKTtcbiAgICAgICAgcmV0dXJuIHsgc2lnbmFsLCB3YWl0VW50aWxMb2FkZWQ6IHJlc291cmNlLndhaXRVbnRpbExvYWRlZCB9O1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgbG9hZGluZ1Jvb21UaHJlYWRzID0gbmV3IERlZmF1bHRNYXAoXG4gICAgICAocXVlcnlLZXkpID0+IHtcbiAgICAgICAgY29uc3QgW3Jvb21JZCwgcXVlcnldID0gSlNPTi5wYXJzZShxdWVyeUtleSk7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFBhZ2luYXRlZFJlc291cmNlKGFzeW5jIChjdXJzb3IpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnRba0ludGVybmFsXS5odHRwQ2xpZW50LmdldFRocmVhZHMoe1xuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgY3Vyc29yLFxuICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICAgICAgICByZXN1bHQudGhyZWFkcyxcbiAgICAgICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkhpbnRzLnVwZGF0ZShyZXN1bHQucGVybWlzc2lvbkhpbnRzKTtcbiAgICAgICAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLiNyb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5nZXQocm9vbUlkKTtcbiAgICAgICAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSB2b2lkIDAgfHwgbGFzdFJlcXVlc3RlZEF0ID4gcmVzdWx0LnJlcXVlc3RlZEF0KSB7XG4gICAgICAgICAgICB0aGlzLiNyb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQoXG4gICAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgICAgcmVzdWx0LnJlcXVlc3RlZEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0Lm5leHRDdXJzb3I7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBEZXJpdmVkU2lnbmFsLmZyb20oKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc291cmNlLmdldCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQuaXNMb2FkaW5nIHx8IHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGhyZWFkczIgPSB0aGlzLm91dHB1dHMudGhyZWFkcy5nZXQoKS5maW5kTWFueShyb29tSWQsIHF1ZXJ5ID8/IHt9LCBcImFzY1wiKTtcbiAgICAgICAgICBjb25zdCBwYWdlID0gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICB0aHJlYWRzOiB0aHJlYWRzMixcbiAgICAgICAgICAgIGhhc0ZldGNoZWRBbGw6IHBhZ2UuaGFzRmV0Y2hlZEFsbCxcbiAgICAgICAgICAgIGlzRmV0Y2hpbmdNb3JlOiBwYWdlLmlzRmV0Y2hpbmdNb3JlLFxuICAgICAgICAgICAgZmV0Y2hNb3JlRXJyb3I6IHBhZ2UuZmV0Y2hNb3JlRXJyb3IsXG4gICAgICAgICAgICBmZXRjaE1vcmU6IHBhZ2UuZmV0Y2hNb3JlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgc2hhbGxvdzIpO1xuICAgICAgICByZXR1cm4geyBzaWduYWwsIHdhaXRVbnRpbExvYWRlZDogcmVzb3VyY2Uud2FpdFVudGlsTG9hZGVkIH07XG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBsb2FkaW5nTm90aWZpY2F0aW9ucyA9IHtcbiAgICAgIHNpZ25hbDogRGVyaXZlZFNpZ25hbC5mcm9tKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSB0aGlzLiNub3RpZmljYXRpb25zUGFnaW5hdGlvblN0YXRlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXNvdXJjZS5nZXQoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc0xvYWRpbmcgfHwgcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWdlID0gcmVzdWx0LmRhdGE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHRoaXMub3V0cHV0cy5ub3RpZmljYXRpb25zLmdldCgpLnNvcnRlZE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgaGFzRmV0Y2hlZEFsbDogcGFnZS5oYXNGZXRjaGVkQWxsLFxuICAgICAgICAgIGlzRmV0Y2hpbmdNb3JlOiBwYWdlLmlzRmV0Y2hpbmdNb3JlLFxuICAgICAgICAgIGZldGNoTW9yZUVycm9yOiBwYWdlLmZldGNoTW9yZUVycm9yLFxuICAgICAgICAgIGZldGNoTW9yZTogcGFnZS5mZXRjaE1vcmVcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgd2FpdFVudGlsTG9hZGVkOiB0aGlzLiNub3RpZmljYXRpb25zUGFnaW5hdGlvblN0YXRlLndhaXRVbnRpbExvYWRlZFxuICAgIH07XG4gICAgY29uc3Qgc2V0dGluZ3NCeVJvb21JZCA9IG5ldyBEZWZhdWx0TWFwKChyb29tSWQpID0+IHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFNpbmdsZVBhZ2VSZXNvdXJjZShhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvb20gPSB0aGlzLiNjbGllbnQuZ2V0Um9vbShyb29tSWQpO1xuICAgICAgICBpZiAocm9vbSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUm9vbSAnJHtyb29tSWR9JyBpcyBub3QgYXZhaWxhYmxlIG9uIGNsaWVudGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJvb20uZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5yb29tTm90aWZpY2F0aW9uU2V0dGluZ3MudXBkYXRlKHJvb21JZCwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2lnbmFsID0gRGVyaXZlZFNpZ25hbC5mcm9tKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb3VyY2UuZ2V0KCk7XG4gICAgICAgIGlmIChyZXN1bHQuaXNMb2FkaW5nIHx8IHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIEFTWU5DX09LKFxuICAgICAgICAgICAgXCJzZXR0aW5nc1wiLFxuICAgICAgICAgICAgbm4odGhpcy5yb29tTm90aWZpY2F0aW9uU2V0dGluZ3Muc2lnbmFsLmdldCgpW3Jvb21JZF0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSwgc2hhbGxvdzMpO1xuICAgICAgcmV0dXJuIHsgc2lnbmFsLCB3YWl0VW50aWxMb2FkZWQ6IHJlc291cmNlLndhaXRVbnRpbExvYWRlZCB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHZlcnNpb25zQnlSb29tSWQgPSBuZXcgRGVmYXVsdE1hcChcbiAgICAgIChyb29tSWQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgU2luZ2xlUGFnZVJlc291cmNlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCByb29tID0gdGhpcy4jY2xpZW50LmdldFJvb20ocm9vbUlkKTtcbiAgICAgICAgICBpZiAocm9vbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb29tICcke3Jvb21JZH0nIGlzIG5vdCBhdmFpbGFibGUgb24gY2xpZW50YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJvb21ba0ludGVybmFsXS5saXN0VGV4dFZlcnNpb25zKCk7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5VmVyc2lvbnMudXBkYXRlKHJvb21JZCwgcmVzdWx0LnZlcnNpb25zKTtcbiAgICAgICAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLiNyb29tVmVyc2lvbnNMYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb21JZCk7XG4gICAgICAgICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gdm9pZCAwIHx8IGxhc3RSZXF1ZXN0ZWRBdCA+IHJlc3VsdC5yZXF1ZXN0ZWRBdCkge1xuICAgICAgICAgICAgdGhpcy4jcm9vbVZlcnNpb25zTGFzdFJlcXVlc3RlZEF0QnlSb29tLnNldChcbiAgICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgICByZXN1bHQucmVxdWVzdGVkQXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gRGVyaXZlZFNpZ25hbC5mcm9tKCgpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNvdXJjZS5nZXQoKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmlzTG9hZGluZyB8fCByZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBBU1lOQ19PSyhcbiAgICAgICAgICAgICAgXCJ2ZXJzaW9uc1wiLFxuICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuaGlzdG9yeVZlcnNpb25zLnNpZ25hbC5nZXQoKVtyb29tSWRdID8/IHt9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHNoYWxsb3czKTtcbiAgICAgICAgcmV0dXJuIHsgc2lnbmFsLCB3YWl0VW50aWxMb2FkZWQ6IHJlc291cmNlLndhaXRVbnRpbExvYWRlZCB9O1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgdXNlck5vdGlmaWNhdGlvblNldHRpbmdzID0ge1xuICAgICAgc2lnbmFsOiBEZXJpdmVkU2lnbmFsLmZyb20oKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiN1c2VyTm90aWZpY2F0aW9uU2V0dGluZ3MuZ2V0KCk7XG4gICAgICAgIGlmIChyZXN1bHQuaXNMb2FkaW5nIHx8IHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFTWU5DX09LKFxuICAgICAgICAgIFwic2V0dGluZ3NcIixcbiAgICAgICAgICBubih0aGlzLnVzZXJOb3RpZmljYXRpb25TZXR0aW5ncy5zaWduYWwuZ2V0KCkpXG4gICAgICAgICk7XG4gICAgICB9LCBzaGFsbG93MyksXG4gICAgICB3YWl0VW50aWxMb2FkZWQ6IHRoaXMuI3VzZXJOb3RpZmljYXRpb25TZXR0aW5ncy53YWl0VW50aWxMb2FkZWRcbiAgICB9O1xuICAgIHRoaXMub3V0cHV0cyA9IHtcbiAgICAgIHRocmVhZGlmaWNhdGlvbnMsXG4gICAgICB0aHJlYWRzLFxuICAgICAgbG9hZGluZ1Jvb21UaHJlYWRzLFxuICAgICAgbG9hZGluZ1VzZXJUaHJlYWRzLFxuICAgICAgbm90aWZpY2F0aW9ucyxcbiAgICAgIGxvYWRpbmdOb3RpZmljYXRpb25zLFxuICAgICAgc2V0dGluZ3NCeVJvb21JZCxcbiAgICAgIHZlcnNpb25zQnlSb29tSWQsXG4gICAgICB1c2VyTm90aWZpY2F0aW9uU2V0dGluZ3NcbiAgICB9O1xuICAgIGF1dG9iaW5kKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIGluYm94IG5vdGlmaWNhdGlvbiB3aXRoIGEgbmV3IHZhbHVlLCByZXBsYWNpbmcgdGhlXG4gICAqIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgdXBkYXRlIGFueXRoaW5nIGlmIHRoZSBpbmJveCBub3RpZmljYXRpb24gSUQgaXNuJ3QgZm91bmQuXG4gICAqL1xuICBtYXJrSW5ib3hOb3RpZmljYXRpb25SZWFkKGluYm94Tm90aWZpY2F0aW9uSWQsIHJlYWRBdCwgb3B0aW1pc3RpY0lkKSB7XG4gICAgYmF0Y2gyKCgpID0+IHtcbiAgICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNJZCk7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMubWFya1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZCwgcmVhZEF0KTtcbiAgICB9KTtcbiAgfVxuICBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zUmVhZChvcHRpbWlzdGljSWQsIHJlYWRBdCkge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zLm1hcmtBbGxSZWFkKHJlYWRBdCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gZXhpc3RpbmcgaW5ib3ggbm90aWZpY2F0aW9uLCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICogb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICBkZWxldGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkLCBvcHRpbWlzdGljSWQpIHtcbiAgICBiYXRjaDIoKCkgPT4ge1xuICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY0lkKTtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucy5kZWxldGUoaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgKmFsbCogaW5ib3ggbm90aWZpY2F0aW9ucywgcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWNcbiAgICogdXBkYXRlLlxuICAgKi9cbiAgZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKG9wdGltaXN0aWNJZCkge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zLmNsZWFyKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gbmV3IHRocmVhZCwgcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKi9cbiAgY3JlYXRlVGhyZWFkKG9wdGltaXN0aWNJZCwgdGhyZWFkKSB7XG4gICAgYmF0Y2gyKCgpID0+IHtcbiAgICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNJZCk7XG4gICAgICB0aGlzLnRocmVhZHMudXBzZXJ0KHRocmVhZCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgdGhyZWFkIHdpdGggYSBuZXcgdmFsdWUsIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZ1xuICAgKiBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCB1cGRhdGUgYW55dGhpbmcgaWY6XG4gICAqIC0gVGhlIHRocmVhZCBJRCBpc24ndCBmb3VuZDsgb3JcbiAgICogLSBUaGUgdGhyZWFkIElEIHdhcyBhbHJlYWR5IGRlbGV0ZWQ7IG9yXG4gICAqIC0gVGhlIHRocmVhZCBJRCB3YXMgdXBkYXRlZCBtb3JlIHJlY2VudGx5IHRoYW4gdGhlIG9wdGltaXN0aWMgdXBkYXRlJ3NcbiAgICogICB0aW1lc3RhbXAgKGlmIGdpdmVuKVxuICAgKi9cbiAgI3VwZGF0ZVRocmVhZCh0aHJlYWRJZCwgb3B0aW1pc3RpY0lkLCBjYWxsYmFjaywgdXBkYXRlZEF0KSB7XG4gICAgYmF0Y2gyKCgpID0+IHtcbiAgICAgIGlmIChvcHRpbWlzdGljSWQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY0lkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRiID0gdGhpcy50aHJlYWRzO1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBkYi5nZXQodGhyZWFkSWQpO1xuICAgICAgaWYgKCFleGlzdGluZykgcmV0dXJuO1xuICAgICAgaWYgKCEhdXBkYXRlZEF0ICYmIGV4aXN0aW5nLnVwZGF0ZWRBdCA+IHVwZGF0ZWRBdCkgcmV0dXJuO1xuICAgICAgZGIudXBzZXJ0KGNhbGxiYWNrKGV4aXN0aW5nKSk7XG4gICAgfSk7XG4gIH1cbiAgcGF0Y2hUaHJlYWQodGhyZWFkSWQsIG9wdGltaXN0aWNJZCwgcGF0Y2gsIHVwZGF0ZWRBdCkge1xuICAgIHJldHVybiB0aGlzLiN1cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICh0aHJlYWQpID0+ICh7IC4uLnRocmVhZCwgLi4uY29tcGFjdE9iamVjdChwYXRjaCkgfSksXG4gICAgICB1cGRhdGVkQXRcbiAgICApO1xuICB9XG4gIGFkZFJlYWN0aW9uKHRocmVhZElkLCBvcHRpbWlzdGljSWQsIGNvbW1lbnRJZCwgcmVhY3Rpb24sIGNyZWF0ZWRBdCkge1xuICAgIHRoaXMuI3VwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgKHRocmVhZCkgPT4gYXBwbHlBZGRSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgcmVhY3Rpb24pLFxuICAgICAgY3JlYXRlZEF0XG4gICAgKTtcbiAgfVxuICByZW1vdmVSZWFjdGlvbih0aHJlYWRJZCwgb3B0aW1pc3RpY0lkLCBjb21tZW50SWQsIGVtb2ppLCB1c2VySWQsIHJlbW92ZWRBdCkge1xuICAgIHRoaXMuI3VwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgKHRocmVhZCkgPT4gYXBwbHlSZW1vdmVSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgZW1vamksIHVzZXJJZCwgcmVtb3ZlZEF0KSxcbiAgICAgIHJlbW92ZWRBdFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFNvZnQtZGVsZXRlcyBhbiBleGlzdGluZyB0aHJlYWQgYnkgc2V0dGluZyBpdHMgYGRlbGV0ZWRBdGAgdmFsdWUsXG4gICAqIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZyBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCB1cGRhdGUgYW55dGhpbmcgaWY6XG4gICAqIC0gVGhlIHRocmVhZCBJRCBpc24ndCBmb3VuZDsgb3JcbiAgICogLSBUaGUgdGhyZWFkIElEIHdhcyBhbHJlYWR5IGRlbGV0ZWRcbiAgICovXG4gIGRlbGV0ZVRocmVhZCh0aHJlYWRJZCwgb3B0aW1pc3RpY0lkKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgLy8gQSBkZWxldGlvbiBpcyBhY3R1YWxseSBhbiB1cGRhdGUgb2YgdGhlIGRlbGV0ZWRBdCBwcm9wZXJ0eSBpbnRlcm5hbGx5XG4gICAgICAodGhyZWFkKSA9PiAoeyAuLi50aHJlYWQsIHVwZGF0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGRlbGV0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV4aXN0aW5nIGNvbW1lbnQgYW5kIGVuc3VyZXMgdGhlIGFzc29jaWF0ZWQgbm90aWZpY2F0aW9uIGlzXG4gICAqIHVwZGF0ZWQgY29ycmVjdGx5LCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICBjcmVhdGVDb21tZW50KG5ld0NvbW1lbnQsIG9wdGltaXN0aWNJZCkge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSB0aGlzLnRocmVhZHMuZ2V0KG5ld0NvbW1lbnQudGhyZWFkSWQpO1xuICAgICAgaWYgKCFleGlzdGluZ1RocmVhZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRocmVhZHMudXBzZXJ0KGFwcGx5VXBzZXJ0Q29tbWVudChleGlzdGluZ1RocmVhZCwgbmV3Q29tbWVudCkpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zLnVwZGF0ZUFzc29jaWF0ZWROb3RpZmljYXRpb24obmV3Q29tbWVudCk7XG4gICAgfSk7XG4gIH1cbiAgZWRpdENvbW1lbnQodGhyZWFkSWQsIG9wdGltaXN0aWNJZCwgZWRpdGVkQ29tbWVudCkge1xuICAgIHJldHVybiB0aGlzLiN1cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICh0aHJlYWQpID0+IGFwcGx5VXBzZXJ0Q29tbWVudCh0aHJlYWQsIGVkaXRlZENvbW1lbnQpXG4gICAgKTtcbiAgfVxuICBkZWxldGVDb21tZW50KHRocmVhZElkLCBvcHRpbWlzdGljSWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KSB7XG4gICAgcmV0dXJuIHRoaXMuI3VwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgKHRocmVhZCkgPT4gYXBwbHlEZWxldGVDb21tZW50KHRocmVhZCwgY29tbWVudElkLCBkZWxldGVkQXQpLFxuICAgICAgZGVsZXRlZEF0XG4gICAgKTtcbiAgfVxuICB1cGRhdGVUaHJlYWRpZmljYXRpb25zKHRocmVhZHMsIG5vdGlmaWNhdGlvbnMsIGRlbGV0ZWRUaHJlYWRzID0gW10sIGRlbGV0ZWROb3RpZmljYXRpb25zID0gW10pIHtcbiAgICBiYXRjaDIoKCkgPT4ge1xuICAgICAgdGhpcy50aHJlYWRzLmFwcGx5RGVsdGEodGhyZWFkcywgZGVsZXRlZFRocmVhZHMpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zLmFwcGx5RGVsdGEobm90aWZpY2F0aW9ucywgZGVsZXRlZE5vdGlmaWNhdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGV4aXN0aW5nIG5vdGlmaWNhdGlvbiBzZXR0aW5nIGZvciBhIHJvb20gd2l0aCBhIG5ldyB2YWx1ZSxcbiAgICogcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgb3B0aW1pc3RpY0lkLCBzZXR0aW5ncykge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgdGhpcy5yb29tTm90aWZpY2F0aW9uU2V0dGluZ3MudXBkYXRlKHJvb21JZCwgc2V0dGluZ3MpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZldGNoTm90aWZpY2F0aW9uc0RlbHRhVXBkYXRlKHNpZ25hbCkge1xuICAgIGNvbnN0IGxhc3RSZXF1ZXN0ZWRBdCA9IHRoaXMuI25vdGlmaWNhdGlvbnNMYXN0UmVxdWVzdGVkQXQ7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnQuZ2V0SW5ib3hOb3RpZmljYXRpb25zU2luY2Uoe1xuICAgICAgc2luY2U6IGxhc3RSZXF1ZXN0ZWRBdCxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPCByZXN1bHQucmVxdWVzdGVkQXQpIHtcbiAgICAgIHRoaXMuI25vdGlmaWNhdGlvbnNMYXN0UmVxdWVzdGVkQXQgPSByZXN1bHQucmVxdWVzdGVkQXQ7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGhyZWFkaWZpY2F0aW9ucyhcbiAgICAgIHJlc3VsdC50aHJlYWRzLnVwZGF0ZWQsXG4gICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLnVwZGF0ZWQsXG4gICAgICByZXN1bHQudGhyZWFkcy5kZWxldGVkLFxuICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy5kZWxldGVkXG4gICAgKTtcbiAgfVxuICBhc3luYyBmZXRjaFJvb21UaHJlYWRzRGVsdGFVcGRhdGUocm9vbUlkLCBzaWduYWwpIHtcbiAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLiNyb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5nZXQocm9vbUlkKTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlcyA9IGF3YWl0IHRoaXMuI2NsaWVudFtrSW50ZXJuYWxdLmh0dHBDbGllbnQuZ2V0VGhyZWFkc1NpbmNlKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHNpbmNlOiBsYXN0UmVxdWVzdGVkQXQsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICB1cGRhdGVzLnRocmVhZHMudXBkYXRlZCxcbiAgICAgIHVwZGF0ZXMuaW5ib3hOb3RpZmljYXRpb25zLnVwZGF0ZWQsXG4gICAgICB1cGRhdGVzLnRocmVhZHMuZGVsZXRlZCxcbiAgICAgIHVwZGF0ZXMuaW5ib3hOb3RpZmljYXRpb25zLmRlbGV0ZWRcbiAgICApO1xuICAgIHRoaXMucGVybWlzc2lvbkhpbnRzLnVwZGF0ZSh1cGRhdGVzLnBlcm1pc3Npb25IaW50cyk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA8IHVwZGF0ZXMucmVxdWVzdGVkQXQpIHtcbiAgICAgIHRoaXMuI3Jvb21UaHJlYWRzTGFzdFJlcXVlc3RlZEF0QnlSb29tLnNldChyb29tSWQsIHVwZGF0ZXMucmVxdWVzdGVkQXQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmZXRjaFVzZXJUaHJlYWRzRGVsdGFVcGRhdGUoc2lnbmFsKSB7XG4gICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gdGhpcy4jdXNlclRocmVhZHNMYXN0UmVxdWVzdGVkQXQ7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnRba0ludGVybmFsXS5odHRwQ2xpZW50LmdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsKHtcbiAgICAgIHNpbmNlOiBsYXN0UmVxdWVzdGVkQXQsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0IDwgcmVzdWx0LnJlcXVlc3RlZEF0KSB7XG4gICAgICB0aGlzLiNub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0ID0gcmVzdWx0LnJlcXVlc3RlZEF0O1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICByZXN1bHQudGhyZWFkcy51cGRhdGVkLFxuICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy51cGRhdGVkLFxuICAgICAgcmVzdWx0LnRocmVhZHMuZGVsZXRlZCxcbiAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMuZGVsZXRlZFxuICAgICk7XG4gICAgdGhpcy5wZXJtaXNzaW9uSGludHMudXBkYXRlKHJlc3VsdC5wZXJtaXNzaW9uSGludHMpO1xuICB9XG4gIGFzeW5jIGZldGNoUm9vbVZlcnNpb25zRGVsdGFVcGRhdGUocm9vbUlkLCBzaWduYWwpIHtcbiAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLiNyb29tVmVyc2lvbnNMYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb21JZCk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvb20gPSBubihcbiAgICAgIHRoaXMuI2NsaWVudC5nZXRSb29tKHJvb21JZCksXG4gICAgICBgUm9vbSB3aXRoIGlkICR7cm9vbUlkfSBpcyBub3QgYXZhaWxhYmxlIG9uIGNsaWVudGBcbiAgICApO1xuICAgIGNvbnN0IHVwZGF0ZXMgPSBhd2FpdCByb29tW2tJbnRlcm5hbF0ubGlzdFRleHRWZXJzaW9uc1NpbmNlKHtcbiAgICAgIHNpbmNlOiBsYXN0UmVxdWVzdGVkQXQsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmhpc3RvcnlWZXJzaW9ucy51cGRhdGUocm9vbUlkLCB1cGRhdGVzLnZlcnNpb25zKTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0IDwgdXBkYXRlcy5yZXF1ZXN0ZWRBdCkge1xuICAgICAgdGhpcy4jcm9vbVZlcnNpb25zTGFzdFJlcXVlc3RlZEF0QnlSb29tLnNldChyb29tSWQsIHVwZGF0ZXMucmVxdWVzdGVkQXQpO1xuICAgIH1cbiAgfVxuICBhc3luYyByZWZyZXNoUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgc2lnbmFsKSB7XG4gICAgY29uc3Qgcm9vbSA9IG5uKFxuICAgICAgdGhpcy4jY2xpZW50LmdldFJvb20ocm9vbUlkKSxcbiAgICAgIGBSb29tIHdpdGggaWQgJHtyb29tSWR9IGlzIG5vdCBhdmFpbGFibGUgb24gY2xpZW50YFxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcm9vbS5nZXROb3RpZmljYXRpb25TZXR0aW5ncyh7IHNpZ25hbCB9KTtcbiAgICB0aGlzLnJvb21Ob3RpZmljYXRpb25TZXR0aW5ncy51cGRhdGUocm9vbUlkLCByZXN1bHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZWZyZXNoIFVzZXIgTm90aWZpY2F0aW9uIFNldHRpbmdzIGZyb20gcG9sbGVyXG4gICAqL1xuICBhc3luYyByZWZyZXNoVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKHNpZ25hbCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NsaWVudC5nZXROb3RpZmljYXRpb25TZXR0aW5ncyh7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLnVzZXJOb3RpZmljYXRpb25TZXR0aW5ncy51cGRhdGUocmVzdWx0KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB1c2VyIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyB3aXRoIGEgbmV3IHZhbHVlLCByZXBsYWNpbmcgdGhlXG4gICAqIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGVVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3NfY29uZmlybU9wdGltaXN0aWNVcGRhdGUoc2V0dGluZ3MsIG9wdGltaXN0aWNVcGRhdGVJZCkge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgdGhpcy51c2VyTm90aWZpY2F0aW9uU2V0dGluZ3MudXBkYXRlKHNldHRpbmdzKTtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXNfZm9yVGhyZWFkaWZpY2F0aW9ucyhiYXNlVGhyZWFkc0RCLCBub3RpZmljYXRpb25zTFVULCBvcHRpbWlzdGljVXBkYXRlcykge1xuICBjb25zdCB0aHJlYWRzREIgPSBiYXNlVGhyZWFkc0RCLmNsb25lKCk7XG4gIGxldCBub3RpZmljYXRpb25zQnlJZCA9IE9iamVjdC5mcm9tRW50cmllcyhub3RpZmljYXRpb25zTFVUKTtcbiAgZm9yIChjb25zdCBvcHRpbWlzdGljVXBkYXRlIG9mIG9wdGltaXN0aWNVcGRhdGVzKSB7XG4gICAgc3dpdGNoIChvcHRpbWlzdGljVXBkYXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJjcmVhdGUtdGhyZWFkXCI6IHtcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChvcHRpbWlzdGljVXBkYXRlLnRocmVhZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImVkaXQtdGhyZWFkLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgaWYgKHRocmVhZC51cGRhdGVkQXQgPiBvcHRpbWlzdGljVXBkYXRlLnVwZGF0ZWRBdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoe1xuICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG9wdGltaXN0aWNVcGRhdGUudXBkYXRlZEF0LFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAuLi50aHJlYWQubWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5vcHRpbWlzdGljVXBkYXRlLm1ldGFkYXRhXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay10aHJlYWQtYXMtcmVzb2x2ZWRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkSWQpO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KHsgLi4udGhyZWFkLCByZXNvbHZlZDogdHJ1ZSB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay10aHJlYWQtYXMtdW5yZXNvbHZlZFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZHNEQi5nZXQob3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoeyAuLi50aHJlYWQsIHJlc29sdmVkOiBmYWxzZSB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiY3JlYXRlLWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUuY29tbWVudC50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoYXBwbHlVcHNlcnRDb21tZW50KHRocmVhZCwgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50KSk7XG4gICAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uID0gT2JqZWN0LnZhbHVlcyhub3RpZmljYXRpb25zQnlJZCkuZmluZChcbiAgICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBub3RpZmljYXRpb24ua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBub3RpZmljYXRpb24udGhyZWFkSWQgPT09IHRocmVhZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoaW5ib3hOb3RpZmljYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmaWNhdGlvbnNCeUlkW2luYm94Tm90aWZpY2F0aW9uLmlkXSA9IHtcbiAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgICBub3RpZmllZEF0OiBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQuY3JlYXRlZEF0LFxuICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LmNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlZGl0LWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUuY29tbWVudC50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoYXBwbHlVcHNlcnRDb21tZW50KHRocmVhZCwgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1jb21tZW50XCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChcbiAgICAgICAgICBhcHBseURlbGV0ZUNvbW1lbnQoXG4gICAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuZGVsZXRlZEF0XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZWxldGUtdGhyZWFkXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydCh7XG4gICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgIGRlbGV0ZWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5kZWxldGVkQXQsXG4gICAgICAgICAgdXBkYXRlZEF0OiBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdCxcbiAgICAgICAgICBjb21tZW50czogW11cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFkZC1yZWFjdGlvblwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZHNEQi5nZXQob3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoXG4gICAgICAgICAgYXBwbHlBZGRSZWFjdGlvbihcbiAgICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5yZWFjdGlvblxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwicmVtb3ZlLXJlYWN0aW9uXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChcbiAgICAgICAgICBhcHBseVJlbW92ZVJlYWN0aW9uKFxuICAgICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50SWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmVtb2ppLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS51c2VySWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLnJlbW92ZWRBdFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay1pbmJveC1ub3RpZmljYXRpb24tYXMtcmVhZFwiOiB7XG4gICAgICAgIGNvbnN0IGlibiA9IG5vdGlmaWNhdGlvbnNCeUlkW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF07XG4gICAgICAgIGlmIChpYm4gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmaWNhdGlvbnNCeUlkW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF0gPSB7XG4gICAgICAgICAgLi4uaWJuLFxuICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5yZWFkQXRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay1hbGwtaW5ib3gtbm90aWZpY2F0aW9ucy1hcy1yZWFkXCI6IHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBpbiBub3RpZmljYXRpb25zQnlJZCkge1xuICAgICAgICAgIGNvbnN0IGlibiA9IG5vdGlmaWNhdGlvbnNCeUlkW2lkXTtcbiAgICAgICAgICBpZiAoaWJuID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub3RpZmljYXRpb25zQnlJZFtpZF0gPSB7XG4gICAgICAgICAgICAuLi5pYm4sXG4gICAgICAgICAgICByZWFkQXQ6IG9wdGltaXN0aWNVcGRhdGUucmVhZEF0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZWxldGUtaW5ib3gtbm90aWZpY2F0aW9uXCI6IHtcbiAgICAgICAgZGVsZXRlIG5vdGlmaWNhdGlvbnNCeUlkW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1hbGwtaW5ib3gtbm90aWZpY2F0aW9uc1wiOiB7XG4gICAgICAgIG5vdGlmaWNhdGlvbnNCeUlkID0ge307XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzb3J0ZWROb3RpZmljYXRpb25zID0gKFxuICAgIC8vIFNvcnQgc28gdGhhdCB0aGUgbW9zdCByZWNlbnQgbm90aWZpY2F0aW9ucyBhcmUgZmlyc3RcbiAgICBPYmplY3QudmFsdWVzKG5vdGlmaWNhdGlvbnNCeUlkKS5maWx0ZXIoXG4gICAgICAoaWJuKSA9PiBpYm4ua2luZCA9PT0gXCJ0aHJlYWRcIiA/IHRocmVhZHNEQi5nZXQoaWJuLnRocmVhZElkKSAhPT0gdm9pZCAwIDogdHJ1ZVxuICAgICkuc29ydCgoYSwgYikgPT4gYi5ub3RpZmllZEF0LmdldFRpbWUoKSAtIGEubm90aWZpZWRBdC5nZXRUaW1lKCkpXG4gICk7XG4gIHJldHVybiB7XG4gICAgc29ydGVkTm90aWZpY2F0aW9ucyxcbiAgICBub3RpZmljYXRpb25zQnlJZCxcbiAgICB0aHJlYWRzREJcbiAgfTtcbn1cbmZ1bmN0aW9uIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXNfZm9yU2V0dGluZ3Moc2V0dGluZ3NMVVQsIG9wdGltaXN0aWNVcGRhdGVzKSB7XG4gIGNvbnN0IHNldHRpbmdzQnlSb29tSWQgPSBPYmplY3QuZnJvbUVudHJpZXMoc2V0dGluZ3NMVVQpO1xuICBmb3IgKGNvbnN0IG9wdGltaXN0aWNVcGRhdGUgb2Ygb3B0aW1pc3RpY1VwZGF0ZXMpIHtcbiAgICBzd2l0Y2ggKG9wdGltaXN0aWNVcGRhdGUudHlwZSkge1xuICAgICAgY2FzZSBcInVwZGF0ZS1ub3RpZmljYXRpb24tc2V0dGluZ3NcIjoge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHNldHRpbmdzQnlSb29tSWRbb3B0aW1pc3RpY1VwZGF0ZS5yb29tSWRdO1xuICAgICAgICBpZiAoc2V0dGluZ3MgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNldHRpbmdzQnlSb29tSWRbb3B0aW1pc3RpY1VwZGF0ZS5yb29tSWRdID0ge1xuICAgICAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgICAgIC4uLm9wdGltaXN0aWNVcGRhdGUuc2V0dGluZ3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdzQnlSb29tSWQ7XG59XG5mdW5jdGlvbiBhcHBseU9wdGltaXN0aWNVcGRhdGVzX2ZvclVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhiYXNlU2V0dGluZ3MsIG9wdGltaXN0aWNVcGRhdGVzKSB7XG4gIGNvbnN0IG91dGNvbWluZ1NldHRpbmdzID0geyAuLi5iYXNlU2V0dGluZ3MgfTtcbiAgZm9yIChjb25zdCBvcHRpbWlzdGljVXBkYXRlIG9mIG9wdGltaXN0aWNVcGRhdGVzKSB7XG4gICAgc3dpdGNoIChvcHRpbWlzdGljVXBkYXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJ1cGRhdGUtdXNlci1ub3RpZmljYXRpb24tc2V0dGluZ3NcIjoge1xuICAgICAgICBjb25zdCBpbmNvbWluZ1NldHRpbmdzID0gb3B0aW1pc3RpY1VwZGF0ZS5zZXR0aW5ncztcbiAgICAgICAgZm9yIChjb25zdCBjaGFubmVsS2V5IG9mIGtleXMoaW5jb21pbmdTZXR0aW5ncykpIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBjaGFubmVsS2V5O1xuICAgICAgICAgIGNvbnN0IGNoYW5uZWxVcGRhdGVzID0gaW5jb21pbmdTZXR0aW5nc1trZXldO1xuICAgICAgICAgIGlmIChjaGFubmVsVXBkYXRlcykge1xuICAgICAgICAgICAgY29uc3QgcmVhbENoYW5uZWxVcGRhdGVzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICBlbnRyaWVzKGNoYW5uZWxVcGRhdGVzKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG91dGNvbWluZ1NldHRpbmdzW2tleV0gPSB7XG4gICAgICAgICAgICAgIC4uLm91dGNvbWluZ1NldHRpbmdzW2tleV0sXG4gICAgICAgICAgICAgIC4uLnJlYWxDaGFubmVsVXBkYXRlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRjb21pbmdTZXR0aW5ncztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJbmJveE5vdGlmaWNhdGlvbnMoaW5ib3hOb3RpZmljYXRpb25BLCBpbmJveE5vdGlmaWNhdGlvbkIpIHtcbiAgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5ub3RpZmllZEF0ID4gaW5ib3hOb3RpZmljYXRpb25CLm5vdGlmaWVkQXQpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChpbmJveE5vdGlmaWNhdGlvbkEubm90aWZpZWRBdCA8IGluYm94Tm90aWZpY2F0aW9uQi5ub3RpZmllZEF0KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0ICYmIGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQpIHtcbiAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA+IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQgPyAxIDogaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA8IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQgPyAtMSA6IDA7XG4gIH0gZWxzZSBpZiAoaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCB8fCBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0KSB7XG4gICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBhcHBseVVwc2VydENvbW1lbnQodGhyZWFkLCBjb21tZW50KSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChjb21tZW50LnRocmVhZElkICE9PSB0aHJlYWQuaWQpIHtcbiAgICBjb25zb2xlMi53YXJuKFxuICAgICAgYENvbW1lbnQgJHtjb21tZW50LmlkfSBkb2VzIG5vdCBiZWxvbmcgdG8gdGhyZWFkICR7dGhyZWFkLmlkfWBcbiAgICApO1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGV4aXN0aW5nQ29tbWVudDIpID0+IGV4aXN0aW5nQ29tbWVudDIuaWQgPT09IGNvbW1lbnQuaWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoXG4gICAgICBNYXRoLm1heCh0aHJlYWQudXBkYXRlZEF0LmdldFRpbWUoKSwgY29tbWVudC5jcmVhdGVkQXQuZ2V0VGltZSgpKVxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlZFRocmVhZCA9IHtcbiAgICAgIC4uLnRocmVhZCxcbiAgICAgIHVwZGF0ZWRBdCxcbiAgICAgIGNvbW1lbnRzOiBbLi4udGhyZWFkLmNvbW1lbnRzLCBjb21tZW50XVxuICAgIH07XG4gICAgcmV0dXJuIHVwZGF0ZWRUaHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5lZGl0ZWRBdCA9PT0gdm9pZCAwIHx8IGNvbW1lbnQuZWRpdGVkQXQgPT09IHZvaWQgMCB8fCBleGlzdGluZ0NvbW1lbnQuZWRpdGVkQXQgPD0gY29tbWVudC5lZGl0ZWRBdCkge1xuICAgIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgICAoZXhpc3RpbmdDb21tZW50MikgPT4gZXhpc3RpbmdDb21tZW50Mi5pZCA9PT0gY29tbWVudC5pZCA/IGNvbW1lbnQgOiBleGlzdGluZ0NvbW1lbnQyXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGVkVGhyZWFkID0ge1xuICAgICAgLi4udGhyZWFkLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgdGhyZWFkLnVwZGF0ZWRBdC5nZXRUaW1lKCksXG4gICAgICAgICAgY29tbWVudC5lZGl0ZWRBdD8uZ2V0VGltZSgpIHx8IGNvbW1lbnQuY3JlYXRlZEF0LmdldFRpbWUoKVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICAgIH07XG4gICAgcmV0dXJuIHVwZGF0ZWRUaHJlYWQ7XG4gIH1cbiAgcmV0dXJuIHRocmVhZDtcbn1cbmZ1bmN0aW9uIGFwcGx5RGVsZXRlQ29tbWVudCh0aHJlYWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWQgPyB7XG4gICAgICAuLi5jb21tZW50LFxuICAgICAgZGVsZXRlZEF0LFxuICAgICAgLy8gV2Ugb3B0aW1pc3RpY2FsbHkgcmVtb3ZlIHRoZSBjb21tZW50IGJvZHkgYW5kIGF0dGFjaG1lbnRzIHdoZW4gbWFya2luZyBpdCBhcyBkZWxldGVkXG4gICAgICBib2R5OiB2b2lkIDAsXG4gICAgICBhdHRhY2htZW50czogW11cbiAgICB9IDogY29tbWVudFxuICApO1xuICBpZiAodXBkYXRlZENvbW1lbnRzLmV2ZXJ5KChjb21tZW50KSA9PiBjb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICBkZWxldGVkQXQsXG4gICAgICB1cGRhdGVkQXQ6IGRlbGV0ZWRBdFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBkZWxldGVkQXQsXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gYXBwbHlBZGRSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgcmVhY3Rpb24pIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICByZWFjdGlvbnM6IHVwc2VydFJlYWN0aW9uKGNvbW1lbnQucmVhY3Rpb25zLCByZWFjdGlvbilcbiAgICB9IDogY29tbWVudFxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgocmVhY3Rpb24uY3JlYXRlZEF0LmdldFRpbWUoKSwgdGhyZWFkLnVwZGF0ZWRBdC5nZXRUaW1lKCkpXG4gICAgKSxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBhcHBseVJlbW92ZVJlYWN0aW9uKHRocmVhZCwgY29tbWVudElkLCBlbW9qaSwgdXNlcklkLCByZW1vdmVkQXQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICByZWFjdGlvbnM6IGNvbW1lbnQucmVhY3Rpb25zLm1hcChcbiAgICAgICAgKHJlYWN0aW9uKSA9PiByZWFjdGlvbi5lbW9qaSA9PT0gZW1vamkgPyB7XG4gICAgICAgICAgLi4ucmVhY3Rpb24sXG4gICAgICAgICAgdXNlcnM6IHJlYWN0aW9uLnVzZXJzLmZpbHRlcigodXNlcikgPT4gdXNlci5pZCAhPT0gdXNlcklkKVxuICAgICAgICB9IDogcmVhY3Rpb25cbiAgICAgICkuZmlsdGVyKChyZWFjdGlvbikgPT4gcmVhY3Rpb24udXNlcnMubGVuZ3RoID4gMClcbiAgICAgIC8vIFJlbW92ZSByZWFjdGlvbnMgd2l0aCBubyB1c2VycyBsZWZ0XG4gICAgfSA6IGNvbW1lbnRcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHJlbW92ZWRBdC5nZXRUaW1lKCksIHRocmVhZC51cGRhdGVkQXQuZ2V0VGltZSgpKVxuICAgICksXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gdXBzZXJ0UmVhY3Rpb24ocmVhY3Rpb25zLCByZWFjdGlvbikge1xuICBjb25zdCBleGlzdGluZ1JlYWN0aW9uID0gcmVhY3Rpb25zLmZpbmQoXG4gICAgKGV4aXN0aW5nUmVhY3Rpb24yKSA9PiBleGlzdGluZ1JlYWN0aW9uMi5lbW9qaSA9PT0gcmVhY3Rpb24uZW1vamlcbiAgKTtcbiAgaWYgKGV4aXN0aW5nUmVhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5yZWFjdGlvbnMsXG4gICAgICB7XG4gICAgICAgIGVtb2ppOiByZWFjdGlvbi5lbW9qaSxcbiAgICAgICAgY3JlYXRlZEF0OiByZWFjdGlvbi5jcmVhdGVkQXQsXG4gICAgICAgIHVzZXJzOiBbeyBpZDogcmVhY3Rpb24udXNlcklkIH1dXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBpZiAoZXhpc3RpbmdSZWFjdGlvbi51c2Vycy5zb21lKCh1c2VyKSA9PiB1c2VyLmlkID09PSByZWFjdGlvbi51c2VySWQpID09PSBmYWxzZSkge1xuICAgIHJldHVybiByZWFjdGlvbnMubWFwKFxuICAgICAgKGV4aXN0aW5nUmVhY3Rpb24yKSA9PiBleGlzdGluZ1JlYWN0aW9uMi5lbW9qaSA9PT0gcmVhY3Rpb24uZW1vamkgPyB7XG4gICAgICAgIC4uLmV4aXN0aW5nUmVhY3Rpb24yLFxuICAgICAgICB1c2VyczogWy4uLmV4aXN0aW5nUmVhY3Rpb24yLnVzZXJzLCB7IGlkOiByZWFjdGlvbi51c2VySWQgfV1cbiAgICAgIH0gOiBleGlzdGluZ1JlYWN0aW9uMlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlYWN0aW9ucztcbn1cblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBDbGllbnRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDIobnVsbCk7XG5mdW5jdGlvbiBtaXNzaW5nVXNlckVycm9yKHVzZXJJZCkge1xuICByZXR1cm4gbmV3IEVycm9yKGByZXNvbHZlVXNlcnMgZGlkbid0IHJldHVybiBhbnl0aGluZyBmb3IgdXNlciAnJHt1c2VySWR9J2ApO1xufVxuZnVuY3Rpb24gbWlzc2luZ1Jvb21JbmZvRXJyb3Iocm9vbUlkKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgYHJlc29sdmVSb29tc0luZm8gZGlkbid0IHJldHVybiBhbnl0aGluZyBmb3Igcm9vbSAnJHtyb29tSWR9J2BcbiAgKTtcbn1cbmZ1bmN0aW9uIGlkZW50aXR5Mih4KSB7XG4gIHJldHVybiB4O1xufVxudmFyIF91bWJyZWxsYVN0b3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIF9leHRyYXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBfYnVuZGxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2VsZWN0b3JGb3JfdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQocmVzdWx0KSB7XG4gIGlmICghcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucykge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIEFTWU5DX09LKFxuICAgIFwiY291bnRcIixcbiAgICBjb3VudChcbiAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAobikgPT4gbi5yZWFkQXQgPT09IG51bGwgfHwgbi5yZWFkQXQgPCBuLm5vdGlmaWVkQXRcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VVc2VyKHN0YXRlLCB1c2VySWQpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDAgfHwgc3RhdGU/LmlzTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZSA/PyB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICB9XG4gIGlmIChzdGF0ZS5lcnJvcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAoIXN0YXRlLmRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGVycm9yOiBtaXNzaW5nVXNlckVycm9yKHVzZXJJZClcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICB1c2VyOiBzdGF0ZS5kYXRhXG4gIH07XG59XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VSb29tSW5mbyhzdGF0ZSwgcm9vbUlkKSB7XG4gIGlmIChzdGF0ZSA9PT0gdm9pZCAwIHx8IHN0YXRlPy5pc0xvYWRpbmcpIHtcbiAgICByZXR1cm4gc3RhdGUgPz8geyBpc0xvYWRpbmc6IHRydWUgfTtcbiAgfVxuICBpZiAoc3RhdGUuZXJyb3IpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgaWYgKCFzdGF0ZS5kYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBlcnJvcjogbWlzc2luZ1Jvb21JbmZvRXJyb3Iocm9vbUlkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIGluZm86IHN0YXRlLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlQ29udGV4dEJ1bmRsZShjbGllbnQpIHtcbiAgbGV0IGJ1bmRsZSA9IF9idW5kbGVzLmdldChjbGllbnQpO1xuICBpZiAoIWJ1bmRsZSkge1xuICAgIGJ1bmRsZSA9IG1ha2VMaXZlYmxvY2tzQ29udGV4dEJ1bmRsZShjbGllbnQpO1xuICAgIF9idW5kbGVzLnNldChjbGllbnQsIGJ1bmRsZSk7XG4gIH1cbiAgcmV0dXJuIGJ1bmRsZTtcbn1cbmZ1bmN0aW9uIGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQoY2xpZW50KSB7XG4gIGxldCBzdG9yZSA9IF91bWJyZWxsYVN0b3Jlcy5nZXQoY2xpZW50KTtcbiAgaWYgKCFzdG9yZSkge1xuICAgIHN0b3JlID0gbmV3IFVtYnJlbGxhU3RvcmUoY2xpZW50KTtcbiAgICBfdW1icmVsbGFTdG9yZXMuc2V0KGNsaWVudCwgc3RvcmUpO1xuICB9XG4gIHJldHVybiBzdG9yZTtcbn1cbmZ1bmN0aW9uIGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KSB7XG4gIGxldCBleHRyYXMgPSBfZXh0cmFzLmdldChjbGllbnQpO1xuICBpZiAoIWV4dHJhcykge1xuICAgIGV4dHJhcyA9IG1ha2VMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgX2V4dHJhcy5zZXQoY2xpZW50LCBleHRyYXMpO1xuICB9XG4gIHJldHVybiBleHRyYXM7XG59XG5mdW5jdGlvbiBtYWtlTGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRVbWJyZWxsYVN0b3JlRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IG5vdGlmaWNhdGlvbnNQb2xsZXIgPSBtYWtlUG9sbGVyKFxuICAgIGFzeW5jIChzaWduYWwpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdG9yZS5mZXRjaE5vdGlmaWNhdGlvbnNEZWx0YVVwZGF0ZShzaWduYWwpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUG9sbGluZyBuZXcgaW5ib3ggbm90aWZpY2F0aW9ucyBmYWlsZWQ6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbmZpZy5OT1RJRklDQVRJT05TX1BPTExfSU5URVJWQUwsXG4gICAgeyBtYXhTdGFsZVRpbWVNczogY29uZmlnLk5PVElGSUNBVElPTlNfTUFYX1NUQUxFX1RJTUUgfVxuICApO1xuICBjb25zdCB1c2VyVGhyZWFkc1BvbGxlciA9IG1ha2VQb2xsZXIoXG4gICAgYXN5bmMgKHNpZ25hbCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLmZldGNoVXNlclRocmVhZHNEZWx0YVVwZGF0ZShzaWduYWwpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUG9sbGluZyBuZXcgdXNlciB0aHJlYWRzIGZhaWxlZDogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29uZmlnLlVTRVJfVEhSRUFEU19QT0xMX0lOVEVSVkFMLFxuICAgIHsgbWF4U3RhbGVUaW1lTXM6IGNvbmZpZy5VU0VSX1RIUkVBRFNfTUFYX1NUQUxFX1RJTUUgfVxuICApO1xuICBjb25zdCB1c2VyTm90aWZpY2F0aW9uU2V0dGluZ3NQb2xsZXIgPSBtYWtlUG9sbGVyKFxuICAgIGFzeW5jIChzaWduYWwpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdG9yZS5yZWZyZXNoVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKHNpZ25hbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBQb2xsaW5nIG5ldyB1c2VyIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmYWlsZWQ6ICR7U3RyaW5nKGVycil9YFxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb25maWcuVVNFUl9OT1RJRklDQVRJT05fU0VUVElOR1NfSU5URVJWQUwsXG4gICAgeyBtYXhTdGFsZVRpbWVNczogY29uZmlnLlVTRVJfTk9USUZJQ0FUSU9OX1NFVFRJTkdTX01BWF9TVEFMRV9USU1FIH1cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBzdG9yZSxcbiAgICBub3RpZmljYXRpb25zUG9sbGVyLFxuICAgIHVzZXJUaHJlYWRzUG9sbGVyLFxuICAgIHVzZXJOb3RpZmljYXRpb25TZXR0aW5nc1BvbGxlclxuICB9O1xufVxuZnVuY3Rpb24gbWFrZUxpdmVibG9ja3NDb250ZXh0QnVuZGxlKGNsaWVudCkge1xuICBjb25zdCB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZDIgPSAoaW5ib3hOb3RpZmljYXRpb25JZCkgPT4gdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWRfd2l0aENsaWVudChjbGllbnQsIGluYm94Tm90aWZpY2F0aW9uSWQpO1xuICBjb25zdCB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQyID0gKCkgPT4gdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkX3dpdGhDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDIgPSAoKSA9PiB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkX3dpdGhDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb24yID0gKCkgPT4gdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb25fd2l0aENsaWVudChjbGllbnQpO1xuICBjb25zdCB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMyID0gKCkgPT4gdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MyID0gKCkgPT4gdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3Nfd2l0aENsaWVudChjbGllbnQpO1xuICBmdW5jdGlvbiBMaXZlYmxvY2tzUHJvdmlkZXIyKHByb3BzKSB7XG4gICAgdXNlRW5zdXJlTm9MaXZlYmxvY2tzUHJvdmlkZXIoKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChDbGllbnRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjbGllbnQsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KTtcbiAgfVxuICBjb25zdCBzaGFyZWQgPSBjcmVhdGVTaGFyZWRDb250ZXh0KGNsaWVudCk7XG4gIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICBMaXZlYmxvY2tzUHJvdmlkZXI6IExpdmVibG9ja3NQcm92aWRlcjIsXG4gICAgdXNlSW5ib3hOb3RpZmljYXRpb25zOiAoKSA9PiB1c2VJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQsIGlkZW50aXR5Miwgc2hhbGxvdzQpLFxuICAgIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiAoKSA9PiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudF93aXRoQ2xpZW50KGNsaWVudCksXG4gICAgdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkOiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQyLFxuICAgIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQ6IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQyLFxuICAgIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uOiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbjIsXG4gICAgdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zOiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMyLFxuICAgIHVzZU5vdGlmaWNhdGlvblNldHRpbmdzOiAoKSA9PiB1c2VOb3RpZmljYXRpb25TZXR0aW5nc193aXRoQ2xpZW50KGNsaWVudCksXG4gICAgdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3M6IHVzZVVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzMixcbiAgICB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZDogdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQyLFxuICAgIHVzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCxcbiAgICAuLi5zaGFyZWQuY2xhc3NpYyxcbiAgICBzdXNwZW5zZToge1xuICAgICAgTGl2ZWJsb2Nrc1Byb3ZpZGVyOiBMaXZlYmxvY2tzUHJvdmlkZXIyLFxuICAgICAgdXNlSW5ib3hOb3RpZmljYXRpb25zOiAoKSA9PiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCksXG4gICAgICB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudDogKCkgPT4gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCksXG4gICAgICB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQ6IHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDIsXG4gICAgICB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkOiB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkMixcbiAgICAgIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uOiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbjIsXG4gICAgICB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnM6IHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczIsXG4gICAgICB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZDogdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQyLFxuICAgICAgdXNlTm90aWZpY2F0aW9uU2V0dGluZ3M6ICgpID0+IHVzZU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQpLFxuICAgICAgdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3M6IHVzZVVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzMixcbiAgICAgIHVzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbDogdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWwsXG4gICAgICAuLi5zaGFyZWQuc3VzcGVuc2VcbiAgICB9XG4gIH07XG4gIHJldHVybiBidW5kbGU7XG59XG5mdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IHsgc3RvcmUsIG5vdGlmaWNhdGlvbnNQb2xsZXI6IHBvbGxlciB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICB1c2VFZmZlY3QzKFxuICAgICgpID0+IHZvaWQgc3RvcmUub3V0cHV0cy5sb2FkaW5nTm90aWZpY2F0aW9ucy53YWl0VW50aWxMb2FkZWQoKVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIHdhaXRVbnRpbCBvbiAqZXZlcnkqIHJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGhhcm1sZXNzIHRob3VnaCwgb24gbW9zdCByZW5kZXJzLCBleGNlcHQ6XG4gICAgLy8gMS4gVGhlIHZlcnkgZmlyc3QgcmVuZGVyLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gdHJpZ2dlciB0aGUgaW5pdGlhbCBwYWdlIGZldGNoLlxuICAgIC8vIDIuIEFsbCBvdGhlciBzdWJzZXF1ZW50IHJlbmRlcnMgbm93IFwianVzdFwiIHJldHVybiB0aGUgc2FtZSBwcm9taXNlIChhIHF1aWNrIG9wZXJhdGlvbikuXG4gICAgLy8gMy4gSWYgZXZlciB0aGUgcHJvbWlzZSB3b3VsZCBmYWlsLCB0aGVuIGFmdGVyIDUgc2Vjb25kcyBpdCB3b3VsZCByZXNldCwgYW5kIG9uIHRoZSB2ZXJ5XG4gICAgLy8gICAgKm5leHQqIHJlbmRlciBhZnRlciB0aGF0LCBhICpuZXcqIGZldGNoL3Byb21pc2Ugd2lsbCBnZXQgY3JlYXRlZC5cbiAgKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgcG9sbGVyLmluYygpO1xuICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb2xsZXIuZGVjKCk7XG4gICAgfTtcbiAgfSwgW3BvbGxlcl0pO1xuICByZXR1cm4gdXNlU2lnbmFsKFxuICAgIHN0b3JlLm91dHB1dHMubG9hZGluZ05vdGlmaWNhdGlvbnMuc2lnbmFsLFxuICAgIHNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkuc3RvcmU7XG4gIHVzZShzdG9yZS5vdXRwdXRzLmxvYWRpbmdOb3RpZmljYXRpb25zLndhaXRVbnRpbExvYWRlZCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQoY2xpZW50LCBpZGVudGl0eTIsIHNoYWxsb3c0KTtcbiAgYXNzZXJ0KCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIGFzc2VydCghcmVzdWx0LmlzTG9hZGluZywgXCJEaWQgbm90IGV4cGVjdCBsb2FkaW5nXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KFxuICAgIGNsaWVudCxcbiAgICBzZWxlY3RvckZvcl91c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBzaGFsbG93NFxuICApO1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpLnN0b3JlO1xuICB1c2Uoc3RvcmUub3V0cHV0cy5sb2FkaW5nTm90aWZpY2F0aW9ucy53YWl0VW50aWxMb2FkZWQoKSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50X3dpdGhDbGllbnQoY2xpZW50KTtcbiAgYXNzZXJ0KCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIGFzc2VydCghcmVzdWx0LmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoXG4gICAgKGluYm94Tm90aWZpY2F0aW9uSWQpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IHJlYWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLWluYm94LW5vdGlmaWNhdGlvbi1hcy1yZWFkXCIsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQsXG4gICAgICAgIHJlYWRBdFxuICAgICAgfSk7XG4gICAgICBjbGllbnQubWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5tYXJrSW5ib3hOb3RpZmljYXRpb25SZWFkKFxuICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZCxcbiAgICAgICAgICAgIHJlYWRBdCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY0lkKTtcbiAgICAgICAgICBjbGllbnRba0ludGVybmFsMl0uZW1pdEVycm9yKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcIk1BUktfSU5CT1hfTk9USUZJQ0FUSU9OX0FTX1JFQURfRVJST1JcIixcbiAgICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVyclxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50XVxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZF93aXRoQ2xpZW50KGNsaWVudCkge1xuICByZXR1cm4gdXNlQ2FsbGJhY2syKCgpID0+IHtcbiAgICBjb25zdCB7IHN0b3JlIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgY29uc3QgcmVhZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgIHR5cGU6IFwibWFyay1hbGwtaW5ib3gtbm90aWZpY2F0aW9ucy1hcy1yZWFkXCIsXG4gICAgICByZWFkQXRcbiAgICB9KTtcbiAgICBjbGllbnQubWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCgpLnRoZW4oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHN0b3JlLm1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNSZWFkKG9wdGltaXN0aWNJZCwgcmVhZEF0KTtcbiAgICAgIH0sXG4gICAgICAoZXJyKSA9PiB7XG4gICAgICAgIHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgICBjbGllbnRba0ludGVybmFsMl0uZW1pdEVycm9yKFxuICAgICAgICAgIC8vIE5vIHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCB0byBpbmNsdWRlIGZvciB0aGlzIGVycm9yXG4gICAgICAgICAgeyB0eXBlOiBcIk1BUktfQUxMX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9FUlJPUlwiIH0sXG4gICAgICAgICAgZXJyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcbiAgfSwgW2NsaWVudF0pO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb25fd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMihcbiAgICAoaW5ib3hOb3RpZmljYXRpb25JZCkgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3QgZGVsZXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgICB0eXBlOiBcImRlbGV0ZS1pbmJveC1ub3RpZmljYXRpb25cIixcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZCxcbiAgICAgICAgZGVsZXRlZEF0XG4gICAgICB9KTtcbiAgICAgIGNsaWVudC5kZWxldGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUuZGVsZXRlSW5ib3hOb3RpZmljYXRpb24oaW5ib3hOb3RpZmljYXRpb25JZCwgb3B0aW1pc3RpY0lkKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgIHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgICAgIGNsaWVudFtrSW50ZXJuYWwyXS5lbWl0RXJyb3IoXG4gICAgICAgICAgICB7IHR5cGU6IFwiREVMRVRFX0lOQk9YX05PVElGSUNBVElPTl9FUlJPUlwiLCBpbmJveE5vdGlmaWNhdGlvbklkIH0sXG4gICAgICAgICAgICBlcnJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KGNsaWVudCkge1xuICByZXR1cm4gdXNlQ2FsbGJhY2syKCgpID0+IHtcbiAgICBjb25zdCB7IHN0b3JlIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlLWFsbC1pbmJveC1ub3RpZmljYXRpb25zXCIsXG4gICAgICBkZWxldGVkQXRcbiAgICB9KTtcbiAgICBjbGllbnQuZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKCkudGhlbihcbiAgICAgICgpID0+IHtcbiAgICAgICAgc3RvcmUuZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKG9wdGltaXN0aWNJZCk7XG4gICAgICB9LFxuICAgICAgKGVycikgPT4ge1xuICAgICAgICBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY0lkKTtcbiAgICAgICAgY2xpZW50W2tJbnRlcm5hbDJdLmVtaXRFcnJvcihcbiAgICAgICAgICB7IHR5cGU6IFwiREVMRVRFX0FMTF9JTkJPWF9OT1RJRklDQVRJT05TX0VSUk9SXCIgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuICB9LCBbY2xpZW50XSk7XG59XG5mdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZF93aXRoQ2xpZW50KGNsaWVudCwgaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICBjb25zdCB7IHN0b3JlIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIHJldHVybiB1c2VTaWduYWwoXG4gICAgc3RvcmUub3V0cHV0cy50aHJlYWRpZmljYXRpb25zLFxuICAgIHVzZUNhbGxiYWNrMihcbiAgICAgIChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbiA9IHN0YXRlLm5vdGlmaWNhdGlvbnNCeUlkW2luYm94Tm90aWZpY2F0aW9uSWRdID8/IHJhaXNlKFxuICAgICAgICAgIGBJbmJveCBub3RpZmljYXRpb24gd2l0aCBJRCBcIiR7aW5ib3hOb3RpZmljYXRpb25JZH1cIiBub3QgZm91bmRgXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpbmJveE5vdGlmaWNhdGlvbi5raW5kICE9PSBcInRocmVhZFwiKSB7XG4gICAgICAgICAgcmFpc2UoXG4gICAgICAgICAgICBgSW5ib3ggbm90aWZpY2F0aW9uIHdpdGggSUQgXCIke2luYm94Tm90aWZpY2F0aW9uSWR9XCIgaXMgbm90IG9mIGtpbmQgXCJ0aHJlYWRcImBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHN0YXRlLnRocmVhZHNEQi5nZXQoaW5ib3hOb3RpZmljYXRpb24udGhyZWFkSWQpID8/IHJhaXNlKFxuICAgICAgICAgIGBUaHJlYWQgd2l0aCBJRCBcIiR7aW5ib3hOb3RpZmljYXRpb24udGhyZWFkSWR9XCIgbm90IGZvdW5kLCB0aGlzIGluYm94IG5vdGlmaWNhdGlvbiBtaWdodCBub3QgYmUgb2Yga2luZCBcInRocmVhZFwiYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhyZWFkO1xuICAgICAgfSxcbiAgICAgIFtpbmJveE5vdGlmaWNhdGlvbklkXVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoXG4gICAgKHNldHRpbmdzKSA9PiB7XG4gICAgICBjb25zdCB7IHN0b3JlIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgICB0eXBlOiBcInVwZGF0ZS11c2VyLW5vdGlmaWNhdGlvbi1zZXR0aW5nc1wiLFxuICAgICAgICBzZXR0aW5nc1xuICAgICAgfSk7XG4gICAgICBjbGllbnQudXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3Moc2V0dGluZ3MpLnRoZW4oXG4gICAgICAgIChzZXR0aW5nczIpID0+IHtcbiAgICAgICAgICBzdG9yZS51cGRhdGVVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3NfY29uZmlybU9wdGltaXN0aWNVcGRhdGUoXG4gICAgICAgICAgICBzZXR0aW5nczIsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEh0dHBFcnJvcikge1xuICAgICAgICAgICAgaWYgKGVyci5zdGF0dXMgPT09IDQyMikge1xuICAgICAgICAgICAgICBjb25zdCBtc2cgPSBbZXJyLmRldGFpbHM/LmVycm9yLCBlcnIuZGV0YWlscz8ucmVhc29uXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpZW50W2tJbnRlcm5hbDJdLmVtaXRFcnJvcihcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiVVBEQVRFX1VTRVJfTk9USUZJQ0FUSU9OX1NFVFRJTkdTX0VSUk9SXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU5vdGlmaWNhdGlvblNldHRpbmdzX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIGNvbnN0IHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzID0gdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3Nfd2l0aENsaWVudChjbGllbnQpO1xuICBjb25zdCB7IHN0b3JlLCB1c2VyTm90aWZpY2F0aW9uU2V0dGluZ3NQb2xsZXI6IHBvbGxlciB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICB2b2lkIHN0b3JlLm91dHB1dHMudXNlck5vdGlmaWNhdGlvblNldHRpbmdzLndhaXRVbnRpbExvYWRlZCgpO1xuICB9KTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgcG9sbGVyLmluYygpO1xuICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb2xsZXIuZGVjKCk7XG4gICAgfTtcbiAgfSwgW3BvbGxlcl0pO1xuICBjb25zdCByZXN1bHQgPSB1c2VTaWduYWwoc3RvcmUub3V0cHV0cy51c2VyTm90aWZpY2F0aW9uU2V0dGluZ3Muc2lnbmFsKTtcbiAgcmV0dXJuIHVzZU1lbW8yKCgpID0+IHtcbiAgICByZXR1cm4gW3Jlc3VsdCwgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NdO1xuICB9LCBbcmVzdWx0LCB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc10pO1xufVxuZnVuY3Rpb24gdXNlTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpLnN0b3JlO1xuICB1c2Uoc3RvcmUub3V0cHV0cy51c2VyTm90aWZpY2F0aW9uU2V0dGluZ3Mud2FpdFVudGlsTG9hZGVkKCkpO1xuICBjb25zdCBbcmVzdWx0LCB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc10gPSB1c2VOb3RpZmljYXRpb25TZXR0aW5nc193aXRoQ2xpZW50KGNsaWVudCk7XG4gIGFzc2VydCghcmVzdWx0LmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICBhc3NlcnQoIXJlc3VsdC5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgcmV0dXJuIHVzZU1lbW8yKCgpID0+IHtcbiAgICByZXR1cm4gW3Jlc3VsdCwgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NdO1xuICB9LCBbcmVzdWx0LCB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc10pO1xufVxuZnVuY3Rpb24gdXNlVXNlcl93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKSB7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjbGllbnRba0ludGVybmFsMl0udXNlcnNTdG9yZTtcbiAgY29uc3QgZ2V0VXNlclN0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IHVzZXJzU3RvcmUuZ2V0SXRlbVN0YXRlKHVzZXJJZCksXG4gICAgW3VzZXJzU3RvcmUsIHVzZXJJZF1cbiAgKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSB1c2VDYWxsYmFjazIoXG4gICAgKHN0YXRlKSA9PiBzZWxlY3RvckZvcl91c2VVc2VyKHN0YXRlLCB1c2VySWQpLFxuICAgIFt1c2VySWRdXG4gICk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHVzZXJzU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldFVzZXJTdGF0ZSxcbiAgICBnZXRVc2VyU3RhdGUsXG4gICAgc2VsZWN0b3IsXG4gICAgc2hhbGxvdzRcbiAgKTtcbiAgdXNlRWZmZWN0MyhcbiAgICAoKSA9PiB2b2lkIHVzZXJzU3RvcmUuZW5xdWV1ZSh1c2VySWQpXG4gICAgLy8gTk9URTogRGVsaWJlcmF0ZWx5ICpub3QqIHVzaW5nIGEgZGVwZW5kZW5jeSBhcnJheSBoZXJlIVxuICAgIC8vXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNhbGwgdXNlcnNTdG9yZS5lbnF1ZXVlIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIGV2YWx1YXRpb25cbiAgICAvLyAgICBvZiB0aGUgdXNlcklkLlxuICAgIC8vIDIuIEFsbCBvdGhlciBzdWJzZXF1ZW50IHJlbmRlcnMgbm93IGFyZSBhIG5vLW9wIChmcm9tIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgIC8vICAgIG9mIC5lbnF1ZXVlKVxuICAgIC8vIDMuIElmIGV2ZXIgdGhlIHVzZXJJZCBnZXRzIGludmFsaWRhdGVkLCB0aGUgdXNlciB3b3VsZCBiZSBmZXRjaGVkIGFnYWluLlxuICApO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlVXNlclN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpIHtcbiAgY29uc3QgdXNlcnNTdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwyXS51c2Vyc1N0b3JlO1xuICBjb25zdCBnZXRVc2VyU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgKCkgPT4gdXNlcnNTdG9yZS5nZXRJdGVtU3RhdGUodXNlcklkKSxcbiAgICBbdXNlcnNTdG9yZSwgdXNlcklkXVxuICApO1xuICBjb25zdCB1c2VyU3RhdGUgPSBnZXRVc2VyU3RhdGUoKTtcbiAgaWYgKCF1c2VyU3RhdGUgfHwgdXNlclN0YXRlLmlzTG9hZGluZykge1xuICAgIHRocm93IHVzZXJzU3RvcmUuZW5xdWV1ZSh1c2VySWQpO1xuICB9XG4gIGlmICh1c2VyU3RhdGUuZXJyb3IpIHtcbiAgICB0aHJvdyB1c2VyU3RhdGUuZXJyb3I7XG4gIH1cbiAgaWYgKCF1c2VyU3RhdGUuZGF0YSkge1xuICAgIHRocm93IG1pc3NpbmdVc2VyRXJyb3IodXNlcklkKTtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMihcbiAgICB1c2Vyc1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRVc2VyU3RhdGUsXG4gICAgZ2V0VXNlclN0YXRlXG4gICk7XG4gIGFzc2VydChzdGF0ZSAhPT0gdm9pZCAwLCBcIlVuZXhwZWN0ZWQgbWlzc2luZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0KCFzdGF0ZS5pc0xvYWRpbmcsIFwiVW5leHBlY3RlZCBsb2FkaW5nIHN0YXRlXCIpO1xuICBhc3NlcnQoIXN0YXRlLmVycm9yLCBcIlVuZXhwZWN0ZWQgZXJyb3Igc3RhdGVcIik7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICB1c2VyOiBzdGF0ZS5kYXRhLFxuICAgIGVycm9yOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvX3dpdGhDbGllbnQoY2xpZW50LCByb29tSWQpIHtcbiAgY29uc3Qgcm9vbXNJbmZvU3RvcmUgPSBjbGllbnRba0ludGVybmFsMl0ucm9vbXNJbmZvU3RvcmU7XG4gIGNvbnN0IGdldFJvb21JbmZvU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgKCkgPT4gcm9vbXNJbmZvU3RvcmUuZ2V0SXRlbVN0YXRlKHJvb21JZCksXG4gICAgW3Jvb21zSW5mb1N0b3JlLCByb29tSWRdXG4gICk7XG4gIGNvbnN0IHNlbGVjdG9yID0gdXNlQ2FsbGJhY2syKFxuICAgIChzdGF0ZSkgPT4gc2VsZWN0b3JGb3JfdXNlUm9vbUluZm8oc3RhdGUsIHJvb21JZCksXG4gICAgW3Jvb21JZF1cbiAgKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgcm9vbXNJbmZvU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldFJvb21JbmZvU3RhdGUsXG4gICAgZ2V0Um9vbUluZm9TdGF0ZSxcbiAgICBzZWxlY3RvcixcbiAgICBzaGFsbG93NFxuICApO1xuICB1c2VFZmZlY3QzKFxuICAgICgpID0+IHZvaWQgcm9vbXNJbmZvU3RvcmUuZW5xdWV1ZShyb29tSWQpXG4gICAgLy8gTk9URTogRGVsaWJlcmF0ZWx5ICpub3QqIHVzaW5nIGEgZGVwZW5kZW5jeSBhcnJheSBoZXJlIVxuICAgIC8vXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNhbGwgcm9vbXNJbmZvU3RvcmUuZW5xdWV1ZSBvbiAqZXZlcnkqIHJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGhhcm1sZXNzIHRob3VnaCwgb24gbW9zdCByZW5kZXJzLCBleGNlcHQ6XG4gICAgLy8gMS4gVGhlIHZlcnkgZmlyc3QgcmVuZGVyLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gdHJpZ2dlciBldmFsdWF0aW9uXG4gICAgLy8gICAgb2YgdGhlIHJvb21JZC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBhcmUgYSBuby1vcCAoZnJvbSB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAvLyAgICBvZiAuZW5xdWV1ZSlcbiAgICAvLyAzLiBJZiBldmVyIHRoZSByb29tSWQgZ2V0cyBpbnZhbGlkYXRlZCwgdGhlIHJvb20gaW5mbyB3b3VsZCBiZSBmZXRjaGVkIGFnYWluLlxuICApO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlUm9vbUluZm9TdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgcm9vbUlkKSB7XG4gIGNvbnN0IHJvb21zSW5mb1N0b3JlID0gY2xpZW50W2tJbnRlcm5hbDJdLnJvb21zSW5mb1N0b3JlO1xuICBjb25zdCBnZXRSb29tSW5mb1N0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IHJvb21zSW5mb1N0b3JlLmdldEl0ZW1TdGF0ZShyb29tSWQpLFxuICAgIFtyb29tc0luZm9TdG9yZSwgcm9vbUlkXVxuICApO1xuICBjb25zdCByb29tSW5mb1N0YXRlID0gZ2V0Um9vbUluZm9TdGF0ZSgpO1xuICBpZiAoIXJvb21JbmZvU3RhdGUgfHwgcm9vbUluZm9TdGF0ZS5pc0xvYWRpbmcpIHtcbiAgICB0aHJvdyByb29tc0luZm9TdG9yZS5lbnF1ZXVlKHJvb21JZCk7XG4gIH1cbiAgaWYgKHJvb21JbmZvU3RhdGUuZXJyb3IpIHtcbiAgICB0aHJvdyByb29tSW5mb1N0YXRlLmVycm9yO1xuICB9XG4gIGlmICghcm9vbUluZm9TdGF0ZS5kYXRhKSB7XG4gICAgdGhyb3cgbWlzc2luZ1Jvb21JbmZvRXJyb3Iocm9vbUlkKTtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMihcbiAgICByb29tc0luZm9TdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0Um9vbUluZm9TdGF0ZSxcbiAgICBnZXRSb29tSW5mb1N0YXRlXG4gICk7XG4gIGFzc2VydChzdGF0ZSAhPT0gdm9pZCAwLCBcIlVuZXhwZWN0ZWQgbWlzc2luZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0KCFzdGF0ZS5pc0xvYWRpbmcsIFwiVW5leHBlY3RlZCBsb2FkaW5nIHN0YXRlXCIpO1xuICBhc3NlcnQoIXN0YXRlLmVycm9yLCBcIlVuZXhwZWN0ZWQgZXJyb3Igc3RhdGVcIik7XG4gIGFzc2VydChzdGF0ZS5kYXRhICE9PSB2b2lkIDAsIFwiVW5leHBlY3RlZCBtaXNzaW5nIHJvb20gaW5mbyBkYXRhXCIpO1xuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgaW5mbzogc3RhdGUuZGF0YSxcbiAgICBlcnJvcjogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTaGFyZWRDb250ZXh0KGNsaWVudCkge1xuICBjb25zdCB1c2VDbGllbnQyID0gKCkgPT4gY2xpZW50O1xuICBmdW5jdGlvbiB1c2VTeW5jU3RhdHVzMihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHVzZVN5bmNTdGF0dXNfd2l0aENsaWVudChjbGllbnQsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY2xhc3NpYzoge1xuICAgICAgdXNlQ2xpZW50OiB1c2VDbGllbnQyLFxuICAgICAgdXNlVXNlcjogKHVzZXJJZCkgPT4gdXNlVXNlcl93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKSxcbiAgICAgIHVzZVJvb21JbmZvOiAocm9vbUlkKSA9PiB1c2VSb29tSW5mb193aXRoQ2xpZW50KGNsaWVudCwgcm9vbUlkKSxcbiAgICAgIHVzZUlzSW5zaWRlUm9vbSxcbiAgICAgIHVzZUVycm9yTGlzdGVuZXIsXG4gICAgICB1c2VTeW5jU3RhdHVzOiB1c2VTeW5jU3RhdHVzMlxuICAgIH0sXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIHVzZUNsaWVudDogdXNlQ2xpZW50MixcbiAgICAgIHVzZVVzZXI6ICh1c2VySWQpID0+IHVzZVVzZXJTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKSxcbiAgICAgIHVzZVJvb21JbmZvOiAocm9vbUlkKSA9PiB1c2VSb29tSW5mb1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCByb29tSWQpLFxuICAgICAgdXNlSXNJbnNpZGVSb29tLFxuICAgICAgdXNlRXJyb3JMaXN0ZW5lcixcbiAgICAgIHVzZVN5bmNTdGF0dXM6IHVzZVN5bmNTdGF0dXMyXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdXNlRW5zdXJlTm9MaXZlYmxvY2tzUHJvdmlkZXIob3B0aW9ucykge1xuICBjb25zdCBleGlzdGluZyA9IHVzZUNsaWVudE9yTnVsbCgpO1xuICBpZiAoIW9wdGlvbnM/LmFsbG93TmVzdGluZyAmJiBleGlzdGluZyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbm5vdCBuZXN0IG11bHRpcGxlIExpdmVibG9ja3NQcm92aWRlciBpbnN0YW5jZXMgaW4gdGhlIHNhbWUgUmVhY3QgdHJlZS5cIlxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUNsaWVudE9yTnVsbCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQyKENsaWVudENvbnRleHQpO1xufVxuZnVuY3Rpb24gdXNlQ2xpZW50KCkge1xuICByZXR1cm4gdXNlQ2xpZW50T3JOdWxsKCkgPz8gcmFpc2UoXCJMaXZlYmxvY2tzUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbn1cbmZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcldpdGhDbGllbnQocHJvcHMpIHtcbiAgdXNlRW5zdXJlTm9MaXZlYmxvY2tzUHJvdmlkZXIocHJvcHMpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChDbGllbnRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwcm9wcy5jbGllbnQsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcihwcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5vIH0gPSBwcm9wcztcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBwdWJsaWNBcGlLZXk6IHVzZUluaXRpYWwoby5wdWJsaWNBcGlLZXkpLFxuICAgIHRocm90dGxlOiB1c2VJbml0aWFsKG8udGhyb3R0bGUpLFxuICAgIGxvc3RDb25uZWN0aW9uVGltZW91dDogdXNlSW5pdGlhbChvLmxvc3RDb25uZWN0aW9uVGltZW91dCksXG4gICAgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQ6IHVzZUluaXRpYWwoby5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCksXG4gICAgcG9seWZpbGxzOiB1c2VJbml0aWFsKG8ucG9seWZpbGxzKSxcbiAgICBsYXJnZU1lc3NhZ2VTdHJhdGVneTogdXNlSW5pdGlhbChvLmxhcmdlTWVzc2FnZVN0cmF0ZWd5KSxcbiAgICB1bnN0YWJsZV9mYWxsYmFja1RvSFRUUDogdXNlSW5pdGlhbChvLnVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQKSxcbiAgICB1bnN0YWJsZV9zdHJlYW1EYXRhOiB1c2VJbml0aWFsKG8udW5zdGFibGVfc3RyZWFtRGF0YSksXG4gICAgcHJldmVudFVuc2F2ZWRDaGFuZ2VzOiB1c2VJbml0aWFsKG8ucHJldmVudFVuc2F2ZWRDaGFuZ2VzKSxcbiAgICBhdXRoRW5kcG9pbnQ6IHVzZUluaXRpYWxVbmxlc3NGdW5jdGlvbihvLmF1dGhFbmRwb2ludCksXG4gICAgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uczogdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKFxuICAgICAgby5yZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zXG4gICAgKSxcbiAgICByZXNvbHZlVXNlcnM6IHVzZUluaXRpYWxVbmxlc3NGdW5jdGlvbihvLnJlc29sdmVVc2VycyksXG4gICAgcmVzb2x2ZVJvb21zSW5mbzogdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKG8ucmVzb2x2ZVJvb21zSW5mbyksXG4gICAgYmFzZVVybDogdXNlSW5pdGlhbChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBIaWRkZW4gY29uZmlnIG9wdGlvbnNcbiAgICAgIG8uYmFzZVVybFxuICAgICksXG4gICAgZW5hYmxlRGVidWdMb2dnaW5nOiB1c2VJbml0aWFsKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIEhpZGRlbiBjb25maWcgb3B0aW9uc1xuICAgICAgby5lbmFibGVEZWJ1Z0xvZ2dpbmdcbiAgICApXG4gIH07XG4gIGNvbnN0IGNsaWVudCA9IHVzZU1lbW8yKCgpID0+IGNyZWF0ZUNsaWVudChvcHRpb25zKSwgW10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChMaXZlYmxvY2tzUHJvdmlkZXJXaXRoQ2xpZW50LCB7IGNsaWVudCwgY2hpbGRyZW4gfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVMaXZlYmxvY2tzQ29udGV4dChjbGllbnQpIHtcbiAgcmV0dXJuIGdldE9yQ3JlYXRlQ29udGV4dEJ1bmRsZShjbGllbnQpO1xufVxuZnVuY3Rpb24gdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgeyBzdG9yZSwgdXNlclRocmVhZHNQb2xsZXI6IHBvbGxlciB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBxdWVyeUtleSA9IG1ha2VVc2VyVGhyZWFkc1F1ZXJ5S2V5KG9wdGlvbnMucXVlcnkpO1xuICB1c2VFZmZlY3QzKFxuICAgICgpID0+IHZvaWQgc3RvcmUub3V0cHV0cy5sb2FkaW5nVXNlclRocmVhZHMuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLndhaXRVbnRpbExvYWRlZCgpXG4gICAgLy8gTk9URTogRGVsaWJlcmF0ZWx5ICpub3QqIHVzaW5nIGEgZGVwZW5kZW5jeSBhcnJheSBoZXJlIVxuICAgIC8vXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNhbGwgd2FpdFVudGlsIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIHRoZSBpbml0aWFsIHBhZ2UgZmV0Y2guXG4gICAgLy8gMi4gQWxsIG90aGVyIHN1YnNlcXVlbnQgcmVuZGVycyBub3cgXCJqdXN0XCIgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UgKGEgcXVpY2sgb3BlcmF0aW9uKS5cbiAgICAvLyAzLiBJZiBldmVyIHRoZSBwcm9taXNlIHdvdWxkIGZhaWwsIHRoZW4gYWZ0ZXIgNSBzZWNvbmRzIGl0IHdvdWxkIHJlc2V0LCBhbmQgb24gdGhlIHZlcnlcbiAgICAvLyAgICAqbmV4dCogcmVuZGVyIGFmdGVyIHRoYXQsIGEgKm5ldyogZmV0Y2gvcHJvbWlzZSB3aWxsIGdldCBjcmVhdGVkLlxuICApO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBwb2xsZXIuaW5jKCk7XG4gICAgcG9sbGVyLnBvbGxOb3dJZlN0YWxlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvbGxlci5kZWMoKTtcbiAgICB9O1xuICB9LCBbcG9sbGVyXSk7XG4gIHJldHVybiB1c2VTaWduYWwoXG4gICAgc3RvcmUub3V0cHV0cy5sb2FkaW5nVXNlclRocmVhZHMuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLnNpZ25hbFxuICApO1xufVxuZnVuY3Rpb24gdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWwob3B0aW9ucyA9IHt9KSB7XG4gIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHsgc3RvcmUgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgcXVlcnlLZXkgPSBtYWtlVXNlclRocmVhZHNRdWVyeUtleShvcHRpb25zLnF1ZXJ5KTtcbiAgdXNlKHN0b3JlLm91dHB1dHMubG9hZGluZ1VzZXJUaHJlYWRzLmdldE9yQ3JlYXRlKHF1ZXJ5S2V5KS53YWl0VW50aWxMb2FkZWQoKSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbChvcHRpb25zKTtcbiAgYXNzZXJ0KCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIGFzc2VydCghcmVzdWx0LmlzTG9hZGluZywgXCJEaWQgbm90IGV4cGVjdCBsb2FkaW5nXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zKCkge1xuICByZXR1cm4gdXNlSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQodXNlQ2xpZW50KCksIGlkZW50aXR5Miwgc2hhbGxvdzQpO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2UoKSB7XG4gIHJldHVybiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZV93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgcmV0dXJuIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkX3dpdGhDbGllbnQoXG4gICAgdXNlQ2xpZW50KCksXG4gICAgaW5ib3hOb3RpZmljYXRpb25JZFxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCgpIHtcbiAgcmV0dXJuIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWRfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoKSB7XG4gIHJldHVybiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMoKSB7XG4gIHJldHVybiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbigpIHtcbiAgcmV0dXJuIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoKSB7XG4gIHJldHVybiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudF93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2UoKSB7XG4gIHJldHVybiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlTm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gIHJldHVybiB1c2VOb3RpZmljYXRpb25TZXR0aW5nc193aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UoKSB7XG4gIHJldHVybiB1c2VOb3RpZmljYXRpb25TZXR0aW5nc1N1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gIHJldHVybiB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc193aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZVVzZXIodXNlcklkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlVXNlcl93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKTtcbn1cbmZ1bmN0aW9uIHVzZVVzZXJTdXNwZW5zZSh1c2VySWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VVc2VyU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIHVzZXJJZCk7XG59XG5mdW5jdGlvbiB1c2VSb29tSW5mbyhyb29tSWQpIHtcbiAgcmV0dXJuIHVzZVJvb21JbmZvX3dpdGhDbGllbnQodXNlQ2xpZW50KCksIHJvb21JZCk7XG59XG5mdW5jdGlvbiB1c2VSb29tSW5mb1N1c3BlbnNlKHJvb21JZCkge1xuICByZXR1cm4gdXNlUm9vbUluZm9TdXNwZW5zZV93aXRoQ2xpZW50KHVzZUNsaWVudCgpLCByb29tSWQpO1xufVxudmFyIF91c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZCA9IHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkO1xudmFyIF91c2VVc2VyID0gdXNlVXNlcjtcbnZhciBfdXNlVXNlclN1c3BlbnNlID0gdXNlVXNlclN1c3BlbnNlO1xudmFyIF91c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWwgPSB1c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWw7XG52YXIgX3VzZVVzZXJUaHJlYWRzU3VzcGVuc2VfZXhwZXJpbWVudGFsID0gdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWw7XG5mdW5jdGlvbiB1c2VTeW5jU3RhdHVzX3dpdGhDbGllbnQoY2xpZW50LCBvcHRpb25zKSB7XG4gIGNvbnN0IHNtb290aCA9IHVzZUluaXRpYWwob3B0aW9ucz8uc21vb3RoID8/IGZhbHNlKTtcbiAgaWYgKHNtb290aCkge1xuICAgIHJldHVybiB1c2VTeW5jU3RhdHVzU21vb3RoX3dpdGhDbGllbnQoY2xpZW50KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdXNlU3luY1N0YXR1c0ltbWVkaWF0ZV93aXRoQ2xpZW50KGNsaWVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZVN5bmNTdGF0dXNJbW1lZGlhdGVfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMihcbiAgICBjbGllbnQuZXZlbnRzLnN5bmNTdGF0dXMuc3Vic2NyaWJlLFxuICAgIGNsaWVudC5nZXRTeW5jU3RhdHVzLFxuICAgIGNsaWVudC5nZXRTeW5jU3RhdHVzXG4gICk7XG59XG5mdW5jdGlvbiB1c2VTeW5jU3RhdHVzU21vb3RoX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIGNvbnN0IGdldHRlciA9IGNsaWVudC5nZXRTeW5jU3RhdHVzO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGUoZ2V0dGVyKTtcbiAgY29uc3Qgb2xkU3RhdHVzID0gdXNlTGF0ZXN0KGdldHRlcigpKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCB1bnN1YiA9IGNsaWVudC5ldmVudHMuc3luY1N0YXR1cy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgY29uc3QgbmV3U3RhdHVzID0gZ2V0dGVyKCk7XG4gICAgICBpZiAob2xkU3RhdHVzLmN1cnJlbnQgPT09IFwic3luY2hyb25pemluZ1wiICYmIG5ld1N0YXR1cyA9PT0gXCJzeW5jaHJvbml6ZWRcIikge1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHNldFN0YXR1cyhuZXdTdGF0dXMpLCBjb25maWcuU01PT1RIX0RFTEFZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBzZXRTdGF0dXMobmV3U3RhdHVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB1bnN1YigpO1xuICAgIH07XG4gIH0sIFtjbGllbnQsIGdldHRlciwgb2xkU3RhdHVzXSk7XG4gIHJldHVybiBzdGF0dXM7XG59XG5mdW5jdGlvbiB1c2VTeW5jU3RhdHVzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVzZVN5bmNTdGF0dXNfd2l0aENsaWVudCh1c2VDbGllbnQoKSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB1c2VFcnJvckxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgdXNlRWZmZWN0MyhcbiAgICAoKSA9PiBjbGllbnQuZXZlbnRzLmVycm9yLnN1YnNjcmliZSgoZSkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGUpKSxcbiAgICBbY2xpZW50LCBzYXZlZENhbGxiYWNrXVxuICApO1xufVxuXG4vLyBzcmMvcm9vbS50c3hcbmltcG9ydCB7IHNoYWxsb3cgYXMgc2hhbGxvdzUgfSBmcm9tIFwiQGxpdmVibG9ja3MvY2xpZW50XCI7XG5pbXBvcnQge1xuICBhc3NlcnQgYXMgYXNzZXJ0MixcbiAgY29uc29sZSBhcyBjb25zb2xlMyxcbiAgY3JlYXRlQ29tbWVudElkLFxuICBjcmVhdGVUaHJlYWRJZCxcbiAgRGVmYXVsdE1hcCBhcyBEZWZhdWx0TWFwMixcbiAgZXJyb3JJZixcbiAgSHR0cEVycm9yIGFzIEh0dHBFcnJvcjIsXG4gIGtJbnRlcm5hbCBhcyBrSW50ZXJuYWwzLFxuICBtYWtlUG9sbGVyIGFzIG1ha2VQb2xsZXIyLFxuICBTZXJ2ZXJNc2dDb2RlXG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQge1xuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazMsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q1LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8zLFxuICB1c2VSZWYgYXMgdXNlUmVmMyxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUyLFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMsXG4gIHZlcnNpb24gYXMgcmVhY3RWZXJzaW9uXG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdXNlLXNjcm9sbC10by1jb21tZW50LW9uLWxvYWQtZWZmZWN0LnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NCB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gaGFuZGxlU2Nyb2xsVG9Db21tZW50T25Mb2FkKHNob3VsZFNjcm9sbE9uTG9hZCwgc3RhdGUpIHtcbiAgaWYgKHNob3VsZFNjcm9sbE9uTG9hZCA9PT0gZmFsc2UpIHJldHVybjtcbiAgaWYgKCFzdGF0ZS50aHJlYWRzKSByZXR1cm47XG4gIGNvbnN0IGlzV2luZG93RGVmaW5lZCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmICghaXNXaW5kb3dEZWZpbmVkKSByZXR1cm47XG4gIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgY29uc3QgY29tbWVudElkID0gaGFzaC5zbGljZSgxKTtcbiAgaWYgKCFjb21tZW50SWQuc3RhcnRzV2l0aChcImNtX1wiKSkgcmV0dXJuO1xuICBjb25zdCBjb21tZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29tbWVudElkKTtcbiAgaWYgKGNvbW1lbnQgPT09IG51bGwpIHJldHVybjtcbiAgY29uc3QgY29tbWVudHMgPSBzdGF0ZS50aHJlYWRzLmZsYXRNYXAoKHRocmVhZCkgPT4gdGhyZWFkLmNvbW1lbnRzKTtcbiAgY29uc3QgaXNDb21tZW50SW5UaHJlYWRzID0gY29tbWVudHMuc29tZShcbiAgICAoY29tbWVudDIpID0+IGNvbW1lbnQyLmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKCFpc0NvbW1lbnRJblRocmVhZHMpIHJldHVybjtcbiAgY29tbWVudC5zY3JvbGxJbnRvVmlldygpO1xufVxuZnVuY3Rpb24gdXNlU2Nyb2xsVG9Db21tZW50T25Mb2FkRWZmZWN0KHNob3VsZFNjcm9sbE9uTG9hZCwgc3RhdGUpIHtcbiAgdXNlRWZmZWN0NChcbiAgICAoKSA9PiB7XG4gICAgICBoYW5kbGVTY3JvbGxUb0NvbW1lbnRPbkxvYWQoc2hvdWxkU2Nyb2xsT25Mb2FkLCBzdGF0ZSk7XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIC0tIFdlIG9ubHkgd2FudCB0byBydW4gdGhpcyBlZmZlY3Qgb25jZVxuICAgIFtzdGF0ZS5pc0xvYWRpbmddXG4gICk7XG59XG5cbi8vIHNyYy9yb29tLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBub29wMyA9ICgpID0+IHtcbn07XG52YXIgaWRlbnRpdHkzID0gKHgpID0+IHg7XG52YXIgU1RBQkxFX0VNUFRZX0xJU1QgPSBPYmplY3QuZnJlZXplKFtdKTtcbmZ1bmN0aW9uIGFsd2F5c0VtcHR5TGlzdCgpIHtcbiAgcmV0dXJuIFNUQUJMRV9FTVBUWV9MSVNUO1xufVxuZnVuY3Rpb24gYWx3YXlzTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VPdGhlcnNDb25uZWN0aW9uSWRzKG90aGVycykge1xuICByZXR1cm4gb3RoZXJzLm1hcCgodXNlcikgPT4gdXNlci5jb25uZWN0aW9uSWQpO1xufVxuZnVuY3Rpb24gbWFrZU11dGF0aW9uQ29udGV4dChyb29tKSB7XG4gIGNvbnN0IGNhbm5vdFVzZVVudGlsID0gXCJUaGlzIG11dGF0aW9uIGNhbm5vdCBiZSB1c2VkIHVudGlsXCI7XG4gIGNvbnN0IG5lZWRzUHJlc2VuY2UgPSBgJHtjYW5ub3RVc2VVbnRpbH0gY29ubmVjdGVkIHRvIHRoZSBMaXZlYmxvY2tzIHJvb21gO1xuICBjb25zdCBuZWVkc1N0b3JhZ2UgPSBgJHtjYW5ub3RVc2VVbnRpbH0gc3RvcmFnZSBoYXMgYmVlbiBsb2FkZWRgO1xuICByZXR1cm4ge1xuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgY29uc3QgbXV0YWJsZVJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICAgICAgaWYgKG11dGFibGVSb290ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuZWVkc1N0b3JhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG11dGFibGVSb290O1xuICAgIH0sXG4gICAgZ2V0IHNlbGYoKSB7XG4gICAgICBjb25zdCBzZWxmID0gcm9vbS5nZXRTZWxmKCk7XG4gICAgICBpZiAoc2VsZiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmVlZHNQcmVzZW5jZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuICAgIGdldCBvdGhlcnMoKSB7XG4gICAgICBjb25zdCBvdGhlcnMgPSByb29tLmdldE90aGVycygpO1xuICAgICAgaWYgKHJvb20uZ2V0U2VsZigpID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuZWVkc1ByZXNlbmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdGhlcnM7XG4gICAgfSxcbiAgICBzZXRNeVByZXNlbmNlOiByb29tLnVwZGF0ZVByZXNlbmNlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VXNlcklkKGNsaWVudCkge1xuICBjb25zdCB1c2VySWQgPSBjbGllbnRba0ludGVybmFsM10uY3VycmVudFVzZXJJZC5nZXQoKTtcbiAgaWYgKHVzZXJJZCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFwiYW5vbnltb3VzXCI7XG4gIH1cbiAgcmV0dXJuIHVzZXJJZDtcbn1cbnZhciBfZXh0cmFzMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIF9idW5kbGVzMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0T3JDcmVhdGVSb29tQ29udGV4dEJ1bmRsZShjbGllbnQpIHtcbiAgbGV0IGJ1bmRsZSA9IF9idW5kbGVzMi5nZXQoY2xpZW50KTtcbiAgaWYgKCFidW5kbGUpIHtcbiAgICBidW5kbGUgPSBtYWtlUm9vbUNvbnRleHRCdW5kbGUoY2xpZW50KTtcbiAgICBfYnVuZGxlczIuc2V0KGNsaWVudCwgYnVuZGxlKTtcbiAgfVxuICByZXR1cm4gYnVuZGxlO1xufVxuZnVuY3Rpb24gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpIHtcbiAgbGV0IGV4dHJhcyA9IF9leHRyYXMyLmdldChjbGllbnQpO1xuICBpZiAoIWV4dHJhcykge1xuICAgIGV4dHJhcyA9IG1ha2VSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgX2V4dHJhczIuc2V0KGNsaWVudCwgZXh0cmFzKTtcbiAgfVxuICByZXR1cm4gZXh0cmFzO1xufVxuZnVuY3Rpb24gbWFrZVJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudChjbGllbnQpO1xuICBmdW5jdGlvbiBvbk11dGF0aW9uRmFpbHVyZShvcHRpbWlzdGljSWQsIGNvbnRleHQsIGlubmVyRXJyb3IpIHtcbiAgICBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY0lkKTtcbiAgICBpZiAoaW5uZXJFcnJvciBpbnN0YW5jZW9mIEh0dHBFcnJvcjIpIHtcbiAgICAgIGlmIChpbm5lckVycm9yLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgIGNvbnN0IGRldGFpbGVkTWVzc2FnZSA9IFtcbiAgICAgICAgICBpbm5lckVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgaW5uZXJFcnJvci5kZXRhaWxzPy5zdWdnZXN0aW9uLFxuICAgICAgICAgIGlubmVyRXJyb3IuZGV0YWlscz8uZG9jc1xuICAgICAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXFxuXCIpO1xuICAgICAgICBjb25zb2xlMy5lcnJvcihkZXRhaWxlZE1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgY2xpZW50W2tJbnRlcm5hbDNdLmVtaXRFcnJvcihjb250ZXh0LCBpbm5lckVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgaW5uZXJFcnJvcjtcbiAgICB9XG4gIH1cbiAgY29uc3QgdGhyZWFkc1BvbGxlcnNCeVJvb21JZCA9IG5ldyBEZWZhdWx0TWFwMihcbiAgICAocm9vbUlkKSA9PiBtYWtlUG9sbGVyMihcbiAgICAgIGFzeW5jIChzaWduYWwpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgc3RvcmUuZmV0Y2hSb29tVGhyZWFkc0RlbHRhVXBkYXRlKHJvb21JZCwgc2lnbmFsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZTMud2FybihgUG9sbGluZyBuZXcgdGhyZWFkcyBmb3IgJyR7cm9vbUlkfScgZmFpbGVkOiAke1N0cmluZyhlcnIpfWApO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbmZpZy5ST09NX1RIUkVBRFNfUE9MTF9JTlRFUlZBTCxcbiAgICAgIHsgbWF4U3RhbGVUaW1lTXM6IGNvbmZpZy5ST09NX1RIUkVBRFNfTUFYX1NUQUxFX1RJTUUgfVxuICAgIClcbiAgKTtcbiAgY29uc3QgdmVyc2lvbnNQb2xsZXJzQnlSb29tSWQgPSBuZXcgRGVmYXVsdE1hcDIoXG4gICAgKHJvb21JZCkgPT4gbWFrZVBvbGxlcjIoXG4gICAgICBhc3luYyAoc2lnbmFsKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLmZldGNoUm9vbVZlcnNpb25zRGVsdGFVcGRhdGUocm9vbUlkLCBzaWduYWwpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlMy53YXJuKGBQb2xsaW5nIG5ldyBoaXN0b3J5IHZlcnNpb25zIGZvciAnJHtyb29tSWR9JyBmYWlsZWQ6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29uZmlnLkhJU1RPUllfVkVSU0lPTlNfUE9MTF9JTlRFUlZBTCxcbiAgICAgIHsgbWF4U3RhbGVUaW1lTXM6IGNvbmZpZy5ISVNUT1JZX1ZFUlNJT05TX01BWF9TVEFMRV9USU1FIH1cbiAgICApXG4gICk7XG4gIGNvbnN0IHJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1BvbGxlcnNCeVJvb21JZCA9IG5ldyBEZWZhdWx0TWFwMihcbiAgICAocm9vbUlkKSA9PiBtYWtlUG9sbGVyMihcbiAgICAgIGFzeW5jIChzaWduYWwpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgc3RvcmUucmVmcmVzaFJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyhyb29tSWQsIHNpZ25hbCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUzLndhcm4oYFBvbGxpbmcgbm90aWZpY2F0aW9uIHNldHRpbmdzIGZvciAnJHtyb29tSWR9JyBmYWlsZWQ6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29uZmlnLk5PVElGSUNBVElPTl9TRVRUSU5HU19QT0xMX0lOVEVSVkFMLFxuICAgICAgeyBtYXhTdGFsZVRpbWVNczogY29uZmlnLk5PVElGSUNBVElPTl9TRVRUSU5HU19NQVhfU1RBTEVfVElNRSB9XG4gICAgKVxuICApO1xuICByZXR1cm4ge1xuICAgIHN0b3JlLFxuICAgIG9uTXV0YXRpb25GYWlsdXJlLFxuICAgIGdldE9yQ3JlYXRlVGhyZWFkc1BvbGxlckZvclJvb21JZDogdGhyZWFkc1BvbGxlcnNCeVJvb21JZC5nZXRPckNyZWF0ZS5iaW5kKFxuICAgICAgdGhyZWFkc1BvbGxlcnNCeVJvb21JZFxuICAgICksXG4gICAgZ2V0T3JDcmVhdGVWZXJzaW9uc1BvbGxlckZvclJvb21JZDogdmVyc2lvbnNQb2xsZXJzQnlSb29tSWQuZ2V0T3JDcmVhdGUuYmluZCh2ZXJzaW9uc1BvbGxlcnNCeVJvb21JZCksXG4gICAgZ2V0T3JDcmVhdGVOb3RpZmljYXRpb25zU2V0dGluZ3NQb2xsZXJGb3JSb29tSWQ6IHJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1BvbGxlcnNCeVJvb21JZC5nZXRPckNyZWF0ZS5iaW5kKFxuICAgICAgcm9vbU5vdGlmaWNhdGlvblNldHRpbmdzUG9sbGVyc0J5Um9vbUlkXG4gICAgKVxuICB9O1xufVxuZnVuY3Rpb24gbWFrZVJvb21Db250ZXh0QnVuZGxlKGNsaWVudCkge1xuICBmdW5jdGlvbiBSb29tUHJvdmlkZXJfd2l0aEltcGxpY2l0TGl2ZWJsb2Nrc1Byb3ZpZGVyKHByb3BzKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyKExpdmVibG9ja3NQcm92aWRlcldpdGhDbGllbnQsIHsgY2xpZW50LCBhbGxvd05lc3Rpbmc6IHRydWUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihSb29tUHJvdmlkZXIsIHsgLi4ucHJvcHMgfSkgfSk7XG4gIH1cbiAgY29uc3Qgc2hhcmVkID0gY3JlYXRlU2hhcmVkQ29udGV4dChjbGllbnQpO1xuICBjb25zdCBidW5kbGUgPSB7XG4gICAgUm9vbUNvbnRleHQsXG4gICAgUm9vbVByb3ZpZGVyOiBSb29tUHJvdmlkZXJfd2l0aEltcGxpY2l0TGl2ZWJsb2Nrc1Byb3ZpZGVyLFxuICAgIHVzZVJvb20sXG4gICAgdXNlU3RhdHVzLFxuICAgIHVzZVN0b3JhZ2VTdGF0dXMsXG4gICAgdXNlQmF0Y2gsXG4gICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgdXNlT3RoZXJzTGlzdGVuZXIsXG4gICAgdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcixcbiAgICB1c2VFdmVudExpc3RlbmVyLFxuICAgIHVzZUhpc3RvcnksXG4gICAgdXNlVW5kbyxcbiAgICB1c2VSZWRvLFxuICAgIHVzZUNhblJlZG8sXG4gICAgdXNlQ2FuVW5kbyxcbiAgICB1c2VTdG9yYWdlUm9vdCxcbiAgICB1c2VTdG9yYWdlLFxuICAgIHVzZVNlbGYsXG4gICAgdXNlTXlQcmVzZW5jZSxcbiAgICB1c2VVcGRhdGVNeVByZXNlbmNlLFxuICAgIHVzZU90aGVycyxcbiAgICB1c2VPdGhlcnNNYXBwZWQsXG4gICAgdXNlT3RoZXJzQ29ubmVjdGlvbklkcyxcbiAgICB1c2VPdGhlcixcbiAgICB1c2VNdXRhdGlvbixcbiAgICB1c2VUaHJlYWRzLFxuICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICB1c2VEZWxldGVUaHJlYWQsXG4gICAgdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIHVzZU1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICAgIHVzZU1hcmtUaHJlYWRBc1VucmVzb2x2ZWQsXG4gICAgdXNlQ3JlYXRlQ29tbWVudCxcbiAgICB1c2VFZGl0Q29tbWVudCxcbiAgICB1c2VEZWxldGVDb21tZW50LFxuICAgIHVzZUFkZFJlYWN0aW9uLFxuICAgIHVzZVJlbW92ZVJlYWN0aW9uLFxuICAgIHVzZU1hcmtUaHJlYWRBc1JlYWQsXG4gICAgdXNlVGhyZWFkU3Vic2NyaXB0aW9uLFxuICAgIHVzZUF0dGFjaG1lbnRVcmwsXG4gICAgdXNlSGlzdG9yeVZlcnNpb25zLFxuICAgIHVzZUhpc3RvcnlWZXJzaW9uRGF0YSxcbiAgICB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIC4uLnNoYXJlZC5jbGFzc2ljLFxuICAgIHN1c3BlbnNlOiB7XG4gICAgICBSb29tQ29udGV4dCxcbiAgICAgIFJvb21Qcm92aWRlcjogUm9vbVByb3ZpZGVyX3dpdGhJbXBsaWNpdExpdmVibG9ja3NQcm92aWRlcixcbiAgICAgIHVzZVJvb20sXG4gICAgICB1c2VTdGF0dXMsXG4gICAgICB1c2VTdG9yYWdlU3RhdHVzOiB1c2VTdG9yYWdlU3RhdHVzU3VzcGVuc2UsXG4gICAgICB1c2VCYXRjaCxcbiAgICAgIHVzZUJyb2FkY2FzdEV2ZW50LFxuICAgICAgdXNlT3RoZXJzTGlzdGVuZXIsXG4gICAgICB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyLFxuICAgICAgdXNlRXZlbnRMaXN0ZW5lcixcbiAgICAgIHVzZUhpc3RvcnksXG4gICAgICB1c2VVbmRvLFxuICAgICAgdXNlUmVkbyxcbiAgICAgIHVzZUNhblJlZG8sXG4gICAgICB1c2VDYW5VbmRvLFxuICAgICAgdXNlU3RvcmFnZVJvb3QsXG4gICAgICB1c2VTdG9yYWdlOiB1c2VTdG9yYWdlU3VzcGVuc2UsXG4gICAgICB1c2VTZWxmOiB1c2VTZWxmU3VzcGVuc2UsXG4gICAgICB1c2VNeVByZXNlbmNlLFxuICAgICAgdXNlVXBkYXRlTXlQcmVzZW5jZSxcbiAgICAgIHVzZU90aGVyczogdXNlT3RoZXJzU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcnNNYXBwZWQ6IHVzZU90aGVyc01hcHBlZFN1c3BlbnNlLFxuICAgICAgdXNlT3RoZXJzQ29ubmVjdGlvbklkczogdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlLFxuICAgICAgdXNlT3RoZXI6IHVzZU90aGVyU3VzcGVuc2UsXG4gICAgICB1c2VNdXRhdGlvbixcbiAgICAgIHVzZVRocmVhZHM6IHVzZVRocmVhZHNTdXNwZW5zZSxcbiAgICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICAgIHVzZURlbGV0ZVRocmVhZCxcbiAgICAgIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICAgIHVzZU1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICAgICAgdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICAgIHVzZUNyZWF0ZUNvbW1lbnQsXG4gICAgICB1c2VFZGl0Q29tbWVudCxcbiAgICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgICB1c2VBZGRSZWFjdGlvbixcbiAgICAgIHVzZVJlbW92ZVJlYWN0aW9uLFxuICAgICAgdXNlTWFya1RocmVhZEFzUmVhZCxcbiAgICAgIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgICAgIHVzZUF0dGFjaG1lbnRVcmw6IHVzZUF0dGFjaG1lbnRVcmxTdXNwZW5zZSxcbiAgICAgIC8vIFRPRE86IHVzZUhpc3RvcnlWZXJzaW9uRGF0YTogdXNlSGlzdG9yeVZlcnNpb25EYXRhU3VzcGVuc2UsXG4gICAgICB1c2VIaXN0b3J5VmVyc2lvbnM6IHVzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlLFxuICAgICAgdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzOiB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSxcbiAgICAgIHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIC4uLnNoYXJlZC5zdXNwZW5zZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShidW5kbGUsIGtJbnRlcm5hbDMsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFJvb21Qcm92aWRlcihwcm9wcykge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgW2NhY2hlXSA9IHVzZVN0YXRlMihcbiAgICAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gICk7XG4gIGNvbnN0IHN0YWJsZUVudGVyUm9vbSA9IHVzZUNhbGxiYWNrMyhcbiAgICAocm9vbUlkLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQocm9vbUlkKTtcbiAgICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgICBjb25zdCBydiA9IGNsaWVudC5lbnRlclJvb20ocm9vbUlkLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IG9yaWdMZWF2ZSA9IHJ2LmxlYXZlO1xuICAgICAgcnYubGVhdmUgPSAoKSA9PiB7XG4gICAgICAgIG9yaWdMZWF2ZSgpO1xuICAgICAgICBjYWNoZS5kZWxldGUocm9vbUlkKTtcbiAgICAgIH07XG4gICAgICBjYWNoZS5zZXQocm9vbUlkLCBydik7XG4gICAgICByZXR1cm4gcnY7XG4gICAgfSxcbiAgICBbY2xpZW50LCBjYWNoZV1cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFxuICAgIFJvb21Qcm92aWRlcklubmVyLFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgc3RhYmxlRW50ZXJSb29tXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gUm9vbVByb3ZpZGVySW5uZXIocHJvcHMpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHsgaWQ6IHJvb21JZCwgc3RhYmxlRW50ZXJSb29tIH0gPSBwcm9wcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghcm9vbUlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiUm9vbVByb3ZpZGVyIGlkIHByb3BlcnR5IGlzIHJlcXVpcmVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtcmVhY3QvUm9vbVByb3ZpZGVyLWlkLXByb3BlcnR5LWlzLXJlcXVpcmVkXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygcm9vbUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaWQgcHJvcGVydHkgc2hvdWxkIGJlIGEgc3RyaW5nLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbWFqb3JSZWFjdFZlcnNpb24gPSBwYXJzZUludChyZWFjdFZlcnNpb24pIHx8IDE7XG4gICAgY29uc3QgcmVxdWlyZWRWZXJzaW9uID0gMTg7XG4gICAgZXJyb3JJZihcbiAgICAgIG1ham9yUmVhY3RWZXJzaW9uIDwgcmVxdWlyZWRWZXJzaW9uLFxuICAgICAgYFJlYWN0ICR7cmVxdWlyZWRWZXJzaW9ufSBvciBoaWdoZXIgaXMgcmVxdWlyZWQgKHlvdVxcdTIwMTlyZSBvbiAke3JlYWN0VmVyc2lvbn0pYFxuICAgICk7XG4gIH1cbiAgY29uc3QgZnJvemVuUHJvcHMgPSB1c2VJbml0aWFsKHtcbiAgICBpbml0aWFsUHJlc2VuY2U6IHByb3BzLmluaXRpYWxQcmVzZW5jZSxcbiAgICBpbml0aWFsU3RvcmFnZTogcHJvcHMuaW5pdGlhbFN0b3JhZ2UsXG4gICAgYXV0b0Nvbm5lY3Q6IHByb3BzLmF1dG9Db25uZWN0ID8/IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcbiAgfSk7XG4gIGNvbnN0IFt7IHJvb20gfSwgc2V0Um9vbUxlYXZlUGFpcl0gPSB1c2VTdGF0ZTIoXG4gICAgKCkgPT4gc3RhYmxlRW50ZXJSb29tKHJvb21JZCwge1xuICAgICAgLi4uZnJvemVuUHJvcHMsXG4gICAgICBhdXRvQ29ubmVjdDogZmFsc2VcbiAgICAgIC8vIERlbGliZXJhdGVseSB1c2luZyBmYWxzZSBoZXJlIG9uIHRoZSBmaXJzdCByZW5kZXIsIHNlZSBiZWxvd1xuICAgIH0pXG4gICk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICBhc3luYyBmdW5jdGlvbiBoYW5kbGVDb21tZW50RXZlbnQobWVzc2FnZSkge1xuICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gU2VydmVyTXNnQ29kZS5USFJFQURfREVMRVRFRCkge1xuICAgICAgICBzdG9yZS5kZWxldGVUaHJlYWQobWVzc2FnZS50aHJlYWRJZCwgbnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCByb29tLmdldFRocmVhZChtZXNzYWdlLnRocmVhZElkKTtcbiAgICAgIGlmICghaW5mby50aHJlYWQpIHtcbiAgICAgICAgc3RvcmUuZGVsZXRlVGhyZWFkKG1lc3NhZ2UudGhyZWFkSWQsIG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRocmVhZCwgaW5ib3hOb3RpZmljYXRpb246IG1heWJlTm90aWZpY2F0aW9uIH0gPSBpbmZvO1xuICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdG9yZS5vdXRwdXRzLnRocmVhZHMuZ2V0KCkuZ2V0RXZlbklmRGVsZXRlZChtZXNzYWdlLnRocmVhZElkKTtcbiAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX0VESVRFRDpcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLlRIUkVBRF9NRVRBREFUQV9VUERBVEVEOlxuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuVEhSRUFEX1VQREFURUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX1JFQUNUSU9OX0FEREVEOlxuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEOlxuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9ERUxFVEVEOlxuICAgICAgICAgIGlmICghZXhpc3RpbmdUaHJlYWQpIGJyZWFrO1xuICAgICAgICAgIHN0b3JlLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICAgICAgICBbdGhyZWFkXSxcbiAgICAgICAgICAgIG1heWJlTm90aWZpY2F0aW9uID8gW21heWJlTm90aWZpY2F0aW9uXSA6IFtdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfQ1JFQVRFRDpcbiAgICAgICAgICBzdG9yZS51cGRhdGVUaHJlYWRpZmljYXRpb25zKFxuICAgICAgICAgICAgW3RocmVhZF0sXG4gICAgICAgICAgICBtYXliZU5vdGlmaWNhdGlvbiA/IFttYXliZU5vdGlmaWNhdGlvbl0gOiBbXVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb29tLmV2ZW50cy5jb21tZW50cy5zdWJzY3JpYmUoXG4gICAgICAobWVzc2FnZSkgPT4gdm9pZCBoYW5kbGVDb21tZW50RXZlbnQobWVzc2FnZSlcbiAgICApO1xuICB9LCBbY2xpZW50LCByb29tXSk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIGNvbnN0IHBhaXIgPSBzdGFibGVFbnRlclJvb20ocm9vbUlkLCBmcm96ZW5Qcm9wcyk7XG4gICAgc2V0Um9vbUxlYXZlUGFpcihwYWlyKTtcbiAgICBjb25zdCB7IHJvb206IHJvb20yLCBsZWF2ZSB9ID0gcGFpcjtcbiAgICBpZiAoZnJvemVuUHJvcHMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIHJvb20yLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxlYXZlKCk7XG4gICAgfTtcbiAgfSwgW3Jvb21JZCwgZnJvemVuUHJvcHMsIHN0YWJsZUVudGVyUm9vbV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIoUm9vbUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHJvb20sIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIHVzZVJvb20oKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tT3JOdWxsKCk7XG4gIGlmIChyb29tID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbVByb3ZpZGVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIik7XG4gIH1cbiAgcmV0dXJuIHJvb207XG59XG5mdW5jdGlvbiB1c2VTdGF0dXMoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmU7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRTdGF0dXM7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gcm9vbS5nZXRTdGF0dXM7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xufVxuZnVuY3Rpb24gdXNlUmVwb3J0VGV4dEVkaXRvcihlZGl0b3IsIHJvb3RLZXkpIHtcbiAgY29uc3QgaXNSZXBvcnRlZCA9IHVzZVJlZjMoZmFsc2UpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICBpZiAoaXNSZXBvcnRlZC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZSgoc3RhdHVzKSA9PiB7XG4gICAgICBpZiAoc3RhdHVzID09PSBcImNvbm5lY3RlZFwiICYmICFpc1JlcG9ydGVkLmN1cnJlbnQpIHtcbiAgICAgICAgaXNSZXBvcnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgdm9pZCByb29tW2tJbnRlcm5hbDNdLnJlcG9ydFRleHRFZGl0b3IoZWRpdG9yLCByb290S2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIFtyb29tLCBlZGl0b3IsIHJvb3RLZXldKTtcbn1cbmZ1bmN0aW9uIHVzZVlqc1Byb3ZpZGVyKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSB1c2VDYWxsYmFjazMoXG4gICAgKG9uU3RvcmVDaGFuZ2UpID0+IHtcbiAgICAgIHJldHVybiByb29tW2tJbnRlcm5hbDNdLnlqc1Byb3ZpZGVyRGlkQ2hhbmdlLnN1YnNjcmliZShvblN0b3JlQ2hhbmdlKTtcbiAgICB9LFxuICAgIFtyb29tXVxuICApO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHVzZUNhbGxiYWNrMygoKSA9PiB7XG4gICAgcmV0dXJuIHJvb21ba0ludGVybmFsM10uZ2V0WWpzUHJvdmlkZXIoKTtcbiAgfSwgW3Jvb21dKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTbmFwc2hvdCk7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVUZXh0TWVudGlvbigpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAodXNlcklkLCBtZW50aW9uSWQpID0+IHtcbiAgICAgIHJvb21ba0ludGVybmFsM10uY3JlYXRlVGV4dE1lbnRpb24odXNlcklkLCBtZW50aW9uSWQpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZTMuZXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBjcmVhdGUgdGV4dCBtZW50aW9uIGZvciB1c2VyICcke3VzZXJJZH0nIGFuZCBtZW50aW9uICcke21lbnRpb25JZH0nYCxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW3Jvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVUZXh0TWVudGlvbigpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAobWVudGlvbklkKSA9PiB7XG4gICAgICByb29tW2tJbnRlcm5hbDNdLmRlbGV0ZVRleHRNZW50aW9uKG1lbnRpb25JZCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlMy5lcnJvcihgQ2Fubm90IGRlbGV0ZSB0ZXh0IG1lbnRpb24gJyR7bWVudGlvbklkfSdgLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBbcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gY2xpZW50W2tJbnRlcm5hbDNdLnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnM7XG59XG5mdW5jdGlvbiB1c2VNZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiBjbGllbnRba0ludGVybmFsM10ubWVudGlvblN1Z2dlc3Rpb25zQ2FjaGU7XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3RhdHVzKG9wdGlvbnMpIHtcbiAgY29uc3Qgc21vb3RoID0gdXNlSW5pdGlhbChvcHRpb25zPy5zbW9vdGggPz8gZmFsc2UpO1xuICBpZiAoc21vb3RoKSB7XG4gICAgcmV0dXJuIHVzZVN0b3JhZ2VTdGF0dXNTbW9vdGgoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdXNlU3RvcmFnZVN0YXR1c0ltbWVkaWF0ZSgpO1xuICB9XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3RhdHVzSW1tZWRpYXRlKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5zdG9yYWdlU3RhdHVzLnN1YnNjcmliZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFN0b3JhZ2VTdGF0dXM7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gcm9vbS5nZXRTdG9yYWdlU3RhdHVzO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUzKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VTdGF0dXNTbW9vdGgoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZTIocm9vbS5nZXRTdG9yYWdlU3RhdHVzKTtcbiAgY29uc3Qgb2xkU3RhdHVzID0gdXNlTGF0ZXN0KHJvb20uZ2V0U3RvcmFnZVN0YXR1cygpKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCB1bnN1YiA9IHJvb20uZXZlbnRzLnN0b3JhZ2VTdGF0dXMuc3Vic2NyaWJlKChuZXdTdGF0dXMpID0+IHtcbiAgICAgIGlmIChvbGRTdGF0dXMuY3VycmVudCA9PT0gXCJzeW5jaHJvbml6aW5nXCIgJiYgbmV3U3RhdHVzID09PSBcInN5bmNocm9uaXplZFwiKSB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0U3RhdHVzKG5ld1N0YXR1cyksIGNvbmZpZy5TTU9PVEhfREVMQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIHNldFN0YXR1cyhuZXdTdGF0dXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHVuc3ViKCk7XG4gICAgfTtcbiAgfSwgW3Jvb20sIG9sZFN0YXR1c10pO1xuICByZXR1cm4gc3RhdHVzO1xufVxuZnVuY3Rpb24gdXNlQmF0Y2goKSB7XG4gIHJldHVybiB1c2VSb29tKCkuYmF0Y2g7XG59XG5mdW5jdGlvbiB1c2VCcm9hZGNhc3RFdmVudCgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAoZXZlbnQsIG9wdGlvbnMgPSB7IHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZSB9KSA9PiB7XG4gICAgICByb29tLmJyb2FkY2FzdEV2ZW50KGV2ZW50LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIFtyb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gIHVzZUVmZmVjdDUoXG4gICAgKCkgPT4gcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZSgoZXZlbnQpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudCkpLFxuICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcihjYWxsYmFjaykge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgdXNlRWZmZWN0NShcbiAgICAoKSA9PiByb29tLmV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAoZXZlbnQpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudClcbiAgICApLFxuICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcihjYWxsYmFjaykge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnREYXRhKSA9PiB7XG4gICAgICBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZXZlbnREYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiByb29tLmV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICB9LCBbcm9vbSwgc2F2ZWRDYWxsYmFja10pO1xufVxuZnVuY3Rpb24gdXNlSGlzdG9yeSgpIHtcbiAgcmV0dXJuIHVzZVJvb20oKS5oaXN0b3J5O1xufVxuZnVuY3Rpb24gdXNlVW5kbygpIHtcbiAgcmV0dXJuIHVzZUhpc3RvcnkoKS51bmRvO1xufVxuZnVuY3Rpb24gdXNlUmVkbygpIHtcbiAgcmV0dXJuIHVzZUhpc3RvcnkoKS5yZWRvO1xufVxuZnVuY3Rpb24gdXNlQ2FuVW5kbygpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuaGlzdG9yeS5zdWJzY3JpYmU7XG4gIGNvbnN0IGNhblVuZG8gPSByb29tLmhpc3RvcnkuY2FuVW5kbztcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUsIGNhblVuZG8sIGNhblVuZG8pO1xufVxuZnVuY3Rpb24gdXNlQ2FuUmVkbygpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuaGlzdG9yeS5zdWJzY3JpYmU7XG4gIGNvbnN0IGNhblJlZG8gPSByb29tLmhpc3RvcnkuY2FuUmVkbztcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUsIGNhblJlZG8sIGNhblJlZG8pO1xufVxuZnVuY3Rpb24gdXNlU2VsZihtYXliZVNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0U2VsZjtcbiAgY29uc3Qgc2VsZWN0b3IgPSBtYXliZVNlbGVjdG9yID8/IGlkZW50aXR5MztcbiAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gdXNlQ2FsbGJhY2szKFxuICAgIChtZSkgPT4gbWUgIT09IG51bGwgPyBzZWxlY3RvcihtZSkgOiBudWxsLFxuICAgIFtzZWxlY3Rvcl1cbiAgKTtcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNOdWxsO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgc3Vic2NyaWJlLFxuICAgIGdldFNuYXBzaG90LFxuICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNeVByZXNlbmNlKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5teVByZXNlbmNlLnN1YnNjcmliZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFByZXNlbmNlO1xuICBjb25zdCBwcmVzZW5jZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTbmFwc2hvdCk7XG4gIGNvbnN0IHNldFByZXNlbmNlID0gcm9vbS51cGRhdGVQcmVzZW5jZTtcbiAgcmV0dXJuIFtwcmVzZW5jZSwgc2V0UHJlc2VuY2VdO1xufVxuZnVuY3Rpb24gdXNlVXBkYXRlTXlQcmVzZW5jZSgpIHtcbiAgcmV0dXJuIHVzZVJvb20oKS51cGRhdGVQcmVzZW5jZTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVycyhzZWxlY3RvciwgaXNFcXVhbCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0T3RoZXJzO1xuICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c0VtcHR5TGlzdDtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHN1YnNjcmliZSxcbiAgICBnZXRTbmFwc2hvdCxcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICBzZWxlY3RvciA/PyBpZGVudGl0eTMsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzTWFwcGVkKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpIHtcbiAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gdXNlQ2FsbGJhY2szKFxuICAgIChvdGhlcnMpID0+IG90aGVycy5tYXAoKG90aGVyKSA9PiBbb3RoZXIuY29ubmVjdGlvbklkLCBpdGVtU2VsZWN0b3Iob3RoZXIpXSksXG4gICAgW2l0ZW1TZWxlY3Rvcl1cbiAgKTtcbiAgY29uc3Qgd3JhcHBlZElzRXF1YWwgPSB1c2VDYWxsYmFjazMoXG4gICAgKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGVxID0gaXRlbUlzRXF1YWwgPz8gT2JqZWN0LmlzO1xuICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChhdHVwbGUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGJ0dXBsZSA9IGJbaW5kZXhdO1xuICAgICAgICByZXR1cm4gYXR1cGxlWzBdID09PSBidHVwbGVbMF0gJiYgZXEoYXR1cGxlWzFdLCBidHVwbGVbMV0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBbaXRlbUlzRXF1YWxdXG4gICk7XG4gIHJldHVybiB1c2VPdGhlcnMod3JhcHBlZFNlbGVjdG9yLCB3cmFwcGVkSXNFcXVhbCk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCkge1xuICByZXR1cm4gdXNlT3RoZXJzKHNlbGVjdG9yRm9yX3VzZU90aGVyc0Nvbm5lY3Rpb25JZHMsIHNoYWxsb3c1KTtcbn1cbnZhciBOT1RfRk9VTkQgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIHVzZU90aGVyKGNvbm5lY3Rpb25JZCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gdXNlQ2FsbGJhY2szKFxuICAgIChvdGhlcnMpID0+IHtcbiAgICAgIGNvbnN0IG90aGVyMiA9IG90aGVycy5maW5kKChvdGhlcjMpID0+IG90aGVyMy5jb25uZWN0aW9uSWQgPT09IGNvbm5lY3Rpb25JZCk7XG4gICAgICByZXR1cm4gb3RoZXIyICE9PSB2b2lkIDAgPyBzZWxlY3RvcihvdGhlcjIpIDogTk9UX0ZPVU5EO1xuICAgIH0sXG4gICAgW2Nvbm5lY3Rpb25JZCwgc2VsZWN0b3JdXG4gICk7XG4gIGNvbnN0IHdyYXBwZWRJc0VxdWFsID0gdXNlQ2FsbGJhY2szKFxuICAgIChwcmV2LCBjdXJyKSA9PiB7XG4gICAgICBpZiAocHJldiA9PT0gTk9UX0ZPVU5EIHx8IGN1cnIgPT09IE5PVF9GT1VORCkge1xuICAgICAgICByZXR1cm4gcHJldiA9PT0gY3VycjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVxID0gaXNFcXVhbCA/PyBPYmplY3QuaXM7XG4gICAgICByZXR1cm4gZXEocHJldiwgY3Vycik7XG4gICAgfSxcbiAgICBbaXNFcXVhbF1cbiAgKTtcbiAgY29uc3Qgb3RoZXIgPSB1c2VPdGhlcnMod3JhcHBlZFNlbGVjdG9yLCB3cmFwcGVkSXNFcXVhbCk7XG4gIGlmIChvdGhlciA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE5vIHN1Y2ggb3RoZXIgdXNlciB3aXRoIGNvbm5lY3Rpb24gaWQgJHtjb25uZWN0aW9uSWR9IGV4aXN0c2BcbiAgICApO1xuICB9XG4gIHJldHVybiBvdGhlcjtcbn1cbmZ1bmN0aW9uIHVzZU11dGFibGVTdG9yYWdlUm9vdCgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RvcmFnZURpZExvYWQuc3Vic2NyaWJlT25jZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdDtcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNOdWxsO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUzKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VSb290KCkge1xuICByZXR1cm4gW3VzZU11dGFibGVTdG9yYWdlUm9vdCgpXTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgcm9vdE9yTnVsbCA9IHVzZU11dGFibGVTdG9yYWdlUm9vdCgpO1xuICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSB1c2VDYWxsYmFjazMoXG4gICAgKHJvb3RPck51bGwyKSA9PiByb290T3JOdWxsMiAhPT0gbnVsbCA/IHNlbGVjdG9yKHJvb3RPck51bGwyKSA6IG51bGwsXG4gICAgW3NlbGVjdG9yXVxuICApO1xuICBjb25zdCBzdWJzY3JpYmUgPSB1c2VDYWxsYmFjazMoXG4gICAgKG9uU3RvcmVDaGFuZ2UpID0+IHJvb3RPck51bGwgIT09IG51bGwgPyByb29tLnN1YnNjcmliZShyb290T3JOdWxsLCBvblN0b3JlQ2hhbmdlLCB7IGlzRGVlcDogdHJ1ZSB9KSA6IG5vb3AzLFxuICAgIFtyb29tLCByb290T3JOdWxsXVxuICApO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHVzZUNhbGxiYWNrMygoKSA9PiB7XG4gICAgaWYgKHJvb3RPck51bGwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb290ID0gcm9vdE9yTnVsbDtcbiAgICAgIGNvbnN0IGltbSA9IHJvb3QudG9JbW11dGFibGUoKTtcbiAgICAgIHJldHVybiBpbW07XG4gICAgfVxuICB9LCBbcm9vdE9yTnVsbF0pO1xuICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U25hcHNob3QsXG4gICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU11dGF0aW9uKGNhbGxiYWNrLCBkZXBzKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiB1c2VNZW1vMyhcbiAgICAoKSA9PiB7XG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgIHJvb20uYmF0Y2goXG4gICAgICAgICAgKCkgPT4gKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgbWFrZU11dGF0aW9uQ29udGV4dChyb29tKSxcbiAgICAgICAgICAgICAgLi4uYXJnc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbcm9vbSwgLi4uZGVwc11cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVRocmVhZHMob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgc2Nyb2xsT25Mb2FkID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHsgc3RvcmUsIGdldE9yQ3JlYXRlVGhyZWFkc1BvbGxlckZvclJvb21JZCB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBxdWVyeUtleSA9IG1ha2VSb29tVGhyZWFkc1F1ZXJ5S2V5KHJvb20uaWQsIG9wdGlvbnMucXVlcnkpO1xuICBjb25zdCBwb2xsZXIgPSBnZXRPckNyZWF0ZVRocmVhZHNQb2xsZXJGb3JSb29tSWQocm9vbS5pZCk7XG4gIHVzZUVmZmVjdDUoXG4gICAgKCkgPT4gdm9pZCBzdG9yZS5vdXRwdXRzLmxvYWRpbmdSb29tVGhyZWFkcy5nZXRPckNyZWF0ZShxdWVyeUtleSkud2FpdFVudGlsTG9hZGVkKClcbiAgICAvLyBOT1RFOiBEZWxpYmVyYXRlbHkgKm5vdCogdXNpbmcgYSBkZXBlbmRlbmN5IGFycmF5IGhlcmUhXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCB3YWl0VW50aWwgb24gKmV2ZXJ5KiByZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBoYXJtbGVzcyB0aG91Z2gsIG9uIG1vc3QgcmVuZGVycywgZXhjZXB0OlxuICAgIC8vIDEuIFRoZSB2ZXJ5IGZpcnN0IHJlbmRlciwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHRyaWdnZXIgdGhlIGluaXRpYWwgcGFnZSBmZXRjaC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBcImp1c3RcIiByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZSAoYSBxdWljayBvcGVyYXRpb24pLlxuICAgIC8vIDMuIElmIGV2ZXIgdGhlIHByb21pc2Ugd291bGQgZmFpbCwgdGhlbiBhZnRlciA1IHNlY29uZHMgaXQgd291bGQgcmVzZXQsIGFuZCBvbiB0aGUgdmVyeVxuICAgIC8vICAgICpuZXh0KiByZW5kZXIgYWZ0ZXIgdGhhdCwgYSAqbmV3KiBmZXRjaC9wcm9taXNlIHdpbGwgZ2V0IGNyZWF0ZWQuXG4gICk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIHBvbGxlci5pbmMoKTtcbiAgICBwb2xsZXIucG9sbE5vd0lmU3RhbGUoKTtcbiAgICByZXR1cm4gKCkgPT4gcG9sbGVyLmRlYygpO1xuICB9LCBbcG9sbGVyXSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVNpZ25hbChcbiAgICBzdG9yZS5vdXRwdXRzLmxvYWRpbmdSb29tVGhyZWFkcy5nZXRPckNyZWF0ZShxdWVyeUtleSkuc2lnbmFsXG4gICk7XG4gIHVzZVNjcm9sbFRvQ29tbWVudE9uTG9hZEVmZmVjdChzY3JvbGxPbkxvYWQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVUaHJlYWQoKSB7XG4gIHJldHVybiB1c2VDcmVhdGVSb29tVGhyZWFkKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVSb29tVGhyZWFkKHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YSA/PyB7fTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRzID0gb3B0aW9ucy5hdHRhY2htZW50cztcbiAgICAgIGNvbnN0IHRocmVhZElkID0gY3JlYXRlVGhyZWFkSWQoKTtcbiAgICAgIGNvbnN0IGNvbW1lbnRJZCA9IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBuZXdDb21tZW50ID0ge1xuICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgcm9vbUlkLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIHR5cGU6IFwiY29tbWVudFwiLFxuICAgICAgICB1c2VySWQ6IGdldEN1cnJlbnRVc2VySWQoY2xpZW50KSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgcmVhY3Rpb25zOiBbXSxcbiAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzID8/IFtdXG4gICAgICB9O1xuICAgICAgY29uc3QgbmV3VGhyZWFkID0ge1xuICAgICAgICBpZDogdGhyZWFkSWQsXG4gICAgICAgIHR5cGU6IFwidGhyZWFkXCIsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgdXBkYXRlZEF0OiBjcmVhdGVkQXQsXG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGNvbW1lbnRzOiBbbmV3Q29tbWVudF0sXG4gICAgICAgIHJlc29sdmVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgICB0eXBlOiBcImNyZWF0ZS10aHJlYWRcIixcbiAgICAgICAgdGhyZWFkOiBuZXdUaHJlYWQsXG4gICAgICAgIHJvb21JZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBhdHRhY2htZW50SWRzID0gYXR0YWNobWVudHM/Lm1hcCgoYXR0YWNobWVudCkgPT4gYXR0YWNobWVudC5pZCk7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uaHR0cENsaWVudC5jcmVhdGVUaHJlYWQoe1xuICAgICAgICByb29tSWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICBjb21tZW50SWQsXG4gICAgICAgIGJvZHksXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBhdHRhY2htZW50SWRzXG4gICAgICB9KS50aGVuKFxuICAgICAgICAodGhyZWFkKSA9PiB7XG4gICAgICAgICAgc3RvcmUuY3JlYXRlVGhyZWFkKG9wdGltaXN0aWNJZCwgdGhyZWFkKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQ1JFQVRFX1RIUkVBRF9FUlJPUlwiLFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ld1RocmVhZDtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZVRocmVhZCgpIHtcbiAgcmV0dXJuIHVzZURlbGV0ZVJvb21UaHJlYWQodXNlUm9vbSgpLmlkKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZVJvb21UaHJlYWQocm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgICh0aHJlYWRJZCkgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGdldEN1cnJlbnRVc2VySWQoY2xpZW50KTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gc3RvcmUub3V0cHV0cy50aHJlYWRzLmdldCgpLmdldCh0aHJlYWRJZCk7XG4gICAgICBpZiAoZXhpc3Rpbmc/LmNvbW1lbnRzPy5bMF0/LnVzZXJJZCAhPT0gdXNlcklkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgdGhlIHRocmVhZCBjcmVhdG9yIGNhbiBkZWxldGUgdGhlIHRocmVhZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwiZGVsZXRlLXRocmVhZFwiLFxuICAgICAgICByb29tSWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICBkZWxldGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICB9KTtcbiAgICAgIGNsaWVudFtrSW50ZXJuYWwzXS5odHRwQ2xpZW50LmRlbGV0ZVRocmVhZCh7IHJvb21JZCwgdGhyZWFkSWQgfSkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLmRlbGV0ZVRocmVhZCh0aHJlYWRJZCwgb3B0aW1pc3RpY0lkKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgIHsgdHlwZTogXCJERUxFVEVfVEhSRUFEX0VSUk9SXCIsIHJvb21JZCwgdGhyZWFkSWQgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSgpIHtcbiAgcmV0dXJuIHVzZUVkaXRSb29tVGhyZWFkTWV0YWRhdGEodXNlUm9vbSgpLmlkKTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRSb29tVGhyZWFkTWV0YWRhdGEocm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgIChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbnMubWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGhyZWFkSWQgPSBvcHRpb25zLnRocmVhZElkO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBvcHRpb25zLm1ldGFkYXRhO1xuICAgICAgY29uc3QgdXBkYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJlZGl0LXRocmVhZC1tZXRhZGF0YVwiLFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIHVwZGF0ZWRBdFxuICAgICAgfSk7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uaHR0cENsaWVudC5lZGl0VGhyZWFkTWV0YWRhdGEoeyByb29tSWQsIHRocmVhZElkLCBtZXRhZGF0YSB9KS50aGVuKFxuICAgICAgICAobWV0YWRhdGEyKSA9PiAoXG4gICAgICAgICAgLy8gUmVwbGFjZSB0aGUgb3B0aW1pc3RpYyB1cGRhdGUgYnkgdGhlIHJlYWwgdGhpbmdcbiAgICAgICAgICBzdG9yZS5wYXRjaFRocmVhZCh0aHJlYWRJZCwgb3B0aW1pc3RpY0lkLCB7IG1ldGFkYXRhOiBtZXRhZGF0YTIgfSwgdXBkYXRlZEF0KVxuICAgICAgICApLFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJFRElUX1RIUkVBRF9NRVRBREFUQV9FUlJPUlwiLFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tSWRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVDb21tZW50KCkge1xuICByZXR1cm4gdXNlQ3JlYXRlUm9vbUNvbW1lbnQodXNlUm9vbSgpLmlkKTtcbn1cbmZ1bmN0aW9uIHVzZUNyZWF0ZVJvb21Db21tZW50KHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAoeyB0aHJlYWRJZCwgYm9keSwgYXR0YWNobWVudHMgfSkgPT4ge1xuICAgICAgY29uc3QgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IGNvbW1lbnQgPSB7XG4gICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICByb29tSWQsXG4gICAgICAgIHR5cGU6IFwiY29tbWVudFwiLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIHVzZXJJZDogZ2V0Q3VycmVudFVzZXJJZChjbGllbnQpLFxuICAgICAgICBib2R5LFxuICAgICAgICByZWFjdGlvbnM6IFtdLFxuICAgICAgICBhdHRhY2htZW50czogYXR0YWNobWVudHMgPz8gW11cbiAgICAgIH07XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJjcmVhdGUtY29tbWVudFwiLFxuICAgICAgICBjb21tZW50XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRJZHMgPSBhdHRhY2htZW50cz8ubWFwKChhdHRhY2htZW50KSA9PiBhdHRhY2htZW50LmlkKTtcbiAgICAgIGNsaWVudFtrSW50ZXJuYWwzXS5odHRwQ2xpZW50LmNyZWF0ZUNvbW1lbnQoeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQsIGJvZHksIGF0dGFjaG1lbnRJZHMgfSkudGhlbihcbiAgICAgICAgKG5ld0NvbW1lbnQpID0+IHtcbiAgICAgICAgICBzdG9yZS5jcmVhdGVDb21tZW50KG5ld0NvbW1lbnQsIG9wdGltaXN0aWNJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIkNSRUFURV9DT01NRU5UX0VSUk9SXCIsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tSWRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VFZGl0Q29tbWVudCgpIHtcbiAgcmV0dXJuIHVzZUVkaXRSb29tQ29tbWVudCh1c2VSb29tKCkuaWQpO1xufVxuZnVuY3Rpb24gdXNlRWRpdFJvb21Db21tZW50KHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5LCBhdHRhY2htZW50cyB9KSA9PiB7XG4gICAgICBjb25zdCBlZGl0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gc3RvcmUub3V0cHV0cy50aHJlYWRzLmdldCgpLmdldEV2ZW5JZkRlbGV0ZWQodGhyZWFkSWQpO1xuICAgICAgaWYgKGV4aXN0aW5nID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc29sZTMud2FybihcbiAgICAgICAgICBgSW50ZXJuYWwgdW5leHBlY3RlZCBiZWhhdmlvci4gQ2Fubm90IGVkaXQgY29tbWVudCBpbiB0aHJlYWQgXCIke3RocmVhZElkfVwiIGJlY2F1c2UgdGhlIHRocmVhZCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGUuYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjb21tZW50ID0gZXhpc3RpbmcuY29tbWVudHMuZmluZChcbiAgICAgICAgKGNvbW1lbnQyKSA9PiBjb21tZW50Mi5pZCA9PT0gY29tbWVudElkXG4gICAgICApO1xuICAgICAgaWYgKGNvbW1lbnQgPT09IHZvaWQgMCB8fCBjb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnNvbGUzLndhcm4oXG4gICAgICAgICAgYEludGVybmFsIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIENhbm5vdCBlZGl0IGNvbW1lbnQgXCIke2NvbW1lbnRJZH1cIiBpbiB0aHJlYWQgXCIke3RocmVhZElkfVwiIGJlY2F1c2UgdGhlIGNvbW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJlZGl0LWNvbW1lbnRcIixcbiAgICAgICAgY29tbWVudDoge1xuICAgICAgICAgIC4uLmNvbW1lbnQsXG4gICAgICAgICAgZWRpdGVkQXQsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBhdHRhY2htZW50czogYXR0YWNobWVudHMgPz8gW11cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBhdHRhY2htZW50SWRzID0gYXR0YWNobWVudHM/Lm1hcCgoYXR0YWNobWVudCkgPT4gYXR0YWNobWVudC5pZCk7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uaHR0cENsaWVudC5lZGl0Q29tbWVudCh7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSwgYXR0YWNobWVudElkcyB9KS50aGVuKFxuICAgICAgICAoZWRpdGVkQ29tbWVudCkgPT4ge1xuICAgICAgICAgIHN0b3JlLmVkaXRDb21tZW50KHRocmVhZElkLCBvcHRpbWlzdGljSWQsIGVkaXRlZENvbW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAgeyB0eXBlOiBcIkVESVRfQ09NTUVOVF9FUlJPUlwiLCByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQsIGJvZHkgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZUNvbW1lbnQoKSB7XG4gIHJldHVybiB1c2VEZWxldGVSb29tQ29tbWVudCh1c2VSb29tKCkuaWQpO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlUm9vbUNvbW1lbnQocm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgICh7IHRocmVhZElkLCBjb21tZW50SWQgfSkgPT4ge1xuICAgICAgY29uc3QgZGVsZXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJkZWxldGUtY29tbWVudFwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudElkLFxuICAgICAgICBkZWxldGVkQXQsXG4gICAgICAgIHJvb21JZFxuICAgICAgfSk7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uaHR0cENsaWVudC5kZWxldGVDb21tZW50KHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkIH0pLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5kZWxldGVDb21tZW50KHRocmVhZElkLCBvcHRpbWlzdGljSWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgIHsgdHlwZTogXCJERUxFVEVfQ09NTUVOVF9FUlJPUlwiLCByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUFkZFJlYWN0aW9uKCkge1xuICByZXR1cm4gdXNlQWRkUm9vbUNvbW1lbnRSZWFjdGlvbih1c2VSb29tKCkuaWQpO1xufVxuZnVuY3Rpb24gdXNlQWRkUm9vbUNvbW1lbnRSZWFjdGlvbihyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkgPT4ge1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKGNsaWVudCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJhZGQtcmVhY3Rpb25cIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgcmVhY3Rpb246IHtcbiAgICAgICAgICBlbW9qaSxcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2xpZW50W2tJbnRlcm5hbDNdLmh0dHBDbGllbnQuYWRkUmVhY3Rpb24oeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pLnRoZW4oXG4gICAgICAgIChhZGRlZFJlYWN0aW9uKSA9PiB7XG4gICAgICAgICAgc3RvcmUuYWRkUmVhY3Rpb24oXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGFkZGVkUmVhY3Rpb24sXG4gICAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJBRERfUkVBQ1RJT05fRVJST1JcIixcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgZW1vamlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlUmVtb3ZlUmVhY3Rpb24oKSB7XG4gIHJldHVybiB1c2VSZW1vdmVSb29tQ29tbWVudFJlYWN0aW9uKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VSZW1vdmVSb29tQ29tbWVudFJlYWN0aW9uKHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKGNsaWVudCk7XG4gICAgICBjb25zdCByZW1vdmVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgICB0eXBlOiBcInJlbW92ZS1yZWFjdGlvblwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudElkLFxuICAgICAgICBlbW9qaSxcbiAgICAgICAgdXNlcklkLFxuICAgICAgICByZW1vdmVkQXRcbiAgICAgIH0pO1xuICAgICAgY2xpZW50W2tJbnRlcm5hbDNdLmh0dHBDbGllbnQucmVtb3ZlUmVhY3Rpb24oeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5yZW1vdmVSZWFjdGlvbihcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgZW1vamksXG4gICAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgICByZW1vdmVkQXRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJSRU1PVkVfUkVBQ1RJT05fRVJST1JcIixcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgZW1vamlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya1RocmVhZEFzUmVhZCgpIHtcbiAgcmV0dXJuIHVzZU1hcmtSb29tVGhyZWFkQXNSZWFkKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VNYXJrUm9vbVRocmVhZEFzUmVhZChyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHRocmVhZElkKSA9PiB7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKFxuICAgICAgICBzdG9yZS5vdXRwdXRzLm5vdGlmaWNhdGlvbnMuZ2V0KCkubm90aWZpY2F0aW9uc0J5SWRcbiAgICAgICkuZmluZChcbiAgICAgICAgKGluYm94Tm90aWZpY2F0aW9uMikgPT4gaW5ib3hOb3RpZmljYXRpb24yLmtpbmQgPT09IFwidGhyZWFkXCIgJiYgaW5ib3hOb3RpZmljYXRpb24yLnRocmVhZElkID09PSB0aHJlYWRJZFxuICAgICAgKTtcbiAgICAgIGlmICghaW5ib3hOb3RpZmljYXRpb24pIHJldHVybjtcbiAgICAgIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLWluYm94LW5vdGlmaWNhdGlvbi1hcy1yZWFkXCIsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQ6IGluYm94Tm90aWZpY2F0aW9uLmlkLFxuICAgICAgICByZWFkQXQ6IG5vd1xuICAgICAgfSk7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uaHR0cENsaWVudC5tYXJrUm9vbUluYm94Tm90aWZpY2F0aW9uQXNSZWFkKHtcbiAgICAgICAgcm9vbUlkLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkOiBpbmJveE5vdGlmaWNhdGlvbi5pZFxuICAgICAgfSkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLm1hcmtJbmJveE5vdGlmaWNhdGlvblJlYWQoXG4gICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbi5pZCxcbiAgICAgICAgICAgIG5vdyxcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJNQVJLX0lOQk9YX05PVElGSUNBVElPTl9BU19SRUFEX0VSUk9SXCIsXG4gICAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZDogaW5ib3hOb3RpZmljYXRpb24uaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU1hcmtUaHJlYWRBc1Jlc29sdmVkKCkge1xuICByZXR1cm4gdXNlTWFya1Jvb21UaHJlYWRBc1Jlc29sdmVkKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VNYXJrUm9vbVRocmVhZEFzUmVzb2x2ZWQocm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgICh0aHJlYWRJZCkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLXRocmVhZC1hcy1yZXNvbHZlZFwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgdXBkYXRlZEF0XG4gICAgICB9KTtcbiAgICAgIGNsaWVudFtrSW50ZXJuYWwzXS5odHRwQ2xpZW50Lm1hcmtUaHJlYWRBc1Jlc29sdmVkKHsgcm9vbUlkLCB0aHJlYWRJZCB9KS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUucGF0Y2hUaHJlYWQoXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICAgIHsgcmVzb2x2ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICB7IHR5cGU6IFwiTUFSS19USFJFQURfQVNfUkVTT0xWRURfRVJST1JcIiwgcm9vbUlkLCB0aHJlYWRJZCB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCgpIHtcbiAgcmV0dXJuIHVzZU1hcmtSb29tVGhyZWFkQXNVbnJlc29sdmVkKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VNYXJrUm9vbVRocmVhZEFzVW5yZXNvbHZlZChyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHRocmVhZElkKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgICB0eXBlOiBcIm1hcmstdGhyZWFkLWFzLXVucmVzb2x2ZWRcIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIHVwZGF0ZWRBdFxuICAgICAgfSk7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uaHR0cENsaWVudC5tYXJrVGhyZWFkQXNVbnJlc29sdmVkKHsgcm9vbUlkLCB0aHJlYWRJZCB9KS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUucGF0Y2hUaHJlYWQoXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICAgIHsgcmVzb2x2ZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB1cGRhdGVkQXRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAgeyB0eXBlOiBcIk1BUktfVEhSRUFEX0FTX1VOUkVTT0xWRURfRVJST1JcIiwgcm9vbUlkLCB0aHJlYWRJZCB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlVGhyZWFkU3Vic2NyaXB0aW9uKHRocmVhZElkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCB7IHN0b3JlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHNpZ25hbCA9IHN0b3JlLm91dHB1dHMudGhyZWFkaWZpY2F0aW9ucztcbiAgY29uc3Qgc2VsZWN0b3IgPSB1c2VDYWxsYmFjazMoXG4gICAgKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBub3RpZmljYXRpb24gPSBzdGF0ZS5zb3J0ZWROb3RpZmljYXRpb25zLmZpbmQoXG4gICAgICAgIChpbmJveE5vdGlmaWNhdGlvbikgPT4gaW5ib3hOb3RpZmljYXRpb24ua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBpbmJveE5vdGlmaWNhdGlvbi50aHJlYWRJZCA9PT0gdGhyZWFkSWRcbiAgICAgICk7XG4gICAgICBjb25zdCB0aHJlYWQgPSBzdGF0ZS50aHJlYWRzREIuZ2V0KHRocmVhZElkKTtcbiAgICAgIGlmIChub3RpZmljYXRpb24gPT09IHZvaWQgMCB8fCB0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwibm90LXN1YnNjcmliZWRcIiB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBcInN1YnNjcmliZWRcIixcbiAgICAgICAgdW5yZWFkU2luY2U6IG5vdGlmaWNhdGlvbi5yZWFkQXRcbiAgICAgIH07XG4gICAgfSxcbiAgICBbdGhyZWFkSWRdXG4gICk7XG4gIHJldHVybiB1c2VTaWduYWwoc2lnbmFsLCBzZWxlY3Rvciwgc2hhbGxvdzUpO1xufVxuZnVuY3Rpb24gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCkge1xuICBjb25zdCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MgPSB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKTtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHsgc3RvcmUsIGdldE9yQ3JlYXRlTm90aWZpY2F0aW9uc1NldHRpbmdzUG9sbGVyRm9yUm9vbUlkIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHBvbGxlciA9IGdldE9yQ3JlYXRlTm90aWZpY2F0aW9uc1NldHRpbmdzUG9sbGVyRm9yUm9vbUlkKHJvb20uaWQpO1xuICB1c2VFZmZlY3Q1KFxuICAgICgpID0+IHZvaWQgc3RvcmUub3V0cHV0cy5zZXR0aW5nc0J5Um9vbUlkLmdldE9yQ3JlYXRlKHJvb20uaWQpLndhaXRVbnRpbExvYWRlZCgpXG4gICAgLy8gTk9URTogRGVsaWJlcmF0ZWx5ICpub3QqIHVzaW5nIGEgZGVwZW5kZW5jeSBhcnJheSBoZXJlIVxuICAgIC8vXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNhbGwgd2FpdFVudGlsIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIHRoZSBpbml0aWFsIHBhZ2UgZmV0Y2guXG4gICAgLy8gMi4gQWxsIG90aGVyIHN1YnNlcXVlbnQgcmVuZGVycyBub3cgXCJqdXN0XCIgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UgKGEgcXVpY2sgb3BlcmF0aW9uKS5cbiAgICAvLyAzLiBJZiBldmVyIHRoZSBwcm9taXNlIHdvdWxkIGZhaWwsIHRoZW4gYWZ0ZXIgNSBzZWNvbmRzIGl0IHdvdWxkIHJlc2V0LCBhbmQgb24gdGhlIHZlcnlcbiAgICAvLyAgICAqbmV4dCogcmVuZGVyIGFmdGVyIHRoYXQsIGEgKm5ldyogZmV0Y2gvcHJvbWlzZSB3aWxsIGdldCBjcmVhdGVkLlxuICApO1xuICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICBwb2xsZXIuaW5jKCk7XG4gICAgcG9sbGVyLnBvbGxOb3dJZlN0YWxlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvbGxlci5kZWMoKTtcbiAgICB9O1xuICB9LCBbcG9sbGVyXSk7XG4gIGNvbnN0IHNldHRpbmdzID0gdXNlU2lnbmFsKFxuICAgIHN0b3JlLm91dHB1dHMuc2V0dGluZ3NCeVJvb21JZC5nZXRPckNyZWF0ZShyb29tLmlkKS5zaWduYWxcbiAgKTtcbiAgcmV0dXJuIHVzZU1lbW8zKCgpID0+IHtcbiAgICByZXR1cm4gW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdO1xuICB9LCBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc10pO1xufVxuZnVuY3Rpb24gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UoKSB7XG4gIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpLnN0b3JlO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICB1c2Uoc3RvcmUub3V0cHV0cy5zZXR0aW5nc0J5Um9vbUlkLmdldE9yQ3JlYXRlKHJvb20uaWQpLndhaXRVbnRpbExvYWRlZCgpKTtcbiAgY29uc3QgW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdID0gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gIGFzc2VydDIoIXNldHRpbmdzLmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICBhc3NlcnQyKCFzZXR0aW5ncy5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgcmV0dXJuIHVzZU1lbW8zKCgpID0+IHtcbiAgICByZXR1cm4gW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdO1xuICB9LCBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc10pO1xufVxuZnVuY3Rpb24gdXNlSGlzdG9yeVZlcnNpb25EYXRhKHZlcnNpb25JZCkge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlMih7XG4gICAgaXNMb2FkaW5nOiB0cnVlXG4gIH0pO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICBzZXRTdGF0ZSh7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICBjb25zdCBsb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByb29tW2tJbnRlcm5hbDNdLmdldFRleHRWZXJzaW9uKHZlcnNpb25JZCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nIHRoaXMgdmVyc2lvblwiXG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZvaWQgbG9hZCgpO1xuICB9LCBbcm9vbSwgdmVyc2lvbklkXSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZUhpc3RvcnlWZXJzaW9ucygpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHsgc3RvcmUsIGdldE9yQ3JlYXRlVmVyc2lvbnNQb2xsZXJGb3JSb29tSWQgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgcG9sbGVyID0gZ2V0T3JDcmVhdGVWZXJzaW9uc1BvbGxlckZvclJvb21JZChyb29tLmlkKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgcG9sbGVyLmluYygpO1xuICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgIHJldHVybiAoKSA9PiBwb2xsZXIuZGVjKCk7XG4gIH0sIFtwb2xsZXJdKTtcbiAgdXNlRWZmZWN0NShcbiAgICAoKSA9PiB2b2lkIHN0b3JlLm91dHB1dHMudmVyc2lvbnNCeVJvb21JZC5nZXRPckNyZWF0ZShyb29tLmlkKS53YWl0VW50aWxMb2FkZWQoKVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIHdhaXRVbnRpbCBvbiAqZXZlcnkqIHJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGhhcm1sZXNzIHRob3VnaCwgb24gbW9zdCByZW5kZXJzLCBleGNlcHQ6XG4gICAgLy8gMS4gVGhlIHZlcnkgZmlyc3QgcmVuZGVyLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gdHJpZ2dlciB0aGUgaW5pdGlhbCBwYWdlIGZldGNoLlxuICAgIC8vIDIuIEFsbCBvdGhlciBzdWJzZXF1ZW50IHJlbmRlcnMgbm93IFwianVzdFwiIHJldHVybiB0aGUgc2FtZSBwcm9taXNlIChhIHF1aWNrIG9wZXJhdGlvbikuXG4gICAgLy8gMy4gSWYgZXZlciB0aGUgcHJvbWlzZSB3b3VsZCBmYWlsLCB0aGVuIGFmdGVyIDUgc2Vjb25kcyBpdCB3b3VsZCByZXNldCwgYW5kIG9uIHRoZSB2ZXJ5XG4gICAgLy8gICAgKm5leHQqIHJlbmRlciBhZnRlciB0aGF0LCBhICpuZXcqIGZldGNoL3Byb21pc2Ugd2lsbCBnZXQgY3JlYXRlZC5cbiAgKTtcbiAgcmV0dXJuIHVzZVNpZ25hbChzdG9yZS5vdXRwdXRzLnZlcnNpb25zQnlSb29tSWQuZ2V0T3JDcmVhdGUocm9vbS5pZCkuc2lnbmFsKTtcbn1cbmZ1bmN0aW9uIHVzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlKCkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdG9yZSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KS5zdG9yZTtcbiAgdXNlKHN0b3JlLm91dHB1dHMudmVyc2lvbnNCeVJvb21JZC5nZXRPckNyZWF0ZShyb29tLmlkKS53YWl0VW50aWxMb2FkZWQoKSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZUhpc3RvcnlWZXJzaW9ucygpO1xuICBhc3NlcnQyKCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIGFzc2VydDIoIXJlc3VsdC5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHNldHRpbmdzKSA9PiB7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGUtbm90aWZpY2F0aW9uLXNldHRpbmdzXCIsXG4gICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgc2V0dGluZ3NcbiAgICAgIH0pO1xuICAgICAgcm9vbS51cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykudGhlbihcbiAgICAgICAgKHNldHRpbmdzMikgPT4ge1xuICAgICAgICAgIHN0b3JlLnVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyhyb29tLmlkLCBvcHRpbWlzdGljSWQsIHNldHRpbmdzMik7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICB7IHR5cGU6IFwiVVBEQVRFX05PVElGSUNBVElPTl9TRVRUSU5HU19FUlJPUlwiLCByb29tSWQ6IHJvb20uaWQgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHVzZShyb29tLndhaXRVbnRpbFByZXNlbmNlUmVhZHkoKSk7XG59XG5mdW5jdGlvbiB1c2VTZWxmU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VSZWFkeSgpO1xuICByZXR1cm4gdXNlU2VsZihcbiAgICBzZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcnMoXG4gICAgc2VsZWN0b3IsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlKCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZShpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZU90aGVyc01hcHBlZChpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyU3VzcGVuc2UoY29ubmVjdGlvbklkLCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcihjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VSZWFkeSgpIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICB1c2Uocm9vbS53YWl0VW50aWxTdG9yYWdlUmVhZHkoKSk7XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgdXNlU3VzcGVuZFVudGlsU3RvcmFnZVJlYWR5KCk7XG4gIHJldHVybiB1c2VTdG9yYWdlKFxuICAgIHNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VTdGF0dXNTdXNwZW5zZShvcHRpb25zKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VSZWFkeSgpO1xuICByZXR1cm4gdXNlU3RvcmFnZVN0YXR1cyhvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHVzZVRocmVhZHNTdXNwZW5zZShvcHRpb25zID0ge30pIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBxdWVyeUtleSA9IG1ha2VSb29tVGhyZWFkc1F1ZXJ5S2V5KHJvb20uaWQsIG9wdGlvbnMucXVlcnkpO1xuICB1c2Uoc3RvcmUub3V0cHV0cy5sb2FkaW5nUm9vbVRocmVhZHMuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLndhaXRVbnRpbExvYWRlZCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlVGhyZWFkcyhvcHRpb25zKTtcbiAgYXNzZXJ0MighcmVzdWx0LmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICBhc3NlcnQyKCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VBdHRhY2htZW50VXJsKHN0YXRlKSB7XG4gIGlmIChzdGF0ZSA9PT0gdm9pZCAwIHx8IHN0YXRlPy5pc0xvYWRpbmcpIHtcbiAgICByZXR1cm4gc3RhdGUgPz8geyBpc0xvYWRpbmc6IHRydWUgfTtcbiAgfVxuICBpZiAoc3RhdGUuZXJyb3IpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgYXNzZXJ0MihzdGF0ZS5kYXRhICE9PSB2b2lkIDAsIFwiVW5leHBlY3RlZCBtaXNzaW5nIGF0dGFjaG1lbnQgVVJMXCIpO1xuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgdXJsOiBzdGF0ZS5kYXRhXG4gIH07XG59XG5mdW5jdGlvbiB1c2VBdHRhY2htZW50VXJsKGF0dGFjaG1lbnRJZCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gdXNlUm9vbUF0dGFjaG1lbnRVcmwoYXR0YWNobWVudElkLCByb29tLmlkKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21BdHRhY2htZW50VXJsKGF0dGFjaG1lbnRJZCwgcm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCBzdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwzXS5odHRwQ2xpZW50LmdldE9yQ3JlYXRlQXR0YWNobWVudFVybHNTdG9yZShyb29tSWQpO1xuICBjb25zdCBnZXRBdHRhY2htZW50VXJsU3RhdGUgPSB1c2VDYWxsYmFjazMoXG4gICAgKCkgPT4gc3RvcmUuZ2V0SXRlbVN0YXRlKGF0dGFjaG1lbnRJZCksXG4gICAgW3N0b3JlLCBhdHRhY2htZW50SWRdXG4gICk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIHZvaWQgc3RvcmUuZW5xdWV1ZShhdHRhY2htZW50SWQpO1xuICB9LCBbc3RvcmUsIGF0dGFjaG1lbnRJZF0pO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldEF0dGFjaG1lbnRVcmxTdGF0ZSxcbiAgICBnZXRBdHRhY2htZW50VXJsU3RhdGUsXG4gICAgc2VsZWN0b3JGb3JfdXNlQXR0YWNobWVudFVybCxcbiAgICBzaGFsbG93NVxuICApO1xufVxuZnVuY3Rpb24gdXNlQXR0YWNobWVudFVybFN1c3BlbnNlKGF0dGFjaG1lbnRJZCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IGF0dGFjaG1lbnRVcmxzU3RvcmUgfSA9IHJvb21ba0ludGVybmFsM107XG4gIGNvbnN0IGdldEF0dGFjaG1lbnRVcmxTdGF0ZSA9IHVzZUNhbGxiYWNrMyhcbiAgICAoKSA9PiBhdHRhY2htZW50VXJsc1N0b3JlLmdldEl0ZW1TdGF0ZShhdHRhY2htZW50SWQpLFxuICAgIFthdHRhY2htZW50VXJsc1N0b3JlLCBhdHRhY2htZW50SWRdXG4gICk7XG4gIGNvbnN0IGF0dGFjaG1lbnRVcmxTdGF0ZSA9IGdldEF0dGFjaG1lbnRVcmxTdGF0ZSgpO1xuICBpZiAoIWF0dGFjaG1lbnRVcmxTdGF0ZSB8fCBhdHRhY2htZW50VXJsU3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgdGhyb3cgYXR0YWNobWVudFVybHNTdG9yZS5lbnF1ZXVlKGF0dGFjaG1lbnRJZCk7XG4gIH1cbiAgaWYgKGF0dGFjaG1lbnRVcmxTdGF0ZS5lcnJvcikge1xuICAgIHRocm93IGF0dGFjaG1lbnRVcmxTdGF0ZS5lcnJvcjtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhcbiAgICBhdHRhY2htZW50VXJsc1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRBdHRhY2htZW50VXJsU3RhdGUsXG4gICAgZ2V0QXR0YWNobWVudFVybFN0YXRlXG4gICk7XG4gIGFzc2VydDIoc3RhdGUgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3Npbmcgc3RhdGVcIik7XG4gIGFzc2VydDIoIXN0YXRlLmlzTG9hZGluZywgXCJVbmV4cGVjdGVkIGxvYWRpbmcgc3RhdGVcIik7XG4gIGFzc2VydDIoIXN0YXRlLmVycm9yLCBcIlVuZXhwZWN0ZWQgZXJyb3Igc3RhdGVcIik7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICB1cmw6IHN0YXRlLmRhdGEsXG4gICAgZXJyb3I6IHZvaWQgMFxuICB9O1xufVxudmFyIE5PX1BFUk1JU1NJT05TID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHVzZVJvb21QZXJtaXNzaW9ucyhyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpLnN0b3JlO1xuICByZXR1cm4gdXNlU2lnbmFsKFxuICAgIHN0b3JlLnBlcm1pc3Npb25IaW50cy5zaWduYWwsXG4gICAgKGhpbnRzKSA9PiBoaW50cy5nZXQocm9vbUlkKSA/PyBOT19QRVJNSVNTSU9OU1xuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbUNvbnRleHQoY2xpZW50KSB7XG4gIHJldHVybiBnZXRPckNyZWF0ZVJvb21Db250ZXh0QnVuZGxlKGNsaWVudCk7XG59XG52YXIgX1Jvb21Qcm92aWRlciA9IFJvb21Qcm92aWRlcjtcbnZhciBfdXNlQnJvYWRjYXN0RXZlbnQgPSB1c2VCcm9hZGNhc3RFdmVudDtcbnZhciBfdXNlT3RoZXJzTGlzdGVuZXIgPSB1c2VPdGhlcnNMaXN0ZW5lcjtcbnZhciBfdXNlUm9vbSA9IHVzZVJvb207XG52YXIgX3VzZUlzSW5zaWRlUm9vbSA9IHVzZUlzSW5zaWRlUm9vbTtcbnZhciBfdXNlQWRkUmVhY3Rpb24gPSB1c2VBZGRSZWFjdGlvbjtcbnZhciBfdXNlTXV0YXRpb24gPSB1c2VNdXRhdGlvbjtcbnZhciBfdXNlQ3JlYXRlVGhyZWFkID0gdXNlQ3JlYXRlVGhyZWFkO1xudmFyIF91c2VEZWxldGVUaHJlYWQgPSB1c2VEZWxldGVUaHJlYWQ7XG52YXIgX3VzZUVkaXRUaHJlYWRNZXRhZGF0YSA9IHVzZUVkaXRUaHJlYWRNZXRhZGF0YTtcbnZhciBfdXNlRXZlbnRMaXN0ZW5lciA9IHVzZUV2ZW50TGlzdGVuZXI7XG52YXIgX3VzZU15UHJlc2VuY2UgPSB1c2VNeVByZXNlbmNlO1xudmFyIF91c2VPdGhlcnNNYXBwZWQgPSB1c2VPdGhlcnNNYXBwZWQ7XG52YXIgX3VzZU90aGVyc01hcHBlZFN1c3BlbnNlID0gdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2U7XG52YXIgX3VzZVRocmVhZHMgPSB1c2VUaHJlYWRzO1xudmFyIF91c2VUaHJlYWRzU3VzcGVuc2UgPSB1c2VUaHJlYWRzU3VzcGVuc2U7XG52YXIgX3VzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyA9IHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncztcbnZhciBfdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UgPSB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZTtcbnZhciBfdXNlSGlzdG9yeVZlcnNpb25zID0gdXNlSGlzdG9yeVZlcnNpb25zO1xudmFyIF91c2VIaXN0b3J5VmVyc2lvbnNTdXNwZW5zZSA9IHVzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlO1xudmFyIF91c2VPdGhlciA9IHVzZU90aGVyO1xuZnVuY3Rpb24gX3VzZU90aGVycyguLi5hcmdzKSB7XG4gIHJldHVybiB1c2VPdGhlcnMoLi4uYXJncyk7XG59XG52YXIgX3VzZU90aGVyU3VzcGVuc2UgPSB1c2VPdGhlclN1c3BlbnNlO1xuZnVuY3Rpb24gX3VzZU90aGVyc1N1c3BlbnNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHVzZU90aGVyc1N1c3BlbnNlKC4uLmFyZ3MpO1xufVxudmFyIF91c2VTdG9yYWdlID0gdXNlU3RvcmFnZTtcbnZhciBfdXNlU3RvcmFnZVN1c3BlbnNlID0gdXNlU3RvcmFnZVN1c3BlbnNlO1xuZnVuY3Rpb24gX3VzZVNlbGYoLi4uYXJncykge1xuICByZXR1cm4gdXNlU2VsZiguLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIF91c2VTZWxmU3VzcGVuc2UoLi4uYXJncykge1xuICByZXR1cm4gdXNlU2VsZlN1c3BlbnNlKC4uLmFyZ3MpO1xufVxudmFyIF91c2VTdG9yYWdlUm9vdCA9IHVzZVN0b3JhZ2VSb290O1xudmFyIF91c2VVcGRhdGVNeVByZXNlbmNlID0gdXNlVXBkYXRlTXlQcmVzZW5jZTtcblxuZXhwb3J0IHtcbiAgUm9vbUNvbnRleHQsXG4gIHVzZVJvb21Pck51bGwsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yLFxuICB1c2VTaWduYWwsXG4gIENsaWVudENvbnRleHQsXG4gIGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQsXG4gIHVzZUNsaWVudE9yTnVsbCxcbiAgdXNlQ2xpZW50LFxuICBMaXZlYmxvY2tzUHJvdmlkZXIsXG4gIGNyZWF0ZUxpdmVibG9ja3NDb250ZXh0LFxuICB1c2VJbmJveE5vdGlmaWNhdGlvbnMsXG4gIHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlLFxuICB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyxcbiAgdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb24sXG4gIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlLFxuICB1c2VOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgdXNlTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSxcbiAgdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIHVzZVJvb21JbmZvLFxuICB1c2VSb29tSW5mb1N1c3BlbnNlLFxuICBfdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQsXG4gIF91c2VVc2VyLFxuICBfdXNlVXNlclN1c3BlbnNlLFxuICBfdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsLFxuICBfdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWwsXG4gIHVzZVN5bmNTdGF0dXMsXG4gIHVzZUVycm9yTGlzdGVuZXIsXG4gIHVzZVN0YXR1cyxcbiAgdXNlUmVwb3J0VGV4dEVkaXRvcixcbiAgdXNlWWpzUHJvdmlkZXIsXG4gIHVzZUNyZWF0ZVRleHRNZW50aW9uLFxuICB1c2VEZWxldGVUZXh0TWVudGlvbixcbiAgdXNlUmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyxcbiAgdXNlTWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUsXG4gIHVzZVN0b3JhZ2VTdGF0dXMsXG4gIHVzZUJhdGNoLFxuICB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyLFxuICB1c2VIaXN0b3J5LFxuICB1c2VVbmRvLFxuICB1c2VSZWRvLFxuICB1c2VDYW5VbmRvLFxuICB1c2VDYW5SZWRvLFxuICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzLFxuICB1c2VDcmVhdGVSb29tVGhyZWFkLFxuICB1c2VEZWxldGVSb29tVGhyZWFkLFxuICB1c2VFZGl0Um9vbVRocmVhZE1ldGFkYXRhLFxuICB1c2VDcmVhdGVDb21tZW50LFxuICB1c2VDcmVhdGVSb29tQ29tbWVudCxcbiAgdXNlRWRpdENvbW1lbnQsXG4gIHVzZUVkaXRSb29tQ29tbWVudCxcbiAgdXNlRGVsZXRlQ29tbWVudCxcbiAgdXNlRGVsZXRlUm9vbUNvbW1lbnQsXG4gIHVzZUFkZFJvb21Db21tZW50UmVhY3Rpb24sXG4gIHVzZVJlbW92ZVJlYWN0aW9uLFxuICB1c2VSZW1vdmVSb29tQ29tbWVudFJlYWN0aW9uLFxuICB1c2VNYXJrVGhyZWFkQXNSZWFkLFxuICB1c2VNYXJrUm9vbVRocmVhZEFzUmVhZCxcbiAgdXNlTWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gIHVzZU1hcmtSb29tVGhyZWFkQXNSZXNvbHZlZCxcbiAgdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgdXNlTWFya1Jvb21UaHJlYWRBc1VucmVzb2x2ZWQsXG4gIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgdXNlSGlzdG9yeVZlcnNpb25EYXRhLFxuICB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHNTdXNwZW5zZSxcbiAgdXNlU3RvcmFnZVN0YXR1c1N1c3BlbnNlLFxuICB1c2VBdHRhY2htZW50VXJsLFxuICB1c2VSb29tQXR0YWNobWVudFVybCxcbiAgdXNlQXR0YWNobWVudFVybFN1c3BlbnNlLFxuICB1c2VSb29tUGVybWlzc2lvbnMsXG4gIGNyZWF0ZVJvb21Db250ZXh0LFxuICBfUm9vbVByb3ZpZGVyLFxuICBfdXNlQnJvYWRjYXN0RXZlbnQsXG4gIF91c2VPdGhlcnNMaXN0ZW5lcixcbiAgX3VzZVJvb20sXG4gIF91c2VJc0luc2lkZVJvb20sXG4gIF91c2VBZGRSZWFjdGlvbixcbiAgX3VzZU11dGF0aW9uLFxuICBfdXNlQ3JlYXRlVGhyZWFkLFxuICBfdXNlRGVsZXRlVGhyZWFkLFxuICBfdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICBfdXNlRXZlbnRMaXN0ZW5lcixcbiAgX3VzZU15UHJlc2VuY2UsXG4gIF91c2VPdGhlcnNNYXBwZWQsXG4gIF91c2VPdGhlcnNNYXBwZWRTdXNwZW5zZSxcbiAgX3VzZVRocmVhZHMsXG4gIF91c2VUaHJlYWRzU3VzcGVuc2UsXG4gIF91c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIF91c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSxcbiAgX3VzZUhpc3RvcnlWZXJzaW9ucyxcbiAgX3VzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlLFxuICBfdXNlT3RoZXIsXG4gIF91c2VPdGhlcnMsXG4gIF91c2VPdGhlclN1c3BlbnNlLFxuICBfdXNlT3RoZXJzU3VzcGVuc2UsXG4gIF91c2VTdG9yYWdlLFxuICBfdXNlU3RvcmFnZVN1c3BlbnNlLFxuICBfdXNlU2VsZixcbiAgX3VzZVNlbGZTdXNwZW5zZSxcbiAgX3VzZVN0b3JhZ2VSb290LFxuICBfdXNlVXBkYXRlTXlQcmVzZW5jZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLTVSVlcyNTNXLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/chunk-5RVW253W.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/chunk-QYTJHNNQ.js":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/chunk-QYTJHNNQ.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientSideSuspense: () => (/* binding */ ClientSideSuspense),\n/* harmony export */   PKG_FORMAT: () => (/* binding */ PKG_FORMAT),\n/* harmony export */   PKG_NAME: () => (/* binding */ PKG_NAME),\n/* harmony export */   PKG_VERSION: () => (/* binding */ PKG_VERSION)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/react\";\nvar PKG_VERSION = \"2.19.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/ClientSideSuspense.tsx\n\n\nfunction ClientSideSuspense(props) {\n  const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    setMounted(true);\n  }, []);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, { fallback: props.fallback, children: mounted ? typeof props.children === \"function\" ? props.children() : props.children : props.fallback });\n}\n\n\n//# sourceMappingURL=chunk-QYTJHNNQ.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9jaHVuay1RWVRKSE5OUS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzRDtBQUNkO0FBQ3hDO0FBQ0EsZ0NBQWdDLCtDQUFRO0FBQ3hDLEVBQUUsZ0RBQVM7QUFDWDtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsc0RBQUcsQ0FBQywyQ0FBUSxJQUFJLHlJQUF5STtBQUNsTDs7QUFPRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JpdGV0b2dldGhlci8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC9kaXN0L2NodW5rLVFZVEpITk5RLmpzPzY5MjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3ZlcnNpb24udHNcbnZhciBQS0dfTkFNRSA9IFwiQGxpdmVibG9ja3MvcmVhY3RcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi4xOS4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9DbGllbnRTaWRlU3VzcGVuc2UudHN4XG5pbXBvcnQgeyBTdXNwZW5zZSwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBDbGllbnRTaWRlU3VzcGVuc2UocHJvcHMpIHtcbiAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goU3VzcGVuc2UsIHsgZmFsbGJhY2s6IHByb3BzLmZhbGxiYWNrLCBjaGlsZHJlbjogbW91bnRlZCA/IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gcHJvcHMuY2hpbGRyZW4oKSA6IHByb3BzLmNoaWxkcmVuIDogcHJvcHMuZmFsbGJhY2sgfSk7XG59XG5cbmV4cG9ydCB7XG4gIFBLR19OQU1FLFxuICBQS0dfVkVSU0lPTixcbiAgUEtHX0ZPUk1BVCxcbiAgQ2xpZW50U2lkZVN1c3BlbnNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstUVlUSkhOTlEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/chunk-QYTJHNNQ.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/yjs/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@liveblocks/yjs/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiveblocksYjsProvider: () => (/* binding */ LiveblocksYjsProvider),\n/* harmony export */   getYjsProviderForRoom: () => (/* binding */ getYjsProviderForRoom)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-base64 */ \"(ssr)/./node_modules/js-base64/base64.mjs\");\n/* harmony import */ var y_indexeddb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-indexeddb */ \"(ssr)/./node_modules/y-indexeddb/src/y-indexeddb.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n// src/index.ts\n\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/yjs\";\nvar PKG_VERSION = \"2.19.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/provider.ts\n\n\n\n// ../../node_modules/lib0/map.js\nvar create = () => /* @__PURE__ */ new Map();\nvar setIfUndefined = (map, key, createT) => {\n  let set = map.get(key);\n  if (set === void 0) {\n    map.set(key, set = createT());\n  }\n  return set;\n};\n\n// ../../node_modules/lib0/set.js\nvar create2 = () => /* @__PURE__ */ new Set();\n\n// ../../node_modules/lib0/array.js\nvar from = Array.from;\nvar isArray = Array.isArray;\n\n// ../../node_modules/lib0/observable.js\nvar Observable = class {\n  constructor() {\n    this._observers = create();\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on(name, f) {\n    setIfUndefined(this._observers, name, create2).add(f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once(name, f) {\n    const _f = (...args) => {\n      this.off(name, _f);\n      f(...args);\n    };\n    this.on(name, _f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off(name, f) {\n    const observers = this._observers.get(name);\n    if (observers !== void 0) {\n      observers.delete(f);\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit(name, args) {\n    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args));\n  }\n  destroy() {\n    this._observers = create();\n  }\n};\n\n// src/provider.ts\n\n\n\n// src/awareness.ts\nvar Y_PRESENCE_KEY = \"__yjs\";\nvar Y_PRESENCE_ID_KEY = \"__yjs_clientid\";\nvar Awareness = class extends Observable {\n  room;\n  doc;\n  states = /* @__PURE__ */ new Map();\n  // used to map liveblock's ActorId to Yjs ClientID, both unique numbers representing a client\n  actorToClientMap = /* @__PURE__ */ new Map();\n  // Meta is used to keep track and timeout users who disconnect. Liveblocks provides this for us, so we don't need to\n  // manage it here. Unfortunately, it's expected to exist by various integrations, so it's an empty map.\n  meta = /* @__PURE__ */ new Map();\n  // _checkInterval this would hold a timer to remove users, but Liveblock's presence already handles this\n  // unfortunately it's typed by various integrations\n  _checkInterval = 0;\n  othersUnsub;\n  constructor(doc, room) {\n    super();\n    this.doc = doc;\n    this.room = room;\n    this.room.updatePresence({\n      [Y_PRESENCE_ID_KEY]: this.doc.clientID\n    });\n    this.othersUnsub = this.room.events.others.subscribe((event) => {\n      let updates;\n      if (event.type === \"leave\") {\n        const targetClientId = this.actorToClientMap.get(\n          event.user.connectionId\n        );\n        if (targetClientId !== void 0) {\n          updates = { added: [], updated: [], removed: [targetClientId] };\n        }\n        this.rebuildActorToClientMap(event.others);\n      }\n      if (event.type === \"enter\" || event.type === \"update\") {\n        this.rebuildActorToClientMap(event.others);\n        const targetClientId = this.actorToClientMap.get(\n          event.user.connectionId\n        );\n        if (targetClientId !== void 0) {\n          updates = {\n            added: event.type === \"enter\" ? [targetClientId] : [],\n            updated: event.type === \"update\" ? [targetClientId] : [],\n            removed: []\n          };\n        }\n      }\n      if (event.type === \"reset\") {\n        this.rebuildActorToClientMap(event.others);\n      }\n      if (updates !== void 0) {\n        this.emit(\"change\", [updates, \"presence\"]);\n        this.emit(\"update\", [updates, \"presence\"]);\n      }\n    });\n  }\n  rebuildActorToClientMap(others) {\n    this.actorToClientMap.clear();\n    others.forEach((user) => {\n      if (user.presence[Y_PRESENCE_ID_KEY] !== void 0) {\n        this.actorToClientMap.set(\n          user.connectionId,\n          user.presence[Y_PRESENCE_ID_KEY]\n        );\n      }\n    });\n  }\n  destroy() {\n    this.emit(\"destroy\", [this]);\n    this.othersUnsub();\n    this.setLocalState(null);\n    super.destroy();\n  }\n  getLocalState() {\n    const presence = this.room.getPresence();\n    if (Object.keys(presence).length === 0 || typeof presence[Y_PRESENCE_KEY] === \"undefined\") {\n      return null;\n    }\n    return presence[Y_PRESENCE_KEY];\n  }\n  setLocalState(state) {\n    const presence = this.room.getSelf()?.presence;\n    if (state === null) {\n      if (presence === void 0) {\n        return;\n      }\n      this.room.updatePresence({ ...presence, [Y_PRESENCE_KEY]: null });\n      this.emit(\"update\", [\n        { added: [], updated: [], removed: [this.doc.clientID] },\n        \"local\"\n      ]);\n      return;\n    }\n    const yPresence = presence?.[Y_PRESENCE_KEY];\n    const added = yPresence === void 0 ? [this.doc.clientID] : [];\n    const updated = yPresence === void 0 ? [] : [this.doc.clientID];\n    this.room.updatePresence({\n      [Y_PRESENCE_KEY]: {\n        ...yPresence || {},\n        ...state || {}\n      }\n    });\n    this.emit(\"update\", [{ added, updated, removed: [] }, \"local\"]);\n  }\n  setLocalStateField(field, value) {\n    const presence = this.room.getSelf()?.presence[Y_PRESENCE_KEY];\n    const update = { [field]: value };\n    this.room.updatePresence({\n      [Y_PRESENCE_KEY]: { ...presence || {}, ...update }\n    });\n  }\n  // Translate liveblocks presence to yjs awareness\n  getStates() {\n    const others = this.room.getOthers();\n    const states = others.reduce((acc, otherUser) => {\n      const otherPresence = otherUser.presence[Y_PRESENCE_KEY];\n      const otherClientId = otherUser.presence[Y_PRESENCE_ID_KEY];\n      if (otherPresence !== void 0 && otherClientId !== void 0) {\n        acc.set(otherClientId, otherPresence || {});\n      }\n      return acc;\n    }, /* @__PURE__ */ new Map());\n    const localPresence = this.room.getSelf()?.presence[Y_PRESENCE_KEY];\n    if (localPresence !== void 0) {\n      states.set(this.doc.clientID, localPresence);\n    }\n    return states;\n  }\n};\n\n// src/doc.ts\n\n\n\nvar yDocHandler = class extends Observable {\n  unsubscribers = [];\n  _synced = false;\n  doc;\n  updateRoomDoc;\n  fetchRoomDoc;\n  useV2Encoding;\n  constructor({\n    doc,\n    isRoot,\n    updateDoc,\n    fetchDoc,\n    useV2Encoding\n  }) {\n    super();\n    this.doc = doc;\n    this.useV2Encoding = useV2Encoding;\n    this.doc.on(useV2Encoding ? \"updateV2\" : \"update\", this.updateHandler);\n    this.updateRoomDoc = (update) => {\n      updateDoc(update, isRoot ? void 0 : this.doc.guid);\n    };\n    this.fetchRoomDoc = (vector) => {\n      fetchDoc(vector, isRoot ? void 0 : this.doc.guid);\n    };\n    this.syncDoc();\n  }\n  handleServerUpdate = ({\n    update,\n    stateVector,\n    readOnly,\n    v2\n  }) => {\n    const applyUpdate2 = v2 ? yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdateV2 : yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdate;\n    applyUpdate2(this.doc, update, \"backend\");\n    if (stateVector) {\n      if (!readOnly) {\n        try {\n          const encodeUpdate = this.useV2Encoding ? yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateAsUpdateV2 : yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateAsUpdate;\n          const localUpdate = encodeUpdate(\n            this.doc,\n            js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.toUint8Array(stateVector)\n          );\n          this.updateRoomDoc(localUpdate);\n        } catch (e) {\n          console.warn(e);\n        }\n      }\n      this.synced = true;\n    }\n  };\n  syncDoc = () => {\n    this.synced = false;\n    const encodedVector = js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.fromUint8Array(yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateVector(this.doc));\n    this.fetchRoomDoc(encodedVector);\n  };\n  // The sync'd property is required by some provider implementations\n  get synced() {\n    return this._synced;\n  }\n  set synced(state) {\n    if (this._synced !== state) {\n      this._synced = state;\n      this.emit(\"synced\", [state]);\n      this.emit(\"sync\", [state]);\n    }\n  }\n  updateHandler = (update, origin) => {\n    const isFromLocal = origin instanceof y_indexeddb__WEBPACK_IMPORTED_MODULE_2__.IndexeddbPersistence;\n    if (origin !== \"backend\" && !isFromLocal) {\n      this.updateRoomDoc(update);\n    }\n  };\n  destroy() {\n    this.doc.off(\"update\", this.updateHandler);\n    this.unsubscribers.forEach((unsub) => unsub());\n    this._observers = /* @__PURE__ */ new Map();\n    this.doc.destroy();\n  }\n};\n\n// src/provider.ts\nvar LiveblocksYjsProvider = class extends Observable {\n  room;\n  rootDoc;\n  options;\n  indexeddbProvider = null;\n  isPaused = false;\n  unsubscribers = [];\n  awareness;\n  rootDocHandler;\n  subdocHandlers = /* @__PURE__ */ new Map();\n  permanentUserData;\n  pending = [];\n  constructor(room, doc, options = {}) {\n    super();\n    this.rootDoc = doc;\n    this.room = room;\n    this.options = options;\n    this.rootDocHandler = new yDocHandler({\n      doc,\n      isRoot: true,\n      updateDoc: this.updateDoc,\n      fetchDoc: this.fetchDoc,\n      useV2Encoding: this.options.useV2Encoding_experimental ?? false\n    });\n    if (this.options.enablePermanentUserData) {\n      this.permanentUserData = new yjs__WEBPACK_IMPORTED_MODULE_0__.PermanentUserData(doc);\n    }\n    room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].setYjsProvider(this);\n    this.awareness = new Awareness(this.rootDoc, this.room);\n    this.unsubscribers.push(\n      this.room.events.status.subscribe((status) => {\n        if (status === \"connected\") {\n          this.rootDocHandler.syncDoc();\n        } else {\n          this.rootDocHandler.synced = false;\n        }\n        this.emit(\"status\", [this.getStatus()]);\n      })\n    );\n    this.unsubscribers.push(\n      this.room.events.ydoc.subscribe((message) => {\n        const { type } = message;\n        if (type === _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ClientMsgCode.UPDATE_YDOC) {\n          return;\n        }\n        const { stateVector, update: updateStr, guid, v2 } = message;\n        const canWrite = this.room.getSelf()?.canWrite ?? true;\n        const update = js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.toUint8Array(updateStr);\n        let foundPendingUpdate = false;\n        const updateId = this.getUniqueUpdateId(update);\n        this.pending = this.pending.filter((pendingUpdate) => {\n          if (pendingUpdate === updateId) {\n            foundPendingUpdate = true;\n            return false;\n          }\n          return true;\n        });\n        if (!foundPendingUpdate) {\n          if (guid !== void 0) {\n            this.subdocHandlers.get(guid)?.handleServerUpdate({\n              update,\n              stateVector,\n              readOnly: !canWrite,\n              v2\n            });\n          } else {\n            this.rootDocHandler.handleServerUpdate({\n              update,\n              stateVector,\n              readOnly: !canWrite,\n              v2\n            });\n          }\n        }\n        this.emit(\"status\", [this.getStatus()]);\n      })\n    );\n    if (options.offlineSupport_experimental) {\n      this.setupOfflineSupport();\n    }\n    this.rootDocHandler.on(\"synced\", () => {\n      const state = this.rootDocHandler.synced;\n      for (const [_, handler] of this.subdocHandlers) {\n        handler.syncDoc();\n      }\n      this.emit(\"synced\", [state]);\n      this.emit(\"sync\", [state]);\n      this.emit(\"status\", [this.getStatus()]);\n    });\n    this.rootDoc.on(\"subdocs\", this.handleSubdocs);\n    this.syncDoc();\n  }\n  setupOfflineSupport = () => {\n    this.indexeddbProvider = new y_indexeddb__WEBPACK_IMPORTED_MODULE_2__.IndexeddbPersistence(\n      this.room.id,\n      this.rootDoc\n    );\n    const onIndexedDbSync = () => {\n      this.rootDocHandler.synced = true;\n    };\n    this.indexeddbProvider.on(\"synced\", onIndexedDbSync);\n    this.unsubscribers.push(() => {\n      this.indexeddbProvider?.off(\"synced\", onIndexedDbSync);\n    });\n  };\n  handleSubdocs = ({\n    loaded,\n    removed,\n    added\n  }) => {\n    loaded.forEach(this.createSubdocHandler);\n    if (this.options.autoloadSubdocs) {\n      for (const subdoc of added) {\n        if (!this.subdocHandlers.has(subdoc.guid)) {\n          subdoc.load();\n        }\n      }\n    }\n    for (const subdoc of removed) {\n      if (this.subdocHandlers.has(subdoc.guid)) {\n        this.subdocHandlers.get(subdoc.guid)?.destroy();\n        this.subdocHandlers.delete(subdoc.guid);\n      }\n    }\n  };\n  getUniqueUpdateId = (update) => {\n    const clock = (0,yjs__WEBPACK_IMPORTED_MODULE_0__.parseUpdateMeta)(update).to.get(this.rootDoc.clientID) ?? \"-1\";\n    return this.rootDoc.clientID + \":\" + clock;\n  };\n  updateDoc = (update, guid) => {\n    const canWrite = this.room.getSelf()?.canWrite ?? true;\n    if (canWrite && !this.isPaused) {\n      const updateId = this.getUniqueUpdateId(update);\n      this.pending.push(updateId);\n      this.room.updateYDoc(\n        js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.fromUint8Array(update),\n        guid,\n        this.useV2Encoding\n      );\n      this.emit(\"status\", [this.getStatus()]);\n    }\n  };\n  fetchDoc = (vector, guid) => {\n    this.room.fetchYDoc(vector, guid, this.useV2Encoding);\n  };\n  createSubdocHandler = (subdoc) => {\n    if (this.subdocHandlers.has(subdoc.guid)) {\n      this.subdocHandlers.get(subdoc.guid)?.syncDoc();\n      return;\n    }\n    const handler = new yDocHandler({\n      doc: subdoc,\n      isRoot: false,\n      updateDoc: this.updateDoc,\n      fetchDoc: this.fetchDoc,\n      useV2Encoding: this.options.useV2Encoding_experimental ?? false\n    });\n    this.subdocHandlers.set(subdoc.guid, handler);\n  };\n  // attempt to load a subdoc of a given guid\n  loadSubdoc = (guid) => {\n    for (const subdoc of this.rootDoc.subdocs) {\n      if (subdoc.guid === guid) {\n        subdoc.load();\n        return true;\n      }\n    }\n    return false;\n  };\n  syncDoc = () => {\n    this.rootDocHandler.syncDoc();\n    for (const [_, handler] of this.subdocHandlers) {\n      handler.syncDoc();\n    }\n  };\n  get useV2Encoding() {\n    return this.options.useV2Encoding_experimental ?? false;\n  }\n  // The sync'd property is required by some provider implementations\n  get synced() {\n    return this.rootDocHandler.synced;\n  }\n  async pause() {\n    await this.indexeddbProvider?.destroy();\n    this.indexeddbProvider = null;\n    this.isPaused = true;\n  }\n  unpause() {\n    this.isPaused = false;\n    if (this.options.offlineSupport_experimental) {\n      this.setupOfflineSupport();\n    }\n    this.rootDocHandler.syncDoc();\n  }\n  getStatus() {\n    if (!this.synced) {\n      return \"loading\";\n    }\n    return this.pending.length === 0 ? \"synchronized\" : \"synchronizing\";\n  }\n  destroy() {\n    this.unsubscribers.forEach((unsub) => unsub());\n    this.awareness.destroy();\n    this.rootDocHandler.destroy();\n    this._observers = /* @__PURE__ */ new Map();\n    for (const [_, handler] of this.subdocHandlers) {\n      handler.destroy();\n    }\n    this.subdocHandlers.clear();\n    super.destroy();\n  }\n  async clearOfflineData() {\n    if (!this.indexeddbProvider) return;\n    return this.indexeddbProvider.clearData();\n  }\n  getYDoc() {\n    return this.rootDoc;\n  }\n  // Some provider implementations expect to be able to call connect/disconnect, implement as noop\n  disconnect() {\n  }\n  connect() {\n  }\n};\n\n// src/providerContext.ts\n\nvar providersMap = /* @__PURE__ */ new WeakMap();\nvar getYjsProviderForRoom = (room, options = {}) => {\n  const provider = providersMap.get(room);\n  if (provider !== void 0) {\n    return provider;\n  }\n  const doc = new yjs__WEBPACK_IMPORTED_MODULE_0__.Doc();\n  const newProvider = new LiveblocksYjsProvider(room, doc, options);\n  room.events.roomWillDestroy.subscribeOnce(() => {\n    newProvider.destroy();\n  });\n  providersMap.set(room, newProvider);\n  return newProvider;\n};\n\n// src/index.ts\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MveWpzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzREO0FBQ2Q7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNEU7QUFDbkI7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7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a0Isb0RBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBCO0FBQzFCO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9DQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBVztBQUlUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3lqcy9kaXN0L2luZGV4LmpzPzI0MDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBkZXRlY3REdXBlcyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL3lqc1wiO1xudmFyIFBLR19WRVJTSU9OID0gXCIyLjE5LjBcIjtcbnZhciBQS0dfRk9STUFUID0gXCJlc21cIjtcblxuLy8gc3JjL3Byb3ZpZGVyLnRzXG5pbXBvcnQgeyBDbGllbnRNc2dDb2RlLCBrSW50ZXJuYWwgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0IHsgQmFzZTY0IGFzIEJhc2U2NDIgfSBmcm9tIFwianMtYmFzZTY0XCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9saWIwL21hcC5qc1xudmFyIGNyZWF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG52YXIgc2V0SWZVbmRlZmluZWQgPSAobWFwLCBrZXksIGNyZWF0ZVQpID0+IHtcbiAgbGV0IHNldCA9IG1hcC5nZXQoa2V5KTtcbiAgaWYgKHNldCA9PT0gdm9pZCAwKSB7XG4gICAgbWFwLnNldChrZXksIHNldCA9IGNyZWF0ZVQoKSk7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9saWIwL3NldC5qc1xudmFyIGNyZWF0ZTIgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbGliMC9hcnJheS5qc1xudmFyIGZyb20gPSBBcnJheS5mcm9tO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbGliMC9vYnNlcnZhYmxlLmpzXG52YXIgT2JzZXJ2YWJsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gY3JlYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvbihuYW1lLCBmKSB7XG4gICAgc2V0SWZVbmRlZmluZWQodGhpcy5fb2JzZXJ2ZXJzLCBuYW1lLCBjcmVhdGUyKS5hZGQoZik7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvbmNlKG5hbWUsIGYpIHtcbiAgICBjb25zdCBfZiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICB0aGlzLm9mZihuYW1lLCBfZik7XG4gICAgICBmKC4uLmFyZ3MpO1xuICAgIH07XG4gICAgdGhpcy5vbihuYW1lLCBfZik7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvZmYobmFtZSwgZikge1xuICAgIGNvbnN0IG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycy5nZXQobmFtZSk7XG4gICAgaWYgKG9ic2VydmVycyAhPT0gdm9pZCAwKSB7XG4gICAgICBvYnNlcnZlcnMuZGVsZXRlKGYpO1xuICAgICAgaWYgKG9ic2VydmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycy5kZWxldGUobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbWl0IGEgbmFtZWQgZXZlbnQuIEFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycyB0aGF0IGxpc3RlbiB0byB0aGVcbiAgICogc3BlY2lmaWVkIG5hbWUgd2lsbCByZWNlaXZlIHRoZSBldmVudC5cbiAgICpcbiAgICogQHRvZG8gVGhpcyBzaG91bGQgY2F0Y2ggZXhjZXB0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge059IG5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncyBUaGUgYXJndW1lbnRzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgZW1pdChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIGZyb20oKHRoaXMuX29ic2VydmVycy5nZXQobmFtZSkgfHwgY3JlYXRlKCkpLnZhbHVlcygpKS5mb3JFYWNoKChmKSA9PiBmKC4uLmFyZ3MpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX29ic2VydmVycyA9IGNyZWF0ZSgpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIudHNcbmltcG9ydCB7IEluZGV4ZWRkYlBlcnNpc3RlbmNlIGFzIEluZGV4ZWRkYlBlcnNpc3RlbmNlMiB9IGZyb20gXCJ5LWluZGV4ZWRkYlwiO1xuaW1wb3J0IHsgcGFyc2VVcGRhdGVNZXRhLCBQZXJtYW5lbnRVc2VyRGF0YSB9IGZyb20gXCJ5anNcIjtcblxuLy8gc3JjL2F3YXJlbmVzcy50c1xudmFyIFlfUFJFU0VOQ0VfS0VZID0gXCJfX3lqc1wiO1xudmFyIFlfUFJFU0VOQ0VfSURfS0VZID0gXCJfX3lqc19jbGllbnRpZFwiO1xudmFyIEF3YXJlbmVzcyA9IGNsYXNzIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIHJvb207XG4gIGRvYztcbiAgc3RhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLy8gdXNlZCB0byBtYXAgbGl2ZWJsb2NrJ3MgQWN0b3JJZCB0byBZanMgQ2xpZW50SUQsIGJvdGggdW5pcXVlIG51bWJlcnMgcmVwcmVzZW50aW5nIGEgY2xpZW50XG4gIGFjdG9yVG9DbGllbnRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvLyBNZXRhIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBhbmQgdGltZW91dCB1c2VycyB3aG8gZGlzY29ubmVjdC4gTGl2ZWJsb2NrcyBwcm92aWRlcyB0aGlzIGZvciB1cywgc28gd2UgZG9uJ3QgbmVlZCB0b1xuICAvLyBtYW5hZ2UgaXQgaGVyZS4gVW5mb3J0dW5hdGVseSwgaXQncyBleHBlY3RlZCB0byBleGlzdCBieSB2YXJpb3VzIGludGVncmF0aW9ucywgc28gaXQncyBhbiBlbXB0eSBtYXAuXG4gIG1ldGEgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvLyBfY2hlY2tJbnRlcnZhbCB0aGlzIHdvdWxkIGhvbGQgYSB0aW1lciB0byByZW1vdmUgdXNlcnMsIGJ1dCBMaXZlYmxvY2sncyBwcmVzZW5jZSBhbHJlYWR5IGhhbmRsZXMgdGhpc1xuICAvLyB1bmZvcnR1bmF0ZWx5IGl0J3MgdHlwZWQgYnkgdmFyaW91cyBpbnRlZ3JhdGlvbnNcbiAgX2NoZWNrSW50ZXJ2YWwgPSAwO1xuICBvdGhlcnNVbnN1YjtcbiAgY29uc3RydWN0b3IoZG9jLCByb29tKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLnJvb20gPSByb29tO1xuICAgIHRoaXMucm9vbS51cGRhdGVQcmVzZW5jZSh7XG4gICAgICBbWV9QUkVTRU5DRV9JRF9LRVldOiB0aGlzLmRvYy5jbGllbnRJRFxuICAgIH0pO1xuICAgIHRoaXMub3RoZXJzVW5zdWIgPSB0aGlzLnJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICBsZXQgdXBkYXRlcztcbiAgICAgIGlmIChldmVudC50eXBlID09PSBcImxlYXZlXCIpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2xpZW50SWQgPSB0aGlzLmFjdG9yVG9DbGllbnRNYXAuZ2V0KFxuICAgICAgICAgIGV2ZW50LnVzZXIuY29ubmVjdGlvbklkXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0YXJnZXRDbGllbnRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IHsgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZDogW3RhcmdldENsaWVudElkXSB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVidWlsZEFjdG9yVG9DbGllbnRNYXAoZXZlbnQub3RoZXJzKTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC50eXBlID09PSBcImVudGVyXCIgfHwgZXZlbnQudHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICB0aGlzLnJlYnVpbGRBY3RvclRvQ2xpZW50TWFwKGV2ZW50Lm90aGVycyk7XG4gICAgICAgIGNvbnN0IHRhcmdldENsaWVudElkID0gdGhpcy5hY3RvclRvQ2xpZW50TWFwLmdldChcbiAgICAgICAgICBldmVudC51c2VyLmNvbm5lY3Rpb25JZFxuICAgICAgICApO1xuICAgICAgICBpZiAodGFyZ2V0Q2xpZW50SWQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHVwZGF0ZXMgPSB7XG4gICAgICAgICAgICBhZGRlZDogZXZlbnQudHlwZSA9PT0gXCJlbnRlclwiID8gW3RhcmdldENsaWVudElkXSA6IFtdLFxuICAgICAgICAgICAgdXBkYXRlZDogZXZlbnQudHlwZSA9PT0gXCJ1cGRhdGVcIiA/IFt0YXJnZXRDbGllbnRJZF0gOiBbXSxcbiAgICAgICAgICAgIHJlbW92ZWQ6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwicmVzZXRcIikge1xuICAgICAgICB0aGlzLnJlYnVpbGRBY3RvclRvQ2xpZW50TWFwKGV2ZW50Lm90aGVycyk7XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCBbdXBkYXRlcywgXCJwcmVzZW5jZVwiXSk7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBbdXBkYXRlcywgXCJwcmVzZW5jZVwiXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVidWlsZEFjdG9yVG9DbGllbnRNYXAob3RoZXJzKSB7XG4gICAgdGhpcy5hY3RvclRvQ2xpZW50TWFwLmNsZWFyKCk7XG4gICAgb3RoZXJzLmZvckVhY2goKHVzZXIpID0+IHtcbiAgICAgIGlmICh1c2VyLnByZXNlbmNlW1lfUFJFU0VOQ0VfSURfS0VZXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuYWN0b3JUb0NsaWVudE1hcC5zZXQoXG4gICAgICAgICAgdXNlci5jb25uZWN0aW9uSWQsXG4gICAgICAgICAgdXNlci5wcmVzZW5jZVtZX1BSRVNFTkNFX0lEX0tFWV1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIiwgW3RoaXNdKTtcbiAgICB0aGlzLm90aGVyc1Vuc3ViKCk7XG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKG51bGwpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXRMb2NhbFN0YXRlKCkge1xuICAgIGNvbnN0IHByZXNlbmNlID0gdGhpcy5yb29tLmdldFByZXNlbmNlKCk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByZXNlbmNlKS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHByZXNlbmNlW1lfUFJFU0VOQ0VfS0VZXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV07XG4gIH1cbiAgc2V0TG9jYWxTdGF0ZShzdGF0ZSkge1xuICAgIGNvbnN0IHByZXNlbmNlID0gdGhpcy5yb29tLmdldFNlbGYoKT8ucHJlc2VuY2U7XG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICBpZiAocHJlc2VuY2UgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJvb20udXBkYXRlUHJlc2VuY2UoeyAuLi5wcmVzZW5jZSwgW1lfUFJFU0VOQ0VfS0VZXTogbnVsbCB9KTtcbiAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBbXG4gICAgICAgIHsgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZDogW3RoaXMuZG9jLmNsaWVudElEXSB9LFxuICAgICAgICBcImxvY2FsXCJcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB5UHJlc2VuY2UgPSBwcmVzZW5jZT8uW1lfUFJFU0VOQ0VfS0VZXTtcbiAgICBjb25zdCBhZGRlZCA9IHlQcmVzZW5jZSA9PT0gdm9pZCAwID8gW3RoaXMuZG9jLmNsaWVudElEXSA6IFtdO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSB5UHJlc2VuY2UgPT09IHZvaWQgMCA/IFtdIDogW3RoaXMuZG9jLmNsaWVudElEXTtcbiAgICB0aGlzLnJvb20udXBkYXRlUHJlc2VuY2Uoe1xuICAgICAgW1lfUFJFU0VOQ0VfS0VZXToge1xuICAgICAgICAuLi55UHJlc2VuY2UgfHwge30sXG4gICAgICAgIC4uLnN0YXRlIHx8IHt9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIFt7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkOiBbXSB9LCBcImxvY2FsXCJdKTtcbiAgfVxuICBzZXRMb2NhbFN0YXRlRmllbGQoZmllbGQsIHZhbHVlKSB7XG4gICAgY29uc3QgcHJlc2VuY2UgPSB0aGlzLnJvb20uZ2V0U2VsZigpPy5wcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV07XG4gICAgY29uc3QgdXBkYXRlID0geyBbZmllbGRdOiB2YWx1ZSB9O1xuICAgIHRoaXMucm9vbS51cGRhdGVQcmVzZW5jZSh7XG4gICAgICBbWV9QUkVTRU5DRV9LRVldOiB7IC4uLnByZXNlbmNlIHx8IHt9LCAuLi51cGRhdGUgfVxuICAgIH0pO1xuICB9XG4gIC8vIFRyYW5zbGF0ZSBsaXZlYmxvY2tzIHByZXNlbmNlIHRvIHlqcyBhd2FyZW5lc3NcbiAgZ2V0U3RhdGVzKCkge1xuICAgIGNvbnN0IG90aGVycyA9IHRoaXMucm9vbS5nZXRPdGhlcnMoKTtcbiAgICBjb25zdCBzdGF0ZXMgPSBvdGhlcnMucmVkdWNlKChhY2MsIG90aGVyVXNlcikgPT4ge1xuICAgICAgY29uc3Qgb3RoZXJQcmVzZW5jZSA9IG90aGVyVXNlci5wcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV07XG4gICAgICBjb25zdCBvdGhlckNsaWVudElkID0gb3RoZXJVc2VyLnByZXNlbmNlW1lfUFJFU0VOQ0VfSURfS0VZXTtcbiAgICAgIGlmIChvdGhlclByZXNlbmNlICE9PSB2b2lkIDAgJiYgb3RoZXJDbGllbnRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGFjYy5zZXQob3RoZXJDbGllbnRJZCwgb3RoZXJQcmVzZW5jZSB8fCB7fSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIGNvbnN0IGxvY2FsUHJlc2VuY2UgPSB0aGlzLnJvb20uZ2V0U2VsZigpPy5wcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV07XG4gICAgaWYgKGxvY2FsUHJlc2VuY2UgIT09IHZvaWQgMCkge1xuICAgICAgc3RhdGVzLnNldCh0aGlzLmRvYy5jbGllbnRJRCwgbG9jYWxQcmVzZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9kb2MudHNcbmltcG9ydCB7IEJhc2U2NCB9IGZyb20gXCJqcy1iYXNlNjRcIjtcbmltcG9ydCB7IEluZGV4ZWRkYlBlcnNpc3RlbmNlIH0gZnJvbSBcInktaW5kZXhlZGRiXCI7XG5pbXBvcnQgKiBhcyBZIGZyb20gXCJ5anNcIjtcbnZhciB5RG9jSGFuZGxlciA9IGNsYXNzIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIHVuc3Vic2NyaWJlcnMgPSBbXTtcbiAgX3N5bmNlZCA9IGZhbHNlO1xuICBkb2M7XG4gIHVwZGF0ZVJvb21Eb2M7XG4gIGZldGNoUm9vbURvYztcbiAgdXNlVjJFbmNvZGluZztcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRvYyxcbiAgICBpc1Jvb3QsXG4gICAgdXBkYXRlRG9jLFxuICAgIGZldGNoRG9jLFxuICAgIHVzZVYyRW5jb2RpbmdcbiAgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy51c2VWMkVuY29kaW5nID0gdXNlVjJFbmNvZGluZztcbiAgICB0aGlzLmRvYy5vbih1c2VWMkVuY29kaW5nID8gXCJ1cGRhdGVWMlwiIDogXCJ1cGRhdGVcIiwgdGhpcy51cGRhdGVIYW5kbGVyKTtcbiAgICB0aGlzLnVwZGF0ZVJvb21Eb2MgPSAodXBkYXRlKSA9PiB7XG4gICAgICB1cGRhdGVEb2ModXBkYXRlLCBpc1Jvb3QgPyB2b2lkIDAgOiB0aGlzLmRvYy5ndWlkKTtcbiAgICB9O1xuICAgIHRoaXMuZmV0Y2hSb29tRG9jID0gKHZlY3RvcikgPT4ge1xuICAgICAgZmV0Y2hEb2ModmVjdG9yLCBpc1Jvb3QgPyB2b2lkIDAgOiB0aGlzLmRvYy5ndWlkKTtcbiAgICB9O1xuICAgIHRoaXMuc3luY0RvYygpO1xuICB9XG4gIGhhbmRsZVNlcnZlclVwZGF0ZSA9ICh7XG4gICAgdXBkYXRlLFxuICAgIHN0YXRlVmVjdG9yLFxuICAgIHJlYWRPbmx5LFxuICAgIHYyXG4gIH0pID0+IHtcbiAgICBjb25zdCBhcHBseVVwZGF0ZTIgPSB2MiA/IFkuYXBwbHlVcGRhdGVWMiA6IFkuYXBwbHlVcGRhdGU7XG4gICAgYXBwbHlVcGRhdGUyKHRoaXMuZG9jLCB1cGRhdGUsIFwiYmFja2VuZFwiKTtcbiAgICBpZiAoc3RhdGVWZWN0b3IpIHtcbiAgICAgIGlmICghcmVhZE9ubHkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVVcGRhdGUgPSB0aGlzLnVzZVYyRW5jb2RpbmcgPyBZLmVuY29kZVN0YXRlQXNVcGRhdGVWMiA6IFkuZW5jb2RlU3RhdGVBc1VwZGF0ZTtcbiAgICAgICAgICBjb25zdCBsb2NhbFVwZGF0ZSA9IGVuY29kZVVwZGF0ZShcbiAgICAgICAgICAgIHRoaXMuZG9jLFxuICAgICAgICAgICAgQmFzZTY0LnRvVWludDhBcnJheShzdGF0ZVZlY3RvcilcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMudXBkYXRlUm9vbURvYyhsb2NhbFVwZGF0ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc3luY2VkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIHN5bmNEb2MgPSAoKSA9PiB7XG4gICAgdGhpcy5zeW5jZWQgPSBmYWxzZTtcbiAgICBjb25zdCBlbmNvZGVkVmVjdG9yID0gQmFzZTY0LmZyb21VaW50OEFycmF5KFkuZW5jb2RlU3RhdGVWZWN0b3IodGhpcy5kb2MpKTtcbiAgICB0aGlzLmZldGNoUm9vbURvYyhlbmNvZGVkVmVjdG9yKTtcbiAgfTtcbiAgLy8gVGhlIHN5bmMnZCBwcm9wZXJ0eSBpcyByZXF1aXJlZCBieSBzb21lIHByb3ZpZGVyIGltcGxlbWVudGF0aW9uc1xuICBnZXQgc3luY2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9zeW5jZWQ7XG4gIH1cbiAgc2V0IHN5bmNlZChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9zeW5jZWQgIT09IHN0YXRlKSB7XG4gICAgICB0aGlzLl9zeW5jZWQgPSBzdGF0ZTtcbiAgICAgIHRoaXMuZW1pdChcInN5bmNlZFwiLCBbc3RhdGVdKTtcbiAgICAgIHRoaXMuZW1pdChcInN5bmNcIiwgW3N0YXRlXSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUhhbmRsZXIgPSAodXBkYXRlLCBvcmlnaW4pID0+IHtcbiAgICBjb25zdCBpc0Zyb21Mb2NhbCA9IG9yaWdpbiBpbnN0YW5jZW9mIEluZGV4ZWRkYlBlcnNpc3RlbmNlO1xuICAgIGlmIChvcmlnaW4gIT09IFwiYmFja2VuZFwiICYmICFpc0Zyb21Mb2NhbCkge1xuICAgICAgdGhpcy51cGRhdGVSb29tRG9jKHVwZGF0ZSk7XG4gICAgfVxuICB9O1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZG9jLm9mZihcInVwZGF0ZVwiLCB0aGlzLnVwZGF0ZUhhbmRsZXIpO1xuICAgIHRoaXMudW5zdWJzY3JpYmVycy5mb3JFYWNoKCh1bnN1YikgPT4gdW5zdWIoKSk7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRvYy5kZXN0cm95KCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci50c1xudmFyIExpdmVibG9ja3NZanNQcm92aWRlciA9IGNsYXNzIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIHJvb207XG4gIHJvb3REb2M7XG4gIG9wdGlvbnM7XG4gIGluZGV4ZWRkYlByb3ZpZGVyID0gbnVsbDtcbiAgaXNQYXVzZWQgPSBmYWxzZTtcbiAgdW5zdWJzY3JpYmVycyA9IFtdO1xuICBhd2FyZW5lc3M7XG4gIHJvb3REb2NIYW5kbGVyO1xuICBzdWJkb2NIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHBlcm1hbmVudFVzZXJEYXRhO1xuICBwZW5kaW5nID0gW107XG4gIGNvbnN0cnVjdG9yKHJvb20sIGRvYywgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJvb3REb2MgPSBkb2M7XG4gICAgdGhpcy5yb29tID0gcm9vbTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucm9vdERvY0hhbmRsZXIgPSBuZXcgeURvY0hhbmRsZXIoe1xuICAgICAgZG9jLFxuICAgICAgaXNSb290OiB0cnVlLFxuICAgICAgdXBkYXRlRG9jOiB0aGlzLnVwZGF0ZURvYyxcbiAgICAgIGZldGNoRG9jOiB0aGlzLmZldGNoRG9jLFxuICAgICAgdXNlVjJFbmNvZGluZzogdGhpcy5vcHRpb25zLnVzZVYyRW5jb2RpbmdfZXhwZXJpbWVudGFsID8/IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVQZXJtYW5lbnRVc2VyRGF0YSkge1xuICAgICAgdGhpcy5wZXJtYW5lbnRVc2VyRGF0YSA9IG5ldyBQZXJtYW5lbnRVc2VyRGF0YShkb2MpO1xuICAgIH1cbiAgICByb29tW2tJbnRlcm5hbF0uc2V0WWpzUHJvdmlkZXIodGhpcyk7XG4gICAgdGhpcy5hd2FyZW5lc3MgPSBuZXcgQXdhcmVuZXNzKHRoaXMucm9vdERvYywgdGhpcy5yb29tKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlcnMucHVzaChcbiAgICAgIHRoaXMucm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZSgoc3RhdHVzKSA9PiB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICB0aGlzLnJvb3REb2NIYW5kbGVyLnN5bmNEb2MoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJvb3REb2NIYW5kbGVyLnN5bmNlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInN0YXR1c1wiLCBbdGhpcy5nZXRTdGF0dXMoKV0pO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMudW5zdWJzY3JpYmVycy5wdXNoKFxuICAgICAgdGhpcy5yb29tLmV2ZW50cy55ZG9jLnN1YnNjcmliZSgobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IG1lc3NhZ2U7XG4gICAgICAgIGlmICh0eXBlID09PSBDbGllbnRNc2dDb2RlLlVQREFURV9ZRE9DKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RhdGVWZWN0b3IsIHVwZGF0ZTogdXBkYXRlU3RyLCBndWlkLCB2MiB9ID0gbWVzc2FnZTtcbiAgICAgICAgY29uc3QgY2FuV3JpdGUgPSB0aGlzLnJvb20uZ2V0U2VsZigpPy5jYW5Xcml0ZSA/PyB0cnVlO1xuICAgICAgICBjb25zdCB1cGRhdGUgPSBCYXNlNjQyLnRvVWludDhBcnJheSh1cGRhdGVTdHIpO1xuICAgICAgICBsZXQgZm91bmRQZW5kaW5nVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUlkID0gdGhpcy5nZXRVbmlxdWVVcGRhdGVJZCh1cGRhdGUpO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSB0aGlzLnBlbmRpbmcuZmlsdGVyKChwZW5kaW5nVXBkYXRlKSA9PiB7XG4gICAgICAgICAgaWYgKHBlbmRpbmdVcGRhdGUgPT09IHVwZGF0ZUlkKSB7XG4gICAgICAgICAgICBmb3VuZFBlbmRpbmdVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZm91bmRQZW5kaW5nVXBkYXRlKSB7XG4gICAgICAgICAgaWYgKGd1aWQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy5zdWJkb2NIYW5kbGVycy5nZXQoZ3VpZCk/LmhhbmRsZVNlcnZlclVwZGF0ZSh7XG4gICAgICAgICAgICAgIHVwZGF0ZSxcbiAgICAgICAgICAgICAgc3RhdGVWZWN0b3IsXG4gICAgICAgICAgICAgIHJlYWRPbmx5OiAhY2FuV3JpdGUsXG4gICAgICAgICAgICAgIHYyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb290RG9jSGFuZGxlci5oYW5kbGVTZXJ2ZXJVcGRhdGUoe1xuICAgICAgICAgICAgICB1cGRhdGUsXG4gICAgICAgICAgICAgIHN0YXRlVmVjdG9yLFxuICAgICAgICAgICAgICByZWFkT25seTogIWNhbldyaXRlLFxuICAgICAgICAgICAgICB2MlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInN0YXR1c1wiLCBbdGhpcy5nZXRTdGF0dXMoKV0pO1xuICAgICAgfSlcbiAgICApO1xuICAgIGlmIChvcHRpb25zLm9mZmxpbmVTdXBwb3J0X2V4cGVyaW1lbnRhbCkge1xuICAgICAgdGhpcy5zZXR1cE9mZmxpbmVTdXBwb3J0KCk7XG4gICAgfVxuICAgIHRoaXMucm9vdERvY0hhbmRsZXIub24oXCJzeW5jZWRcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnJvb3REb2NIYW5kbGVyLnN5bmNlZDtcbiAgICAgIGZvciAoY29uc3QgW18sIGhhbmRsZXJdIG9mIHRoaXMuc3ViZG9jSGFuZGxlcnMpIHtcbiAgICAgICAgaGFuZGxlci5zeW5jRG9jKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJzeW5jZWRcIiwgW3N0YXRlXSk7XG4gICAgICB0aGlzLmVtaXQoXCJzeW5jXCIsIFtzdGF0ZV0pO1xuICAgICAgdGhpcy5lbWl0KFwic3RhdHVzXCIsIFt0aGlzLmdldFN0YXR1cygpXSk7XG4gICAgfSk7XG4gICAgdGhpcy5yb290RG9jLm9uKFwic3ViZG9jc1wiLCB0aGlzLmhhbmRsZVN1YmRvY3MpO1xuICAgIHRoaXMuc3luY0RvYygpO1xuICB9XG4gIHNldHVwT2ZmbGluZVN1cHBvcnQgPSAoKSA9PiB7XG4gICAgdGhpcy5pbmRleGVkZGJQcm92aWRlciA9IG5ldyBJbmRleGVkZGJQZXJzaXN0ZW5jZTIoXG4gICAgICB0aGlzLnJvb20uaWQsXG4gICAgICB0aGlzLnJvb3REb2NcbiAgICApO1xuICAgIGNvbnN0IG9uSW5kZXhlZERiU3luYyA9ICgpID0+IHtcbiAgICAgIHRoaXMucm9vdERvY0hhbmRsZXIuc3luY2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHRoaXMuaW5kZXhlZGRiUHJvdmlkZXIub24oXCJzeW5jZWRcIiwgb25JbmRleGVkRGJTeW5jKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlcnMucHVzaCgoKSA9PiB7XG4gICAgICB0aGlzLmluZGV4ZWRkYlByb3ZpZGVyPy5vZmYoXCJzeW5jZWRcIiwgb25JbmRleGVkRGJTeW5jKTtcbiAgICB9KTtcbiAgfTtcbiAgaGFuZGxlU3ViZG9jcyA9ICh7XG4gICAgbG9hZGVkLFxuICAgIHJlbW92ZWQsXG4gICAgYWRkZWRcbiAgfSkgPT4ge1xuICAgIGxvYWRlZC5mb3JFYWNoKHRoaXMuY3JlYXRlU3ViZG9jSGFuZGxlcik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvbG9hZFN1YmRvY3MpIHtcbiAgICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIGFkZGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5zdWJkb2NIYW5kbGVycy5oYXMoc3ViZG9jLmd1aWQpKSB7XG4gICAgICAgICAgc3ViZG9jLmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHN1YmRvYyBvZiByZW1vdmVkKSB7XG4gICAgICBpZiAodGhpcy5zdWJkb2NIYW5kbGVycy5oYXMoc3ViZG9jLmd1aWQpKSB7XG4gICAgICAgIHRoaXMuc3ViZG9jSGFuZGxlcnMuZ2V0KHN1YmRvYy5ndWlkKT8uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnN1YmRvY0hhbmRsZXJzLmRlbGV0ZShzdWJkb2MuZ3VpZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBnZXRVbmlxdWVVcGRhdGVJZCA9ICh1cGRhdGUpID0+IHtcbiAgICBjb25zdCBjbG9jayA9IHBhcnNlVXBkYXRlTWV0YSh1cGRhdGUpLnRvLmdldCh0aGlzLnJvb3REb2MuY2xpZW50SUQpID8/IFwiLTFcIjtcbiAgICByZXR1cm4gdGhpcy5yb290RG9jLmNsaWVudElEICsgXCI6XCIgKyBjbG9jaztcbiAgfTtcbiAgdXBkYXRlRG9jID0gKHVwZGF0ZSwgZ3VpZCkgPT4ge1xuICAgIGNvbnN0IGNhbldyaXRlID0gdGhpcy5yb29tLmdldFNlbGYoKT8uY2FuV3JpdGUgPz8gdHJ1ZTtcbiAgICBpZiAoY2FuV3JpdGUgJiYgIXRoaXMuaXNQYXVzZWQpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZUlkID0gdGhpcy5nZXRVbmlxdWVVcGRhdGVJZCh1cGRhdGUpO1xuICAgICAgdGhpcy5wZW5kaW5nLnB1c2godXBkYXRlSWQpO1xuICAgICAgdGhpcy5yb29tLnVwZGF0ZVlEb2MoXG4gICAgICAgIEJhc2U2NDIuZnJvbVVpbnQ4QXJyYXkodXBkYXRlKSxcbiAgICAgICAgZ3VpZCxcbiAgICAgICAgdGhpcy51c2VWMkVuY29kaW5nXG4gICAgICApO1xuICAgICAgdGhpcy5lbWl0KFwic3RhdHVzXCIsIFt0aGlzLmdldFN0YXR1cygpXSk7XG4gICAgfVxuICB9O1xuICBmZXRjaERvYyA9ICh2ZWN0b3IsIGd1aWQpID0+IHtcbiAgICB0aGlzLnJvb20uZmV0Y2hZRG9jKHZlY3RvciwgZ3VpZCwgdGhpcy51c2VWMkVuY29kaW5nKTtcbiAgfTtcbiAgY3JlYXRlU3ViZG9jSGFuZGxlciA9IChzdWJkb2MpID0+IHtcbiAgICBpZiAodGhpcy5zdWJkb2NIYW5kbGVycy5oYXMoc3ViZG9jLmd1aWQpKSB7XG4gICAgICB0aGlzLnN1YmRvY0hhbmRsZXJzLmdldChzdWJkb2MuZ3VpZCk/LnN5bmNEb2MoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyB5RG9jSGFuZGxlcih7XG4gICAgICBkb2M6IHN1YmRvYyxcbiAgICAgIGlzUm9vdDogZmFsc2UsXG4gICAgICB1cGRhdGVEb2M6IHRoaXMudXBkYXRlRG9jLFxuICAgICAgZmV0Y2hEb2M6IHRoaXMuZmV0Y2hEb2MsXG4gICAgICB1c2VWMkVuY29kaW5nOiB0aGlzLm9wdGlvbnMudXNlVjJFbmNvZGluZ19leHBlcmltZW50YWwgPz8gZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnN1YmRvY0hhbmRsZXJzLnNldChzdWJkb2MuZ3VpZCwgaGFuZGxlcik7XG4gIH07XG4gIC8vIGF0dGVtcHQgdG8gbG9hZCBhIHN1YmRvYyBvZiBhIGdpdmVuIGd1aWRcbiAgbG9hZFN1YmRvYyA9IChndWlkKSA9PiB7XG4gICAgZm9yIChjb25zdCBzdWJkb2Mgb2YgdGhpcy5yb290RG9jLnN1YmRvY3MpIHtcbiAgICAgIGlmIChzdWJkb2MuZ3VpZCA9PT0gZ3VpZCkge1xuICAgICAgICBzdWJkb2MubG9hZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBzeW5jRG9jID0gKCkgPT4ge1xuICAgIHRoaXMucm9vdERvY0hhbmRsZXIuc3luY0RvYygpO1xuICAgIGZvciAoY29uc3QgW18sIGhhbmRsZXJdIG9mIHRoaXMuc3ViZG9jSGFuZGxlcnMpIHtcbiAgICAgIGhhbmRsZXIuc3luY0RvYygpO1xuICAgIH1cbiAgfTtcbiAgZ2V0IHVzZVYyRW5jb2RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy51c2VWMkVuY29kaW5nX2V4cGVyaW1lbnRhbCA/PyBmYWxzZTtcbiAgfVxuICAvLyBUaGUgc3luYydkIHByb3BlcnR5IGlzIHJlcXVpcmVkIGJ5IHNvbWUgcHJvdmlkZXIgaW1wbGVtZW50YXRpb25zXG4gIGdldCBzeW5jZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdERvY0hhbmRsZXIuc3luY2VkO1xuICB9XG4gIGFzeW5jIHBhdXNlKCkge1xuICAgIGF3YWl0IHRoaXMuaW5kZXhlZGRiUHJvdmlkZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLmluZGV4ZWRkYlByb3ZpZGVyID0gbnVsbDtcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgfVxuICB1bnBhdXNlKCkge1xuICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZmxpbmVTdXBwb3J0X2V4cGVyaW1lbnRhbCkge1xuICAgICAgdGhpcy5zZXR1cE9mZmxpbmVTdXBwb3J0KCk7XG4gICAgfVxuICAgIHRoaXMucm9vdERvY0hhbmRsZXIuc3luY0RvYygpO1xuICB9XG4gIGdldFN0YXR1cygpIHtcbiAgICBpZiAoIXRoaXMuc3luY2VkKSB7XG4gICAgICByZXR1cm4gXCJsb2FkaW5nXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwID8gXCJzeW5jaHJvbml6ZWRcIiA6IFwic3luY2hyb25pemluZ1wiO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnN1YnNjcmliZXJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKTtcbiAgICB0aGlzLmF3YXJlbmVzcy5kZXN0cm95KCk7XG4gICAgdGhpcy5yb290RG9jSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtfLCBoYW5kbGVyXSBvZiB0aGlzLnN1YmRvY0hhbmRsZXJzKSB7XG4gICAgICBoYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJkb2NIYW5kbGVycy5jbGVhcigpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBhc3luYyBjbGVhck9mZmxpbmVEYXRhKCkge1xuICAgIGlmICghdGhpcy5pbmRleGVkZGJQcm92aWRlcikgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLmluZGV4ZWRkYlByb3ZpZGVyLmNsZWFyRGF0YSgpO1xuICB9XG4gIGdldFlEb2MoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdERvYztcbiAgfVxuICAvLyBTb21lIHByb3ZpZGVyIGltcGxlbWVudGF0aW9ucyBleHBlY3QgdG8gYmUgYWJsZSB0byBjYWxsIGNvbm5lY3QvZGlzY29ubmVjdCwgaW1wbGVtZW50IGFzIG5vb3BcbiAgZGlzY29ubmVjdCgpIHtcbiAgfVxuICBjb25uZWN0KCkge1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXJDb250ZXh0LnRzXG5pbXBvcnQgeyBEb2MgfSBmcm9tIFwieWpzXCI7XG52YXIgcHJvdmlkZXJzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgZ2V0WWpzUHJvdmlkZXJGb3JSb29tID0gKHJvb20sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBwcm92aWRlciA9IHByb3ZpZGVyc01hcC5nZXQocm9vbSk7XG4gIGlmIChwcm92aWRlciAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xuICB9XG4gIGNvbnN0IGRvYyA9IG5ldyBEb2MoKTtcbiAgY29uc3QgbmV3UHJvdmlkZXIgPSBuZXcgTGl2ZWJsb2Nrc1lqc1Byb3ZpZGVyKHJvb20sIGRvYywgb3B0aW9ucyk7XG4gIHJvb20uZXZlbnRzLnJvb21XaWxsRGVzdHJveS5zdWJzY3JpYmVPbmNlKCgpID0+IHtcbiAgICBuZXdQcm92aWRlci5kZXN0cm95KCk7XG4gIH0pO1xuICBwcm92aWRlcnNNYXAuc2V0KHJvb20sIG5ld1Byb3ZpZGVyKTtcbiAgcmV0dXJuIG5ld1Byb3ZpZGVyO1xufTtcblxuLy8gc3JjL2luZGV4LnRzXG5kZXRlY3REdXBlcyhQS0dfTkFNRSwgUEtHX1ZFUlNJT04sIFBLR19GT1JNQVQpO1xuZXhwb3J0IHtcbiAgTGl2ZWJsb2Nrc1lqc1Byb3ZpZGVyLFxuICBnZXRZanNQcm92aWRlckZvclJvb21cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/yjs/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@liveblocks/core/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   DefaultMap: () => (/* binding */ DefaultMap),\n/* harmony export */   DerivedSignal: () => (/* binding */ DerivedSignal),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   LiveblocksError: () => (/* binding */ LiveblocksError),\n/* harmony export */   MutableSignal: () => (/* binding */ MutableSignal),\n/* harmony export */   NotificationsApiError: () => (/* binding */ NotificationsApiError),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   Permission: () => (/* binding */ Permission),\n/* harmony export */   Promise_withResolvers: () => (/* binding */ Promise_withResolvers),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   Signal: () => (/* binding */ Signal),\n/* harmony export */   SortedList: () => (/* binding */ SortedList),\n/* harmony export */   TextEditorType: () => (/* binding */ TextEditorType),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   autoRetry: () => (/* binding */ autoRetry),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   compactObject: () => (/* binding */ compactObject),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToInboxNotificationData: () => (/* binding */ convertToInboxNotificationData),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   createCommentAttachmentId: () => (/* binding */ createCommentAttachmentId),\n/* harmony export */   createCommentId: () => (/* binding */ createCommentId),\n/* harmony export */   createInboxNotificationId: () => (/* binding */ createInboxNotificationId),\n/* harmony export */   createThreadId: () => (/* binding */ createThreadId),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   entries: () => (/* binding */ entries),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   generateCommentUrl: () => (/* binding */ generateCommentUrl),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   html: () => (/* binding */ html),\n/* harmony export */   htmlSafe: () => (/* binding */ htmlSafe),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isCommentBodyLink: () => (/* binding */ isCommentBodyLink),\n/* harmony export */   isCommentBodyMention: () => (/* binding */ isCommentBodyMention),\n/* harmony export */   isCommentBodyText: () => (/* binding */ isCommentBodyText),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isNotificationChannelEnabled: () => (/* binding */ isNotificationChannelEnabled),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   isStartsWithOperator: () => (/* binding */ isStartsWithOperator),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   mapValues: () => (/* binding */ mapValues),\n/* harmony export */   memoizeOnSuccess: () => (/* binding */ memoizeOnSuccess),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   objectToQuery: () => (/* binding */ objectToQuery),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   resolveUsersInCommentBody: () => (/* binding */ resolveUsersInCommentBody),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stableStringify: () => (/* binding */ stableStringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toAbsoluteUrl: () => (/* binding */ toAbsoluteUrl),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   urljoin: () => (/* binding */ urljoin),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"2.19.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/guards.ts\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction isStartsWithOperator(blob) {\n  return isPlainObject(blob) && typeof blob.startsWith === \"string\";\n}\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction keys(obj) {\n  return Object.keys(obj);\n}\nfunction values(obj) {\n  return Object.values(obj);\n}\nfunction mapValues(obj, mapFn) {\n  const result = {};\n  for (const pair of Object.entries(obj)) {\n    const key = pair[0];\n    if (key === \"__proto__\") {\n      continue;\n    }\n    const value = pair[1];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n// src/lib/autoRetry.ts\nvar HttpError = class _HttpError extends Error {\n  response;\n  details;\n  constructor(message, response, details) {\n    super(message);\n    this.name = \"HttpError\";\n    this.response = response;\n    this.details = details;\n  }\n  static async fromResponse(response) {\n    let bodyAsText;\n    try {\n      bodyAsText = await response.text();\n    } catch {\n    }\n    const bodyAsJson = bodyAsText ? tryParseJson(bodyAsText) : void 0;\n    let bodyAsJsonObject;\n    if (isPlainObject(bodyAsJson)) {\n      bodyAsJsonObject = bodyAsJson;\n    }\n    let message = \"\";\n    message ||= typeof bodyAsJsonObject?.message === \"string\" ? bodyAsJsonObject.message : \"\";\n    message ||= typeof bodyAsJsonObject?.error === \"string\" ? bodyAsJsonObject.error : \"\";\n    if (bodyAsJson === void 0) {\n      message ||= bodyAsText || \"\";\n    }\n    message ||= response.statusText;\n    let path;\n    try {\n      path = new URL(response.url).pathname;\n    } catch {\n    }\n    message += path !== void 0 ? ` (got status ${response.status} from ${path})` : ` (got status ${response.status})`;\n    const details = bodyAsJsonObject;\n    return new _HttpError(message, response, details);\n  }\n  /**\n   * Convenience accessor for response.status.\n   */\n  get status() {\n    return this.response.status;\n  }\n};\nvar DONT_RETRY_4XX = (x) => x instanceof HttpError && x.status >= 400 && x.status < 500;\nasync function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n  let attempt = 0;\n  while (true) {\n    attempt++;\n    try {\n      return await promiseFn();\n    } catch (err) {\n      if (shouldStopRetrying(err)) {\n        throw err;\n      }\n      if (attempt >= maxTries) {\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n    warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _observers = /* @__PURE__ */ new Set();\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    const unsub = subscribe((event) => {\n      unsub();\n      return callback(event);\n    });\n    return unsub;\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notify(event) {\n    let called = false;\n    for (const callback of _observers) {\n      callback(event);\n      called = true;\n    }\n    return called;\n  }\n  function count() {\n    return _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify,\n    subscribe,\n    subscribeOnce,\n    count,\n    waitUntil,\n    [Symbol.dispose]: () => {\n      _observers.clear();\n    },\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\nfunction makeBufferableEventSource() {\n  const eventSource2 = makeEventSource();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      eventSource2.notify(event);\n    }\n    _buffer = null;\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n      return false;\n    } else {\n      return eventSource2.notify(event);\n    }\n  }\n  return {\n    ...eventSource2,\n    notify: notifyOrBuffer,\n    pause,\n    unpause,\n    [Symbol.dispose]: () => {\n      eventSource2[Symbol.dispose]();\n      if (_buffer !== null) {\n        _buffer.length = 0;\n      }\n    }\n  };\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/lib/signals.ts\nvar kSinks = Symbol(\"kSinks\");\nvar kTrigger = Symbol(\"kTrigger\");\nvar signalsToTrigger = null;\nvar trackedReads = null;\nfunction batch(callback) {\n  if (signalsToTrigger !== null) {\n    callback();\n    return;\n  }\n  signalsToTrigger = /* @__PURE__ */ new Set();\n  try {\n    callback();\n  } finally {\n    for (const signal of signalsToTrigger) {\n      signal[kTrigger]();\n    }\n    signalsToTrigger = null;\n  }\n}\nfunction enqueueTrigger(signal) {\n  if (!signalsToTrigger) raise(\"Expected to be in an active batch\");\n  signalsToTrigger.add(signal);\n}\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar AbstractSignal = class {\n  /** @internal */\n  equals;\n  #eventSource;\n  /** @internal */\n  [kSinks];\n  constructor(equals) {\n    this.equals = equals ?? Object.is;\n    this.#eventSource = makeEventSource();\n    this[kSinks] = /* @__PURE__ */ new Set();\n    this.get = this.get.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.subscribeOnce = this.subscribeOnce.bind(this);\n  }\n  [Symbol.dispose]() {\n    this.#eventSource[Symbol.dispose]();\n    this.#eventSource = \"(disposed)\";\n    this.equals = \"(disposed)\";\n  }\n  get hasWatchers() {\n    if (this.#eventSource.count() > 0) return true;\n    for (const sink of this[kSinks]) {\n      if (sink.hasWatchers) {\n        return true;\n      }\n    }\n    return false;\n  }\n  [kTrigger]() {\n    this.#eventSource.notify();\n    for (const sink of this[kSinks]) {\n      enqueueTrigger(sink);\n    }\n  }\n  subscribe(callback) {\n    if (this.#eventSource.count() === 0) {\n      this.get();\n    }\n    return this.#eventSource.subscribe(callback);\n  }\n  subscribeOnce(callback) {\n    const unsub = this.subscribe(() => {\n      unsub();\n      return callback();\n    });\n    return unsub;\n  }\n  waitUntil() {\n    throw new Error(\"waitUntil not supported on Signals\");\n  }\n  markSinksDirty() {\n    for (const sink of this[kSinks]) {\n      sink.markDirty();\n    }\n  }\n  addSink(sink) {\n    this[kSinks].add(sink);\n  }\n  removeSink(sink) {\n    this[kSinks].delete(sink);\n  }\n  asReadonly() {\n    return this;\n  }\n};\nvar Signal = class extends AbstractSignal {\n  #value;\n  constructor(value, equals) {\n    super(equals);\n    this.#value = freeze(value);\n  }\n  [Symbol.dispose]() {\n    super[Symbol.dispose]();\n    this.#value = \"(disposed)\";\n  }\n  get() {\n    trackedReads?.add(this);\n    return this.#value;\n  }\n  set(newValue) {\n    batch(() => {\n      if (typeof newValue === \"function\") {\n        newValue = newValue(this.#value);\n      }\n      if (!this.equals(this.#value, newValue)) {\n        this.#value = freeze(newValue);\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n};\nvar PatchableSignal = class extends Signal {\n  constructor(data) {\n    super(freeze(compactObject(data)));\n  }\n  set() {\n    throw new Error(\"Don't call .set() directly, use .patch()\");\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    super.set((old) => merge(old, patch));\n  }\n};\nvar INITIAL = Symbol();\nvar DerivedSignal = class _DerivedSignal extends AbstractSignal {\n  #prevValue;\n  #dirty;\n  // When true, the value in #value may not be up-to-date and needs re-checking\n  #sources;\n  #deps;\n  #transform;\n  // prettier-ignore\n  static from(...args) {\n    const last = args.pop();\n    if (typeof last !== \"function\")\n      raise(\"Invalid .from() call, last argument expected to be a function\");\n    if (typeof args[args.length - 1] === \"function\") {\n      const equals = last;\n      const transform = args.pop();\n      return new _DerivedSignal(args, transform, equals);\n    } else {\n      const transform = last;\n      return new _DerivedSignal(args, transform);\n    }\n  }\n  constructor(deps, transform, equals) {\n    super(equals);\n    this.#dirty = true;\n    this.#prevValue = INITIAL;\n    this.#deps = deps;\n    this.#sources = /* @__PURE__ */ new Set();\n    this.#transform = transform;\n  }\n  [Symbol.dispose]() {\n    for (const src of this.#sources) {\n      src.removeSink(this);\n    }\n    this.#prevValue = \"(disposed)\";\n    this.#sources = \"(disposed)\";\n    this.#deps = \"(disposed)\";\n    this.#transform = \"(disposed)\";\n  }\n  get isDirty() {\n    return this.#dirty;\n  }\n  #recompute() {\n    const oldTrackedReads = trackedReads;\n    let derived;\n    trackedReads = /* @__PURE__ */ new Set();\n    try {\n      derived = this.#transform(...this.#deps.map((p) => p.get()));\n    } finally {\n      const oldSources = this.#sources;\n      this.#sources = /* @__PURE__ */ new Set();\n      for (const sig of trackedReads) {\n        this.#sources.add(sig);\n        oldSources.delete(sig);\n      }\n      for (const oldSource of oldSources) {\n        oldSource.removeSink(this);\n      }\n      for (const newSource of this.#sources) {\n        newSource.addSink(this);\n      }\n      trackedReads = oldTrackedReads;\n    }\n    this.#dirty = false;\n    if (!this.equals(this.#prevValue, derived)) {\n      this.#prevValue = derived;\n      return true;\n    }\n    return false;\n  }\n  markDirty() {\n    if (!this.#dirty) {\n      this.#dirty = true;\n      this.markSinksDirty();\n    }\n  }\n  get() {\n    if (this.#dirty) {\n      this.#recompute();\n    }\n    trackedReads?.add(this);\n    return this.#prevValue;\n  }\n  /**\n   * Called by the Signal system if one or more of the dependent signals have\n   * changed. In the case of a DerivedSignal, we'll only want to re-evaluate\n   * the actual value if it's being watched, or any of their sinks are being\n   * watched actively.\n   */\n  [kTrigger]() {\n    if (!this.hasWatchers) {\n      return;\n    }\n    const updated = this.#recompute();\n    if (updated) {\n      super[kTrigger]();\n    }\n  }\n};\nvar MutableSignal = class extends AbstractSignal {\n  #state;\n  constructor(initialState) {\n    super();\n    this.#state = initialState;\n  }\n  [Symbol.dispose]() {\n    super[Symbol.dispose]();\n    this.#state = \"(disposed)\";\n  }\n  get() {\n    trackedReads?.add(this);\n    return this.#state;\n  }\n  /**\n   * Invokes a callback function that is allowed to mutate the given state\n   * value. Do not change the value outside of the callback.\n   *\n   * If the callback explicitly returns `false`, it's assumed that the state\n   * was not changed.\n   */\n  mutate(callback) {\n    batch(() => {\n      const result = callback ? callback(this.#state) : true;\n      if (result !== null && typeof result === \"object\" && \"then\" in result) {\n        raise(\"MutableSignal.mutate() does not support async callbacks\");\n      }\n      if (result !== false) {\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n};\n\n// src/lib/stringify.ts\nfunction replacer(_key, value) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value) ? Object.keys(value).sort().reduce((sorted, key) => {\n    sorted[key] = value[key];\n    return sorted;\n  }, {}) : value;\n}\nfunction stableStringify(value) {\n  return JSON.stringify(value, replacer);\n}\nfunction stringifyOrLog(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (err) {\n    console.error(`Could not stringify: ${err.message}`);\n    console.error(value);\n    throw err;\n  }\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  input;\n  resolve;\n  reject;\n  promise;\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  #queue = [];\n  #callback;\n  #size;\n  #delay;\n  #delayTimeoutId;\n  error = false;\n  constructor(callback, options) {\n    this.#callback = callback;\n    this.#size = options.size ?? DEFAULT_SIZE;\n    this.#delay = options.delay;\n  }\n  #clearDelayTimeout() {\n    if (this.#delayTimeoutId !== void 0) {\n      clearTimeout(this.#delayTimeoutId);\n      this.#delayTimeoutId = void 0;\n    }\n  }\n  #schedule() {\n    if (this.#queue.length === this.#size) {\n      void this.#flush();\n    } else if (this.#queue.length === 1) {\n      this.#clearDelayTimeout();\n      this.#delayTimeoutId = setTimeout(() => void this.#flush(), this.#delay);\n    }\n  }\n  async #flush() {\n    if (this.#queue.length === 0) {\n      return;\n    }\n    const calls = this.#queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.#callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.#queue.find(\n      (call2) => stableStringify(call2.input) === stableStringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.#queue.push(call);\n    this.#schedule();\n    return call.promise;\n  }\n  clear() {\n    this.#queue = [];\n    this.error = false;\n    this.#clearDelayTimeout();\n  }\n};\nfunction createBatchStore(batch2) {\n  const signal = new MutableSignal(/* @__PURE__ */ new Map());\n  function getCacheKey(args) {\n    return stableStringify(args);\n  }\n  function update(cacheKey, state) {\n    signal.mutate((cache) => {\n      cache.set(cacheKey, state);\n    });\n  }\n  function invalidate(inputs) {\n    signal.mutate((cache) => {\n      if (Array.isArray(inputs)) {\n        for (const input of inputs) {\n          cache.delete(getCacheKey(input));\n        }\n      } else {\n        cache.clear();\n      }\n    });\n  }\n  async function enqueue(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      update(cacheKey, { isLoading: true });\n      const result = await batch2.get(input);\n      update(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      update(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getItemState(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey);\n  }\n  function _cacheKeys() {\n    const cache = signal.get();\n    return [...cache.keys()];\n  }\n  return {\n    subscribe: signal.subscribe,\n    enqueue,\n    getItemState,\n    invalidate,\n    batch: batch2,\n    _cacheKeys\n  };\n}\n\n// src/lib/chunk.ts\nfunction chunk(array, size) {\n  const chunks = [];\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n// src/lib/nanoid.ts\nvar nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(\n  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? \"_\" : \"-\",\n  \"\"\n);\n\n// src/lib/createIds.ts\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nvar INBOX_NOTIFICATION_ID_PREFIX = \"in\";\nfunction createOptimisticId(prefix) {\n  return `${prefix}_${nanoid()}`;\n}\nfunction createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction createCommentAttachmentId() {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\nfunction createInboxNotificationId() {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n\n// src/lib/DefaultMap.ts\nvar DefaultMap = class extends Map {\n  #defaultFn;\n  /**\n   * If the default function is not provided to the constructor, it has to be\n   * provided in each .getOrCreate() call individually.\n   */\n  constructor(defaultFn, entries2) {\n    super(entries2);\n    this.#defaultFn = defaultFn;\n  }\n  /**\n   * Gets the value at the given key, or creates it.\n   *\n   * Difference from normal Map: if the key does not exist, it will be created\n   * on the fly using the factory function, and that value will get returned\n   * instead of `undefined`.\n   */\n  getOrCreate(key, defaultFn) {\n    if (super.has(key)) {\n      return super.get(key);\n    } else {\n      const fn = defaultFn ?? this.#defaultFn ?? raise(\"DefaultMap used without a factory function\");\n      const value = fn(key);\n      this.set(key, value);\n      return value;\n    }\n  }\n};\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isPlainObject(value)) {\n      if (isStartsWithOperator(value)) {\n        keyValuePairsWithOperator.push([key, value]);\n      } else {\n        indexedKeys.push([key, value]);\n      }\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isStartsWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(({ key, operator, value }) => `${key}${operator}${quote(value)}`).join(\" \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  return typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || value === null;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${quote(nestedKey)}]`;\n  }\n  return key;\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\nfunction quote(input) {\n  const result = JSON.stringify(input);\n  if (typeof input !== \"string\") {\n    return result;\n  }\n  if (result.includes(\"'\")) {\n    return result;\n  }\n  return `'${result.slice(1, -1).replace(/\\\\\"/g, '\"')}'`;\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url2 = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url2.toString();\n}\nfunction url(strings, ...values2) {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values2[i - 1] ?? \"\") + str\n  );\n}\n\n// src/api-client.ts\nfunction createApiClient({\n  baseUrl,\n  authManager,\n  fetchPolyfill\n}) {\n  const httpClient = new HttpClient(baseUrl, fetchPolyfill);\n  async function getThreadsSince(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/threads/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        since: options.since.toISOString()\n      },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: result.data.map(convertToThreadData),\n        deleted: result.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: result.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: result.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(result.meta.requestedAt),\n      permissionHints: result.meta.permissionHints\n    };\n  }\n  async function getThreads(options) {\n    let query;\n    if (options.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    try {\n      const result = await httpClient.get(\n        url`/v2/c/rooms/${options.roomId}/threads`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\",\n          roomId: options.roomId\n        }),\n        {\n          cursor: options.cursor,\n          query,\n          limit: PAGE_SIZE\n        }\n      );\n      return {\n        threads: result.data.map(convertToThreadData),\n        inboxNotifications: result.inboxNotifications.map(\n          convertToInboxNotificationData\n        ),\n        nextCursor: result.meta.nextCursor,\n        requestedAt: new Date(result.meta.requestedAt),\n        permissionHints: result.meta.permissionHints\n      };\n    } catch (err) {\n      if (err instanceof HttpError && err.status === 404) {\n        return {\n          threads: [],\n          inboxNotifications: [],\n          nextCursor: null,\n          //\n          // HACK\n          // requestedAt needs to be a *server* timestamp here. However, on\n          // this 404 error response, there is no such timestamp. So out of\n          // pure necessity we'll fall back to a local timestamp instead (and\n          // allow for a possible 6 hour clock difference between client and\n          // server).\n          //\n          requestedAt: new Date(Date.now() - 6 * 60 * 60 * 1e3),\n          permissionHints: {}\n        };\n      }\n      throw err;\n    }\n  }\n  async function createThread(options) {\n    const commentId = options.commentId ?? createCommentId();\n    const threadId = options.threadId ?? createThreadId();\n    const thread = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        id: threadId,\n        comment: {\n          id: commentId,\n          body: options.body,\n          attachmentIds: options.attachmentIds\n        },\n        metadata: options.metadata\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function deleteThread(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function getThread(options) {\n    const response = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/thread-with-notification/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: void 0,\n        inboxNotification: void 0\n      };\n    } else {\n      throw new Error(\n        `There was an error while getting thread ${options.threadId}.`\n      );\n    }\n  }\n  async function editThreadMetadata(options) {\n    return await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.metadata\n    );\n  }\n  async function createComment(options) {\n    const commentId = options.commentId ?? createCommentId();\n    const comment = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        id: commentId,\n        body: options.body,\n        attachmentIds: options.attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment(options) {\n    const comment = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        body: options.body,\n        attachmentIds: options.attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function addReaction(options) {\n    const reaction = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      { emoji: options.emoji }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function markThreadAsResolved(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-resolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function markThreadAsUnresolved(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-unresolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function uploadAttachment(options) {\n    const roomId = options.roomId;\n    const abortSignal = options.signal;\n    const attachment = options.attachment;\n    const abortError = abortSignal ? new DOMException(\n      `Upload of attachment ${options.attachment.id} was aborted.`,\n      \"AbortError\"\n    ) : void 0;\n    if (abortSignal?.aborted) {\n      throw abortError;\n    }\n    const handleRetryError = (err) => {\n      if (abortSignal?.aborted) {\n        throw abortError;\n      }\n      if (err instanceof HttpError && err.status === 413) {\n        throw err;\n      }\n      return false;\n    };\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\n    const RETRY_ATTEMPTS = 10;\n    const RETRY_DELAYS = [\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3\n    ];\n    function splitFileIntoParts(file) {\n      const parts = [];\n      let start = 0;\n      while (start < file.size) {\n        const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n        parts.push({\n          partNumber: parts.length + 1,\n          part: file.slice(start, end)\n        });\n        start = end;\n      }\n      return parts;\n    }\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      return autoRetry(\n        async () => httpClient.putBlob(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          attachment.file,\n          { fileSize: attachment.size },\n          { signal: abortSignal }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      let uploadId;\n      const uploadedParts = [];\n      const createMultiPartUpload = await autoRetry(\n        async () => httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          void 0,\n          { signal: abortSignal },\n          { fileSize: attachment.size }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n        const parts = splitFileIntoParts(attachment.file);\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const batches = chunk(parts, 5);\n        for (const parts2 of batches) {\n          const uploadedPartsPromises = [];\n          for (const { part, partNumber } of parts2) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                async () => httpClient.putBlob(\n                  url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                  await authManager.getAuthValue({\n                    requestedScope: \"comments:read\",\n                    roomId\n                  }),\n                  part,\n                  void 0,\n                  { signal: abortSignal }\n                ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n          uploadedParts.push(...await Promise.all(uploadedPartsPromises));\n        }\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n        return httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { parts: sortedUploadedParts },\n          { signal: abortSignal }\n        );\n      } catch (error3) {\n        if (uploadId && error3?.name && (error3.name === \"AbortError\" || error3.name === \"TimeoutError\")) {\n          try {\n            await httpClient.rawDelete(\n              url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}`,\n              await authManager.getAuthValue({\n                requestedScope: \"comments:read\",\n                roomId\n              })\n            );\n          } catch (error4) {\n          }\n        }\n        throw error3;\n      }\n    }\n  }\n  const attachmentUrlsBatchStoresByRoom = new DefaultMap((roomId) => {\n    const batch2 = new Batch(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { attachmentIds }\n        );\n        return urls.map(\n          (url2) => url2 ?? new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch2);\n  });\n  function getOrCreateAttachmentUrlsStore(roomId) {\n    return attachmentUrlsBatchStoresByRoom.getOrCreate(roomId);\n  }\n  function getAttachmentUrl(options) {\n    const batch2 = getOrCreateAttachmentUrlsStore(options.roomId).batch;\n    return batch2.get(options.attachmentId);\n  }\n  async function getNotificationSettings(options) {\n    return httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/notification-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      void 0,\n      {\n        signal: options.signal\n      }\n    );\n  }\n  async function updateNotificationSettings(options) {\n    return httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/notification-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.settings\n    );\n  }\n  const markAsReadBatchesByRoom = new DefaultMap(\n    (roomId) => new Batch(\n      async (batchedInboxNotificationIds) => {\n        const inboxNotificationIds = batchedInboxNotificationIds.flat();\n        await httpClient.post(\n          url`/v2/c/rooms/${roomId}/inbox-notifications/read`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { inboxNotificationIds }\n        );\n        return inboxNotificationIds;\n      },\n      { delay: 50 }\n    )\n  );\n  async function markRoomInboxNotificationAsRead(options) {\n    const batch2 = markAsReadBatchesByRoom.getOrCreate(options.roomId);\n    return batch2.get(options.inboxNotificationId);\n  }\n  async function createTextMention(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-mentions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        userId: options.userId,\n        mentionId: options.mentionId\n      }\n    );\n  }\n  async function deleteTextMention(options) {\n    await httpClient.rawDelete(\n      url`/v2/c/rooms/${options.roomId}/text-mentions/${options.mentionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function getTextVersion(options) {\n    return httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/y-version/${options.versionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function createTextVersion(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/version`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function reportTextEditor(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        type: options.type,\n        rootKey: options.rootKey\n      }\n    );\n  }\n  async function executeContextualPrompt(options) {\n    const result = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/ai/contextual-prompt`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      }),\n      {\n        prompt: options.prompt,\n        context: {\n          beforeSelection: options.context.beforeSelection,\n          selection: options.context.selection,\n          afterSelection: options.context.afterSelection\n        },\n        previous: options.previous\n      },\n      { signal: options.signal }\n    );\n    if (!result || result.content.length === 0) {\n      throw new Error(\"No content returned from server\");\n    }\n    return result.content[0].text;\n  }\n  async function listTextVersions(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/versions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function listTextVersionsSince(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/versions/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function streamStorage(options) {\n    const result = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/storage`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      })\n    );\n    return await result.json();\n  }\n  async function sendMessages(options) {\n    return httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/send-message`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      }),\n      {\n        nonce: options.nonce,\n        messages: options.messages\n      }\n    );\n  }\n  async function getInboxNotifications(options) {\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        limit: PAGE_SIZE\n      }\n    );\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getInboxNotificationsSince(options) {\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await httpClient.get(\n      url`/v2/c/inbox-notifications/count`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds: \"all\"\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds\n      }\n    );\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications/${inboxNotificationId}`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n  async function getUserNotificationSettings(options) {\n    return httpClient.get(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      void 0,\n      { signal: options?.signal }\n    );\n  }\n  async function updateUserNotificationSettings(settings) {\n    return httpClient.post(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      settings\n    );\n  }\n  async function getUserThreads_experimental(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(\n      url`/v2/c/threads`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        query,\n        limit: PAGE_SIZE\n      }\n    );\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints\n    };\n  }\n  async function getUserThreadsSince_experimental(options) {\n    const json = await httpClient.get(\n      url`/v2/c/threads/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints\n    };\n  }\n  return {\n    // Room threads\n    getThreads,\n    getThreadsSince,\n    createThread,\n    getThread,\n    deleteThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment,\n    addReaction,\n    removeReaction,\n    markThreadAsResolved,\n    markThreadAsUnresolved,\n    markRoomInboxNotificationAsRead,\n    // Room notifications\n    getNotificationSettings,\n    updateNotificationSettings,\n    // Room text editor\n    createTextMention,\n    deleteTextMention,\n    getTextVersion,\n    createTextVersion,\n    reportTextEditor,\n    listTextVersions,\n    listTextVersionsSince,\n    // Room attachments\n    getAttachmentUrl,\n    uploadAttachment,\n    getOrCreateAttachmentUrlsStore,\n    // Room storage\n    streamStorage,\n    sendMessages,\n    // Notification\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    getUserNotificationSettings,\n    updateUserNotificationSettings,\n    // User threads\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental,\n    // AI\n    executeContextualPrompt\n  };\n}\nfunction getBearerTokenFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nvar HttpClient = class {\n  #baseUrl;\n  #fetchPolyfill;\n  constructor(baseUrl, fetchPolyfill) {\n    this.#baseUrl = baseUrl;\n    this.#fetchPolyfill = fetchPolyfill;\n  }\n  // ------------------------------------------------------------------\n  // Public methods\n  // ------------------------------------------------------------------\n  /**\n   * Constructs and makes the HTTP request, but does not handle the response.\n   *\n   * This is what .rawFetch() does:    👈 This method!\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails\n   *   6. Throw HttpError if response is an error\n   */\n  async #rawFetch(endpoint, authValue, options, params) {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"This client can only be used to make /v2/c/* requests\");\n    }\n    const url2 = urljoin(this.#baseUrl, endpoint, params);\n    return await this.#fetchPolyfill(url2, {\n      ...options,\n      headers: {\n        // These headers are default, but can be overriden by custom headers\n        \"Content-Type\": \"application/json; charset=utf-8\",\n        // Possible header overrides\n        ...options?.headers,\n        // Cannot be overriden by custom headers\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\"\n      }\n    });\n  }\n  /**\n   * Constructs, makes the HTTP request, and handles the response by parsing\n   * JSON and/or throwing an HttpError if it failed.\n   *\n   * This is what .rawFetch() does:\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:   👈 This method!\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails (🤔)\n   *   6. Throw HttpError if response is an error\n   */\n  async #fetch(endpoint, authValue, options, params) {\n    const response = await this.#rawFetch(endpoint, authValue, options, params);\n    if (!response.ok) {\n      throw await HttpError.fromResponse(response);\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  /**\n   * Makes a GET request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .get() instead.\n   */\n  async rawGet(endpoint, authValue, params, options) {\n    return await this.#rawFetch(endpoint, authValue, options, params);\n  }\n  /**\n   * Makes a POST request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .post() instead.\n   */\n  async rawPost(endpoint, authValue, body) {\n    return await this.#rawFetch(endpoint, authValue, {\n      method: \"POST\",\n      body: stringifyOrLog(body)\n    });\n  }\n  /**\n   * Makes a DELETE request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .delete() instead.\n   */\n  async rawDelete(endpoint, authValue) {\n    return await this.#rawFetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a GET request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async get(endpoint, authValue, params, options) {\n    return await this.#fetch(endpoint, authValue, options, params);\n  }\n  /**\n   * Makes a POST request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async post(endpoint, authValue, body, options, params) {\n    return await this.#fetch(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"POST\",\n        body: stringifyOrLog(body)\n      },\n      params\n    );\n  }\n  /**\n   * Makes a DELETE request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async delete(endpoint, authValue) {\n    return await this.#fetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a PUT request for a Blob body, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async putBlob(endpoint, authValue, blob, params, options) {\n    return await this.#fetch(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/octet-stream\"\n        },\n        body: blob\n      },\n      params\n    );\n  }\n};\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  #curr;\n  constructor(initialContext) {\n    this.#curr = initialContext;\n  }\n  get current() {\n    return this.#curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.#curr,\n      patch(patch) {\n        if (allowed) {\n          self.#curr = Object.assign({}, self.#curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  id;\n  // Indicates whether this state machine is still being configured, has\n  // started, or has terminated\n  #runningState;\n  #currentContext;\n  #states;\n  #currentStateOrNull;\n  #allowedTransitions;\n  #eventHub;\n  events;\n  //\n  // The cleanup stack is a stack of (optional) callback functions that will\n  // be run when exiting the current state. If a state (or state group) does\n  // not have an exit handler, then the entry for that level may be\n  // `undefined`, but there will be an explicit entry in the stack for it.\n  //\n  // This will always be true:\n  //\n  //   cleanupStack.length == currentState.split('.').length + 1\n  //\n  // Each stack level represents a different state \"group\".\n  //\n  // For example, if you are in a state named `foo.bar.qux`, then the stack\n  // will contain the exit handler for `foo.bar.qux` (at the top), then\n  // `foo.bar.*`, then `foo.*`, and finally, `*`.\n  //\n  #cleanupStack;\n  #enterFns;\n  // Used to provide better error messages\n  #knownEventTypes;\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get #initialState() {\n    const result = this.#states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.#currentStateOrNull === null) {\n      if (this.#runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.#currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.#runningState = 1 /* STARTED */;\n    this.#currentStateOrNull = this.#initialState;\n    this.#enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.#runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.#exit(null);\n    this.#runningState = 2 /* STOPPED */;\n    this.#currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.#runningState = 0 /* NOT_STARTED_YET */;\n    this.#currentStateOrNull = null;\n    this.#states = /* @__PURE__ */ new Set();\n    this.#enterFns = /* @__PURE__ */ new Map();\n    this.#cleanupStack = [];\n    this.#knownEventTypes = /* @__PURE__ */ new Set();\n    this.#allowedTransitions = /* @__PURE__ */ new Map();\n    this.#currentContext = new SafeContext(initialContext);\n    this.#eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.#eventHub.didReceiveEvent.observable,\n      willTransition: this.#eventHub.willTransition.observable,\n      didIgnoreEvent: this.#eventHub.didIgnoreEvent.observable,\n      willExitState: this.#eventHub.willExitState.observable,\n      didEnterState: this.#eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.#currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.#states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.#enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.#enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  /**\n   * Defines a promise-based state. When the state is entered, the promise is\n   * created. When the promise resolves, the machine will transition to the\n   * provided `onOK` target state. When the promise rejects, the machine will\n   * transition to the `onError` target state.\n   *\n   * Optionally, a `maxTimeout` can be set. If the timeout happens before the\n   * promise is settled, then the machine will also transition to the `onError`\n   * target state.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param promiseFn       The callback to be invoked when the state is entered.\n   * @param onOK            The state to transition to when the promise resolves.\n   * @param onError         The state to transition to when the promise\n   *                        rejects, or when the timeout happens before the\n   *                        promise has been settled.\n   * @param maxTimeout      Optional timeout in milliseconds.\n   *\n   * When the promise callback function is invoked, it's provided with an\n   * AbortSignal (2nd argument).\n   * If a state transition happens while the promise is pending (for example,\n   * an event, or a timeout happens), then an abort signal will be used to\n   * indicate this. Implementers can use this abort signal to terminate the\n   * in-flight promise, or ignore its results, etc.\n   */\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      const timeoutId = maxTimeout ? setTimeout(() => {\n        const reason = new Error(\"Timed out\");\n        this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n      }, maxTimeout) : void 0;\n      let done = false;\n      void promiseFn(this.#currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        clearTimeout(timeoutId);\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  #getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.#states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.#states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.#states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.#getStatesMatching(nameOrPattern)) {\n      let map = this.#allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.#allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.#knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param after           Number of milliseconds after which to take the\n   *                        transition. If in the mean time, another transition\n   *                        is taken, the timer will get cancelled.\n   * @param target          The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.#currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.#transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  #getTargetFn(eventName) {\n    return this.#allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  #exit(levels) {\n    this.#eventHub.willExitState.notify(this.currentState);\n    this.#currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.#cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.#cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  #enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.#currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.#enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.#cleanupStack.push(cleanupFn);\n        } else {\n          this.#cleanupStack.push(null);\n        }\n      }\n    });\n    this.#eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.#knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.#runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.#getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.#transition(event, targetFn);\n    } else {\n      this.#eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  #transition(event, target) {\n    this.#eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.#currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.#eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.#states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.#eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.#exit(up);\n    }\n    this.#currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.#currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.#enter(down);\n    }\n  }\n};\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_UPDATED\"] = 408] = \"THREAD_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    // istanbul ignore next\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeBufferableEventSource();\n  onMessage.pause();\n  const onConnectionError = makeEventSource();\n  function fireErrorEvent(message, code) {\n    return () => {\n      onConnectionError.notify({ message, code });\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onConnectionError: onConnectionError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  #machine;\n  #cleanups;\n  events;\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.#machine = machine;\n    this.events = events;\n    this.#cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.#machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.#machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.#machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.#machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.#machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.#machine.stop();\n    let cleanup;\n    while (cleanup = this.#cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.#machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.#machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nvar Permission = /* @__PURE__ */ ((Permission2) => {\n  Permission2[\"Read\"] = \"room:read\";\n  Permission2[\"Write\"] = \"room:write\";\n  Permission2[\"PresenceWrite\"] = \"room:presence:write\";\n  Permission2[\"CommentsWrite\"] = \"comments:write\";\n  Permission2[\"CommentsRead\"] = \"comments:read\";\n  return Permission2;\n})(Permission || {});\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions, onAuthenticate) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      onAuthenticate?.(parsed.parsed);\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          onAuthenticate?.(parsed.parsed);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch, endpoint, body) {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: stringifyOrLog(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${stringifyOrLog(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      // When a devtool panel sends an explicit \"connect\" message back to this\n      // live running client (in response to the \"wake-up-devtools\" message,\n      // or when the devtool panel is opened for the first time), it means that it's okay to\n      // start emitting messages.\n      // Before this explicit acknowledgement, any call to sendToPanel() will\n      // be a no-op.\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        // Sent by the devtool panel when it wants to receive the sync stream\n        // for a room\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  //                  ^^^^^^^^^^^^ TODO: Make this an interface\n  #pool;\n  #id;\n  #parent = NoParent;\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.#pool;\n  }\n  get roomId() {\n    return this.#pool ? this.#pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.#id;\n  }\n  /** @internal */\n  get parent() {\n    return this.#parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this.#parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this.#parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.#id || this.#pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.#id = id;\n    this.#pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.#pool && this.#id) {\n      this.#pool.deleteNode(this.#id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this.#parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this.#parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.#pool = void 0;\n  }\n  /** This caches the result of the last .toImmutable() call for this Live node. */\n  #cachedImmutable;\n  #cachedTreeNodeKey;\n  /** This caches the result of the last .toTreeNode() call for this Live node. */\n  #cachedTreeNode;\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this.#cachedImmutable !== void 0 || this.#cachedTreeNode !== void 0) {\n      this.#cachedImmutable = void 0;\n      this.#cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this.#cachedTreeNode === void 0 || this.#cachedTreeNodeKey !== key) {\n      this.#cachedTreeNodeKey = key;\n      this.#cachedTreeNode = this._toTreeNode(key);\n    }\n    return this.#cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this.#cachedImmutable === void 0) {\n      this.#cachedImmutable = this._toImmutable();\n    }\n    return this.#cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  #data;\n  constructor(data) {\n    super();\n    this.#data = data;\n  }\n  get data() {\n    return this.#data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this.#data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  // TODO: Naive array at first, find a better data structure. Maybe an Order statistics tree?\n  #items;\n  #implicitlyDeletedItems;\n  #unacknowledgedSets;\n  constructor(items) {\n    super();\n    this.#items = [];\n    this.#implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this.#unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this.#items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this.#items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this.#unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this.#items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this.#items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this.#items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this.#items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this.#items) {\n      item._detach();\n    }\n  }\n  #applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this.#items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this.#items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this.#implicitlyDeletedItems.add(itemWithSamePosition);\n        this.#items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this.#detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  #applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this.#detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this.#unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this.#unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this.#implicitlyDeletedItems.add(\n          this.#items[indexOfItemWithSamePosition]\n        );\n        const [prevNode] = this.#items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition, prevNode));\n      }\n      const prevIndex = this.#items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(existingItem);\n      if (newIndex !== prevIndex) {\n        delta.push(moveDelta(prevIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this.#implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this.#items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this.#items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this.#createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   */\n  #detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  #applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this.#shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  #applyInsertAck(op) {\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this.#items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this.#implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  #applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this.#items[existingItemIndex]?._parentPos;\n      const after2 = this.#items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  #applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this.#unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this.#items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this.#items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this.#detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this.#applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this.#applySetAck(op);\n      } else {\n        result = this.#applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this.#applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this.#applyInsertAck(op);\n      } else {\n        result = this.#applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this.#items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      const [previousNode] = this.#items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  #applySetChildKeyRemote(newKey, child) {\n    if (this.#implicitlyDeletedItems.has(child)) {\n      this.#implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this.#items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this.#items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  #applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this.#implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this.#implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this.#items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  #applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this.#items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this.#items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this.#items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this.#applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this.#applySetChildKeyAck(newKey, child);\n    } else {\n      return this.#applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this.#items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this.#items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length}`\n      );\n    }\n    const before2 = this.#items[index - 1] ? this.#items[index - 1]._parentPos : void 0;\n    const after2 = this.#items[index] ? this.#items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this.#items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this.#items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this.#items.length - 1 ? void 0 : this.#items[targetIndex + 1]._parentPos;\n      beforePosition = this.#items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this.#items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this.#items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this.#items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this.#items.length - 1}`\n      );\n    }\n    const item = this.#items[index];\n    item._detach();\n    const [prev] = this.#items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index, prev)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this.#items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0, item));\n        }\n      }\n      this.#items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this.#items) {\n        item._detach();\n      }\n      this.#items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length - 1}`\n      );\n    }\n    const existingItem = this.#items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this.#items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this.#unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this.#items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this.#items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this.#items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this.#items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this.#items);\n  }\n  #createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  #shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this.#items.length > index + 1 ? this.#items[index + 1]?._parentPos : void 0\n    );\n    this.#items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this.#items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this.#items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  #innerIterator;\n  constructor(items) {\n    this.#innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this.#innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index, deletedNode) {\n  return {\n    type: \"delete\",\n    index,\n    deletedItem: deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    type: \"move\",\n    index,\n    item: item instanceof LiveRegister ? item.data : item,\n    previousIndex\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  #map;\n  #unacknowledgedSet;\n  constructor(entries2) {\n    super();\n    this.#unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this.#map = new Map(mappedEntries);\n    } else {\n      this.#map = /* @__PURE__ */ new Map();\n    }\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this.#map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map.#map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.#unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.#unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.#unacknowledgedSet.delete(key);\n    }\n    const previousValue = this.#map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this.#map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this.#map.values()) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this.#map) {\n      if (value === child) {\n        this.#map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this.#map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this.#map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this.#map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.#unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this.#map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this.#map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this.#map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this.#map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this.#map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this.#map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this.#map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this.#map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this.#map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this.#map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  #map;\n  #propToLastUpdate;\n  static #buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject.#buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this.#propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this.#map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj.#map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this.#propToLastUpdate.get(key) === opId) {\n        this.#propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this.#propToLastUpdate.set(key, nn(opId));\n    } else if (this.#propToLastUpdate.get(key) === void 0) {\n    } else if (this.#propToLastUpdate.get(key) === opId) {\n      this.#propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this.#map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this.#map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this.#map) {\n        if (value === child) {\n          this.#map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const value of this.#map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this.#applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this.#applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this.#map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  #applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this.#propToLastUpdate.set(key, nn(op.opId));\n      } else if (this.#propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this.#propToLastUpdate.get(key) === op.opId) {\n        this.#propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this.#map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  #applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this.#map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this.#propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this.#map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this.#map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this.#map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this.#map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this.#map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this.#map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this.#map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this.#map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this.#map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this.#propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this.#propToLastUpdate.set(key, opId);\n      }\n      this.#map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this.#map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this.#map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this.#map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || stringifyOrLog(crdt.data) !== stringifyOrLog(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Deque.ts\nvar Deque = class {\n  #data;\n  #front;\n  #back;\n  #size;\n  constructor() {\n    this.#data = {};\n    this.#front = 0;\n    this.#back = 1;\n    this.#size = 0;\n  }\n  get length() {\n    return this.#size;\n  }\n  *[Symbol.iterator]() {\n    const size = this.#size;\n    const front = this.#front;\n    for (let i = 0; i < size; i++) {\n      yield this.#data[front + i];\n    }\n  }\n  push(value) {\n    const values2 = Array.isArray(value) ? value : [value];\n    if (this.#back > Number.MAX_SAFE_INTEGER - values2.length - 1)\n      raise(\"Deque full\");\n    for (const value2 of values2) {\n      this.#data[this.#back++ - 1] = value2;\n    }\n    this.#size += values2.length;\n  }\n  pop() {\n    if (this.#size < 1) return void 0;\n    this.#back--;\n    const value = this.#data[this.#back - 1];\n    delete this.#data[this.#back - 1];\n    this.#size--;\n    return value;\n  }\n  pushLeft(value) {\n    const values2 = Array.isArray(value) ? value : [value];\n    if (this.#front < Number.MIN_SAFE_INTEGER + values2.length)\n      raise(\"Deque full\");\n    for (let i = values2.length - 1; i >= 0; i--) {\n      this.#data[--this.#front] = values2[i];\n    }\n    this.#size += values2.length;\n  }\n  popLeft() {\n    if (this.#size < 1) return void 0;\n    const value = this.#data[this.#front];\n    delete this.#data[this.#front];\n    this.#front++;\n    this.#size--;\n    return value;\n  }\n};\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ManagedOthers.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar ManagedOthers = class {\n  // Track mutable state internally, but signal to the outside when the\n  // observable derived state changes only\n  #internal;\n  #userCache;\n  // The \"clean\" signal that is exposed to the outside world\n  signal;\n  constructor() {\n    this.#internal = new MutableSignal({\n      connections: /* @__PURE__ */ new Map(),\n      presences: /* @__PURE__ */ new Map()\n    });\n    this.signal = DerivedSignal.from(\n      this.#internal,\n      (_ignore) => compact(\n        Array.from(this.#internal.get().presences.keys()).map(\n          (connectionId) => this.getUser(Number(connectionId))\n        )\n      )\n    );\n    this.#userCache = /* @__PURE__ */ new Map();\n  }\n  // Shorthand for .signal.get()\n  get() {\n    return this.signal.get();\n  }\n  connectionIds() {\n    return this.#internal.get().connections.keys();\n  }\n  clearOthers() {\n    this.#internal.mutate((state) => {\n      state.connections.clear();\n      state.presences.clear();\n      this.#userCache.clear();\n    });\n  }\n  #_getUser(connectionId) {\n    const state = this.#internal.get();\n    const conn = state.connections.get(connectionId);\n    const presence = state.presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this.#userCache.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this.#_getUser(connectionId);\n    if (computedUser) {\n      this.#userCache.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  #invalidateUser(connectionId) {\n    this.#userCache.delete(connectionId);\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this.#internal.mutate((state) => {\n      state.connections.set(\n        connectionId,\n        freeze({\n          connectionId,\n          id: metaUserId,\n          info: metaUserInfo,\n          scopes\n        })\n      );\n      if (!state.presences.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this.#internal.mutate((state) => {\n      state.connections.delete(connectionId);\n      state.presences.delete(connectionId);\n      this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this.#internal.mutate((state) => {\n      state.presences.set(connectionId, freeze(compactObject(presence)));\n      if (!state.connections.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    this.#internal.mutate((state) => {\n      const oldPresence = state.presences.get(connectionId);\n      if (oldPresence === void 0) {\n        return false;\n      }\n      const newPresence = merge(oldPresence, patch);\n      if (oldPresence === newPresence) {\n        return false;\n      }\n      state.presences.set(connectionId, freeze(newPresence));\n      return this.#invalidateUser(connectionId);\n    });\n  }\n};\n\n// src/types/LiveblocksError.ts\nvar LiveblocksError = class _LiveblocksError extends Error {\n  context;\n  constructor(message, context, cause) {\n    super(message, { cause });\n    this.context = context;\n    this.name = \"LiveblocksError\";\n  }\n  /** Convenience accessor for error.context.roomId (if available) */\n  get roomId() {\n    return this.context.roomId;\n  }\n  /** @deprecated Prefer using `context.code` instead, to enable type narrowing */\n  get code() {\n    return this.context.code;\n  }\n  /**\n   * Creates a LiveblocksError from a generic error, by attaching Liveblocks\n   * contextual information like room ID, thread ID, etc.\n   */\n  static from(context, cause) {\n    return new _LiveblocksError(\n      defaultMessageFromContext(context),\n      context,\n      cause\n    );\n  }\n};\nfunction defaultMessageFromContext(context) {\n  switch (context.type) {\n    case \"ROOM_CONNECTION_ERROR\": {\n      switch (context.code) {\n        case 4001:\n          return \"Not allowed to connect to the room\";\n        case 4005:\n          return \"Room is already full\";\n        case 4006:\n          return \"Kicked out of the room, because the room ID changed\";\n        default:\n          return \"Could not connect to the room\";\n      }\n    }\n    case \"CREATE_THREAD_ERROR\":\n      return \"Could not create new thread\";\n    case \"DELETE_THREAD_ERROR\":\n      return \"Could not delete thread\";\n    case \"EDIT_THREAD_METADATA_ERROR\":\n      return \"Could not edit thread metadata\";\n    case \"MARK_THREAD_AS_RESOLVED_ERROR\":\n      return \"Could not mark thread as resolved\";\n    case \"MARK_THREAD_AS_UNRESOLVED_ERROR\":\n      return \"Could not mark thread as unresolved\";\n    case \"CREATE_COMMENT_ERROR\":\n      return \"Could not create new comment\";\n    case \"EDIT_COMMENT_ERROR\":\n      return \"Could not edit comment\";\n    case \"DELETE_COMMENT_ERROR\":\n      return \"Could not delete comment\";\n    case \"ADD_REACTION_ERROR\":\n      return \"Could not add reaction\";\n    case \"REMOVE_REACTION_ERROR\":\n      return \"Could not remove reaction\";\n    case \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\":\n      return \"Could not mark inbox notification as read\";\n    case \"DELETE_INBOX_NOTIFICATION_ERROR\":\n      return \"Could not delete inbox notification\";\n    case \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\":\n      return \"Could not mark all inbox notifications as read\";\n    case \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\":\n      return \"Could not delete all inbox notifications\";\n    case \"UPDATE_NOTIFICATION_SETTINGS_ERROR\":\n      return \"Could not update notification settings\";\n    case \"UPDATE_USER_NOTIFICATION_SETTINGS_ERROR\":\n      return \"Could not update user notification settings\";\n    default:\n      return assertNever(context, \"Unhandled case\");\n  }\n}\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 512;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nfunction createRoom(options, config) {\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const httpClient = config.roomHttpClient;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfoSig: new Signal(null),\n    dynamicSessionInfoSig: new Signal(null),\n    myPresence: new PatchableSignal(initialPresence),\n    others: new ManagedOthers(),\n    initialStorage,\n    idFactory: null,\n    // The Yjs provider associated to this room\n    yjsProvider: void 0,\n    yjsProviderDidChange: makeEventSource(),\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    eventHub.status.notify(newStatus);\n    notifySelfChanged();\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        eventHub.lostConnection.notify(\"lost\");\n        _hasLostConnection = true;\n        context.others.clearOthers();\n        notify({ others: [{ type: \"reset\" }] });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          eventHub.lostConnection.notify(\"failed\");\n        } else {\n          eventHub.lostConnection.notify(\"restored\");\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.get() }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    const type = \"ROOM_CONNECTION_ERROR\";\n    const err = new LiveblocksError(message, { type, code, roomId });\n    const didNotify = config.errorEventSource.notify(err);\n    if (!didNotify) {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n        );\n      }\n    }\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (true) {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.pushLeft(reverse);\n      } else {\n        addToUndoStack(reverse);\n        context.redoStack.length = 0;\n        dispatchOps(ops);\n        notify({ storageUpdates });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfoSig.get()?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource(),\n    roomWillDestroy: makeEventSource()\n  };\n  const roomId = config.roomId;\n  async function createTextMention(userId, mentionId) {\n    return httpClient.createTextMention({ roomId, userId, mentionId });\n  }\n  async function deleteTextMention(mentionId) {\n    return httpClient.deleteTextMention({ roomId, mentionId });\n  }\n  async function reportTextEditor(type, rootKey) {\n    await httpClient.reportTextEditor({ roomId, type, rootKey });\n  }\n  async function listTextVersions() {\n    return httpClient.listTextVersions({ roomId });\n  }\n  async function listTextVersionsSince(options2) {\n    return httpClient.listTextVersionsSince({\n      roomId,\n      since: options2.since,\n      signal: options2.signal\n    });\n  }\n  async function getTextVersion(versionId) {\n    return httpClient.getTextVersion({ roomId, versionId });\n  }\n  async function createTextVersion() {\n    return httpClient.createTextVersion({ roomId });\n  }\n  async function executeContextualPrompt(options2) {\n    return httpClient.executeContextualPrompt({\n      roomId,\n      ...options2\n    });\n  }\n  function* chunkOps(msg) {\n    const { ops, ...rest } = msg;\n    if (ops.length < 2) {\n      throw new Error(\"Cannot split ops into smaller chunks\");\n    }\n    const mid = Math.floor(ops.length / 2);\n    const firstHalf = ops.slice(0, mid);\n    const secondHalf = ops.slice(mid);\n    for (const halfOps of [firstHalf, secondHalf]) {\n      const half = { ops: halfOps, ...rest };\n      const text = stringifyOrLog([half]);\n      if (!isTooBigForWebSocket(text)) {\n        yield text;\n      } else {\n        yield* chunkOps(half);\n      }\n    }\n  }\n  function* chunkMessages(messages) {\n    if (messages.length < 2) {\n      if (messages[0].type === 201 /* UPDATE_STORAGE */) {\n        yield* chunkOps(messages[0]);\n        return;\n      } else {\n        throw new Error(\n          \"Cannot split into chunks smaller than the allowed message size\"\n        );\n      }\n    }\n    const mid = Math.floor(messages.length / 2);\n    const firstHalf = messages.slice(0, mid);\n    const secondHalf = messages.slice(mid);\n    for (const half of [firstHalf, secondHalf]) {\n      const text = stringifyOrLog(half);\n      if (!isTooBigForWebSocket(text)) {\n        yield text;\n      } else {\n        yield* chunkMessages(half);\n      }\n    }\n  }\n  function isTooBigForWebSocket(text) {\n    if (text.length * 4 < MAX_SOCKET_MESSAGE_SIZE) {\n      return false;\n    }\n    return new TextEncoder().encode(text).length >= MAX_SOCKET_MESSAGE_SIZE;\n  }\n  function sendMessages(messages) {\n    const strategy = config.largeMessageStrategy ?? \"default\";\n    const text = stringifyOrLog(messages);\n    if (!isTooBigForWebSocket(text)) {\n      return managedSocket.send(text);\n    }\n    switch (strategy) {\n      case \"default\": {\n        error2(\"Message is too large for websockets, not sending. Configure largeMessageStrategy option to deal with this.\");\n        return;\n      }\n      case \"split\": {\n        warn(\"Message is too large for websockets, splitting into smaller chunks\");\n        for (const chunk2 of chunkMessages(messages)) {\n          managedSocket.send(chunk2);\n        }\n        return;\n      }\n      case \"experimental-fallback-to-http\": {\n        warn(\"Message is too large for websockets, so sending over HTTP instead\");\n        const nonce = context.dynamicSessionInfoSig.get()?.nonce ?? raise(\"Session is not authorized to send message over HTTP\");\n        void httpClient.sendMessages({ roomId, nonce, messages }).then((resp) => {\n          if (!resp.ok && resp.status === 403) {\n            managedSocket.reconnect();\n          }\n        });\n        return;\n      }\n    }\n  }\n  const self = DerivedSignal.from(\n    context.staticSessionInfoSig,\n    context.dynamicSessionInfoSig,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged() {\n    const currSelf = self.get();\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      eventHub.self.notify(currSelf);\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = DerivedSignal.from(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const canWrite = self.get()?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates);\n  }\n  function _addToRealUndoStack(historyOps) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange();\n  }\n  function addToUndoStack(historyOps) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.pushLeft(historyOps);\n    } else {\n      _addToRealUndoStack(historyOps);\n    }\n  }\n  function notify(updates) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n      const others = context.others.get();\n      for (const event of othersUpdates) {\n        eventHub.others.notify({ ...event, others });\n      }\n    }\n    if (updates.presence ?? false) {\n      notifySelfChanged();\n      eventHub.myPresence.notify(context.myPresence.get());\n    }\n    if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n      const updates2 = Array.from(storageUpdates.values());\n      eventHub.storageBatch.notify(updates2);\n    }\n    notifyStorageStatus();\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfoSig.get();\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: new Deque(),\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.get()[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.pushLeft(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.pushLeft(applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: Array.from(output.reverse),\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.get()[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.pushLeft({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      if (options2?.addToHistory) {\n        addToUndoStack([{ type: \"presence\", data: oldValues }]);\n      }\n      notify({ presence: true });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message) {\n    context.dynamicSessionInfoSig.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged();\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange() {\n    eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.get(),\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const inOps = Array.from(offlineOps.values());\n    const result = applyOps(inOps, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    for (const message of messages) {\n      switch (message.type) {\n        case 101 /* USER_JOINED */: {\n          const userJoinedUpdate = onUserJoinedMessage(message);\n          if (userJoinedUpdate) {\n            updates.others.push(userJoinedUpdate);\n          }\n          break;\n        }\n        case 100 /* UPDATE_PRESENCE */: {\n          const othersPresenceUpdate = onUpdatePresenceMessage(message);\n          if (othersPresenceUpdate) {\n            updates.others.push(othersPresenceUpdate);\n          }\n          break;\n        }\n        case 103 /* BROADCASTED_EVENT */: {\n          const others = context.others.get();\n          eventHub.customEvent.notify({\n            connectionId: message.actor,\n            user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n            event: message.event\n          });\n          break;\n        }\n        case 102 /* USER_LEFT */: {\n          const event2 = onUserLeftMessage(message);\n          if (event2) {\n            updates.others.push(event2);\n          }\n          break;\n        }\n        case 300 /* UPDATE_YDOC */: {\n          eventHub.ydoc.notify(message);\n          break;\n        }\n        case 104 /* ROOM_STATE */: {\n          updates.others.push(onRoomStateMessage(message));\n          break;\n        }\n        case 200 /* INITIAL_STORAGE_STATE */: {\n          processInitialStorage(message);\n          break;\n        }\n        // Write event\n        case 201 /* UPDATE_STORAGE */: {\n          const applyResult = applyOps(message.ops, false);\n          for (const [key, value] of applyResult.updates.storageUpdates) {\n            updates.storageUpdates.set(\n              key,\n              mergeStorageUpdates(updates.storageUpdates.get(key), value)\n            );\n          }\n          break;\n        }\n        // Receiving a RejectedOps message in the client means that the server is no\n        // longer in sync with the client. Trying to synchronize the client again by\n        // rolling back particular Ops may be hard/impossible. It's fine to not try and\n        // accept the out-of-sync reality and throw an error. We look at this kind of bug\n        // as a developer-owned bug. In production, these errors are not expected to happen.\n        case 299 /* REJECT_STORAGE_OP */: {\n          errorWithTitle(\n            \"Storage mutation rejection error\",\n            message.reason\n          );\n          if (true) {\n            const traces = /* @__PURE__ */ new Set();\n            for (const opId of message.opIds) {\n              const trace = context.opStackTraces?.get(opId);\n              if (trace) {\n                traces.add(trace);\n              }\n            }\n            if (traces.size > 0) {\n              warnWithTitle(\n                \"The following function calls caused the rejected storage mutations:\",\n                `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n              );\n            }\n            throw new Error(\n              `Storage mutations rejected by server: ${message.reason}`\n            );\n          }\n          break;\n        }\n        case 400 /* THREAD_CREATED */:\n        case 407 /* THREAD_DELETED */:\n        case 401 /* THREAD_METADATA_UPDATED */:\n        case 408 /* THREAD_UPDATED */:\n        case 405 /* COMMENT_REACTION_ADDED */:\n        case 406 /* COMMENT_REACTION_REMOVED */:\n        case 402 /* COMMENT_CREATED */:\n        case 403 /* COMMENT_EDITED */:\n        case 404 /* COMMENT_DELETED */: {\n          eventHub.comments.notify(message);\n          break;\n        }\n      }\n    }\n    notify(updates);\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence™ update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid, isV2) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid,\n      v2: isV2\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message);\n    applyAndSendOps(unacknowledgedOps);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) return;\n    const items = await httpClient.streamStorage({ roomId });\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid, isV2) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid && m.v2 === isV2;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid,\n        v2: isV2\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    notify(result.updates);\n    context.redoStack.push(result.reverse);\n    onHistoryChange();\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    notify(result.updates);\n    context.undoStack.push(result.reverse);\n    onHistoryChange();\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch2(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    context.activeBatch = {\n      ops: [],\n      updates: {\n        storageUpdates: /* @__PURE__ */ new Map(),\n        presence: false,\n        others: []\n      },\n      reverseOps: new Deque()\n    };\n    try {\n      returnValue = callback();\n    } finally {\n      const currentBatch = context.activeBatch;\n      context.activeBatch = null;\n      if (currentBatch.reverseOps.length > 0) {\n        addToUndoStack(Array.from(currentBatch.reverseOps));\n      }\n      if (currentBatch.ops.length > 0) {\n        context.redoStack.length = 0;\n      }\n      if (currentBatch.ops.length > 0) {\n        dispatchOps(currentBatch.ops);\n      }\n      notify(currentBatch.updates);\n      flushNowOrSoon();\n    }\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = new Deque();\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(Array.from(historyOps));\n    }\n  }\n  const syncSourceForStorage = config.createSyncSource();\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n    syncSourceForStorage.setSyncStatus(\n      storageStatus === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n  function isPresenceReady() {\n    return self.get() !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = DerivedSignal.from(\n    context.others.signal,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable,\n    roomWillDestroy: eventHub.roomWillDestroy.observable\n  };\n  async function getThreadsSince(options2) {\n    return httpClient.getThreadsSince({\n      roomId,\n      since: options2.since,\n      signal: options2.signal\n    });\n  }\n  async function getThreads(options2) {\n    return httpClient.getThreads({\n      roomId,\n      query: options2?.query,\n      cursor: options2?.cursor\n    });\n  }\n  async function getThread(threadId) {\n    return httpClient.getThread({ roomId, threadId });\n  }\n  async function createThread(options2) {\n    return httpClient.createThread({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      metadata: options2.metadata,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function deleteThread(threadId) {\n    return httpClient.deleteThread({ roomId, threadId });\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return httpClient.editThreadMetadata({ roomId, threadId, metadata });\n  }\n  async function markThreadAsResolved(threadId) {\n    return httpClient.markThreadAsResolved({ roomId, threadId });\n  }\n  async function markThreadAsUnresolved(threadId) {\n    return httpClient.markThreadAsUnresolved({\n      roomId,\n      threadId\n    });\n  }\n  async function createComment(options2) {\n    return httpClient.createComment({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function editComment(options2) {\n    return httpClient.editComment({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function deleteComment({\n    threadId,\n    commentId\n  }) {\n    return httpClient.deleteComment({ roomId, threadId, commentId });\n  }\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    return httpClient.addReaction({ roomId, threadId, commentId, emoji });\n  }\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    return await httpClient.removeReaction({\n      roomId,\n      threadId,\n      commentId,\n      emoji\n    });\n  }\n  function prepareAttachment(file) {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file\n    };\n  }\n  async function uploadAttachment(attachment, options2 = {}) {\n    return httpClient.uploadAttachment({\n      roomId,\n      attachment,\n      signal: options2.signal\n    });\n  }\n  function getAttachmentUrl(attachmentId) {\n    return httpClient.getAttachmentUrl({ roomId, attachmentId });\n  }\n  function getNotificationSettings(options2) {\n    return httpClient.getNotificationSettings({\n      roomId,\n      signal: options2?.signal\n    });\n  }\n  function updateNotificationSettings(settings) {\n    return httpClient.updateNotificationSettings({ roomId, settings });\n  }\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await httpClient.markRoomInboxNotificationAsRead({\n      roomId,\n      inboxNotificationId\n    });\n  }\n  const syncSourceForYjs = config.createSyncSource();\n  function yjsStatusDidChange(status) {\n    return syncSourceForYjs.setSyncStatus(\n      status === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        getYjsProvider() {\n          return context.yjsProvider;\n        },\n        setYjsProvider(newProvider) {\n          context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n          context.yjsProvider = newProvider;\n          newProvider?.on(\"status\", yjsStatusDidChange);\n          context.yjsProviderDidChange.notify();\n        },\n        yjsProviderDidChange: context.yjsProviderDidChange.observable,\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // List versions of the document since the specified date\n        listTextVersionsSince,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n        // execute a contextual prompt\n        executeContextualPrompt,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.get(),\n        getOthers_forDevTools: () => others_forDevTools.get(),\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        attachmentUrlsStore: httpClient.getOrCreateAttachmentUrlsStore(roomId)\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(\n        config.roomId,\n        events,\n        config.errorEventSource\n      ),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        const { roomWillDestroy, ...eventsExceptDestroy } = eventHub;\n        for (const source of Object.values(eventsExceptDestroy)) {\n          source[Symbol.dispose]();\n        }\n        eventHub.roomWillDestroy.notify();\n        context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n        syncSourceForStorage.destroy();\n        syncSourceForYjs.destroy();\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n        roomWillDestroy[Symbol.dispose]();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch: batch2,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.get(),\n      // Presence\n      getPresence: () => context.myPresence.get(),\n      getOthers: () => context.others.get(),\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      createComment,\n      editComment,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n      // Notifications\n      getNotificationSettings,\n      updateNotificationSettings,\n      markInboxNotificationAsRead\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(roomId, events, errorEvents) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\": {\n          return errorEvents.subscribe((err) => {\n            if (err.roomId === roomId) {\n              return callback(err);\n            }\n          });\n        }\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        case \"comments\":\n          return events.comments.subscribe(\n            callback\n          );\n        // istanbul ignore next\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\" || value === \"comments\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url2 = new URL(baseUrl);\n    url2.protocol = url2.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url2.pathname = \"/v7\";\n    url2.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url2.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url2.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url2.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url2.toString());\n  };\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const currentUserId = new Signal(void 0);\n  const authManager = createAuthManager(options, (token) => {\n    const userId = token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid;\n    currentUserId.set(() => userId);\n  });\n  const fetchPolyfill = clientOptions.polyfills?.fetch || /* istanbul ignore next */\n  globalThis.fetch?.bind(globalThis);\n  const httpClient = createApiClient({\n    baseUrl,\n    fetchPolyfill,\n    authManager\n  });\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        baseUrl,\n        errorEventSource: liveblocksErrorSource,\n        largeMessageStrategy: clientOptions.largeMessageStrategy ?? (clientOptions.unstable_fallbackToHTTP ? \"experimental-fallback-to-http\" : void 0),\n        unstable_streamData: !!clientOptions.unstable_streamData,\n        roomHttpClient: httpClient,\n        createSyncSource\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    currentUserId.set(() => void 0);\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n  function invalidateResolvedUsers(userIds) {\n    usersStore.invalidate(userIds);\n  }\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n  function invalidateResolvedRoomsInfo(roomIds) {\n    roomsInfoStore.invalidate(roomIds);\n  }\n  const mentionSuggestionsCache = /* @__PURE__ */ new Map();\n  function invalidateResolvedMentionSuggestions() {\n    mentionSuggestionsCache.clear();\n  }\n  const syncStatusSources = [];\n  const syncStatusSignal = new Signal(\"synchronized\");\n  const liveblocksErrorSource = makeEventSource();\n  function getSyncStatus() {\n    const status = syncStatusSignal.get();\n    return status === \"synchronizing\" ? status : \"synchronized\";\n  }\n  function recompute() {\n    syncStatusSignal.set(\n      syncStatusSources.some((src) => src.get() === \"synchronizing\") ? \"synchronizing\" : syncStatusSources.some((src) => src.get() === \"has-local-changes\") ? \"has-local-changes\" : \"synchronized\"\n    );\n  }\n  function createSyncSource() {\n    const source = new Signal(\"synchronized\");\n    syncStatusSources.push(source);\n    const unsub = source.subscribe(() => recompute());\n    function setSyncStatus(status) {\n      source.set(status);\n    }\n    function destroy() {\n      unsub();\n      const index = syncStatusSources.findIndex((item) => item === source);\n      if (index > -1) {\n        const [ref] = syncStatusSources.splice(index, 1);\n        const wasStillPending = ref.get() !== \"synchronized\";\n        if (wasStillPending) {\n          recompute();\n        }\n      }\n    }\n    return { setSyncStatus, destroy };\n  }\n  {\n    const maybePreventClose = (e) => {\n      if (clientOptions.preventUnsavedChanges && syncStatusSignal.get() !== \"synchronized\") {\n        e.preventDefault();\n      }\n    };\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    win?.addEventListener(\"beforeunload\", maybePreventClose);\n  }\n  const client = Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      // Public inbox notifications API\n      getInboxNotifications: httpClient.getInboxNotifications,\n      getInboxNotificationsSince: httpClient.getInboxNotificationsSince,\n      getUnreadInboxNotificationsCount: httpClient.getUnreadInboxNotificationsCount,\n      markAllInboxNotificationsAsRead: httpClient.markAllInboxNotificationsAsRead,\n      markInboxNotificationAsRead: httpClient.markInboxNotificationAsRead,\n      deleteAllInboxNotifications: httpClient.deleteAllInboxNotifications,\n      deleteInboxNotification: httpClient.deleteInboxNotification,\n      // Public channel notification settings API\n      getNotificationSettings: httpClient.getUserNotificationSettings,\n      updateNotificationSettings: httpClient.updateUserNotificationSettings,\n      // Advanced resolvers APIs\n      resolvers: {\n        invalidateUsers: invalidateResolvedUsers,\n        invalidateRoomsInfo: invalidateResolvedRoomsInfo,\n        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions\n      },\n      getSyncStatus,\n      events: {\n        error: liveblocksErrorSource,\n        syncStatus: syncStatusSignal\n      },\n      // Internal\n      [kInternal]: {\n        currentUserId,\n        mentionSuggestionsCache,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        httpClient,\n        // Type-level helper only, it's effectively only an identity-function at runtime\n        as: () => client,\n        createSyncSource,\n        emitError: (context, cause) => {\n          const error3 = LiveblocksError.from(context, cause);\n          const didNotify = liveblocksErrorSource.notify(error3);\n          if (!didNotify) {\n            error2(error3.message);\n          }\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n  return client;\n}\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"paragraph\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  #strings;\n  #values;\n  constructor(strings, values2) {\n    this.#strings = strings;\n    this.#values = values2;\n  }\n  toString() {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this.#values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values2) {\n  return new HtmlSafeString(strings, values2);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  #strings;\n  #values;\n  constructor(strings, values2) {\n    this.#strings = strings;\n    this.#values = values2;\n  }\n  toString() {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this.#values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values2) {\n  return new MarkdownSafeString(strings, values2);\n}\nfunction toAbsoluteUrl(url2) {\n  if (url2.startsWith(\"http://\") || url2.startsWith(\"https://\")) {\n    return url2;\n  } else if (url2.startsWith(\"www.\")) {\n    return \"https://\" + url2;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.text ?? element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return html`${children}`;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return html`${children}`;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ? html`${element.text}` : element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ? html`${user?.name}` : element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.text ?? element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/comments/comment-url.ts\nvar PLACEHOLDER_BASE_URL = \"https://localhost:9999\";\nvar ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nfunction generateCommentUrl({\n  roomUrl,\n  commentId\n}) {\n  const isAbsolute = ABSOLUTE_URL_REGEX.test(roomUrl);\n  const urlObject = new URL(\n    roomUrl,\n    isAbsolute ? void 0 : PLACEHOLDER_BASE_URL\n  );\n  urlObject.hash = `#${commentId}`;\n  return isAbsolute ? urlObject.href : urlObject.href.replace(PLACEHOLDER_BASE_URL, \"\");\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nvar BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];\nfunction makePoller(callback, intervalMs, options) {\n  const startTime = performance.now();\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const win = typeof window !== \"undefined\" ? window : void 0;\n  const maxStaleTimeMs = options?.maxStaleTimeMs ?? Number.POSITIVE_INFINITY;\n  const context = {\n    inForeground: doc?.visibilityState !== \"hidden\",\n    lastSuccessfulPollAt: startTime,\n    count: 0,\n    backoff: 0\n  };\n  function mayPoll() {\n    return context.count > 0 && context.inForeground;\n  }\n  const fsm = new FSM({}).addState(\"@idle\").addState(\"@enabled\").addState(\"@polling\");\n  fsm.addTransitions(\"@idle\", { START: \"@enabled\" });\n  fsm.addTransitions(\"@enabled\", { STOP: \"@idle\", POLL: \"@polling\" });\n  fsm.addTimedTransition(\n    \"@enabled\",\n    () => {\n      const lastPoll = context.lastSuccessfulPollAt;\n      const nextPoll = lastPoll + intervalMs;\n      return Math.max(0, nextPoll - performance.now()) + context.backoff;\n    },\n    \"@polling\"\n  );\n  fsm.onEnterAsync(\n    \"@polling\",\n    async (_ctx, signal) => {\n      await callback(signal);\n      if (!signal.aborted) {\n        context.lastSuccessfulPollAt = performance.now();\n      }\n    },\n    // When OK\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = 0;\n        }\n      };\n    },\n    // When error\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = BACKOFF_DELAYS2.find((delay) => delay > context.backoff) ?? BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1];\n        }\n      };\n    },\n    3e4\n    // Abort the poll if the callback takes more than 30 seconds to complete\n  );\n  function startOrStop() {\n    if (mayPoll()) {\n      fsm.send({ type: \"START\" });\n    } else {\n      fsm.send({ type: \"STOP\" });\n    }\n  }\n  function inc() {\n    context.count++;\n    startOrStop();\n  }\n  function dec() {\n    context.count--;\n    if (context.count < 0) {\n      context.count = 0;\n    }\n    startOrStop();\n  }\n  function pollNowIfStale() {\n    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {\n      fsm.send({ type: \"POLL\" });\n    }\n  }\n  function setInForeground(inForeground) {\n    context.inForeground = inForeground;\n    startOrStop();\n    pollNowIfStale();\n  }\n  function onVisibilityChange() {\n    setInForeground(doc?.visibilityState !== \"hidden\");\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  win?.addEventListener(\"online\", onVisibilityChange);\n  win?.addEventListener(\"focus\", pollNowIfStale);\n  fsm.start();\n  return {\n    inc,\n    dec,\n    pollNowIfStale,\n    // Internal API, used by unit tests only to simulate visibility events\n    setInForeground\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/lib/SortedList.ts\nfunction bisectRight(arr, x, lt) {\n  let lo = 0;\n  let hi = arr.length;\n  while (lo < hi) {\n    const mid = lo + (hi - lo >> 1);\n    if (lt(x, arr[mid])) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\nvar SortedList = class _SortedList {\n  #data;\n  #lt;\n  constructor(alreadySortedList, lt) {\n    this.#lt = lt;\n    this.#data = alreadySortedList;\n  }\n  static from(arr, lt) {\n    const sorted = new _SortedList([], lt);\n    for (const item of arr) {\n      sorted.add(item);\n    }\n    return sorted;\n  }\n  static fromAlreadySorted(alreadySorted, lt) {\n    return new _SortedList(alreadySorted, lt);\n  }\n  /**\n   * Clones the sorted list to a new instance.\n   */\n  clone() {\n    return new _SortedList(this.#data.slice(), this.#lt);\n  }\n  /**\n   * Adds a new item to the sorted list, such that it remains sorted.\n   */\n  add(value) {\n    const idx = bisectRight(this.#data, value, this.#lt);\n    this.#data.splice(idx, 0, value);\n  }\n  /**\n   * Removes the given value from the sorted list, if it exists. The given\n   * value must be `===` to one of the list items. Only the first entry will be\n   * removed if the element exists in the sorted list multiple times.\n   */\n  remove(value) {\n    const idx = this.#data.indexOf(value);\n    if (idx >= 0) {\n      this.#data.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n  get length() {\n    return this.#data.length;\n  }\n  *filter(predicate) {\n    for (const item of this.#data) {\n      if (predicate(item)) {\n        yield item;\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this.#data[Symbol.iterator]();\n  }\n};\n\n// src/protocol/UserNotificationSettings.ts\nfunction isNotificationChannelEnabled(settings) {\n  return values(settings).every((enabled) => enabled === true);\n}\n\n// src/types/Others.ts\nvar TextEditorType = /* @__PURE__ */ ((TextEditorType2) => {\n  TextEditorType2[\"Lexical\"] = \"lexical\";\n  TextEditorType2[\"TipTap\"] = \"tiptap\";\n  return TextEditorType2;\n})(TextEditorType || {});\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nvar CommentsApiError = HttpError;\nvar NotificationsApiError = HttpError;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUIsR0FBRyxVQUFVO0FBQ3hFO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0EscUdBQXFHLGtCQUFrQjtBQUN2SDtBQUNBO0FBQ0EsV0FBVyxTQUFTLEVBQUUsVUFBVTtBQUNoQyxXQUFXLFNBQVMsRUFBRSxjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix3QkFBd0I7QUFDM0c7QUFDQTtBQUNBLGFBQWEsVUFBVSxRQUFRLFlBQVk7QUFDM0MsYUFBYSxTQUFTLFFBQVEsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE1BQXFDO0FBQ2xEO0FBQ0EsRUFBRSxDQUFRO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtB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QTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbURBQW1ELDRGQUE0RjtBQUMvSTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSUFBaUksY0FBYztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNLG1DQUFtQyxtQkFBbUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQXFDLEdBQUcsQ0FBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsK0JBQStCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUscUJBQXFCLE9BQU8sR0FBRyxLQUFLO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBcUMsR0FBRyxDQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWEsR0FBRyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJDQUEyQyw0QkFBNEI7QUFDdkU7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0NBQXNDLDZCQUE2QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9DQUFvQyxvQ0FBb0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxzQ0FBc0M7QUFDbkg7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMENBQTBDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUNBQXFDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCLFlBQVk7QUFDbEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGdDQUFnQyxtQkFBbUI7QUFDbkQsbUNBQW1DLGlDQUFpQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEMsTUFBTTtBQUNOLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBMEZFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cml0ZXRvZ2V0aGVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL2NvcmUvZGlzdC9pbmRleC5qcz9iY2FkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi4xOS4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9kdXBlLWRldGVjdGlvbi50c1xudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9O1xudmFyIGNyb3NzTGlua2VkRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2Nyb3NzLWxpbmtlZFwiO1xudmFyIGR1cGVzRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2R1cGVzXCI7XG52YXIgU1BBQ0UgPSBcIiBcIjtcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtc2cpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlY3REdXBlcyhwa2dOYW1lLCBwa2dWZXJzaW9uLCBwa2dGb3JtYXQpIHtcbiAgY29uc3QgcGtnSWQgPSBTeW1ib2wuZm9yKHBrZ05hbWUpO1xuICBjb25zdCBwa2dCdWlsZEluZm8gPSBwa2dGb3JtYXQgPyBgJHtwa2dWZXJzaW9uIHx8IFwiZGV2XCJ9ICgke3BrZ0Zvcm1hdH0pYCA6IHBrZ1ZlcnNpb24gfHwgXCJkZXZcIjtcbiAgaWYgKCFnW3BrZ0lkXSkge1xuICAgIGdbcGtnSWRdID0gcGtnQnVpbGRJbmZvO1xuICB9IGVsc2UgaWYgKGdbcGtnSWRdID09PSBwa2dCdWlsZEluZm8pIHtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtc2cgPSBbXG4gICAgICBgTXVsdGlwbGUgY29waWVzIG9mIExpdmVibG9ja3MgYXJlIGJlaW5nIGxvYWRlZCBpbiB5b3VyIHByb2plY3QuIFRoaXMgd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2R1cGVzRG9jcyArIFNQQUNFfWAsXG4gICAgICBcIlwiLFxuICAgICAgXCJDb25mbGljdHM6XCIsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7Z1twa2dJZF19IChhbHJlYWR5IGxvYWRlZClgLFxuICAgICAgYC0gJHtwa2dOYW1lfSAke3BrZ0J1aWxkSW5mb30gKHRyeWluZyB0byBsb2FkIHRoaXMgbm93KWBcbiAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgZXJyb3IobXNnKTtcbiAgfVxuICBpZiAocGtnVmVyc2lvbiAmJiBQS0dfVkVSU0lPTiAmJiBwa2dWZXJzaW9uICE9PSBQS0dfVkVSU0lPTikge1xuICAgIGVycm9yKFxuICAgICAgW1xuICAgICAgICBgQ3Jvc3MtbGlua2VkIHZlcnNpb25zIG9mIExpdmVibG9ja3MgZm91bmQsIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzISBTZWUgJHtjcm9zc0xpbmtlZERvY3MgKyBTUEFDRX1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgICAgYC0gJHtQS0dfTkFNRX0gaXMgYXQgJHtQS0dfVkVSU0lPTn1gLFxuICAgICAgICBgLSAke3BrZ05hbWV9IGlzIGF0ICR7cGtnVmVyc2lvbn1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkFsd2F5cyB1cGdyYWRlIGFsbCBMaXZlYmxvY2tzIHBhY2thZ2VzIHRvIHRoZSBzYW1lIHZlcnNpb24gbnVtYmVyLlwiXG4gICAgICBdLmpvaW4oXCJcXG5cIilcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb252ZXJ0LXBsYWluLWRhdGEudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnREYXRhKGRhdGEpIHtcbiAgY29uc3QgZWRpdGVkQXQgPSBkYXRhLmVkaXRlZEF0ID8gbmV3IERhdGUoZGF0YS5lZGl0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgcmVhY3Rpb25zID0gZGF0YS5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gKHtcbiAgICAuLi5yZWFjdGlvbixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHJlYWN0aW9uLmNyZWF0ZWRBdClcbiAgfSkpO1xuICBpZiAoZGF0YS5ib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXQsXG4gICAgICBkZWxldGVkQXRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREYXRhKGRhdGEpIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gIGNvbnN0IGNvbW1lbnRzID0gZGF0YS5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpXG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQsXG4gICAgdXBkYXRlZEF0LFxuICAgIGNvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoZGF0YSkge1xuICBjb25zdCBub3RpZmllZEF0ID0gbmV3IERhdGUoZGF0YS5ub3RpZmllZEF0KTtcbiAgY29uc3QgcmVhZEF0ID0gZGF0YS5yZWFkQXQgPyBuZXcgRGF0ZShkYXRhLnJlYWRBdCkgOiBudWxsO1xuICBpZiAoXCJhY3Rpdml0aWVzXCIgaW4gZGF0YSkge1xuICAgIGNvbnN0IGFjdGl2aXRpZXMgPSBkYXRhLmFjdGl2aXRpZXMubWFwKChhY3Rpdml0eSkgPT4gKHtcbiAgICAgIC4uLmFjdGl2aXR5LFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShhY3Rpdml0eS5jcmVhdGVkQXQpXG4gICAgfSkpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgbm90aWZpZWRBdCxcbiAgICAgIHJlYWRBdCxcbiAgICAgIGFjdGl2aXRpZXNcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBub3RpZmllZEF0LFxuICAgIHJlYWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbyhkYXRhKSB7XG4gIGNvbnN0IGRlbGV0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuZGVsZXRlZEF0KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGRlbGV0ZWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvKGRhdGEpIHtcbiAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgZGVsZXRlZEF0XG4gIH07XG59XG5cbi8vIHNyYy9saWIvZmFuY3ktY29uc29sZS50c1xudmFyIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFuY3lfY29uc29sZV9leHBvcnRzLCB7XG4gIGVycm9yOiAoKSA9PiBlcnJvcjIsXG4gIGVycm9yV2l0aFRpdGxlOiAoKSA9PiBlcnJvcldpdGhUaXRsZSxcbiAgd2FybjogKCkgPT4gd2FybixcbiAgd2FybldpdGhUaXRsZTogKCkgPT4gd2FybldpdGhUaXRsZVxufSk7XG52YXIgYmFkZ2UgPSBcImJhY2tncm91bmQ6IzBlMGQxMjtib3JkZXItcmFkaXVzOjk5OTlweDtjb2xvcjojZmZmO3BhZGRpbmc6M3B4IDdweDtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjYwMDtcIjtcbnZhciBib2xkID0gXCJmb250LXdlaWdodDo2MDBcIjtcbmZ1bmN0aW9uIHdyYXAobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIChtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXCIlY0xpdmVibG9ja3NcIiwgYmFkZ2UsIG1lc3NhZ2UsIC4uLmFyZ3MpXG4gICk7XG59XG52YXIgd2FybiA9IHdyYXAoXCJ3YXJuXCIpO1xudmFyIGVycm9yMiA9IHdyYXAoXCJlcnJvclwiKTtcbmZ1bmN0aW9uIHdyYXBXaXRoVGl0bGUobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICh0aXRsZSwgbWVzc2FnZSwgLi4uYXJncykgPT4gY29uc29sZVttZXRob2RdKFxuICAgICAgYCVjTGl2ZWJsb2NrcyVjICR7dGl0bGV9YCxcbiAgICAgIGJhZGdlLFxuICAgICAgYm9sZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICAuLi5hcmdzXG4gICAgKVxuICApO1xufVxudmFyIHdhcm5XaXRoVGl0bGUgPSB3cmFwV2l0aFRpdGxlKFwid2FyblwiKTtcbnZhciBlcnJvcldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJlcnJvclwiKTtcblxuLy8gc3JjL2xpYi9ndWFyZHMudHNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYmxvYikge1xuICByZXR1cm4gYmxvYiAhPT0gbnVsbCAmJiB0eXBlb2YgYmxvYiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxvYikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBpc1N0YXJ0c1dpdGhPcGVyYXRvcihibG9iKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGJsb2IpICYmIHR5cGVvZiBibG9iLnN0YXJ0c1dpdGggPT09IFwic3RyaW5nXCI7XG59XG5cbi8vIHNyYy9saWIvdXRpbHMudHNcbmZ1bmN0aW9uIHJhaXNlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGVudHJpZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopO1xufVxuZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG59XG5mdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKG9iaik7XG59XG5mdW5jdGlvbiBtYXBWYWx1ZXMob2JqLCBtYXBGbikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBwYWlyIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICBjb25zdCBrZXkgPSBwYWlyWzBdO1xuICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHBhaXJbMV07XG4gICAgcmVzdWx0W2tleV0gPSBtYXBGbih2YWx1ZSwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdHJ5UGFyc2VKc29uKHJhd01lc3NhZ2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyYXdNZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gYjY0ZGVjb2RlKGI2NHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZm9ybWF0dGVkVmFsdWUgPSBiNjR2YWx1ZS5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgICBjb25zdCBkZWNvZGVkVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoXG4gICAgICBhdG9iKGZvcm1hdHRlZFZhbHVlKS5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gXCIlXCIgKyAoXCIwMFwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgICAgfSkuam9pbihcIlwiKVxuICAgICk7XG4gICAgcmV0dXJuIGRlY29kZWRWYWx1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGF0b2IoYjY0dmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wYWN0KGl0ZW1zKSB7XG4gIHJldHVybiBpdGVtcy5maWx0ZXIoXG4gICAgKGl0ZW0pID0+IGl0ZW0gIT09IG51bGwgJiYgaXRlbSAhPT0gdm9pZCAwXG4gICk7XG59XG5mdW5jdGlvbiBjb21wYWN0T2JqZWN0KG9iaikge1xuICBjb25zdCBuZXdPYmogPSB7IC4uLm9iaiB9O1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGspID0+IHtcbiAgICBjb25zdCBrZXkgPSBrO1xuICAgIGlmIChuZXdPYmpba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxldGUgbmV3T2JqW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld09iajtcbn1cbmZ1bmN0aW9uIHdhaXQobWlsbGlzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgbWlsbGlzKSk7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoVGltZW91dChwcm9taXNlLCBtaWxsaXMsIGVycm1zZykge1xuICBsZXQgdGltZXJJRDtcbiAgY29uc3QgdGltZXIkID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgIHRpbWVySUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJybXNnKSk7XG4gICAgfSwgbWlsbGlzKTtcbiAgfSk7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVyJF0pLmZpbmFsbHkoKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVySUQpKTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVPblN1Y2Nlc3MoZmFjdG9yeUZuKSB7XG4gIGxldCBjYWNoZWQgPSBudWxsO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChjYWNoZWQgPT09IG51bGwpIHtcbiAgICAgIGNhY2hlZCA9IGZhY3RvcnlGbigpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY2FjaGVkID0gbnVsbDtcbiAgICAgICAgfSwgNWUzKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWQ7XG4gIH07XG59XG5cbi8vIHNyYy9saWIvYXV0b1JldHJ5LnRzXG52YXIgSHR0cEVycm9yID0gY2xhc3MgX0h0dHBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcmVzcG9uc2U7XG4gIGRldGFpbHM7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlc3BvbnNlLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJIdHRwRXJyb3JcIjtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgbGV0IGJvZHlBc1RleHQ7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHlBc1RleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIGNvbnN0IGJvZHlBc0pzb24gPSBib2R5QXNUZXh0ID8gdHJ5UGFyc2VKc29uKGJvZHlBc1RleHQpIDogdm9pZCAwO1xuICAgIGxldCBib2R5QXNKc29uT2JqZWN0O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHlBc0pzb24pKSB7XG4gICAgICBib2R5QXNKc29uT2JqZWN0ID0gYm9keUFzSnNvbjtcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2UgPSBcIlwiO1xuICAgIG1lc3NhZ2UgfHw9IHR5cGVvZiBib2R5QXNKc29uT2JqZWN0Py5tZXNzYWdlID09PSBcInN0cmluZ1wiID8gYm9keUFzSnNvbk9iamVjdC5tZXNzYWdlIDogXCJcIjtcbiAgICBtZXNzYWdlIHx8PSB0eXBlb2YgYm9keUFzSnNvbk9iamVjdD8uZXJyb3IgPT09IFwic3RyaW5nXCIgPyBib2R5QXNKc29uT2JqZWN0LmVycm9yIDogXCJcIjtcbiAgICBpZiAoYm9keUFzSnNvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBtZXNzYWdlIHx8PSBib2R5QXNUZXh0IHx8IFwiXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UgfHw9IHJlc3BvbnNlLnN0YXR1c1RleHQ7XG4gICAgbGV0IHBhdGg7XG4gICAgdHJ5IHtcbiAgICAgIHBhdGggPSBuZXcgVVJMKHJlc3BvbnNlLnVybCkucGF0aG5hbWU7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIG1lc3NhZ2UgKz0gcGF0aCAhPT0gdm9pZCAwID8gYCAoZ290IHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c30gZnJvbSAke3BhdGh9KWAgOiBgIChnb3Qgc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfSlgO1xuICAgIGNvbnN0IGRldGFpbHMgPSBib2R5QXNKc29uT2JqZWN0O1xuICAgIHJldHVybiBuZXcgX0h0dHBFcnJvcihtZXNzYWdlLCByZXNwb25zZSwgZGV0YWlscyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGFjY2Vzc29yIGZvciByZXNwb25zZS5zdGF0dXMuXG4gICAqL1xuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1cztcbiAgfVxufTtcbnZhciBET05UX1JFVFJZXzRYWCA9ICh4KSA9PiB4IGluc3RhbmNlb2YgSHR0cEVycm9yICYmIHguc3RhdHVzID49IDQwMCAmJiB4LnN0YXR1cyA8IDUwMDtcbmFzeW5jIGZ1bmN0aW9uIGF1dG9SZXRyeShwcm9taXNlRm4sIG1heFRyaWVzLCBiYWNrb2ZmLCBzaG91bGRTdG9wUmV0cnlpbmcgPSBET05UX1JFVFJZXzRYWCkge1xuICBjb25zdCBmYWxsYmFja0JhY2tvZmYgPSBiYWNrb2ZmLmxlbmd0aCA+IDAgPyBiYWNrb2ZmW2JhY2tvZmYubGVuZ3RoIC0gMV0gOiAwO1xuICBsZXQgYXR0ZW1wdCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgYXR0ZW1wdCsrO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZUZuKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoc2hvdWxkU3RvcFJldHJ5aW5nKGVycikpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgaWYgKGF0dGVtcHQgPj0gbWF4VHJpZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgYWZ0ZXIgJHttYXhUcmllc30gYXR0ZW1wdHM6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5ID0gYmFja29mZlthdHRlbXB0IC0gMV0gPz8gZmFsbGJhY2tCYWNrb2ZmO1xuICAgIHdhcm4oXG4gICAgICBgQXR0ZW1wdCAke2F0dGVtcHR9IHdhcyB1bnN1Y2Nlc3NmdWwuIFJldHJ5aW5nIGluICR7ZGVsYXl9IG1pbGxpc2Vjb25kcy5gXG4gICAgKTtcbiAgICBhd2FpdCB3YWl0KGRlbGF5KTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL2NvbnRyb2xsZWRQcm9taXNlLnRzXG5mdW5jdGlvbiBjb250cm9sbGVkUHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiBbcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0XTtcbn1cbmZ1bmN0aW9uIFByb21pc2Vfd2l0aFJlc29sdmVycygpIHtcbiAgY29uc3QgW3Byb21pc2UsIHJlc29sdmUsIHJlamVjdF0gPSBjb250cm9sbGVkUHJvbWlzZSgpO1xuICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn1cblxuLy8gc3JjL2xpYi9FdmVudFNvdXJjZS50c1xuZnVuY3Rpb24gbWFrZUV2ZW50U291cmNlKCkge1xuICBjb25zdCBfb2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgX29ic2VydmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiBfb2JzZXJ2ZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlT25jZShjYWxsYmFjaykge1xuICAgIGNvbnN0IHVuc3ViID0gc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgdW5zdWIoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhldmVudCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVuc3ViO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbChwcmVkaWNhdGUpIHtcbiAgICBsZXQgdW5zdWI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgIHVuc3ViID0gc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICBpZiAocHJlZGljYXRlID09PSB2b2lkIDAgfHwgcHJlZGljYXRlKGV2ZW50KSkge1xuICAgICAgICAgIHJlcyhldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdW5zdWI/LigpKTtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnkoZXZlbnQpIHtcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBfb2JzZXJ2ZXJzKSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGVkO1xuICB9XG4gIGZ1bmN0aW9uIGNvdW50KCkge1xuICAgIHJldHVybiBfb2JzZXJ2ZXJzLnNpemU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAvLyBQcml2YXRlL2ludGVybmFsIGNvbnRyb2wgb3ZlciBldmVudCBlbWlzc2lvblxuICAgIG5vdGlmeSxcbiAgICBzdWJzY3JpYmUsXG4gICAgc3Vic2NyaWJlT25jZSxcbiAgICBjb3VudCxcbiAgICB3YWl0VW50aWwsXG4gICAgW1N5bWJvbC5kaXNwb3NlXTogKCkgPT4ge1xuICAgICAgX29ic2VydmVycy5jbGVhcigpO1xuICAgIH0sXG4gICAgLy8gUHVibGljbHkgZXhwb3NhYmxlIHN1YnNjcmlwdGlvbiBBUElcbiAgICBvYnNlcnZhYmxlOiB7XG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBzdWJzY3JpYmVPbmNlLFxuICAgICAgd2FpdFVudGlsXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbWFrZUJ1ZmZlcmFibGVFdmVudFNvdXJjZSgpIHtcbiAgY29uc3QgZXZlbnRTb3VyY2UyID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGxldCBfYnVmZmVyID0gbnVsbDtcbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgX2J1ZmZlciA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKF9idWZmZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBfYnVmZmVyKSB7XG4gICAgICBldmVudFNvdXJjZTIubm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gICAgX2J1ZmZlciA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5T3JCdWZmZXIoZXZlbnQpIHtcbiAgICBpZiAoX2J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgX2J1ZmZlci5wdXNoKGV2ZW50KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV2ZW50U291cmNlMi5ub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmV2ZW50U291cmNlMixcbiAgICBub3RpZnk6IG5vdGlmeU9yQnVmZmVyLFxuICAgIHBhdXNlLFxuICAgIHVucGF1c2UsXG4gICAgW1N5bWJvbC5kaXNwb3NlXTogKCkgPT4ge1xuICAgICAgZXZlbnRTb3VyY2UyW1N5bWJvbC5kaXNwb3NlXSgpO1xuICAgICAgaWYgKF9idWZmZXIgIT09IG51bGwpIHtcbiAgICAgICAgX2J1ZmZlci5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9mcmVlemUudHNcbnZhciBmcmVlemUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyAoXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICh4KSA9PiB4XG4pIDogT2JqZWN0LmZyZWV6ZTtcblxuLy8gc3JjL2xpYi9zaWduYWxzLnRzXG52YXIga1NpbmtzID0gU3ltYm9sKFwia1NpbmtzXCIpO1xudmFyIGtUcmlnZ2VyID0gU3ltYm9sKFwia1RyaWdnZXJcIik7XG52YXIgc2lnbmFsc1RvVHJpZ2dlciA9IG51bGw7XG52YXIgdHJhY2tlZFJlYWRzID0gbnVsbDtcbmZ1bmN0aW9uIGJhdGNoKGNhbGxiYWNrKSB7XG4gIGlmIChzaWduYWxzVG9UcmlnZ2VyICE9PSBudWxsKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc2lnbmFsc1RvVHJpZ2dlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHRyeSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmb3IgKGNvbnN0IHNpZ25hbCBvZiBzaWduYWxzVG9UcmlnZ2VyKSB7XG4gICAgICBzaWduYWxba1RyaWdnZXJdKCk7XG4gICAgfVxuICAgIHNpZ25hbHNUb1RyaWdnZXIgPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlVHJpZ2dlcihzaWduYWwpIHtcbiAgaWYgKCFzaWduYWxzVG9UcmlnZ2VyKSByYWlzZShcIkV4cGVjdGVkIHRvIGJlIGluIGFuIGFjdGl2ZSBiYXRjaFwiKTtcbiAgc2lnbmFsc1RvVHJpZ2dlci5hZGQoc2lnbmFsKTtcbn1cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgcGF0Y2gpIHtcbiAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgY29uc3QgbmV3VmFsdWUgPSB7IC4uLnRhcmdldCB9O1xuICBPYmplY3Qua2V5cyhwYXRjaCkuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgY29uc3QgdmFsID0gcGF0Y2hba2V5XTtcbiAgICBpZiAobmV3VmFsdWVba2V5XSAhPT0gdmFsKSB7XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVsZXRlIG5ld1ZhbHVlW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZVtrZXldID0gdmFsO1xuICAgICAgfVxuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZWQgPyBuZXdWYWx1ZSA6IHRhcmdldDtcbn1cbnZhciBBYnN0cmFjdFNpZ25hbCA9IGNsYXNzIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBlcXVhbHM7XG4gICNldmVudFNvdXJjZTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBba1NpbmtzXTtcbiAgY29uc3RydWN0b3IoZXF1YWxzKSB7XG4gICAgdGhpcy5lcXVhbHMgPSBlcXVhbHMgPz8gT2JqZWN0LmlzO1xuICAgIHRoaXMuI2V2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gICAgdGhpc1trU2lua3NdID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmdldCA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdWJzY3JpYmUgPSB0aGlzLnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3Vic2NyaWJlT25jZSA9IHRoaXMuc3Vic2NyaWJlT25jZS5iaW5kKHRoaXMpO1xuICB9XG4gIFtTeW1ib2wuZGlzcG9zZV0oKSB7XG4gICAgdGhpcy4jZXZlbnRTb3VyY2VbU3ltYm9sLmRpc3Bvc2VdKCk7XG4gICAgdGhpcy4jZXZlbnRTb3VyY2UgPSBcIihkaXNwb3NlZClcIjtcbiAgICB0aGlzLmVxdWFscyA9IFwiKGRpc3Bvc2VkKVwiO1xuICB9XG4gIGdldCBoYXNXYXRjaGVycygpIHtcbiAgICBpZiAodGhpcy4jZXZlbnRTb3VyY2UuY291bnQoKSA+IDApIHJldHVybiB0cnVlO1xuICAgIGZvciAoY29uc3Qgc2luayBvZiB0aGlzW2tTaW5rc10pIHtcbiAgICAgIGlmIChzaW5rLmhhc1dhdGNoZXJzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgW2tUcmlnZ2VyXSgpIHtcbiAgICB0aGlzLiNldmVudFNvdXJjZS5ub3RpZnkoKTtcbiAgICBmb3IgKGNvbnN0IHNpbmsgb2YgdGhpc1trU2lua3NdKSB7XG4gICAgICBlbnF1ZXVlVHJpZ2dlcihzaW5rKTtcbiAgICB9XG4gIH1cbiAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuI2V2ZW50U291cmNlLmNvdW50KCkgPT09IDApIHtcbiAgICAgIHRoaXMuZ2V0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNldmVudFNvdXJjZS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICB9XG4gIHN1YnNjcmliZU9uY2UoY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bnN1YiA9IHRoaXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHVuc3ViKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5zdWI7XG4gIH1cbiAgd2FpdFVudGlsKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIndhaXRVbnRpbCBub3Qgc3VwcG9ydGVkIG9uIFNpZ25hbHNcIik7XG4gIH1cbiAgbWFya1NpbmtzRGlydHkoKSB7XG4gICAgZm9yIChjb25zdCBzaW5rIG9mIHRoaXNba1NpbmtzXSkge1xuICAgICAgc2luay5tYXJrRGlydHkoKTtcbiAgICB9XG4gIH1cbiAgYWRkU2luayhzaW5rKSB7XG4gICAgdGhpc1trU2lua3NdLmFkZChzaW5rKTtcbiAgfVxuICByZW1vdmVTaW5rKHNpbmspIHtcbiAgICB0aGlzW2tTaW5rc10uZGVsZXRlKHNpbmspO1xuICB9XG4gIGFzUmVhZG9ubHkoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgU2lnbmFsID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFNpZ25hbCB7XG4gICN2YWx1ZTtcbiAgY29uc3RydWN0b3IodmFsdWUsIGVxdWFscykge1xuICAgIHN1cGVyKGVxdWFscyk7XG4gICAgdGhpcy4jdmFsdWUgPSBmcmVlemUodmFsdWUpO1xuICB9XG4gIFtTeW1ib2wuZGlzcG9zZV0oKSB7XG4gICAgc3VwZXJbU3ltYm9sLmRpc3Bvc2VdKCk7XG4gICAgdGhpcy4jdmFsdWUgPSBcIihkaXNwb3NlZClcIjtcbiAgfVxuICBnZXQoKSB7XG4gICAgdHJhY2tlZFJlYWRzPy5hZGQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuI3ZhbHVlO1xuICB9XG4gIHNldChuZXdWYWx1ZSkge1xuICAgIGJhdGNoKCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbmV3VmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlKHRoaXMuI3ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5lcXVhbHModGhpcy4jdmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICB0aGlzLiN2YWx1ZSA9IGZyZWV6ZShuZXdWYWx1ZSk7XG4gICAgICAgIHRoaXMubWFya1NpbmtzRGlydHkoKTtcbiAgICAgICAgZW5xdWV1ZVRyaWdnZXIodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG52YXIgUGF0Y2hhYmxlU2lnbmFsID0gY2xhc3MgZXh0ZW5kcyBTaWduYWwge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoZnJlZXplKGNvbXBhY3RPYmplY3QoZGF0YSkpKTtcbiAgfVxuICBzZXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRG9uJ3QgY2FsbCAuc2V0KCkgZGlyZWN0bHksIHVzZSAucGF0Y2goKVwiKTtcbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgY3VycmVudCBvYmplY3QuXG4gICAqL1xuICBwYXRjaChwYXRjaCkge1xuICAgIHN1cGVyLnNldCgob2xkKSA9PiBtZXJnZShvbGQsIHBhdGNoKSk7XG4gIH1cbn07XG52YXIgSU5JVElBTCA9IFN5bWJvbCgpO1xudmFyIERlcml2ZWRTaWduYWwgPSBjbGFzcyBfRGVyaXZlZFNpZ25hbCBleHRlbmRzIEFic3RyYWN0U2lnbmFsIHtcbiAgI3ByZXZWYWx1ZTtcbiAgI2RpcnR5O1xuICAvLyBXaGVuIHRydWUsIHRoZSB2YWx1ZSBpbiAjdmFsdWUgbWF5IG5vdCBiZSB1cC10by1kYXRlIGFuZCBuZWVkcyByZS1jaGVja2luZ1xuICAjc291cmNlcztcbiAgI2RlcHM7XG4gICN0cmFuc2Zvcm07XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBzdGF0aWMgZnJvbSguLi5hcmdzKSB7XG4gICAgY29uc3QgbGFzdCA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBsYXN0ICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByYWlzZShcIkludmFsaWQgLmZyb20oKSBjYWxsLCBsYXN0IGFyZ3VtZW50IGV4cGVjdGVkIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgZXF1YWxzID0gbGFzdDtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGFyZ3MucG9wKCk7XG4gICAgICByZXR1cm4gbmV3IF9EZXJpdmVkU2lnbmFsKGFyZ3MsIHRyYW5zZm9ybSwgZXF1YWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gbGFzdDtcbiAgICAgIHJldHVybiBuZXcgX0Rlcml2ZWRTaWduYWwoYXJncywgdHJhbnNmb3JtKTtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IoZGVwcywgdHJhbnNmb3JtLCBlcXVhbHMpIHtcbiAgICBzdXBlcihlcXVhbHMpO1xuICAgIHRoaXMuI2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLiNwcmV2VmFsdWUgPSBJTklUSUFMO1xuICAgIHRoaXMuI2RlcHMgPSBkZXBzO1xuICAgIHRoaXMuI3NvdXJjZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuI3RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgfVxuICBbU3ltYm9sLmRpc3Bvc2VdKCkge1xuICAgIGZvciAoY29uc3Qgc3JjIG9mIHRoaXMuI3NvdXJjZXMpIHtcbiAgICAgIHNyYy5yZW1vdmVTaW5rKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLiNwcmV2VmFsdWUgPSBcIihkaXNwb3NlZClcIjtcbiAgICB0aGlzLiNzb3VyY2VzID0gXCIoZGlzcG9zZWQpXCI7XG4gICAgdGhpcy4jZGVwcyA9IFwiKGRpc3Bvc2VkKVwiO1xuICAgIHRoaXMuI3RyYW5zZm9ybSA9IFwiKGRpc3Bvc2VkKVwiO1xuICB9XG4gIGdldCBpc0RpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLiNkaXJ0eTtcbiAgfVxuICAjcmVjb21wdXRlKCkge1xuICAgIGNvbnN0IG9sZFRyYWNrZWRSZWFkcyA9IHRyYWNrZWRSZWFkcztcbiAgICBsZXQgZGVyaXZlZDtcbiAgICB0cmFja2VkUmVhZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRyeSB7XG4gICAgICBkZXJpdmVkID0gdGhpcy4jdHJhbnNmb3JtKC4uLnRoaXMuI2RlcHMubWFwKChwKSA9PiBwLmdldCgpKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNvbnN0IG9sZFNvdXJjZXMgPSB0aGlzLiNzb3VyY2VzO1xuICAgICAgdGhpcy4jc291cmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IHNpZyBvZiB0cmFja2VkUmVhZHMpIHtcbiAgICAgICAgdGhpcy4jc291cmNlcy5hZGQoc2lnKTtcbiAgICAgICAgb2xkU291cmNlcy5kZWxldGUoc2lnKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgb2xkU291cmNlIG9mIG9sZFNvdXJjZXMpIHtcbiAgICAgICAgb2xkU291cmNlLnJlbW92ZVNpbmsodGhpcyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG5ld1NvdXJjZSBvZiB0aGlzLiNzb3VyY2VzKSB7XG4gICAgICAgIG5ld1NvdXJjZS5hZGRTaW5rKHRoaXMpO1xuICAgICAgfVxuICAgICAgdHJhY2tlZFJlYWRzID0gb2xkVHJhY2tlZFJlYWRzO1xuICAgIH1cbiAgICB0aGlzLiNkaXJ0eSA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5lcXVhbHModGhpcy4jcHJldlZhbHVlLCBkZXJpdmVkKSkge1xuICAgICAgdGhpcy4jcHJldlZhbHVlID0gZGVyaXZlZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWFya0RpcnR5KCkge1xuICAgIGlmICghdGhpcy4jZGlydHkpIHtcbiAgICAgIHRoaXMuI2RpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMubWFya1NpbmtzRGlydHkoKTtcbiAgICB9XG4gIH1cbiAgZ2V0KCkge1xuICAgIGlmICh0aGlzLiNkaXJ0eSkge1xuICAgICAgdGhpcy4jcmVjb21wdXRlKCk7XG4gICAgfVxuICAgIHRyYWNrZWRSZWFkcz8uYWRkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLiNwcmV2VmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCBieSB0aGUgU2lnbmFsIHN5c3RlbSBpZiBvbmUgb3IgbW9yZSBvZiB0aGUgZGVwZW5kZW50IHNpZ25hbHMgaGF2ZVxuICAgKiBjaGFuZ2VkLiBJbiB0aGUgY2FzZSBvZiBhIERlcml2ZWRTaWduYWwsIHdlJ2xsIG9ubHkgd2FudCB0byByZS1ldmFsdWF0ZVxuICAgKiB0aGUgYWN0dWFsIHZhbHVlIGlmIGl0J3MgYmVpbmcgd2F0Y2hlZCwgb3IgYW55IG9mIHRoZWlyIHNpbmtzIGFyZSBiZWluZ1xuICAgKiB3YXRjaGVkIGFjdGl2ZWx5LlxuICAgKi9cbiAgW2tUcmlnZ2VyXSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzV2F0Y2hlcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZCA9IHRoaXMuI3JlY29tcHV0ZSgpO1xuICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICBzdXBlcltrVHJpZ2dlcl0oKTtcbiAgICB9XG4gIH1cbn07XG52YXIgTXV0YWJsZVNpZ25hbCA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RTaWduYWwge1xuICAjc3RhdGU7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxTdGF0ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIH1cbiAgW1N5bWJvbC5kaXNwb3NlXSgpIHtcbiAgICBzdXBlcltTeW1ib2wuZGlzcG9zZV0oKTtcbiAgICB0aGlzLiNzdGF0ZSA9IFwiKGRpc3Bvc2VkKVwiO1xuICB9XG4gIGdldCgpIHtcbiAgICB0cmFja2VkUmVhZHM/LmFkZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy4jc3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEludm9rZXMgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGFsbG93ZWQgdG8gbXV0YXRlIHRoZSBnaXZlbiBzdGF0ZVxuICAgKiB2YWx1ZS4gRG8gbm90IGNoYW5nZSB0aGUgdmFsdWUgb3V0c2lkZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIElmIHRoZSBjYWxsYmFjayBleHBsaWNpdGx5IHJldHVybnMgYGZhbHNlYCwgaXQncyBhc3N1bWVkIHRoYXQgdGhlIHN0YXRlXG4gICAqIHdhcyBub3QgY2hhbmdlZC5cbiAgICovXG4gIG11dGF0ZShjYWxsYmFjaykge1xuICAgIGJhdGNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrID8gY2FsbGJhY2sodGhpcy4jc3RhdGUpIDogdHJ1ZTtcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiBcInRoZW5cIiBpbiByZXN1bHQpIHtcbiAgICAgICAgcmFpc2UoXCJNdXRhYmxlU2lnbmFsLm11dGF0ZSgpIGRvZXMgbm90IHN1cHBvcnQgYXN5bmMgY2FsbGJhY2tzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5tYXJrU2lua3NEaXJ0eSgpO1xuICAgICAgICBlbnF1ZXVlVHJpZ2dlcih0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9zdHJpbmdpZnkudHNcbmZ1bmN0aW9uIHJlcGxhY2VyKF9rZXksIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpID8gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKS5yZWR1Y2UoKHNvcnRlZCwga2V5KSA9PiB7XG4gICAgc29ydGVkW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgIHJldHVybiBzb3J0ZWQ7XG4gIH0sIHt9KSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc3RhYmxlU3RyaW5naWZ5KHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5T3JMb2codmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3Qgc3RyaW5naWZ5OiAke2Vyci5tZXNzYWdlfWApO1xuICAgIGNvbnNvbGUuZXJyb3IodmFsdWUpO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG4vLyBzcmMvbGliL2JhdGNoLnRzXG52YXIgREVGQVVMVF9TSVpFID0gNTA7XG52YXIgQmF0Y2hDYWxsID0gY2xhc3Mge1xuICBpbnB1dDtcbiAgcmVzb2x2ZTtcbiAgcmVqZWN0O1xuICBwcm9taXNlO1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICB9XG59O1xudmFyIEJhdGNoID0gY2xhc3Mge1xuICAjcXVldWUgPSBbXTtcbiAgI2NhbGxiYWNrO1xuICAjc2l6ZTtcbiAgI2RlbGF5O1xuICAjZGVsYXlUaW1lb3V0SWQ7XG4gIGVycm9yID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdGhpcy4jY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLiNzaXplID0gb3B0aW9ucy5zaXplID8/IERFRkFVTFRfU0laRTtcbiAgICB0aGlzLiNkZWxheSA9IG9wdGlvbnMuZGVsYXk7XG4gIH1cbiAgI2NsZWFyRGVsYXlUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLiNkZWxheVRpbWVvdXRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZGVsYXlUaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jZGVsYXlUaW1lb3V0SWQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gICNzY2hlZHVsZSgpIHtcbiAgICBpZiAodGhpcy4jcXVldWUubGVuZ3RoID09PSB0aGlzLiNzaXplKSB7XG4gICAgICB2b2lkIHRoaXMuI2ZsdXNoKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNxdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuI2NsZWFyRGVsYXlUaW1lb3V0KCk7XG4gICAgICB0aGlzLiNkZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gdm9pZCB0aGlzLiNmbHVzaCgpLCB0aGlzLiNkZWxheSk7XG4gICAgfVxuICB9XG4gIGFzeW5jICNmbHVzaCgpIHtcbiAgICBpZiAodGhpcy4jcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhbGxzID0gdGhpcy4jcXVldWUuc3BsaWNlKDApO1xuICAgIGNvbnN0IGlucHV0cyA9IGNhbGxzLm1hcCgoY2FsbCkgPT4gY2FsbC5pbnB1dCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLiNjYWxsYmFjayhpbnB1dHMpO1xuICAgICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgICAgY2FsbHMuZm9yRWFjaCgoY2FsbCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0cz8uW2luZGV4XTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QobmV3IEVycm9yKFwiQ2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gYXJyYXkuXCIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYWxscy5sZW5ndGggIT09IHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBDYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheSBvZiB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIG51bWJlciBvZiBwcm92aWRlZCBpdGVtcy4gRXhwZWN0ZWQgJHtjYWxscy5sZW5ndGh9LCBidXQgZ290ICR7cmVzdWx0cy5sZW5ndGh9LmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICB0aGlzLmVycm9yID0gdHJ1ZTtcbiAgICAgIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICAgICAgY2FsbC5yZWplY3QoZXJyb3IzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQoaW5wdXQpIHtcbiAgICBjb25zdCBleGlzdGluZ0NhbGwgPSB0aGlzLiNxdWV1ZS5maW5kKFxuICAgICAgKGNhbGwyKSA9PiBzdGFibGVTdHJpbmdpZnkoY2FsbDIuaW5wdXQpID09PSBzdGFibGVTdHJpbmdpZnkoaW5wdXQpXG4gICAgKTtcbiAgICBpZiAoZXhpc3RpbmdDYWxsKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdDYWxsLnByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IGNhbGwgPSBuZXcgQmF0Y2hDYWxsKGlucHV0KTtcbiAgICB0aGlzLiNxdWV1ZS5wdXNoKGNhbGwpO1xuICAgIHRoaXMuI3NjaGVkdWxlKCk7XG4gICAgcmV0dXJuIGNhbGwucHJvbWlzZTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLiNxdWV1ZSA9IFtdO1xuICAgIHRoaXMuZXJyb3IgPSBmYWxzZTtcbiAgICB0aGlzLiNjbGVhckRlbGF5VGltZW91dCgpO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlQmF0Y2hTdG9yZShiYXRjaDIpIHtcbiAgY29uc3Qgc2lnbmFsID0gbmV3IE11dGFibGVTaWduYWwoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIGZ1bmN0aW9uIGdldENhY2hlS2V5KGFyZ3MpIHtcbiAgICByZXR1cm4gc3RhYmxlU3RyaW5naWZ5KGFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZShjYWNoZUtleSwgc3RhdGUpIHtcbiAgICBzaWduYWwubXV0YXRlKChjYWNoZSkgPT4ge1xuICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZShpbnB1dHMpIHtcbiAgICBzaWduYWwubXV0YXRlKChjYWNoZSkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXRzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICAgIGNhY2hlLmRlbGV0ZShnZXRDYWNoZUtleShpbnB1dCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVucXVldWUoaW5wdXQpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGlucHV0KTtcbiAgICBjb25zdCBjYWNoZSA9IHNpZ25hbC5nZXQoKTtcbiAgICBpZiAoY2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdXBkYXRlKGNhY2hlS2V5LCB7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhdGNoMi5nZXQoaW5wdXQpO1xuICAgICAgdXBkYXRlKGNhY2hlS2V5LCB7IGlzTG9hZGluZzogZmFsc2UsIGRhdGE6IHJlc3VsdCB9KTtcbiAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgIHVwZGF0ZShjYWNoZUtleSwge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SXRlbVN0YXRlKGlucHV0KSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShpbnB1dCk7XG4gICAgY29uc3QgY2FjaGUgPSBzaWduYWwuZ2V0KCk7XG4gICAgcmV0dXJuIGNhY2hlLmdldChjYWNoZUtleSk7XG4gIH1cbiAgZnVuY3Rpb24gX2NhY2hlS2V5cygpIHtcbiAgICBjb25zdCBjYWNoZSA9IHNpZ25hbC5nZXQoKTtcbiAgICByZXR1cm4gWy4uLmNhY2hlLmtleXMoKV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdWJzY3JpYmU6IHNpZ25hbC5zdWJzY3JpYmUsXG4gICAgZW5xdWV1ZSxcbiAgICBnZXRJdGVtU3RhdGUsXG4gICAgaW52YWxpZGF0ZSxcbiAgICBiYXRjaDogYmF0Y2gyLFxuICAgIF9jYWNoZUtleXNcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9jaHVuay50c1xuZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUpIHtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSArPSBzaXplKSB7XG4gICAgY2h1bmtzLnB1c2goYXJyYXkuc2xpY2UoaSwgaSArIHNpemUpKTtcbiAgfVxuICByZXR1cm4gY2h1bmtzO1xufVxuXG4vLyBzcmMvbGliL25hbm9pZC50c1xudmFyIG5hbm9pZCA9ICh0ID0gMjEpID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkodCkpLnJlZHVjZShcbiAgKHQyLCBlKSA9PiB0MiArPSAoZSAmPSA2MykgPCAzNiA/IGUudG9TdHJpbmcoMzYpIDogZSA8IDYyID8gKGUgLSAyNikudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCkgOiBlIDwgNjMgPyBcIl9cIiA6IFwiLVwiLFxuICBcIlwiXG4pO1xuXG4vLyBzcmMvbGliL2NyZWF0ZUlkcy50c1xudmFyIFRIUkVBRF9JRF9QUkVGSVggPSBcInRoXCI7XG52YXIgQ09NTUVOVF9JRF9QUkVGSVggPSBcImNtXCI7XG52YXIgQ09NTUVOVF9BVFRBQ0hNRU5UX0lEX1BSRUZJWCA9IFwiYXRcIjtcbnZhciBJTkJPWF9OT1RJRklDQVRJT05fSURfUFJFRklYID0gXCJpblwiO1xuZnVuY3Rpb24gY3JlYXRlT3B0aW1pc3RpY0lkKHByZWZpeCkge1xuICByZXR1cm4gYCR7cHJlZml4fV8ke25hbm9pZCgpfWA7XG59XG5mdW5jdGlvbiBjcmVhdGVUaHJlYWRJZCgpIHtcbiAgcmV0dXJuIGNyZWF0ZU9wdGltaXN0aWNJZChUSFJFQURfSURfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRJZCgpIHtcbiAgcmV0dXJuIGNyZWF0ZU9wdGltaXN0aWNJZChDT01NRU5UX0lEX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50QXR0YWNobWVudElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKENPTU1FTlRfQVRUQUNITUVOVF9JRF9QUkVGSVgpO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5ib3hOb3RpZmljYXRpb25JZCgpIHtcbiAgcmV0dXJuIGNyZWF0ZU9wdGltaXN0aWNJZChJTkJPWF9OT1RJRklDQVRJT05fSURfUFJFRklYKTtcbn1cblxuLy8gc3JjL2xpYi9EZWZhdWx0TWFwLnRzXG52YXIgRGVmYXVsdE1hcCA9IGNsYXNzIGV4dGVuZHMgTWFwIHtcbiAgI2RlZmF1bHRGbjtcbiAgLyoqXG4gICAqIElmIHRoZSBkZWZhdWx0IGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IsIGl0IGhhcyB0byBiZVxuICAgKiBwcm92aWRlZCBpbiBlYWNoIC5nZXRPckNyZWF0ZSgpIGNhbGwgaW5kaXZpZHVhbGx5LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGVmYXVsdEZuLCBlbnRyaWVzMikge1xuICAgIHN1cGVyKGVudHJpZXMyKTtcbiAgICB0aGlzLiNkZWZhdWx0Rm4gPSBkZWZhdWx0Rm47XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBrZXksIG9yIGNyZWF0ZXMgaXQuXG4gICAqXG4gICAqIERpZmZlcmVuY2UgZnJvbSBub3JtYWwgTWFwOiBpZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCBpdCB3aWxsIGJlIGNyZWF0ZWRcbiAgICogb24gdGhlIGZseSB1c2luZyB0aGUgZmFjdG9yeSBmdW5jdGlvbiwgYW5kIHRoYXQgdmFsdWUgd2lsbCBnZXQgcmV0dXJuZWRcbiAgICogaW5zdGVhZCBvZiBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGdldE9yQ3JlYXRlKGtleSwgZGVmYXVsdEZuKSB7XG4gICAgaWYgKHN1cGVyLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZuID0gZGVmYXVsdEZuID8/IHRoaXMuI2RlZmF1bHRGbiA/PyByYWlzZShcIkRlZmF1bHRNYXAgdXNlZCB3aXRob3V0IGEgZmFjdG9yeSBmdW5jdGlvblwiKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZm4oa2V5KTtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2xpYi9vYmplY3RUb1F1ZXJ5LnRzXG52YXIgaWRlbnRpZmllclJlZ2V4ID0gL15bYS16QS1aX11bYS16QS1aMC05X10qJC87XG5mdW5jdGlvbiBvYmplY3RUb1F1ZXJ5KG9iaikge1xuICBsZXQgZmlsdGVyTGlzdCA9IFtdO1xuICBjb25zdCBlbnRyaWVzMiA9IE9iamVjdC5lbnRyaWVzKG9iaik7XG4gIGNvbnN0IGtleVZhbHVlUGFpcnMgPSBbXTtcbiAgY29uc3Qga2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvciA9IFtdO1xuICBjb25zdCBpbmRleGVkS2V5cyA9IFtdO1xuICBlbnRyaWVzMi5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoIWlkZW50aWZpZXJSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBtdXN0IG9ubHkgY29udGFpbiBsZXR0ZXJzLCBudW1iZXJzLCBfXCIpO1xuICAgIH1cbiAgICBpZiAoaXNTaW1wbGVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGtleVZhbHVlUGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGlmIChpc1N0YXJ0c1dpdGhPcGVyYXRvcih2YWx1ZSkpIHtcbiAgICAgICAga2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvci5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleGVkS2V5cy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZmlsdGVyTGlzdCA9IFtcbiAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnMoa2V5VmFsdWVQYWlycyksXG4gICAgLi4uZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IpXG4gIF07XG4gIGluZGV4ZWRLZXlzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IG5lc3RlZEVudHJpZXMgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gICAgY29uc3QgbktleVZhbHVlUGFpcnMgPSBbXTtcbiAgICBjb25zdCBuS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvciA9IFtdO1xuICAgIG5lc3RlZEVudHJpZXMuZm9yRWFjaCgoW25lc3RlZEtleSwgbmVzdGVkVmFsdWVdKSA9PiB7XG4gICAgICBpZiAoaXNTdHJpbmdFbXB0eShuZXN0ZWRLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXNTaW1wbGVWYWx1ZShuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgbktleVZhbHVlUGFpcnMucHVzaChbZm9ybWF0RmlsdGVyS2V5KGtleSwgbmVzdGVkS2V5KSwgbmVzdGVkVmFsdWVdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTdGFydHNXaXRoT3BlcmF0b3IobmVzdGVkVmFsdWUpKSB7XG4gICAgICAgIG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLnB1c2goW1xuICAgICAgICAgIGZvcm1hdEZpbHRlcktleShrZXksIG5lc3RlZEtleSksXG4gICAgICAgICAgbmVzdGVkVmFsdWVcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZmlsdGVyTGlzdCA9IFtcbiAgICAgIC4uLmZpbHRlckxpc3QsXG4gICAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnMobktleVZhbHVlUGFpcnMpLFxuICAgICAgLi4uZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKVxuICAgIF07XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyTGlzdC5tYXAoKHsga2V5LCBvcGVyYXRvciwgdmFsdWUgfSkgPT4gYCR7a2V5fSR7b3BlcmF0b3J9JHtxdW90ZSh2YWx1ZSl9YCkuam9pbihcIiBcIik7XG59XG52YXIgZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzID0gKGtleVZhbHVlUGFpcnMpID0+IHtcbiAgY29uc3QgZmlsdGVycyA9IFtdO1xuICBrZXlWYWx1ZVBhaXJzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICBrZXksXG4gICAgICBvcGVyYXRvcjogXCI6XCIsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcnM7XG59O1xudmFyIGdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvciA9IChrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yKSA9PiB7XG4gIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAga2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvci5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoXCJzdGFydHNXaXRoXCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnN0YXJ0c1dpdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgb3BlcmF0b3I6IFwiXlwiLFxuICAgICAgICB2YWx1ZTogdmFsdWUuc3RhcnRzV2l0aFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZpbHRlcnM7XG59O1xudmFyIGlzU2ltcGxlVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PT0gbnVsbDtcbn07XG52YXIgZm9ybWF0RmlsdGVyS2V5ID0gKGtleSwgbmVzdGVkS2V5KSA9PiB7XG4gIGlmIChuZXN0ZWRLZXkpIHtcbiAgICByZXR1cm4gYCR7a2V5fVske3F1b3RlKG5lc3RlZEtleSl9XWA7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn07XG52YXIgaXNTdHJpbmdFbXB0eSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gIXZhbHVlIHx8IHZhbHVlLnRvU3RyaW5nKCkudHJpbSgpID09PSBcIlwiO1xufTtcbmZ1bmN0aW9uIHF1b3RlKGlucHV0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKHJlc3VsdC5pbmNsdWRlcyhcIidcIikpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiBgJyR7cmVzdWx0LnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJyl9J2A7XG59XG5cbi8vIHNyYy9saWIvdXJsLnRzXG5mdW5jdGlvbiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVybGpvaW4oYmFzZVVybCwgcGF0aCwgcGFyYW1zKSB7XG4gIGNvbnN0IHVybDIgPSBuZXcgVVJMKHBhdGgsIGJhc2VVcmwpO1xuICBpZiAocGFyYW1zICE9PSB2b2lkIDApIHtcbiAgICB1cmwyLnNlYXJjaCA9IChwYXJhbXMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBwYXJhbXMgOiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB1cmwyLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB1cmwoc3RyaW5ncywgLi4udmFsdWVzMikge1xuICByZXR1cm4gc3RyaW5ncy5yZWR1Y2UoXG4gICAgKHJlc3VsdCwgc3RyLCBpKSA9PiByZXN1bHQgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWVzMltpIC0gMV0gPz8gXCJcIikgKyBzdHJcbiAgKTtcbn1cblxuLy8gc3JjL2FwaS1jbGllbnQudHNcbmZ1bmN0aW9uIGNyZWF0ZUFwaUNsaWVudCh7XG4gIGJhc2VVcmwsXG4gIGF1dGhNYW5hZ2VyLFxuICBmZXRjaFBvbHlmaWxsXG59KSB7XG4gIGNvbnN0IGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudChiYXNlVXJsLCBmZXRjaFBvbHlmaWxsKTtcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkc1NpbmNlKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzL2RlbHRhYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHNpbmNlOiBvcHRpb25zLnNpbmNlLnRvSVNPU3RyaW5nKClcbiAgICAgIH0sXG4gICAgICB7IHNpZ25hbDogb3B0aW9ucy5zaWduYWwgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgdXBkYXRlZDogcmVzdWx0LmRhdGEubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgICBkZWxldGVkOiByZXN1bHQuZGVsZXRlZFRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8pXG4gICAgICB9LFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiB7XG4gICAgICAgIHVwZGF0ZWQ6IHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMubWFwKGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IHJlc3VsdC5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm9cbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShyZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdCksXG4gICAgICBwZXJtaXNzaW9uSGludHM6IHJlc3VsdC5tZXRhLnBlcm1pc3Npb25IaW50c1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkcyhvcHRpb25zKSB7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChvcHRpb25zLnF1ZXJ5KSB7XG4gICAgICBxdWVyeSA9IG9iamVjdFRvUXVlcnkob3B0aW9ucy5xdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IFBBR0VfU0laRSA9IDUwO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHNgLFxuICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICAgIH0pLFxuICAgICAgICB7XG4gICAgICAgICAgY3Vyc29yOiBvcHRpb25zLmN1cnNvcixcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICBsaW1pdDogUEFHRV9TSVpFXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWRzOiByZXN1bHQuZGF0YS5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhXG4gICAgICAgICksXG4gICAgICAgIG5leHRDdXJzb3I6IHJlc3VsdC5tZXRhLm5leHRDdXJzb3IsXG4gICAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShyZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdCksXG4gICAgICAgIHBlcm1pc3Npb25IaW50czogcmVzdWx0Lm1ldGEucGVybWlzc2lvbkhpbnRzXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEh0dHBFcnJvciAmJiBlcnIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0aHJlYWRzOiBbXSxcbiAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IFtdLFxuICAgICAgICAgIG5leHRDdXJzb3I6IG51bGwsXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBIQUNLXG4gICAgICAgICAgLy8gcmVxdWVzdGVkQXQgbmVlZHMgdG8gYmUgYSAqc2VydmVyKiB0aW1lc3RhbXAgaGVyZS4gSG93ZXZlciwgb25cbiAgICAgICAgICAvLyB0aGlzIDQwNCBlcnJvciByZXNwb25zZSwgdGhlcmUgaXMgbm8gc3VjaCB0aW1lc3RhbXAuIFNvIG91dCBvZlxuICAgICAgICAgIC8vIHB1cmUgbmVjZXNzaXR5IHdlJ2xsIGZhbGwgYmFjayB0byBhIGxvY2FsIHRpbWVzdGFtcCBpbnN0ZWFkIChhbmRcbiAgICAgICAgICAvLyBhbGxvdyBmb3IgYSBwb3NzaWJsZSA2IGhvdXIgY2xvY2sgZGlmZmVyZW5jZSBiZXR3ZWVuIGNsaWVudCBhbmRcbiAgICAgICAgICAvLyBzZXJ2ZXIpLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSA2ICogNjAgKiA2MCAqIDFlMyksXG4gICAgICAgICAgcGVybWlzc2lvbkhpbnRzOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUaHJlYWQob3B0aW9ucykge1xuICAgIGNvbnN0IGNvbW1lbnRJZCA9IG9wdGlvbnMuY29tbWVudElkID8/IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgIGNvbnN0IHRocmVhZElkID0gb3B0aW9ucy50aHJlYWRJZCA/PyBjcmVhdGVUaHJlYWRJZCgpO1xuICAgIGNvbnN0IHRocmVhZCA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIGlkOiB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudDoge1xuICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgICAgIGF0dGFjaG1lbnRJZHM6IG9wdGlvbnMuYXR0YWNobWVudElkc1xuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVUaHJlYWQob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQuZGVsZXRlKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWQob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5yYXdHZXQoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkLXdpdGgtbm90aWZpY2F0aW9uLyR7b3B0aW9ucy50aHJlYWRJZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkOiBjb252ZXJ0VG9UaHJlYWREYXRhKGpzb24udGhyZWFkKSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb246IGpzb24uaW5ib3hOb3RpZmljYXRpb24gPyBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoanNvbi5pbmJveE5vdGlmaWNhdGlvbikgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkOiB2b2lkIDAsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRocmVhZCAke29wdGlvbnMudGhyZWFkSWR9LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRUaHJlYWRNZXRhZGF0YShvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vbWV0YWRhdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIG9wdGlvbnMubWV0YWRhdGFcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IGNvbW1lbnRJZCA9IG9wdGlvbnMuY29tbWVudElkID8/IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgIGNvbnN0IGNvbW1lbnQgPSBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L2NvbW1lbnRzYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgICAgYXR0YWNobWVudElkczogb3B0aW9ucy5hdHRhY2htZW50SWRzXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdENvbW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IGNvbW1lbnQgPSBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L2NvbW1lbnRzLyR7b3B0aW9ucy5jb21tZW50SWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgICAgYXR0YWNobWVudElkczogb3B0aW9ucy5hdHRhY2htZW50SWRzXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ29tbWVudChvcHRpb25zKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5kZWxldGUoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L2NvbW1lbnRzLyR7b3B0aW9ucy5jb21tZW50SWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZFJlYWN0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWFjdGlvbiA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vY29tbWVudHMvJHtvcHRpb25zLmNvbW1lbnRJZH0vcmVhY3Rpb25zYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7IGVtb2ppOiBvcHRpb25zLmVtb2ppIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKHJlYWN0aW9uKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZW1vdmVSZWFjdGlvbihvcHRpb25zKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5kZWxldGUoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L2NvbW1lbnRzLyR7b3B0aW9ucy5jb21tZW50SWR9L3JlYWN0aW9ucy8ke29wdGlvbnMuZW1vaml9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtUaHJlYWRBc1Jlc29sdmVkKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L21hcmstYXMtcmVzb2x2ZWRgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzVW5yZXNvbHZlZChvcHRpb25zKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfS9tYXJrLWFzLXVucmVzb2x2ZWRgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdXBsb2FkQXR0YWNobWVudChvcHRpb25zKSB7XG4gICAgY29uc3Qgcm9vbUlkID0gb3B0aW9ucy5yb29tSWQ7XG4gICAgY29uc3QgYWJvcnRTaWduYWwgPSBvcHRpb25zLnNpZ25hbDtcbiAgICBjb25zdCBhdHRhY2htZW50ID0gb3B0aW9ucy5hdHRhY2htZW50O1xuICAgIGNvbnN0IGFib3J0RXJyb3IgPSBhYm9ydFNpZ25hbCA/IG5ldyBET01FeGNlcHRpb24oXG4gICAgICBgVXBsb2FkIG9mIGF0dGFjaG1lbnQgJHtvcHRpb25zLmF0dGFjaG1lbnQuaWR9IHdhcyBhYm9ydGVkLmAsXG4gICAgICBcIkFib3J0RXJyb3JcIlxuICAgICkgOiB2b2lkIDA7XG4gICAgaWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBhYm9ydEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVSZXRyeUVycm9yID0gKGVycikgPT4ge1xuICAgICAgaWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgIHRocm93IGFib3J0RXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgSHR0cEVycm9yICYmIGVyci5zdGF0dXMgPT09IDQxMykge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBBVFRBQ0hNRU5UX1BBUlRfU0laRSA9IDUgKiAxMDI0ICogMTAyNDtcbiAgICBjb25zdCBSRVRSWV9BVFRFTVBUUyA9IDEwO1xuICAgIGNvbnN0IFJFVFJZX0RFTEFZUyA9IFtcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlMyxcbiAgICAgIDJlM1xuICAgIF07XG4gICAgZnVuY3Rpb24gc3BsaXRGaWxlSW50b1BhcnRzKGZpbGUpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgd2hpbGUgKHN0YXJ0IDwgZmlsZS5zaXplKSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgQVRUQUNITUVOVF9QQVJUX1NJWkUsIGZpbGUuc2l6ZSk7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHBhcnROdW1iZXI6IHBhcnRzLmxlbmd0aCArIDEsXG4gICAgICAgICAgcGFydDogZmlsZS5zbGljZShzdGFydCwgZW5kKVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICAgIGlmIChhdHRhY2htZW50LnNpemUgPD0gQVRUQUNITUVOVF9QQVJUX1NJWkUpIHtcbiAgICAgIHJldHVybiBhdXRvUmV0cnkoXG4gICAgICAgIGFzeW5jICgpID0+IGh0dHBDbGllbnQucHV0QmxvYihcbiAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vdXBsb2FkLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGF0dGFjaG1lbnQubmFtZSl9YCxcbiAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgICAgcm9vbUlkXG4gICAgICAgICAgfSksXG4gICAgICAgICAgYXR0YWNobWVudC5maWxlLFxuICAgICAgICAgIHsgZmlsZVNpemU6IGF0dGFjaG1lbnQuc2l6ZSB9LFxuICAgICAgICAgIHsgc2lnbmFsOiBhYm9ydFNpZ25hbCB9XG4gICAgICAgICksXG4gICAgICAgIFJFVFJZX0FUVEVNUFRTLFxuICAgICAgICBSRVRSWV9ERUxBWVMsXG4gICAgICAgIGhhbmRsZVJldHJ5RXJyb3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB1cGxvYWRJZDtcbiAgICAgIGNvbnN0IHVwbG9hZGVkUGFydHMgPSBbXTtcbiAgICAgIGNvbnN0IGNyZWF0ZU11bHRpUGFydFVwbG9hZCA9IGF3YWl0IGF1dG9SZXRyeShcbiAgICAgICAgYXN5bmMgKCkgPT4gaHR0cENsaWVudC5wb3N0KFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS9tdWx0aXBhcnQvJHtlbmNvZGVVUklDb21wb25lbnQoYXR0YWNobWVudC5uYW1lKX1gLFxuICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICByb29tSWRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgeyBzaWduYWw6IGFib3J0U2lnbmFsIH0sXG4gICAgICAgICAgeyBmaWxlU2l6ZTogYXR0YWNobWVudC5zaXplIH1cbiAgICAgICAgKSxcbiAgICAgICAgUkVUUllfQVRURU1QVFMsXG4gICAgICAgIFJFVFJZX0RFTEFZUyxcbiAgICAgICAgaGFuZGxlUmV0cnlFcnJvclxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVwbG9hZElkID0gY3JlYXRlTXVsdGlQYXJ0VXBsb2FkLnVwbG9hZElkO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHNwbGl0RmlsZUludG9QYXJ0cyhhdHRhY2htZW50LmZpbGUpO1xuICAgICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBhYm9ydEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhdGNoZXMgPSBjaHVuayhwYXJ0cywgNSk7XG4gICAgICAgIGZvciAoY29uc3QgcGFydHMyIG9mIGJhdGNoZXMpIHtcbiAgICAgICAgICBjb25zdCB1cGxvYWRlZFBhcnRzUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgcGFydCwgcGFydE51bWJlciB9IG9mIHBhcnRzMikge1xuICAgICAgICAgICAgdXBsb2FkZWRQYXJ0c1Byb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIGF1dG9SZXRyeShcbiAgICAgICAgICAgICAgICBhc3luYyAoKSA9PiBodHRwQ2xpZW50LnB1dEJsb2IoXG4gICAgICAgICAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7Y3JlYXRlTXVsdGlQYXJ0VXBsb2FkLnVwbG9hZElkfS8ke1N0cmluZyhwYXJ0TnVtYmVyKX1gLFxuICAgICAgICAgICAgICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgICAgICAgICAgICByb29tSWRcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIHsgc2lnbmFsOiBhYm9ydFNpZ25hbCB9XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBSRVRSWV9BVFRFTVBUUyxcbiAgICAgICAgICAgICAgICBSRVRSWV9ERUxBWVMsXG4gICAgICAgICAgICAgICAgaGFuZGxlUmV0cnlFcnJvclxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGxvYWRlZFBhcnRzLnB1c2goLi4uYXdhaXQgUHJvbWlzZS5hbGwodXBsb2FkZWRQYXJ0c1Byb21pc2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgdGhyb3cgYWJvcnRFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3J0ZWRVcGxvYWRlZFBhcnRzID0gdXBsb2FkZWRQYXJ0cy5zb3J0KFxuICAgICAgICAgIChhLCBiKSA9PiBhLnBhcnROdW1iZXIgLSBiLnBhcnROdW1iZXJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGh0dHBDbGllbnQucG9zdChcbiAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7dXBsb2FkSWR9L2NvbXBsZXRlYCxcbiAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgICAgcm9vbUlkXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyBwYXJ0czogc29ydGVkVXBsb2FkZWRQYXJ0cyB9LFxuICAgICAgICAgIHsgc2lnbmFsOiBhYm9ydFNpZ25hbCB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgICAgaWYgKHVwbG9hZElkICYmIGVycm9yMz8ubmFtZSAmJiAoZXJyb3IzLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiIHx8IGVycm9yMy5uYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBodHRwQ2xpZW50LnJhd0RlbGV0ZShcbiAgICAgICAgICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7cm9vbUlkfS9hdHRhY2htZW50cy8ke2F0dGFjaG1lbnQuaWR9L211bHRpcGFydC8ke3VwbG9hZElkfWAsXG4gICAgICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgICAgICAgIHJvb21JZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcjQpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBhdHRhY2htZW50VXJsc0JhdGNoU3RvcmVzQnlSb29tID0gbmV3IERlZmF1bHRNYXAoKHJvb21JZCkgPT4ge1xuICAgIGNvbnN0IGJhdGNoMiA9IG5ldyBCYXRjaChcbiAgICAgIGFzeW5jIChiYXRjaGVkQXR0YWNobWVudElkcykgPT4ge1xuICAgICAgICBjb25zdCBhdHRhY2htZW50SWRzID0gYmF0Y2hlZEF0dGFjaG1lbnRJZHMuZmxhdCgpO1xuICAgICAgICBjb25zdCB7IHVybHMgfSA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2F0dGFjaG1lbnRzL3ByZXNpZ25lZC11cmxzYCxcbiAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgICAgcm9vbUlkXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyBhdHRhY2htZW50SWRzIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHVybHMubWFwKFxuICAgICAgICAgICh1cmwyKSA9PiB1cmwyID8/IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoaXMgYXR0YWNobWVudCdzIFVSTFwiKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHsgZGVsYXk6IDUwIH1cbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVCYXRjaFN0b3JlKGJhdGNoMik7XG4gIH0pO1xuICBmdW5jdGlvbiBnZXRPckNyZWF0ZUF0dGFjaG1lbnRVcmxzU3RvcmUocm9vbUlkKSB7XG4gICAgcmV0dXJuIGF0dGFjaG1lbnRVcmxzQmF0Y2hTdG9yZXNCeVJvb20uZ2V0T3JDcmVhdGUocm9vbUlkKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRBdHRhY2htZW50VXJsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBiYXRjaDIgPSBnZXRPckNyZWF0ZUF0dGFjaG1lbnRVcmxzU3RvcmUob3B0aW9ucy5yb29tSWQpLmJhdGNoO1xuICAgIHJldHVybiBiYXRjaDIuZ2V0KG9wdGlvbnMuYXR0YWNobWVudElkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXROb3RpZmljYXRpb25TZXR0aW5ncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAgdm9pZCAwLFxuICAgICAge1xuICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS9ub3RpZmljYXRpb24tc2V0dGluZ3NgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIG9wdGlvbnMuc2V0dGluZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IG1hcmtBc1JlYWRCYXRjaGVzQnlSb29tID0gbmV3IERlZmF1bHRNYXAoXG4gICAgKHJvb21JZCkgPT4gbmV3IEJhdGNoKFxuICAgICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbklkcyA9IGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcy5mbGF0KCk7XG4gICAgICAgIGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZGAsXG4gICAgICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgICAgIHJvb21JZFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgaW5ib3hOb3RpZmljYXRpb25JZHMgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgICB9LFxuICAgICAgeyBkZWxheTogNTAgfVxuICAgIClcbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya1Jvb21JbmJveE5vdGlmaWNhdGlvbkFzUmVhZChvcHRpb25zKSB7XG4gICAgY29uc3QgYmF0Y2gyID0gbWFya0FzUmVhZEJhdGNoZXNCeVJvb20uZ2V0T3JDcmVhdGUob3B0aW9ucy5yb29tSWQpO1xuICAgIHJldHVybiBiYXRjaDIuZ2V0KG9wdGlvbnMuaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGV4dE1lbnRpb24ob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucmF3UG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90ZXh0LW1lbnRpb25zYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHVzZXJJZDogb3B0aW9ucy51c2VySWQsXG4gICAgICAgIG1lbnRpb25JZDogb3B0aW9ucy5tZW50aW9uSWRcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRleHRNZW50aW9uKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnJhd0RlbGV0ZShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90ZXh0LW1lbnRpb25zLyR7b3B0aW9ucy5tZW50aW9uSWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRleHRWZXJzaW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5yYXdHZXQoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0veS12ZXJzaW9uLyR7b3B0aW9ucy52ZXJzaW9uSWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRleHRWZXJzaW9uKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnJhd1Bvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdmVyc2lvbmAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZXBvcnRUZXh0RWRpdG9yKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnJhd1Bvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGV4dC1tZXRhZGF0YWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGUsXG4gICAgICAgIHJvb3RLZXk6IG9wdGlvbnMucm9vdEtleVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUNvbnRleHR1YWxQcm9tcHQob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS9haS9jb250ZXh0dWFsLXByb21wdGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHByb21wdDogb3B0aW9ucy5wcm9tcHQsXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICBiZWZvcmVTZWxlY3Rpb246IG9wdGlvbnMuY29udGV4dC5iZWZvcmVTZWxlY3Rpb24sXG4gICAgICAgICAgc2VsZWN0aW9uOiBvcHRpb25zLmNvbnRleHQuc2VsZWN0aW9uLFxuICAgICAgICAgIGFmdGVyU2VsZWN0aW9uOiBvcHRpb25zLmNvbnRleHQuYWZ0ZXJTZWxlY3Rpb25cbiAgICAgICAgfSxcbiAgICAgICAgcHJldmlvdXM6IG9wdGlvbnMucHJldmlvdXNcbiAgICAgIH0sXG4gICAgICB7IHNpZ25hbDogb3B0aW9ucy5zaWduYWwgfVxuICAgICk7XG4gICAgaWYgKCFyZXN1bHQgfHwgcmVzdWx0LmNvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjb250ZW50IHJldHVybmVkIGZyb20gc2VydmVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmNvbnRlbnRbMF0udGV4dDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsaXN0VGV4dFZlcnNpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS92ZXJzaW9uc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbnM6IHJlc3VsdC52ZXJzaW9ucy5tYXAoKHsgY3JlYXRlZEF0LCAuLi52ZXJzaW9uIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGNyZWF0ZWRBdCksXG4gICAgICAgICAgLi4udmVyc2lvblxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUocmVzdWx0Lm1ldGEucmVxdWVzdGVkQXQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsaXN0VGV4dFZlcnNpb25zU2luY2Uob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3ZlcnNpb25zL2RlbHRhYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7IHNpbmNlOiBvcHRpb25zLnNpbmNlLnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbnM6IHJlc3VsdC52ZXJzaW9ucy5tYXAoKHsgY3JlYXRlZEF0LCAuLi52ZXJzaW9uIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGNyZWF0ZWRBdCksXG4gICAgICAgICAgLi4udmVyc2lvblxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUocmVzdWx0Lm1ldGEucmVxdWVzdGVkQXQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdHJlYW1TdG9yYWdlKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBodHRwQ2xpZW50LnJhd0dldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS9zdG9yYWdlYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcInJvb206cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc2VuZE1lc3NhZ2VzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5yYXdQb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3NlbmQtbWVzc2FnZWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIG5vbmNlOiBvcHRpb25zLm5vbmNlLFxuICAgICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlc1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0SW5ib3hOb3RpZmljYXRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBQQUdFX1NJWkUgPSA1MDtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9uc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7XG4gICAgICAgIGN1cnNvcjogb3B0aW9ucz8uY3Vyc29yLFxuICAgICAgICBsaW1pdDogUEFHRV9TSVpFXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YVxuICAgICAgKSxcbiAgICAgIHRocmVhZHM6IGpzb24udGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICBuZXh0Q3Vyc29yOiBqc29uLm1ldGEubmV4dEN1cnNvcixcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZShvcHRpb25zKSB7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnMvZGVsdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAgeyBzaW5jZTogb3B0aW9ucy5zaW5jZS50b0lTT1N0cmluZygpIH0sXG4gICAgICB7IHNpZ25hbDogb3B0aW9ucy5zaWduYWwgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgICB1cGRhdGVkOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKSxcbiAgICAgICAgZGVsZXRlZDoganNvbi5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm9cbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgdXBkYXRlZDoganNvbi50aHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgICAgZGVsZXRlZDoganNvbi5kZWxldGVkVGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbylcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoKSB7XG4gICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy9jb3VudGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSlcbiAgICApO1xuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKCkge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zL3JlYWRgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAge1xuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkczogXCJhbGxcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zL3JlYWRgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAge1xuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkc1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgY29uc3QgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQgPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb25JZHMgPSBiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMuZmxhdCgpO1xuICAgICAgYXdhaXQgbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcyk7XG4gICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgfSxcbiAgICB7IGRlbGF5OiA1MCB9XG4gICk7XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQuZ2V0KGluYm94Tm90aWZpY2F0aW9uSWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucygpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LmRlbGV0ZShcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlSW5ib3hOb3RpZmljYXRpb24oaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICAgIGF3YWl0IGh0dHBDbGllbnQuZGVsZXRlKFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnMvJHtpbmJveE5vdGlmaWNhdGlvbklkfWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB2b2lkIDAsXG4gICAgICB7IHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KSxcbiAgICAgIHNldHRpbmdzXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWwob3B0aW9ucykge1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAob3B0aW9ucz8ucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3RocmVhZHNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAge1xuICAgICAgICBjdXJzb3I6IG9wdGlvbnM/LmN1cnNvcixcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGxpbWl0OiBQQUdFX1NJWkVcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB0aHJlYWRzOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YVxuICAgICAgKSxcbiAgICAgIG5leHRDdXJzb3I6IGpzb24ubWV0YS5uZXh0Q3Vyc29yLFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdCksXG4gICAgICBwZXJtaXNzaW9uSGludHM6IGpzb24ubWV0YS5wZXJtaXNzaW9uSGludHNcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2MvdGhyZWFkcy9kZWx0YWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7IHNpbmNlOiBvcHRpb25zLnNpbmNlLnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGhyZWFkczoge1xuICAgICAgICB1cGRhdGVkOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgICBkZWxldGVkOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKVxuICAgICAgfSxcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgICB1cGRhdGVkOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKSxcbiAgICAgICAgZGVsZXRlZDoganNvbi5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm9cbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpLFxuICAgICAgcGVybWlzc2lvbkhpbnRzOiBqc29uLm1ldGEucGVybWlzc2lvbkhpbnRzXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC8vIFJvb20gdGhyZWFkc1xuICAgIGdldFRocmVhZHMsXG4gICAgZ2V0VGhyZWFkc1NpbmNlLFxuICAgIGNyZWF0ZVRocmVhZCxcbiAgICBnZXRUaHJlYWQsXG4gICAgZGVsZXRlVGhyZWFkLFxuICAgIGVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICBjcmVhdGVDb21tZW50LFxuICAgIGVkaXRDb21tZW50LFxuICAgIGRlbGV0ZUNvbW1lbnQsXG4gICAgYWRkUmVhY3Rpb24sXG4gICAgcmVtb3ZlUmVhY3Rpb24sXG4gICAgbWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gICAgbWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICBtYXJrUm9vbUluYm94Tm90aWZpY2F0aW9uQXNSZWFkLFxuICAgIC8vIFJvb20gbm90aWZpY2F0aW9uc1xuICAgIGdldE5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIC8vIFJvb20gdGV4dCBlZGl0b3JcbiAgICBjcmVhdGVUZXh0TWVudGlvbixcbiAgICBkZWxldGVUZXh0TWVudGlvbixcbiAgICBnZXRUZXh0VmVyc2lvbixcbiAgICBjcmVhdGVUZXh0VmVyc2lvbixcbiAgICByZXBvcnRUZXh0RWRpdG9yLFxuICAgIGxpc3RUZXh0VmVyc2lvbnMsXG4gICAgbGlzdFRleHRWZXJzaW9uc1NpbmNlLFxuICAgIC8vIFJvb20gYXR0YWNobWVudHNcbiAgICBnZXRBdHRhY2htZW50VXJsLFxuICAgIHVwbG9hZEF0dGFjaG1lbnQsXG4gICAgZ2V0T3JDcmVhdGVBdHRhY2htZW50VXJsc1N0b3JlLFxuICAgIC8vIFJvb20gc3RvcmFnZVxuICAgIHN0cmVhbVN0b3JhZ2UsXG4gICAgc2VuZE1lc3NhZ2VzLFxuICAgIC8vIE5vdGlmaWNhdGlvblxuICAgIGdldEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZSxcbiAgICBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICBkZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZGVsZXRlSW5ib3hOb3RpZmljYXRpb24sXG4gICAgZ2V0VXNlck5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIHVwZGF0ZVVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAvLyBVc2VyIHRocmVhZHNcbiAgICBnZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWwsXG4gICAgZ2V0VXNlclRocmVhZHNTaW5jZV9leHBlcmltZW50YWwsXG4gICAgLy8gQUlcbiAgICBleGVjdXRlQ29udGV4dHVhbFByb21wdFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QmVhcmVyVG9rZW5Gcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSkge1xuICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICByZXR1cm4gYXV0aFZhbHVlLnB1YmxpY0FwaUtleTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXV0aFZhbHVlLnRva2VuLnJhdztcbiAgfVxufVxudmFyIEh0dHBDbGllbnQgPSBjbGFzcyB7XG4gICNiYXNlVXJsO1xuICAjZmV0Y2hQb2x5ZmlsbDtcbiAgY29uc3RydWN0b3IoYmFzZVVybCwgZmV0Y2hQb2x5ZmlsbCkge1xuICAgIHRoaXMuI2Jhc2VVcmwgPSBiYXNlVXJsO1xuICAgIHRoaXMuI2ZldGNoUG9seWZpbGwgPSBmZXRjaFBvbHlmaWxsO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQdWJsaWMgbWV0aG9kc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYW5kIG1ha2VzIHRoZSBIVFRQIHJlcXVlc3QsIGJ1dCBkb2VzIG5vdCBoYW5kbGUgdGhlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBUaGlzIGlzIHdoYXQgLnJhd0ZldGNoKCkgZG9lczogICAg8J+RiCBUaGlzIG1ldGhvZCFcbiAgICogICAxLiBTZXQgQ29udGVudC1UeXBlIGhlYWRlclxuICAgKiAgIDIuIFNldCBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgKiAgIDMuIENhbGwgdGhlIGNhbGxiYWNrIHRvIG9idGFpbiB0aGUgYGF1dGhWYWx1ZWAgdG8gdXNlIGluIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgKlxuICAgKiBUaGlzIGlzIHdoYXQgLmZldGNoKCkgZG9lcyBPTiBUT1Agb2YgdGhhdDpcbiAgICogICA0LiBQYXJzZSByZXNwb25zZSBib2R5IGFzIEpzb25cbiAgICogICA1LiAuLi5idXQgc2lsZW50bHkgcmV0dXJuIGB7fWAgaWYgdGhhdCBwYXJzaW5nIGZhaWxzXG4gICAqICAgNi4gVGhyb3cgSHR0cEVycm9yIGlmIHJlc3BvbnNlIGlzIGFuIGVycm9yXG4gICAqL1xuICBhc3luYyAjcmF3RmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgaWYgKCFlbmRwb2ludC5zdGFydHNXaXRoKFwiL3YyL2MvXCIpKSB7XG4gICAgICByYWlzZShcIlRoaXMgY2xpZW50IGNhbiBvbmx5IGJlIHVzZWQgdG8gbWFrZSAvdjIvYy8qIHJlcXVlc3RzXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwyID0gdXJsam9pbih0aGlzLiNiYXNlVXJsLCBlbmRwb2ludCwgcGFyYW1zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmV0Y2hQb2x5ZmlsbCh1cmwyLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAvLyBUaGVzZSBoZWFkZXJzIGFyZSBkZWZhdWx0LCBidXQgY2FuIGJlIG92ZXJyaWRlbiBieSBjdXN0b20gaGVhZGVyc1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgLy8gUG9zc2libGUgaGVhZGVyIG92ZXJyaWRlc1xuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAvLyBDYW5ub3QgYmUgb3ZlcnJpZGVuIGJ5IGN1c3RvbSBoZWFkZXJzXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKX1gLFxuICAgICAgICBcIlgtTEItQ2xpZW50XCI6IFBLR19WRVJTSU9OIHx8IFwiZGV2XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cywgbWFrZXMgdGhlIEhUVFAgcmVxdWVzdCwgYW5kIGhhbmRsZXMgdGhlIHJlc3BvbnNlIGJ5IHBhcnNpbmdcbiAgICogSlNPTiBhbmQvb3IgdGhyb3dpbmcgYW4gSHR0cEVycm9yIGlmIGl0IGZhaWxlZC5cbiAgICpcbiAgICogVGhpcyBpcyB3aGF0IC5yYXdGZXRjaCgpIGRvZXM6XG4gICAqICAgMS4gU2V0IENvbnRlbnQtVHlwZSBoZWFkZXJcbiAgICogICAyLiBTZXQgQXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICogICAzLiBDYWxsIHRoZSBjYWxsYmFjayB0byBvYnRhaW4gdGhlIGBhdXRoVmFsdWVgIHRvIHVzZSBpbiB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICpcbiAgICogVGhpcyBpcyB3aGF0IC5mZXRjaCgpIGRvZXMgT04gVE9QIG9mIHRoYXQ6ICAg8J+RiCBUaGlzIG1ldGhvZCFcbiAgICogICA0LiBQYXJzZSByZXNwb25zZSBib2R5IGFzIEpzb25cbiAgICogICA1LiAuLi5idXQgc2lsZW50bHkgcmV0dXJuIGB7fWAgaWYgdGhhdCBwYXJzaW5nIGZhaWxzICjwn6SUKVxuICAgKiAgIDYuIFRocm93IEh0dHBFcnJvciBpZiByZXNwb25zZSBpcyBhbiBlcnJvclxuICAgKi9cbiAgYXN5bmMgI2ZldGNoKGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy4jcmF3RmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9ucywgcGFyYW1zKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBIdHRwRXJyb3IuZnJvbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIEdFVCByZXF1ZXN0IGFuZCByZXR1cm5zIHRoZSByYXcgcmVzcG9uc2UuXG4gICAqIFdvbid0IHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICogQGRlcHJlY2F0ZWQgSWRlYWxseSwgdXNlIC5nZXQoKSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgcmF3R2V0KGVuZHBvaW50LCBhdXRoVmFsdWUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNyYXdGZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zLCBwYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIFBPU1QgcmVxdWVzdCBhbmQgcmV0dXJucyB0aGUgcmF3IHJlc3BvbnNlLlxuICAgKiBXb24ndCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqIEBkZXByZWNhdGVkIElkZWFsbHksIHVzZSAucG9zdCgpIGluc3RlYWQuXG4gICAqL1xuICBhc3luYyByYXdQb3N0KGVuZHBvaW50LCBhdXRoVmFsdWUsIGJvZHkpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jcmF3RmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHN0cmluZ2lmeU9yTG9nKGJvZHkpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIGEgREVMRVRFIHJlcXVlc3QgYW5kIHJldHVybnMgdGhlIHJhdyByZXNwb25zZS5cbiAgICogV29uJ3QgdGhyb3cgaWYgdGhlIHJlcG9uc2UgaXMgYSBub24tMnh4LlxuICAgKiBAZGVwcmVjYXRlZCBJZGVhbGx5LCB1c2UgLmRlbGV0ZSgpIGluc3RlYWQuXG4gICAqL1xuICBhc3luYyByYXdEZWxldGUoZW5kcG9pbnQsIGF1dGhWYWx1ZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNyYXdGZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCB7IG1ldGhvZDogXCJERUxFVEVcIiB9KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBHRVQgcmVxdWVzdCwgYW5kIHJldHVybiB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogV2lsbCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqL1xuICBhc3luYyBnZXQoZW5kcG9pbnQsIGF1dGhWYWx1ZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZldGNoKGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMsIHBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIGEgUE9TVCByZXF1ZXN0LCBhbmQgcmV0dXJuIHRoZSBKU09OIHJlc3BvbnNlLlxuICAgKiBXaWxsIHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICovXG4gIGFzeW5jIHBvc3QoZW5kcG9pbnQsIGF1dGhWYWx1ZSwgYm9keSwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZldGNoKFxuICAgICAgZW5kcG9pbnQsXG4gICAgICBhdXRoVmFsdWUsXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IHN0cmluZ2lmeU9yTG9nKGJvZHkpXG4gICAgICB9LFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBERUxFVEUgcmVxdWVzdCwgYW5kIHJldHVybiB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogV2lsbCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqL1xuICBhc3luYyBkZWxldGUoZW5kcG9pbnQsIGF1dGhWYWx1ZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCB7IG1ldGhvZDogXCJERUxFVEVcIiB9KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBQVVQgcmVxdWVzdCBmb3IgYSBCbG9iIGJvZHksIGFuZCByZXR1cm4gdGhlIEpTT04gcmVzcG9uc2UuXG4gICAqIFdpbGwgdGhyb3cgaWYgdGhlIHJlcG9uc2UgaXMgYSBub24tMnh4LlxuICAgKi9cbiAgYXN5bmMgcHV0QmxvYihlbmRwb2ludCwgYXV0aFZhbHVlLCBibG9iLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmV0Y2goXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGF1dGhWYWx1ZSxcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBibG9iXG4gICAgICB9LFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF92YWx1ZSwgZXJybXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgZXJybXNnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICBlcnIubmFtZSA9IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5uKHZhbHVlLCBlcnJtc2cgPSBcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG5vbi1udWxsYWJsZVwiKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwLCBlcnJtc2cpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9saWIvZnNtLnRzXG5mdW5jdGlvbiBkaXN0YW5jZShzdGF0ZTEsIHN0YXRlMikge1xuICBpZiAoc3RhdGUxID09PSBzdGF0ZTIpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGNvbnN0IGNodW5rczEgPSBzdGF0ZTEuc3BsaXQoXCIuXCIpO1xuICBjb25zdCBjaHVua3MyID0gc3RhdGUyLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgbWluTGVuID0gTWF0aC5taW4oY2h1bmtzMS5sZW5ndGgsIGNodW5rczIubGVuZ3RoKTtcbiAgbGV0IHNoYXJlZCA9IDA7XG4gIGZvciAoOyBzaGFyZWQgPCBtaW5MZW47IHNoYXJlZCsrKSB7XG4gICAgaWYgKGNodW5rczFbc2hhcmVkXSAhPT0gY2h1bmtzMltzaGFyZWRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgdXAgPSBjaHVua3MxLmxlbmd0aCAtIHNoYXJlZDtcbiAgY29uc3QgZG93biA9IGNodW5rczIubGVuZ3RoIC0gc2hhcmVkO1xuICByZXR1cm4gW3VwLCBkb3duXTtcbn1cbmZ1bmN0aW9uIHBhdHRlcm5zKHRhcmdldFN0YXRlLCBsZXZlbHMpIHtcbiAgY29uc3QgcGFydHMgPSB0YXJnZXRTdGF0ZS5zcGxpdChcIi5cIik7XG4gIGlmIChsZXZlbHMgPCAxIHx8IGxldmVscyA+IHBhcnRzLmxlbmd0aCArIDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBsZXZlbHNcIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmIChsZXZlbHMgPiBwYXJ0cy5sZW5ndGgpIHtcbiAgICByZXN1bHQucHVzaChcIipcIik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IHBhcnRzLmxlbmd0aCAtIGxldmVscyArIDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNsaWNlID0gcGFydHMuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNsaWNlLmpvaW4oXCIuXCIpICsgXCIuKlwiKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnB1c2godGFyZ2V0U3RhdGUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIFNhZmVDb250ZXh0ID0gY2xhc3Mge1xuICAjY3VycjtcbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLiNjdXJyID0gaW5pdGlhbENvbnRleHQ7XG4gIH1cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnI7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGFsbG93cyBwYXRjaGluZyBvZiB0aGUgY29udGV4dCwgYnlcbiAgICogY2FsbGluZyBgY29udGV4dC5wYXRjaCgpYC4gUGF0Y2hpbmcgaXMgb25seSBhbGxvd2VkIGZvciB0aGUgZHVyYXRpb25cbiAgICogb2YgdGhpcyB3aW5kb3cuXG4gICAqL1xuICBhbGxvd1BhdGNoaW5nKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGFsbG93ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHBhdGNoYWJsZUNvbnRleHQgPSB7XG4gICAgICAuLi50aGlzLiNjdXJyLFxuICAgICAgcGF0Y2gocGF0Y2gpIHtcbiAgICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgICBzZWxmLiNjdXJyID0gT2JqZWN0LmFzc2lnbih7fSwgc2VsZi4jY3VyciwgcGF0Y2gpO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBPYmplY3QuZW50cmllcyhwYXRjaCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhaXI7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcInBhdGNoXCIpIHtcbiAgICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBubyBsb25nZXIgcGF0Y2ggc3RhbGUgY29udGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY2FsbGJhY2socGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgYWxsb3dlZCA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxufTtcbnZhciBuZXh0SWQgPSAxO1xudmFyIEZTTSA9IGNsYXNzIHtcbiAgaWQ7XG4gIC8vIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgc3RhdGUgbWFjaGluZSBpcyBzdGlsbCBiZWluZyBjb25maWd1cmVkLCBoYXNcbiAgLy8gc3RhcnRlZCwgb3IgaGFzIHRlcm1pbmF0ZWRcbiAgI3J1bm5pbmdTdGF0ZTtcbiAgI2N1cnJlbnRDb250ZXh0O1xuICAjc3RhdGVzO1xuICAjY3VycmVudFN0YXRlT3JOdWxsO1xuICAjYWxsb3dlZFRyYW5zaXRpb25zO1xuICAjZXZlbnRIdWI7XG4gIGV2ZW50cztcbiAgLy9cbiAgLy8gVGhlIGNsZWFudXAgc3RhY2sgaXMgYSBzdGFjayBvZiAob3B0aW9uYWwpIGNhbGxiYWNrIGZ1bmN0aW9ucyB0aGF0IHdpbGxcbiAgLy8gYmUgcnVuIHdoZW4gZXhpdGluZyB0aGUgY3VycmVudCBzdGF0ZS4gSWYgYSBzdGF0ZSAob3Igc3RhdGUgZ3JvdXApIGRvZXNcbiAgLy8gbm90IGhhdmUgYW4gZXhpdCBoYW5kbGVyLCB0aGVuIHRoZSBlbnRyeSBmb3IgdGhhdCBsZXZlbCBtYXkgYmVcbiAgLy8gYHVuZGVmaW5lZGAsIGJ1dCB0aGVyZSB3aWxsIGJlIGFuIGV4cGxpY2l0IGVudHJ5IGluIHRoZSBzdGFjayBmb3IgaXQuXG4gIC8vXG4gIC8vIFRoaXMgd2lsbCBhbHdheXMgYmUgdHJ1ZTpcbiAgLy9cbiAgLy8gICBjbGVhbnVwU3RhY2subGVuZ3RoID09IGN1cnJlbnRTdGF0ZS5zcGxpdCgnLicpLmxlbmd0aCArIDFcbiAgLy9cbiAgLy8gRWFjaCBzdGFjayBsZXZlbCByZXByZXNlbnRzIGEgZGlmZmVyZW50IHN0YXRlIFwiZ3JvdXBcIi5cbiAgLy9cbiAgLy8gRm9yIGV4YW1wbGUsIGlmIHlvdSBhcmUgaW4gYSBzdGF0ZSBuYW1lZCBgZm9vLmJhci5xdXhgLCB0aGVuIHRoZSBzdGFja1xuICAvLyB3aWxsIGNvbnRhaW4gdGhlIGV4aXQgaGFuZGxlciBmb3IgYGZvby5iYXIucXV4YCAoYXQgdGhlIHRvcCksIHRoZW5cbiAgLy8gYGZvby5iYXIuKmAsIHRoZW4gYGZvby4qYCwgYW5kIGZpbmFsbHksIGAqYC5cbiAgLy9cbiAgI2NsZWFudXBTdGFjaztcbiAgI2VudGVyRm5zO1xuICAvLyBVc2VkIHRvIHByb3ZpZGUgYmV0dGVyIGVycm9yIG1lc3NhZ2VzXG4gICNrbm93bkV2ZW50VHlwZXM7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIHN0YXRlLCB3aGljaCBpcyBkZWZpbmVkIGJ5IHRoZSBmaXJzdCBjYWxsIG1hZGUgdG9cbiAgICogLmFkZFN0YXRlKCkuXG4gICAqL1xuICBnZXQgI2luaXRpYWxTdGF0ZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNzdGF0ZXMudmFsdWVzKClbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN0YXRlcyBkZWZpbmVkIHlldFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy4jY3VycmVudFN0YXRlT3JOdWxsID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlID09PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3RhcnRlZCB5ZXRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0b3BwZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjdXJyZW50U3RhdGVPck51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgbWFjaGluZSBieSBlbnRlcmluZyB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICh0aGlzLiNydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBtYWNoaW5lIGhhcyBhbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMuI3J1bm5pbmdTdGF0ZSA9IDEgLyogU1RBUlRFRCAqLztcbiAgICB0aGlzLiNjdXJyZW50U3RhdGVPck51bGwgPSB0aGlzLiNpbml0aWFsU3RhdGU7XG4gICAgdGhpcy4jZW50ZXIobnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSBzdGF0ZSBtYWNoaW5lLiBTdG9wcGluZyB0aGUgc3RhdGUgbWFjaGluZSB3aWxsIGNhbGwgZXhpdFxuICAgKiBoYW5kbGVycyBmb3IgdGhlIGN1cnJlbnQgc3RhdGUsIGJ1dCBub3QgZW50ZXIgYSBuZXcgc3RhdGUuXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLiNydW5uaW5nU3RhdGUgIT09IDEgLyogU1RBUlRFRCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0b3AgYSBzdGF0ZSBtYWNoaW5lIHRoYXQgaGFzbid0IHN0YXJ0ZWQgeWV0XCIpO1xuICAgIH1cbiAgICB0aGlzLiNleGl0KG51bGwpO1xuICAgIHRoaXMuI3J1bm5pbmdTdGF0ZSA9IDIgLyogU1RPUFBFRCAqLztcbiAgICB0aGlzLiNjdXJyZW50U3RhdGVPck51bGwgPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxDb250ZXh0KSB7XG4gICAgdGhpcy5pZCA9IG5leHRJZCsrO1xuICAgIHRoaXMuI3J1bm5pbmdTdGF0ZSA9IDAgLyogTk9UX1NUQVJURURfWUVUICovO1xuICAgIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbCA9IG51bGw7XG4gICAgdGhpcy4jc3RhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLiNlbnRlckZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy4jY2xlYW51cFN0YWNrID0gW107XG4gICAgdGhpcy4ja25vd25FdmVudFR5cGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLiNhbGxvd2VkVHJhbnNpdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuI2N1cnJlbnRDb250ZXh0ID0gbmV3IFNhZmVDb250ZXh0KGluaXRpYWxDb250ZXh0KTtcbiAgICB0aGlzLiNldmVudEh1YiA9IHtcbiAgICAgIGRpZFJlY2VpdmVFdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICB3aWxsVHJhbnNpdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICBkaWRJZ25vcmVFdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICB3aWxsRXhpdFN0YXRlOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIGRpZEVudGVyU3RhdGU6IG1ha2VFdmVudFNvdXJjZSgpXG4gICAgfTtcbiAgICB0aGlzLmV2ZW50cyA9IHtcbiAgICAgIGRpZFJlY2VpdmVFdmVudDogdGhpcy4jZXZlbnRIdWIuZGlkUmVjZWl2ZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsVHJhbnNpdGlvbjogdGhpcy4jZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ub2JzZXJ2YWJsZSxcbiAgICAgIGRpZElnbm9yZUV2ZW50OiB0aGlzLiNldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5vYnNlcnZhYmxlLFxuICAgICAgd2lsbEV4aXRTdGF0ZTogdGhpcy4jZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5vYnNlcnZhYmxlLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogdGhpcy4jZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5vYnNlcnZhYmxlXG4gICAgfTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudENvbnRleHQuY3VycmVudDtcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIGFuIGV4cGxpY2l0IGZpbml0ZSBzdGF0ZSBpbiB0aGUgc3RhdGUgbWFjaGluZS5cbiAgICovXG4gIGFkZFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuI3J1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy4jc3RhdGVzLmFkZChzdGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25FbnRlcihuYW1lT3JQYXR0ZXJuLCBlbnRlckZuKSB7XG4gICAgaWYgKHRoaXMuI3J1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2VudGVyRm5zLmhhcyhuYW1lT3JQYXR0ZXJuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBUT0RPIFdlIF9jdXJyZW50bHlfIGRvbid0IHN1cHBvcnQgbXVsdGlwbGUgLm9uRW50ZXJzKCkgZm9yIHRoZSBzYW1lXG4gICAgICAgIC8vIHN0YXRlLCBidXQgdGhpcyBpcyBub3QgYSBmdW5kYW1lbnRhbCBsaW1pdGF0aW9uLiBKdXN0IG5vdFxuICAgICAgICAvLyBpbXBsZW1lbnRlZCB5ZXQuIElmIHdlIHdhbnRlZCB0bywgd2UgY291bGQgbWFrZSB0aGlzIGFuIGFycmF5LlxuICAgICAgICBgZW50ZXIvZXhpdCBmdW5jdGlvbiBmb3IgJHtuYW1lT3JQYXR0ZXJufSBhbHJlYWR5IGV4aXN0c2BcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuI2VudGVyRm5zLnNldChuYW1lT3JQYXR0ZXJuLCBlbnRlckZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVmaW5lcyBhIHByb21pc2UtYmFzZWQgc3RhdGUuIFdoZW4gdGhlIHN0YXRlIGlzIGVudGVyZWQsIHRoZSBwcm9taXNlIGlzXG4gICAqIGNyZWF0ZWQuIFdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMsIHRoZSBtYWNoaW5lIHdpbGwgdHJhbnNpdGlvbiB0byB0aGVcbiAgICogcHJvdmlkZWQgYG9uT0tgIHRhcmdldCBzdGF0ZS4gV2hlbiB0aGUgcHJvbWlzZSByZWplY3RzLCB0aGUgbWFjaGluZSB3aWxsXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIGBvbkVycm9yYCB0YXJnZXQgc3RhdGUuXG4gICAqXG4gICAqIE9wdGlvbmFsbHksIGEgYG1heFRpbWVvdXRgIGNhbiBiZSBzZXQuIElmIHRoZSB0aW1lb3V0IGhhcHBlbnMgYmVmb3JlIHRoZVxuICAgKiBwcm9taXNlIGlzIHNldHRsZWQsIHRoZW4gdGhlIG1hY2hpbmUgd2lsbCBhbHNvIHRyYW5zaXRpb24gdG8gdGhlIGBvbkVycm9yYFxuICAgKiB0YXJnZXQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZU9yUGF0dGVybiAgVGhlIHN0YXRlIG5hbWUsIG9yIHN0YXRlIGdyb3VwIHBhdHRlcm4gbmFtZS5cbiAgICogQHBhcmFtIHByb21pc2VGbiAgICAgICBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBzdGF0ZSBpcyBlbnRlcmVkLlxuICAgKiBAcGFyYW0gb25PSyAgICAgICAgICAgIFRoZSBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvIHdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMuXG4gICAqIEBwYXJhbSBvbkVycm9yICAgICAgICAgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8gd2hlbiB0aGUgcHJvbWlzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdHMsIG9yIHdoZW4gdGhlIHRpbWVvdXQgaGFwcGVucyBiZWZvcmUgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSBoYXMgYmVlbiBzZXR0bGVkLlxuICAgKiBAcGFyYW0gbWF4VGltZW91dCAgICAgIE9wdGlvbmFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBXaGVuIHRoZSBwcm9taXNlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludm9rZWQsIGl0J3MgcHJvdmlkZWQgd2l0aCBhblxuICAgKiBBYm9ydFNpZ25hbCAoMm5kIGFyZ3VtZW50KS5cbiAgICogSWYgYSBzdGF0ZSB0cmFuc2l0aW9uIGhhcHBlbnMgd2hpbGUgdGhlIHByb21pc2UgaXMgcGVuZGluZyAoZm9yIGV4YW1wbGUsXG4gICAqIGFuIGV2ZW50LCBvciBhIHRpbWVvdXQgaGFwcGVucyksIHRoZW4gYW4gYWJvcnQgc2lnbmFsIHdpbGwgYmUgdXNlZCB0b1xuICAgKiBpbmRpY2F0ZSB0aGlzLiBJbXBsZW1lbnRlcnMgY2FuIHVzZSB0aGlzIGFib3J0IHNpZ25hbCB0byB0ZXJtaW5hdGUgdGhlXG4gICAqIGluLWZsaWdodCBwcm9taXNlLCBvciBpZ25vcmUgaXRzIHJlc3VsdHMsIGV0Yy5cbiAgICovXG4gIG9uRW50ZXJBc3luYyhuYW1lT3JQYXR0ZXJuLCBwcm9taXNlRm4sIG9uT0ssIG9uRXJyb3IsIG1heFRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKG5hbWVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICBjb25zdCB0aW1lb3V0SWQgPSBtYXhUaW1lb3V0ID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IG5ldyBFcnJvcihcIlRpbWVkIG91dFwiKTtcbiAgICAgICAgdGhpcy4jdHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfRVJST1JcIiwgcmVhc29uIH0sIG9uRXJyb3IpO1xuICAgICAgfSwgbWF4VGltZW91dCkgOiB2b2lkIDA7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgdm9pZCBwcm9taXNlRm4odGhpcy4jY3VycmVudENvbnRleHQuY3VycmVudCwgc2lnbmFsKS50aGVuKFxuICAgICAgICAvLyBPbiBPS1xuICAgICAgICAoZGF0YSkgPT4ge1xuICAgICAgICAgIGlmICghc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4jdHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfT0tcIiwgZGF0YSB9LCBvbk9LKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE9uIEVycm9yXG4gICAgICAgIChyZWFzb24pID0+IHtcbiAgICAgICAgICBpZiAoIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuI3RyYW5zaXRpb24oeyB0eXBlOiBcIkFTWU5DX0VSUk9SXCIsIHJlYXNvbiB9LCBvbkVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgI2dldFN0YXRlc01hdGNoaW5nKG5hbWVPclBhdHRlcm4pIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgaWYgKG5hbWVPclBhdHRlcm4gPT09IFwiKlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIHRoaXMuI3N0YXRlcykge1xuICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZU9yUGF0dGVybi5lbmRzV2l0aChcIi4qXCIpKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBuYW1lT3JQYXR0ZXJuLnNsaWNlKDAsIC0xKTtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy4jc3RhdGVzKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBuYW1lT3JQYXR0ZXJuO1xuICAgICAgaWYgKHRoaXMuI3N0YXRlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3RhdGVzIG1hdGNoICR7SlNPTi5zdHJpbmdpZnkobmFtZU9yUGF0dGVybil9YCk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgYWxsIGFsbG93ZWQgb3V0Z29pbmcgdHJhbnNpdGlvbnMgZm9yIGEgc3RhdGUuXG4gICAqXG4gICAqIFRoZSB0YXJnZXRzIGZvciBlYWNoIGV2ZW50IGNhbiBiZSBkZWZpbmVkIGFzIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGVcbiAgICogbmV4dCBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvLiBUaGVzZSBmdW5jdGlvbnMgY2FuIGxvb2sgYXQgdGhlIGBldmVudGAgb3JcbiAgICogYGNvbnRleHRgIHBhcmFtcyB0byBjb25kaXRpb25hbGx5IGRlY2lkZSB3aGljaCBuZXh0IHN0YXRlIHRvIHRyYW5zaXRpb25cbiAgICogdG8uXG4gICAqXG4gICAqIElmIHlvdSBzZXQgaXQgdG8gYG51bGxgLCB0aGVuIHRoZSB0cmFuc2l0aW9uIHdpbGwgYmUgZXhwbGljaXRseSBmb3JiaWRkZW5cbiAgICogYW5kIHRocm93IGFuIGVycm9yLiBJZiB5b3UgZG9uJ3QgZGVmaW5lIGEgdGFyZ2V0IGZvciBhIHRyYW5zaXRpb24sIHRoZW5cbiAgICogc3VjaCBldmVudHMgd2lsbCBnZXQgaWdub3JlZC5cbiAgICovXG4gIGFkZFRyYW5zaXRpb25zKG5hbWVPclBhdHRlcm4sIG1hcHBpbmcpIHtcbiAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNyY1N0YXRlIG9mIHRoaXMuI2dldFN0YXRlc01hdGNoaW5nKG5hbWVPclBhdHRlcm4pKSB7XG4gICAgICBsZXQgbWFwID0gdGhpcy4jYWxsb3dlZFRyYW5zaXRpb25zLmdldChzcmNTdGF0ZSk7XG4gICAgICBpZiAobWFwID09PSB2b2lkIDApIHtcbiAgICAgICAgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jYWxsb3dlZFRyYW5zaXRpb25zLnNldChzcmNTdGF0ZSwgbWFwKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW3R5cGUsIHRhcmdldF9dIG9mIE9iamVjdC5lbnRyaWVzKG1hcHBpbmcpKSB7XG4gICAgICAgIGlmIChtYXAuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRyeWluZyB0byBzZXQgdHJhbnNpdGlvbiBcIiR7dHlwZX1cIiBvbiBcIiR7c3JjU3RhdGV9XCIgKHZpYSBcIiR7bmFtZU9yUGF0dGVybn1cIiksIGJ1dCBhIHRyYW5zaXRpb24gYWxyZWFkeSBleGlzdHMgdGhlcmUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0XztcbiAgICAgICAgdGhpcy4ja25vd25FdmVudFR5cGVzLmFkZCh0eXBlKTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Rm4gPSB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgPyB0YXJnZXQgOiAoKSA9PiB0YXJnZXQ7XG4gICAgICAgICAgbWFwLnNldCh0eXBlLCB0YXJnZXRGbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIExpa2UgYC5hZGRUcmFuc2l0aW9uKClgLCBidXQgdGFrZXMgYW4gKGFub255bW91cykgdHJhbnNpdGlvbiB3aGVuZXZlciB0aGVcbiAgICogdGltZXIgZmlyZXMuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZU9yUGF0dGVybiAgVGhlIHN0YXRlIG5hbWUsIG9yIHN0YXRlIGdyb3VwIHBhdHRlcm4gbmFtZS5cbiAgICogQHBhcmFtIGFmdGVyICAgICAgICAgICBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRvIHRha2UgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbi4gSWYgaW4gdGhlIG1lYW4gdGltZSwgYW5vdGhlciB0cmFuc2l0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgaXMgdGFrZW4sIHRoZSB0aW1lciB3aWxsIGdldCBjYW5jZWxsZWQuXG4gICAqIEBwYXJhbSB0YXJnZXQgICAgICAgICAgVGhlIHRhcmdldCBzdGF0ZSB0byBnbyB0by5cbiAgICovXG4gIGFkZFRpbWVkVHJhbnNpdGlvbihzdGF0ZU9yUGF0dGVybiwgYWZ0ZXIyLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKHN0YXRlT3JQYXR0ZXJuLCAoKSA9PiB7XG4gICAgICBjb25zdCBtcyA9IHR5cGVvZiBhZnRlcjIgPT09IFwiZnVuY3Rpb25cIiA/IGFmdGVyMih0aGlzLiNjdXJyZW50Q29udGV4dC5jdXJyZW50KSA6IGFmdGVyMjtcbiAgICAgIGNvbnN0IHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiN0cmFuc2l0aW9uKHsgdHlwZTogXCJUSU1FUlwiIH0sIHRhcmdldCk7XG4gICAgICB9LCBtcyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgI2dldFRhcmdldEZuKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNhbGxvd2VkVHJhbnNpdGlvbnMuZ2V0KHRoaXMuY3VycmVudFN0YXRlKT8uZ2V0KGV2ZW50TmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4aXRzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBjbGVhbnVwIGZ1bmN0aW9ucy5cbiAgICogQ2FsbCB0aGlzIGJlZm9yZSBjaGFuZ2luZyB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIGxldmVscyBEZWZpbmVzIGhvdyBtYW55IFwibGV2ZWxzXCIgb2YgbmVzdGluZyB3aWxsIGJlXG4gICAqIGV4aXRlZC4gRm9yIGV4YW1wbGUsIGlmIHlvdSB0cmFuc2l0aW9uIGZyb20gYGZvby5iYXIucXV4YCB0b1xuICAgKiBgZm9vLmJhci5iYXpgLCB0aGVuIHRoZSBsZXZlbCBpcyAxLiBCdXQgaWYgeW91IHRyYW5zaXRpb24gZnJvbVxuICAgKiBgZm9vLmJhci5xdXhgIHRvIGBibGEuYmxhYCwgdGhlbiB0aGUgbGV2ZWwgaXMgMy5cbiAgICogSWYgYG51bGxgLCBpdCB3aWxsIGV4aXQgYWxsIGxldmVscy5cbiAgICovXG4gICNleGl0KGxldmVscykge1xuICAgIHRoaXMuI2V2ZW50SHViLndpbGxFeGl0U3RhdGUubm90aWZ5KHRoaXMuY3VycmVudFN0YXRlKTtcbiAgICB0aGlzLiNjdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMgPz8gdGhpcy4jY2xlYW51cFN0YWNrLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy4jY2xlYW51cFN0YWNrLnBvcCgpPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVudGVycyB0aGUgY3VycmVudCBzdGF0ZSwgYW5kIGV4ZWN1dGVzIGFueSBuZWNlc3Nhcnkgb25FbnRlciBoYW5kbGVycy5cbiAgICogQ2FsbCB0aGlzIGRpcmVjdGx5IF9hZnRlcl8gc2V0dGluZyB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICovXG4gICNlbnRlcihsZXZlbHMpIHtcbiAgICBjb25zdCBlbnRlclBhdHRlcm5zID0gcGF0dGVybnMoXG4gICAgICB0aGlzLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGxldmVscyA/PyB0aGlzLmN1cnJlbnRTdGF0ZS5zcGxpdChcIi5cIikubGVuZ3RoICsgMVxuICAgICk7XG4gICAgdGhpcy4jY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGVudGVyUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgZW50ZXJGbiA9IHRoaXMuI2VudGVyRm5zLmdldChwYXR0ZXJuKTtcbiAgICAgICAgY29uc3QgY2xlYW51cEZuID0gZW50ZXJGbj8uKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFudXBGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy4jY2xlYW51cFN0YWNrLnB1c2goY2xlYW51cEZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNjbGVhbnVwU3RhY2sucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuI2V2ZW50SHViLmRpZEVudGVyU3RhdGUubm90aWZ5KHRoaXMuY3VycmVudFN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYW4gZXZlbnQgdG8gdGhlIG1hY2hpbmUsIHdoaWNoIG1heSBjYXVzZSBhbiBpbnRlcm5hbCBzdGF0ZVxuICAgKiB0cmFuc2l0aW9uIHRvIGhhcHBlbi4gV2hlbiB0aGF0IGhhcHBlbnMsIHdpbGwgdHJpZ2dlciBzaWRlIGVmZmVjdHMuXG4gICAqL1xuICBzZW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLiNrbm93bkV2ZW50VHlwZXMuaGFzKGV2ZW50LnR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXZlbnQgJHtKU09OLnN0cmluZ2lmeShldmVudC50eXBlKX1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3J1bm5pbmdTdGF0ZSA9PT0gMiAvKiBTVE9QUEVEICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEZuID0gdGhpcy4jZ2V0VGFyZ2V0Rm4oZXZlbnQudHlwZSk7XG4gICAgaWYgKHRhcmdldEZuICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLiN0cmFuc2l0aW9uKGV2ZW50LCB0YXJnZXRGbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gICN0cmFuc2l0aW9uKGV2ZW50LCB0YXJnZXQpIHtcbiAgICB0aGlzLiNldmVudEh1Yi5kaWRSZWNlaXZlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuY3VycmVudFN0YXRlO1xuICAgIGNvbnN0IHRhcmdldEZuID0gdHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiID8gdGFyZ2V0IDogKCkgPT4gdGFyZ2V0O1xuICAgIGNvbnN0IG5leHRUYXJnZXQgPSB0YXJnZXRGbihldmVudCwgdGhpcy4jY3VycmVudENvbnRleHQuY3VycmVudCk7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBsZXQgZWZmZWN0cyA9IHZvaWQgMDtcbiAgICBpZiAobmV4dFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy4jZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXh0VGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXh0VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXh0VGFyZ2V0LnRhcmdldDtcbiAgICAgIGVmZmVjdHMgPSBBcnJheS5pc0FycmF5KG5leHRUYXJnZXQuZWZmZWN0KSA/IG5leHRUYXJnZXQuZWZmZWN0IDogW25leHRUYXJnZXQuZWZmZWN0XTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNzdGF0ZXMuaGFzKG5leHRTdGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuZXh0IHN0YXRlIG5hbWU6ICR7SlNPTi5zdHJpbmdpZnkobmV4dFN0YXRlKX1gKTtcbiAgICB9XG4gICAgdGhpcy4jZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ubm90aWZ5KHsgZnJvbTogb2xkU3RhdGUsIHRvOiBuZXh0U3RhdGUgfSk7XG4gICAgY29uc3QgW3VwLCBkb3duXSA9IGRpc3RhbmNlKHRoaXMuY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpO1xuICAgIGlmICh1cCA+IDApIHtcbiAgICAgIHRoaXMuI2V4aXQodXApO1xuICAgIH1cbiAgICB0aGlzLiNjdXJyZW50U3RhdGVPck51bGwgPSBuZXh0U3RhdGU7XG4gICAgaWYgKGVmZmVjdHMgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZWZmZWN0c1RvUnVuID0gZWZmZWN0cztcbiAgICAgIHRoaXMuI2N1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0c1RvUnVuKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWZmZWN0KHBhdGNoYWJsZUNvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hhYmxlQ29udGV4dC5wYXRjaChlZmZlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkb3duID4gMCkge1xuICAgICAgdGhpcy4jZW50ZXIoZG93bik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvU2VydmVyTXNnLnRzXG52YXIgU2VydmVyTXNnQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcnZlck1zZ0NvZGUyKSA9PiB7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1BSRVNFTkNFXCJdID0gMTAwXSA9IFwiVVBEQVRFX1BSRVNFTkNFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVNFUl9KT0lORURcIl0gPSAxMDFdID0gXCJVU0VSX0pPSU5FRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVTRVJfTEVGVFwiXSA9IDEwMl0gPSBcIlVTRVJfTEVGVFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkJST0FEQ0FTVEVEX0VWRU5UXCJdID0gMTAzXSA9IFwiQlJPQURDQVNURURfRVZFTlRcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJST09NX1NUQVRFXCJdID0gMTA0XSA9IFwiUk9PTV9TVEFURVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIklOSVRJQUxfU1RPUkFHRV9TVEFURVwiXSA9IDIwMF0gPSBcIklOSVRJQUxfU1RPUkFHRV9TVEFURVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJSRUpFQ1RfU1RPUkFHRV9PUFwiXSA9IDI5OV0gPSBcIlJFSkVDVF9TVE9SQUdFX09QXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1lET0NcIl0gPSAzMDBdID0gXCJVUERBVEVfWURPQ1wiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9DUkVBVEVEXCJdID0gNDAwXSA9IFwiVEhSRUFEX0NSRUFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfREVMRVRFRFwiXSA9IDQwN10gPSBcIlRIUkVBRF9ERUxFVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX01FVEFEQVRBX1VQREFURURcIl0gPSA0MDFdID0gXCJUSFJFQURfTUVUQURBVEFfVVBEQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9VUERBVEVEXCJdID0gNDA4XSA9IFwiVEhSRUFEX1VQREFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0NSRUFURURcIl0gPSA0MDJdID0gXCJDT01NRU5UX0NSRUFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0VESVRFRFwiXSA9IDQwM10gPSBcIkNPTU1FTlRfRURJVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9ERUxFVEVEXCJdID0gNDA0XSA9IFwiQ09NTUVOVF9ERUxFVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9SRUFDVElPTl9BRERFRFwiXSA9IDQwNV0gPSBcIkNPTU1FTlRfUkVBQ1RJT05fQURERURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRURcIl0gPSA0MDZdID0gXCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRURcIjtcbiAgcmV0dXJuIFNlcnZlck1zZ0NvZGUyO1xufSkoU2VydmVyTXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9JV2ViU29ja2V0LnRzXG52YXIgV2Vic29ja2V0Q2xvc2VDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFdlYnNvY2tldENsb3NlQ29kZXMyKSA9PiB7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfTk9STUFMXCJdID0gMWUzXSA9IFwiQ0xPU0VfTk9STUFMXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfQUJOT1JNQUxcIl0gPSAxMDA2XSA9IFwiQ0xPU0VfQUJOT1JNQUxcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJVTkVYUEVDVEVEX0NPTkRJVElPTlwiXSA9IDEwMTFdID0gXCJVTkVYUEVDVEVEX0NPTkRJVElPTlwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlRSWV9BR0FJTl9MQVRFUlwiXSA9IDEwMTNdID0gXCJUUllfQUdBSU5fTEFURVJcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCJdID0gNGUzXSA9IFwiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk5PVF9BTExPV0VEXCJdID0gNDAwMV0gPSBcIk5PVF9BTExPV0VEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfU0VDT05EU1wiXSA9IDQwMDJdID0gXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCJdID0gNDAwM10gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU1wiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCJdID0gNDAwNF0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCJdID0gNDAwNV0gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU19QRVJfUk9PTVwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlJPT01fSURfVVBEQVRFRFwiXSA9IDQwMDZdID0gXCJST09NX0lEX1VQREFURURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJLSUNLRURcIl0gPSA0MTAwXSA9IFwiS0lDS0VEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVE9LRU5fRVhQSVJFRFwiXSA9IDQxMDldID0gXCJUT0tFTl9FWFBJUkVEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfV0lUSE9VVF9SRVRSWVwiXSA9IDQ5OTldID0gXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCI7XG4gIHJldHVybiBXZWJzb2NrZXRDbG9zZUNvZGVzMjtcbn0pKFdlYnNvY2tldENsb3NlQ29kZXMgfHwge30pO1xuZnVuY3Rpb24gc2hvdWxkRGlzY29ubmVjdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSA0OTk5IC8qIENMT1NFX1dJVEhPVVRfUkVUUlkgKi8gfHwgY29kZSA+PSA0ZTMgJiYgY29kZSA8IDQxMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSA0MTAwICYmIGNvZGUgPCA0MjAwO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMTMgLyogVFJZX0FHQUlOX0xBVEVSICovIHx8IGNvZGUgPj0gNDIwMCAmJiBjb2RlIDwgNDMwMDtcbn1cblxuLy8gc3JjL2Nvbm5lY3Rpb24udHNcbmZ1bmN0aW9uIGlzSWRsZShzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gXCJpbml0aWFsXCIgfHwgc3RhdHVzID09PSBcImRpc2Nvbm5lY3RlZFwiO1xufVxuZnVuY3Rpb24gdG9OZXdDb25uZWN0aW9uU3RhdHVzKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhdGUgPSBtYWNoaW5lLmN1cnJlbnRTdGF0ZTtcbiAgc3dpdGNoIChzdGF0ZSkge1xuICAgIGNhc2UgXCJAb2suY29ubmVjdGVkXCI6XG4gICAgY2FzZSBcIkBvay5hd2FpdGluZy1wb25nXCI6XG4gICAgICByZXR1cm4gXCJjb25uZWN0ZWRcIjtcbiAgICBjYXNlIFwiQGlkbGUuaW5pdGlhbFwiOlxuICAgICAgcmV0dXJuIFwiaW5pdGlhbFwiO1xuICAgIGNhc2UgXCJAYXV0aC5idXN5XCI6XG4gICAgY2FzZSBcIkBhdXRoLmJhY2tvZmZcIjpcbiAgICBjYXNlIFwiQGNvbm5lY3RpbmcuYnVzeVwiOlxuICAgIGNhc2UgXCJAY29ubmVjdGluZy5iYWNrb2ZmXCI6XG4gICAgY2FzZSBcIkBpZGxlLnpvbWJpZVwiOlxuICAgICAgcmV0dXJuIG1hY2hpbmUuY29udGV4dC5zdWNjZXNzQ291bnQgPiAwID8gXCJyZWNvbm5lY3RpbmdcIiA6IFwiY29ubmVjdGluZ1wiO1xuICAgIGNhc2UgXCJAaWRsZS5mYWlsZWRcIjpcbiAgICAgIHJldHVybiBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihzdGF0ZSwgXCJVbmtub3duIHN0YXRlXCIpO1xuICB9XG59XG52YXIgQkFDS09GRl9ERUxBWVMgPSBbMjUwLCA1MDAsIDFlMywgMmUzLCA0ZTMsIDhlMywgMWU0XTtcbnZhciBSRVNFVF9ERUxBWSA9IEJBQ0tPRkZfREVMQVlTWzBdIC0gMTtcbnZhciBCQUNLT0ZGX0RFTEFZU19TTE9XID0gWzJlMywgM2U0LCA2ZTQsIDNlNV07XG52YXIgSEVBUlRCRUFUX0lOVEVSVkFMID0gM2U0O1xudmFyIFBPTkdfVElNRU9VVCA9IDJlMztcbnZhciBBVVRIX1RJTUVPVVQgPSAxZTQ7XG52YXIgU09DS0VUX0NPTk5FQ1RfVElNRU9VVCA9IDFlNDtcbnZhciBTdG9wUmV0cnlpbmcgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIocmVhc29uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIG5leHRCYWNrb2ZmRGVsYXkoY3VycmVudERlbGF5LCBkZWxheXMpIHtcbiAgcmV0dXJuIGRlbGF5cy5maW5kKChkZWxheSkgPT4gZGVsYXkgPiBjdXJyZW50RGVsYXkpID8/IGRlbGF5c1tkZWxheXMubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVMpXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHkoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHtcbiAgICBiYWNrb2ZmRGVsYXk6IG5leHRCYWNrb2ZmRGVsYXkoY29udGV4dC5iYWNrb2ZmRGVsYXksIEJBQ0tPRkZfREVMQVlTX1NMT1cpXG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzZXRTdWNjZXNzQ291bnQoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHsgc3VjY2Vzc0NvdW50OiAwIH0pO1xufVxuZnVuY3Rpb24gbG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGxvZ2dlciA9IGxldmVsID09PSAyIC8qIEVSUk9SICovID8gZXJyb3IyIDogbGV2ZWwgPT09IDEgLyogV0FSTiAqLyA/IHdhcm4gOiAoXG4gICAgLyogYmxhY2sgaG9sZSAqL1xuICAgICgpID0+IHtcbiAgICB9XG4gICk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbG9nZ2VyKG1lc3NhZ2UpO1xuICB9O1xufVxuZnVuY3Rpb24gbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZSkge1xuICBjb25zdCBjb25uID0gXCJDb25uZWN0aW9uIHRvIExpdmVibG9ja3Mgd2Vic29ja2V0IHNlcnZlclwiO1xuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHdhcm4oYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLiAke1N0cmluZyhlKX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgaXNDbG9zZUV2ZW50KGUpID8gYCR7Y29ubn0gY2xvc2VkIHByZW1hdHVyZWx5IChjb2RlOiAke2UuY29kZX0pLiBSZXRyeWluZyBpbiAke2N0eC5iYWNrb2ZmRGVsYXl9bXMuYCA6IGAke2Nvbm59IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGxvZ0Nsb3NlRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgZGV0YWlscyA9IFtgY29kZTogJHtldmVudC5jb2RlfWBdO1xuICBpZiAoZXZlbnQucmVhc29uKSB7XG4gICAgZGV0YWlscy5wdXNoKGByZWFzb246ICR7ZXZlbnQucmVhc29ufWApO1xuICB9XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgd2FybihcbiAgICAgIGBDb25uZWN0aW9uIHRvIExpdmVibG9ja3Mgd2Vic29ja2V0IHNlcnZlciBjbG9zZWQgKCR7ZGV0YWlscy5qb2luKFwiLCBcIil9KS4gUmV0cnlpbmcgaW4gJHtjdHguYmFja29mZkRlbGF5fW1zLmBcbiAgICApO1xuICB9O1xufVxudmFyIGxvZ1Blcm1hbmVudENsb3NlID0gbG9nKFxuICAxIC8qIFdBUk4gKi8sXG4gIFwiQ29ubmVjdGlvbiB0byBXZWJTb2NrZXQgY2xvc2VkIHBlcm1hbmVudGx5LiBXb24ndCByZXRyeS5cIlxuKTtcbmZ1bmN0aW9uIGlzQ2xvc2VFdmVudChlcnJvcjMpIHtcbiAgcmV0dXJuICEoZXJyb3IzIGluc3RhbmNlb2YgRXJyb3IpICYmIGVycm9yMy50eXBlID09PSBcImNsb3NlXCI7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFjaW5nKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhcnQgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgZnVuY3Rpb24gbG9nMiguLi5hcmdzKSB7XG4gICAgd2FybihcbiAgICAgIGAkeygoKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyAxZTMpLnRvRml4ZWQoMil9IFtGU00gIyR7bWFjaGluZS5pZH1dYCxcbiAgICAgIC4uLmFyZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IHVuc3VicyA9IFtcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRSZWNlaXZlRXZlbnQuc3Vic2NyaWJlKChlKSA9PiBsb2cyKGBFdmVudCAke2UudHlwZX1gKSksXG4gICAgbWFjaGluZS5ldmVudHMud2lsbFRyYW5zaXRpb24uc3Vic2NyaWJlKFxuICAgICAgKHsgZnJvbSwgdG8gfSkgPT4gbG9nMihcIlRyYW5zaXRpb25pbmdcIiwgZnJvbSwgXCJcXHUyMTkyXCIsIHRvKVxuICAgICksXG4gICAgbWFjaGluZS5ldmVudHMuZGlkSWdub3JlRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgKGUpID0+IGxvZzIoXCJJZ25vcmVkIGV2ZW50XCIsIGUudHlwZSwgZSwgXCIoY3VycmVudCBzdGF0ZSB3b24ndCBoYW5kbGUgaXQpXCIpXG4gICAgKVxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLndpbGxFeGl0U3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFeGl0aW5nIHN0YXRlXCIsIHMpKSxcbiAgICAvLyBtYWNoaW5lLmV2ZW50cy5kaWRFbnRlclN0YXRlLnN1YnNjcmliZSgocykgPT4gbG9nKFwiRW50ZXJpbmcgc3RhdGVcIiwgcykpLFxuICBdO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgICB1bnN1YigpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZUNvbm5lY3Rpdml0eUV2ZW50cyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXR1c0RpZENoYW5nZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBjb25zdCBkaWRDb25uZWN0ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZERpc2Nvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgbGV0IGxhc3RTdGF0dXMgPSBudWxsO1xuICBjb25zdCB1bnN1YnNjcmliZSA9IG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zdCBjdXJyU3RhdHVzID0gdG9OZXdDb25uZWN0aW9uU3RhdHVzKG1hY2hpbmUpO1xuICAgIGlmIChjdXJyU3RhdHVzICE9PSBsYXN0U3RhdHVzKSB7XG4gICAgICBzdGF0dXNEaWRDaGFuZ2Uubm90aWZ5KGN1cnJTdGF0dXMpO1xuICAgIH1cbiAgICBpZiAobGFzdFN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIiAmJiBjdXJyU3RhdHVzICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBkaWREaXNjb25uZWN0Lm5vdGlmeSgpO1xuICAgIH0gZWxzZSBpZiAobGFzdFN0YXR1cyAhPT0gXCJjb25uZWN0ZWRcIiAmJiBjdXJyU3RhdHVzID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBkaWRDb25uZWN0Lm5vdGlmeSgpO1xuICAgIH1cbiAgICBsYXN0U3RhdHVzID0gY3VyclN0YXR1cztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzRGlkQ2hhbmdlOiBzdGF0dXNEaWRDaGFuZ2Uub2JzZXJ2YWJsZSxcbiAgICBkaWRDb25uZWN0OiBkaWRDb25uZWN0Lm9ic2VydmFibGUsXG4gICAgZGlkRGlzY29ubmVjdDogZGlkRGlzY29ubmVjdC5vYnNlcnZhYmxlLFxuICAgIHVuc3Vic2NyaWJlXG4gIH07XG59XG52YXIgYXNzaWduID0gKHBhdGNoKSA9PiAoY3R4KSA9PiBjdHgucGF0Y2gocGF0Y2gpO1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblN0YXRlTWFjaGluZShkZWxlZ2F0ZXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb25NZXNzYWdlID0gbWFrZUJ1ZmZlcmFibGVFdmVudFNvdXJjZSgpO1xuICBvbk1lc3NhZ2UucGF1c2UoKTtcbiAgY29uc3Qgb25Db25uZWN0aW9uRXJyb3IgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZmlyZUVycm9yRXZlbnQobWVzc2FnZSwgY29kZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvbkNvbm5lY3Rpb25FcnJvci5ub3RpZnkoeyBtZXNzYWdlLCBjb2RlIH0pO1xuICAgIH07XG4gIH1cbiAgY29uc3QgaW5pdGlhbENvbnRleHQgPSB7XG4gICAgc3VjY2Vzc0NvdW50OiAwLFxuICAgIGF1dGhWYWx1ZTogbnVsbCxcbiAgICBzb2NrZXQ6IG51bGwsXG4gICAgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWVxuICB9O1xuICBjb25zdCBtYWNoaW5lID0gbmV3IEZTTShpbml0aWFsQ29udGV4dCkuYWRkU3RhdGUoXCJAaWRsZS5pbml0aWFsXCIpLmFkZFN0YXRlKFwiQGlkbGUuZmFpbGVkXCIpLmFkZFN0YXRlKFwiQGlkbGUuem9tYmllXCIpLmFkZFN0YXRlKFwiQGF1dGguYnVzeVwiKS5hZGRTdGF0ZShcIkBhdXRoLmJhY2tvZmZcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5idXN5XCIpLmFkZFN0YXRlKFwiQGNvbm5lY3RpbmcuYmFja29mZlwiKS5hZGRTdGF0ZShcIkBvay5jb25uZWN0ZWRcIikuYWRkU3RhdGUoXCJAb2suYXdhaXRpbmctcG9uZ1wiKTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIipcIiwge1xuICAgIFJFQ09OTkVDVDoge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCByZXNldFN1Y2Nlc3NDb3VudF1cbiAgICB9LFxuICAgIERJU0NPTk5FQ1Q6IFwiQGlkbGUuaW5pdGlhbFwiXG4gIH0pO1xuICBtYWNoaW5lLm9uRW50ZXIoXCJAaWRsZS4qXCIsIHJlc2V0U3VjY2Vzc0NvdW50KS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLipcIiwge1xuICAgIENPTk5FQ1Q6IChfLCBjdHgpID0+IChcbiAgICAgIC8vIElmIHdlIHN0aWxsIGhhdmUgYSBrbm93biBhdXRoVmFsdWUsIHRyeSB0byByZWNvbm5lY3QgdG8gdGhlIHNvY2tldCBkaXJlY3RseSxcbiAgICAgIC8vIG90aGVyd2lzZSwgdHJ5IHRvIG9idGFpbiBhIG5ldyBhdXRoVmFsdWVcbiAgICAgIGN0eC5hdXRoVmFsdWUgIT09IG51bGwgPyBcIkBjb25uZWN0aW5nLmJ1c3lcIiA6IFwiQGF1dGguYnVzeVwiXG4gICAgKVxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBhdXRoLmJhY2tvZmZcIiwge1xuICAgIE5BVklHQVRPUl9PTkxJTkU6IHtcbiAgICAgIHRhcmdldDogXCJAYXV0aC5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7IGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVkgfSlcbiAgICB9XG4gIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcbiAgICBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAoY3R4KSA9PiBjdHguYmFja29mZkRlbGF5LFxuICAgIFwiQGF1dGguYnVzeVwiXG4gICkub25FbnRlckFzeW5jKFxuICAgIFwiQGF1dGguYnVzeVwiLFxuICAgICgpID0+IHdpdGhUaW1lb3V0KFxuICAgICAgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpLFxuICAgICAgQVVUSF9USU1FT1VULFxuICAgICAgXCJUaW1lZCBvdXQgZHVyaW5nIGF1dGhcIlxuICAgICksXG4gICAgLy8gT24gc3VjY2Vzc2Z1bCBhdXRoZW50aWNhdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgYXV0aFZhbHVlOiBva0V2ZW50LmRhdGFcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gQXV0aCBmYWlsZWRcbiAgICAoZmFpbGVkRXZlbnQpID0+IHtcbiAgICAgIGlmIChmYWlsZWRFdmVudC5yZWFzb24gaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5LFxuICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgIDIgLyogRVJST1IgKi8sXG4gICAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2ZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIEVycm9yID8gZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UgOiBTdHJpbmcoZmFpbGVkRXZlbnQucmVhc29uKX1gXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgb25Tb2NrZXRFcnJvciA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfRVJST1JcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0Q2xvc2UgPSAoZXZlbnQpID0+IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pO1xuICBjb25zdCBvblNvY2tldE1lc3NhZ2UgPSAoZXZlbnQpID0+IGV2ZW50LmRhdGEgPT09IFwicG9uZ1wiID8gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJQT05HXCIgfSkgOiBvbk1lc3NhZ2Uubm90aWZ5KGV2ZW50KTtcbiAgZnVuY3Rpb24gdGVhcmRvd25Tb2NrZXQoc29ja2V0KSB7XG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvblNvY2tldEVycm9yKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgb25Tb2NrZXRDbG9zZSk7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAY29ubmVjdGluZy5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy9cbiAgICAvLyBVc2UgdGhlIFwiY3JlYXRlU29ja2V0XCIgZGVsZWdhdGUgZnVuY3Rpb24gKHByb3ZpZGVkIHRvIHRoZVxuICAgIC8vIE1hbmFnZWRTb2NrZXQpIHRvIGNyZWF0ZSB0aGUgYWN0dWFsIFdlYlNvY2tldCBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgIC8vIFRoZW4sIHNldCB1cCBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMsIGFuZCB3YWl0IGZvciB0aGVcbiAgICAvLyBcIm9wZW5cIiBldmVudCB0byBvY2N1ci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIFwib3BlblwiIGV2ZW50IGhhcHBlbnMsIHdlJ3JlIHJlYWR5IHRvIHRyYW5zaXRpb24gdG8gdGhlXG4gICAgLy8gT0sgc3RhdGUuIFRoaXMgaXMgZG9uZSBieSByZXNvbHZpbmcgdGhlIFByb21pc2UuXG4gICAgLy9cbiAgICBhc3luYyAoY3R4LCBzaWduYWwpID0+IHtcbiAgICAgIGxldCBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gbnVsbDtcbiAgICAgIGxldCB1bmNvbmZpcm1lZFNvY2tldCA9IG51bGw7XG4gICAgICBjb25zdCBjb25uZWN0JCA9IG5ldyBQcm9taXNlKFxuICAgICAgICAocmVzb2x2ZSwgcmVqKSA9PiB7XG4gICAgICAgICAgaWYgKGN0eC5hdXRoVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggYXV0aFZhbHVlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzb2NrZXQgPSBkZWxlZ2F0ZXMuY3JlYXRlU29ja2V0KGN0eC5hdXRoVmFsdWUpO1xuICAgICAgICAgIHVuY29uZmlybWVkU29ja2V0ID0gc29ja2V0O1xuICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdChldmVudCkge1xuICAgICAgICAgICAgY2FwdHVyZWRQcmVtYXR1cmVFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgICByZWooZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBbYWN0b3IkLCBkaWRSZWNlaXZlQWN0b3JdID0gY29udHJvbGxlZFByb21pc2UoKTtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIGRpZFJlY2VpdmVBY3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB3YWl0Rm9yQWN0b3JJZChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyTXNnID0gdHJ5UGFyc2VKc29uKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgaWYgKHNlcnZlck1zZz8udHlwZSA9PT0gMTA0IC8qIFJPT01fU1RBVEUgKi8pIHtcbiAgICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgICAgIGlmIChvcHRpb25zLndhaXRGb3JBY3RvcklkKSB7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdhaXRGb3JBY3RvcklkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2b2lkIGFjdG9yJC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShbc29ja2V0LCB1bnN1Yl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gd2l0aFRpbWVvdXQoXG4gICAgICAgIGNvbm5lY3QkLFxuICAgICAgICBTT0NLRVRfQ09OTkVDVF9USU1FT1VULFxuICAgICAgICBcIlRpbWVkIG91dCBkdXJpbmcgd2Vic29ja2V0IGNvbm5lY3Rpb25cIlxuICAgICAgKS50aGVuKFxuICAgICAgICAvL1xuICAgICAgICAvLyBQYXJ0IDM6XG4gICAgICAgIC8vIEJ5IG5vdywgb3VyIFwib3BlblwiIGV2ZW50IGhhcyBmaXJlZCwgYW5kIHRoZSBwcm9taXNlIGhhcyBiZWVuXG4gICAgICAgIC8vIHJlc29sdmVkLiBUd28gcG9zc2libGUgc2NlbmFyaW9zOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBUaGUgaGFwcHkgcGF0aC4gTW9zdCBsaWtlbHkuXG4gICAgICAgIC8vIDIuIFVoLW9oLiBBIHByZW1hdHVyZSBjbG9zZS9lcnJvciBldmVudCBoYXMgYmVlbiBvYnNlcnZlZC4gTGV0J3NcbiAgICAgICAgLy8gICAgcmVqZWN0IHRoZSBwcm9taXNlIGFmdGVyIGFsbC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQW55IGNsb3NlL2Vycm9yIGV2ZW50IHRoYXQgd2lsbCBnZXQgc2NoZWR1bGVkIGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gb253YXJkcywgd2lsbCBiZSBjYXVnaHQgaW4gdGhlIE9LIHN0YXRlLCBhbmQgZGVhbHQgd2l0aFxuICAgICAgICAvLyBhY2NvcmRpbmdseS5cbiAgICAgICAgLy9cbiAgICAgICAgKFtzb2NrZXQsIHVuc3ViXSkgPT4ge1xuICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYm9ydGVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FwdHVyZWRQcmVtYXR1cmVFdmVudCkge1xuICAgICAgICAgICAgdGhyb3cgY2FwdHVyZWRQcmVtYXR1cmVFdmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgICAgfVxuICAgICAgKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICB0ZWFyZG93blNvY2tldCh1bmNvbmZpcm1lZFNvY2tldCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIE9ubHkgdHJhbnNpdGlvbiB0byBPSyBzdGF0ZSBhZnRlciBhIHN1Y2Nlc3NmdWxseSBvcGVuZWQgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAob2tFdmVudCkgPT4gKHtcbiAgICAgIHRhcmdldDogXCJAb2suY29ubmVjdGVkXCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7XG4gICAgICAgIHNvY2tldDogb2tFdmVudC5kYXRhLFxuICAgICAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gICAgICB9KVxuICAgIH0pLFxuICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWRcbiAgICAoZmFpbHVyZSkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gZmFpbHVyZS5yZWFzb247XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU3RvcFJldHJ5aW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGVyci5tZXNzYWdlKSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGVyci5tZXNzYWdlLCAtMSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNDbG9zZUV2ZW50KGVycikpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSA0MTA5IC8qIFRPS0VOX0VYUElSRUQgKi8pIHtcbiAgICAgICAgICByZXR1cm4gXCJAYXV0aC5idXN5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgICBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSxcbiAgICAgICAgICAgICAgbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZXJyKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZXJyLmNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLnJlYXNvbiksXG4gICAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGVyci5yZWFzb24sIGVyci5jb2RlKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXVxuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IHNlbmRIZWFydGJlYXQgPSB7XG4gICAgdGFyZ2V0OiBcIkBvay5hd2FpdGluZy1wb25nXCIsXG4gICAgZWZmZWN0OiAoY3R4KSA9PiB7XG4gICAgICBjdHguc29ja2V0Py5zZW5kKFwicGluZ1wiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1heWJlSGVhcnRiZWF0ID0gKCkgPT4ge1xuICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICAgIGNvbnN0IGNhblpvbWJpZSA9IGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiICYmIGRlbGVnYXRlcy5jYW5ab21iaWUoKTtcbiAgICByZXR1cm4gY2FuWm9tYmllID8gXCJAaWRsZS56b21iaWVcIiA6IHNlbmRIZWFydGJlYXQ7XG4gIH07XG4gIG1hY2hpbmUuYWRkVGltZWRUcmFuc2l0aW9uKFwiQG9rLmNvbm5lY3RlZFwiLCBIRUFSVEJFQVRfSU5URVJWQUwsIG1heWJlSGVhcnRiZWF0KS5hZGRUcmFuc2l0aW9ucyhcIkBvay5jb25uZWN0ZWRcIiwge1xuICAgIE5BVklHQVRPUl9PRkZMSU5FOiBtYXliZUhlYXJ0YmVhdCxcbiAgICAvLyBEb24ndCB0YWtlIHRoZSBicm93c2VyJ3Mgd29yZCBmb3IgaXQgd2hlbiBpdCBzYXlzIGl0J3Mgb2ZmbGluZS4gRG8gYSBwaW5nL3BvbmcgdG8gbWFrZSBzdXJlLlxuICAgIFdJTkRPV19HT1RfRk9DVVM6IHNlbmRIZWFydGJlYXRcbiAgfSk7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAaWRsZS56b21iaWVcIiwge1xuICAgIFdJTkRPV19HT1RfRk9DVVM6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiXG4gICAgLy8gV2hlbiBpbiB6b21iaWUgc3RhdGUsIHRoZSBjbGllbnQgd2lsbCB0cnkgdG8gd2FrZSB1cCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHdpbmRvdyByZWdhaW5zIGZvY3VzXG4gIH0pO1xuICBtYWNoaW5lLm9uRW50ZXIoXCJAb2suKlwiLCAoY3R4KSA9PiB7XG4gICAgY3R4LnBhdGNoKHsgc3VjY2Vzc0NvdW50OiBjdHguc3VjY2Vzc0NvdW50ICsgMSB9KTtcbiAgICBjb25zdCB0aW1lcklEID0gc2V0VGltZW91dChcbiAgICAgIC8vIE9uIHRoZSBuZXh0IHRpY2ssIHN0YXJ0IGRlbGl2ZXJpbmcgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBhbHJlYWR5XG4gICAgICAvLyBiZWVuIHJlY2VpdmVkLCBhbmQgY29udGludWUgc3luY2hyb25vdXMgZGVsaXZlcnkgb2YgYWxsIGZ1dHVyZVxuICAgICAgLy8gaW5jb21pbmcgbWVzc2FnZXMuXG4gICAgICBvbk1lc3NhZ2UudW5wYXVzZSxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiAoY3R4MikgPT4ge1xuICAgICAgdGVhcmRvd25Tb2NrZXQoY3R4Mi5zb2NrZXQpO1xuICAgICAgY3R4Mi5wYXRjaCh7IHNvY2tldDogbnVsbCB9KTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTtcbiAgICAgIG9uTWVzc2FnZS5wYXVzZSgpO1xuICAgIH07XG4gIH0pLmFkZFRyYW5zaXRpb25zKFwiQG9rLmF3YWl0aW5nLXBvbmdcIiwgeyBQT05HOiBcIkBvay5jb25uZWN0ZWRcIiB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suYXdhaXRpbmctcG9uZ1wiLCBQT05HX1RJTUVPVVQsIHtcbiAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgIC8vIExvZyBpbXBsaWNpdCBjb25uZWN0aW9uIGxvc3MgYW5kIGRyb3AgdGhlIGN1cnJlbnQgb3BlbiBzb2NrZXRcbiAgICBlZmZlY3Q6IGxvZyhcbiAgICAgIDEgLyogV0FSTiAqLyxcbiAgICAgIFwiUmVjZWl2ZWQgbm8gcG9uZyBmcm9tIHNlcnZlciwgYXNzdW1lIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcy5cIlxuICAgIClcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suKlwiLCB7XG4gICAgLy8gV2hlbiBhIHNvY2tldCByZWNlaXZlcyBhbiBlcnJvciwgdGhpcyBjYW4gY2F1c2UgdGhlIGNsb3Npbmcgb2YgdGhlXG4gICAgLy8gc29ja2V0LCBvciBub3QuIFNvIGFsd2F5cyBjaGVjayB0byBzZWUgaWYgdGhlIHNvY2tldCBpcyBzdGlsbCBPUEVOIG9yXG4gICAgLy8gbm90LiBXaGVuIHN0aWxsIE9QRU4sIGRvbid0IHRyYW5zaXRpb24uXG4gICAgRVhQTElDSVRfU09DS0VUX0VSUk9SOiAoXywgY29udGV4dCkgPT4ge1xuICAgICAgaWYgKGNvbnRleHQuc29ja2V0Py5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBpbmNyZWFzZUJhY2tvZmZEZWxheVxuICAgICAgfTtcbiAgICB9LFxuICAgIEVYUExJQ0lUX1NPQ0tFVF9DTE9TRTogKGUpID0+IHtcbiAgICAgIGlmIChzaG91bGREaXNjb25uZWN0KGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2dQZXJtYW5lbnRDbG9zZSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGUuZXZlbnQucmVhc29uLCBlLmV2ZW50LmNvZGUpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIGlmIChlLmV2ZW50LmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICAgIGNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gICAgY29uc3Qgcm9vdCA9IHdpbiA/PyBkb2M7XG4gICAgbWFjaGluZS5vbkVudGVyKFwiKlwiLCAoY3R4KSA9PiB7XG4gICAgICBmdW5jdGlvbiBvbk5ldHdvcmtPZmZsaW5lKCkge1xuICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIk5BVklHQVRPUl9PRkZMSU5FXCIgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvbk5ldHdvcmtCYWNrT25saW5lKCkge1xuICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIk5BVklHQVRPUl9PTkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikge1xuICAgICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiV0lORE9XX0dPVF9GT0NVU1wiIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25OZXR3b3JrQmFja09ubGluZSk7XG4gICAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgcm9vdD8uYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJvb3Q/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICAgIHdpbj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvbk5ldHdvcmtPZmZsaW5lKTtcbiAgICAgICAgdGVhcmRvd25Tb2NrZXQoY3R4LnNvY2tldCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGNsZWFudXBzID0gW107XG4gIGNvbnN0IHsgc3RhdHVzRGlkQ2hhbmdlLCBkaWRDb25uZWN0LCBkaWREaXNjb25uZWN0LCB1bnN1YnNjcmliZSB9ID0gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpO1xuICBjbGVhbnVwcy5wdXNoKHVuc3Vic2NyaWJlKTtcbiAgaWYgKG9wdGlvbnMuZW5hYmxlRGVidWdMb2dnaW5nKSB7XG4gICAgY2xlYW51cHMucHVzaChlbmFibGVUcmFjaW5nKG1hY2hpbmUpKTtcbiAgfVxuICBtYWNoaW5lLnN0YXJ0KCk7XG4gIHJldHVybiB7XG4gICAgbWFjaGluZSxcbiAgICBjbGVhbnVwcyxcbiAgICAvLyBPYnNlcnZhYmxlIGV2ZW50cyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGlzIG1hY2hpbmVcbiAgICBldmVudHM6IHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZSxcbiAgICAgIGRpZENvbm5lY3QsXG4gICAgICBkaWREaXNjb25uZWN0LFxuICAgICAgb25NZXNzYWdlOiBvbk1lc3NhZ2Uub2JzZXJ2YWJsZSxcbiAgICAgIG9uQ29ubmVjdGlvbkVycm9yOiBvbkNvbm5lY3Rpb25FcnJvci5vYnNlcnZhYmxlXG4gICAgfVxuICB9O1xufVxudmFyIE1hbmFnZWRTb2NrZXQgPSBjbGFzcyB7XG4gICNtYWNoaW5lO1xuICAjY2xlYW51cHM7XG4gIGV2ZW50cztcbiAgY29uc3RydWN0b3IoZGVsZWdhdGVzLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgPSBmYWxzZSwgd2FpdEZvckFjdG9ySWQgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBtYWNoaW5lLCBldmVudHMsIGNsZWFudXBzIH0gPSBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKFxuICAgICAgZGVsZWdhdGVzLFxuICAgICAgeyB3YWl0Rm9yQWN0b3JJZCwgZW5hYmxlRGVidWdMb2dnaW5nIH1cbiAgICApO1xuICAgIHRoaXMuI21hY2hpbmUgPSBtYWNoaW5lO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMuI2NsZWFudXBzID0gY2xlYW51cHM7XG4gIH1cbiAgZ2V0U3RhdHVzKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdG9OZXdDb25uZWN0aW9uU3RhdHVzKHRoaXMuI21hY2hpbmUpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIFwiaW5pdGlhbFwiO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBhdXRoIGF1dGhWYWx1ZS5cbiAgICovXG4gIGdldCBhdXRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hY2hpbmUuY29udGV4dC5hdXRoVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyBtZXRob2QgdG8gdHJ5IHRvIGNvbm5lY3QgdG8gYSBXZWJTb2NrZXQuIFRoaXMgb25seSBoYXMgYW4gZWZmZWN0XG4gICAqIGlmIHRoZSBtYWNoaW5lIGlzIGlkbGUgYXQgdGhlIG1vbWVudCwgb3RoZXJ3aXNlIHRoaXMgaXMgYSBuby1vcC5cbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgdGhpcy4jbWFjaGluZS5zZW5kKHsgdHlwZTogXCJDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIGlkbGUsIHdpbGwgdHJ5IHRvIGNvbm5lY3QuIE90aGVyd2lzZSwgaXQgd2lsbCBhdHRlbXB0IHRvIHJlY29ubmVjdCB0b1xuICAgKiB0aGUgc29ja2V0LCBwb3RlbnRpYWxseSBvYnRhaW5pbmcgYSBuZXcgYXV0aFZhbHVlIGZpcnN0LCBpZiBuZWVkZWQuXG4gICAqL1xuICByZWNvbm5lY3QoKSB7XG4gICAgdGhpcy4jbWFjaGluZS5zZW5kKHsgdHlwZTogXCJSRUNPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byBkaXNjb25uZWN0IGZyb20gdGhlIGN1cnJlbnQgV2ViU29ja2V0LiBJcyBnb2luZyB0byBiZVxuICAgKiBhIG5vLW9wIGlmIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb25uZWN0aW9uLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLiNtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkRJU0NPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIHN0b3AgdGhlIG1hY2hpbmUgYW5kIHJ1biBuZWNlc3NhcnkgY2xlYW51cCBmdW5jdGlvbnMuIEFmdGVyXG4gICAqIGNhbGxpbmcgZGVzdHJveSgpLCB5b3UgY2FuIG5vIGxvbmdlciB1c2UgdGhpcyBpbnN0YW5jZS4gQ2FsbCB0aGlzIGJlZm9yZVxuICAgKiBsZXR0aW5nIHRoZSBpbnN0YW5jZSBnZXQgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI21hY2hpbmUuc3RvcCgpO1xuICAgIGxldCBjbGVhbnVwO1xuICAgIHdoaWxlIChjbGVhbnVwID0gdGhpcy4jY2xlYW51cHMucG9wKCkpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNhZmVseSBzZW5kIGEgbWVzc2FnZSB0byB0aGUgY3VycmVudCBXZWJTb2NrZXQgY29ubmVjdGlvbi4gV2lsbCBlbWl0IGEgbG9nXG4gICAqIG1lc3NhZ2UgaWYgdGhpcyBpcyBzb21laG93IGltcG9zc2libGUuXG4gICAqL1xuICBzZW5kKGRhdGEpIHtcbiAgICBjb25zdCBzb2NrZXQgPSB0aGlzLiNtYWNoaW5lLmNvbnRleHQ/LnNvY2tldDtcbiAgICBpZiAoc29ja2V0ID09PSBudWxsKSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHNlbmQ6IG5vdCBjb25uZWN0ZWQgeWV0XCIsIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IDEpIHtcbiAgICAgIHdhcm4oXCJDYW5ub3Qgc2VuZDogV2ViU29ja2V0IG5vIGxvbmdlciBvcGVuXCIsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQuc2VuZChkYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE5PVEU6IFVzZWQgYnkgdGhlIEUyRSBhcHAgb25seSwgdG8gc2ltdWxhdGUgZXhwbGljaXQgZXZlbnRzLlxuICAgKiBOb3QgaWRlYWwgdG8ga2VlcCBleHBvc2VkIDooXG4gICAqL1xuICBfcHJpdmF0ZVNlbmRNYWNoaW5lRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLiNtYWNoaW5lLnNlbmQoZXZlbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvQXV0aFRva2VuLnRzXG52YXIgUGVybWlzc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKFBlcm1pc3Npb24yKSA9PiB7XG4gIFBlcm1pc3Npb24yW1wiUmVhZFwiXSA9IFwicm9vbTpyZWFkXCI7XG4gIFBlcm1pc3Npb24yW1wiV3JpdGVcIl0gPSBcInJvb206d3JpdGVcIjtcbiAgUGVybWlzc2lvbjJbXCJQcmVzZW5jZVdyaXRlXCJdID0gXCJyb29tOnByZXNlbmNlOndyaXRlXCI7XG4gIFBlcm1pc3Npb24yW1wiQ29tbWVudHNXcml0ZVwiXSA9IFwiY29tbWVudHM6d3JpdGVcIjtcbiAgUGVybWlzc2lvbjJbXCJDb21tZW50c1JlYWRcIl0gPSBcImNvbW1lbnRzOnJlYWRcIjtcbiAgcmV0dXJuIFBlcm1pc3Npb24yO1xufSkoUGVybWlzc2lvbiB8fCB7fSk7XG5mdW5jdGlvbiBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gY2FuQ29tbWVudChzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOndyaXRlXCIgLyogQ29tbWVudHNXcml0ZSAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkKGRhdGEpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoZGF0YSkgJiYgKGRhdGEuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcImlkXCIgLyogSURfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXV0aFRva2VuKHJhd1Rva2VuU3RyaW5nKSB7XG4gIGNvbnN0IHRva2VuUGFydHMgPSByYXdUb2tlblN0cmluZy5zcGxpdChcIi5cIik7XG4gIGlmICh0b2tlblBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBpbnZhbGlkIEpXVCB0b2tlblwiKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gdHJ5UGFyc2VKc29uKGI2NGRlY29kZSh0b2tlblBhcnRzWzFdKSk7XG4gIGlmICghKHBheWxvYWQgJiYgaXNWYWxpZEF1dGhUb2tlblBheWxvYWQocGF5bG9hZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBdXRoZW50aWNhdGlvbiBlcnJvcjogZXhwZWN0ZWQgYSB2YWxpZCB0b2tlbiBidXQgZGlkIG5vdCBnZXQgb25lLiBIaW50OiBpZiB5b3UgYXJlIHVzaW5nIGEgY2FsbGJhY2ssIGVuc3VyZSB0aGUgcm9vbSBpcyBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgdG9rZW4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudENhbGxiYWNrXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmF3OiByYXdUb2tlblN0cmluZyxcbiAgICBwYXJzZWQ6IHBheWxvYWRcbiAgfTtcbn1cblxuLy8gc3JjL2F1dGgtbWFuYWdlci50c1xuZnVuY3Rpb24gY3JlYXRlQXV0aE1hbmFnZXIoYXV0aE9wdGlvbnMsIG9uQXV0aGVudGljYXRlKSB7XG4gIGNvbnN0IGF1dGhlbnRpY2F0aW9uID0gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKTtcbiAgY29uc3Qgc2VlblRva2VucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBjb25zdCBleHBpcnlUaW1lcyA9IFtdO1xuICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBzZWVuVG9rZW5zLmNsZWFyKCk7XG4gICAgdG9rZW5zLmxlbmd0aCA9IDA7XG4gICAgZXhwaXJ5VGltZXMubGVuZ3RoID0gMDtcbiAgICByZXF1ZXN0UHJvbWlzZXMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RlZFNjb3BlLCBzY29wZXMpIHtcbiAgICBpZiAocmVxdWVzdGVkU2NvcGUgPT09IFwiY29tbWVudHM6cmVhZFwiKSB7XG4gICAgICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6cmVhZFwiIC8qIENvbW1lbnRzUmVhZCAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6d3JpdGVcIiAvKiBDb21tZW50c1dyaXRlICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOnJlYWRcIiAvKiBSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdGVkU2NvcGUgPT09IFwicm9vbTpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOnJlYWRcIiAvKiBSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdE9wdGlvbnMpIHtcbiAgICBjb25zdCBub3cgPSBNYXRoLmNlaWwoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgZm9yIChsZXQgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBleHBpcnlUaW1lc1tpXTtcbiAgICAgIGlmIChleHBpcmVzQXQgPD0gbm93KSB7XG4gICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGV4cGlyeVRpbWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiaWRcIiAvKiBJRF9UT0tFTiAqLykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnBhcnNlZC5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLykge1xuICAgICAgICBpZiAoIXJlcXVlc3RPcHRpb25zLnJvb21JZCAmJiBPYmplY3QuZW50cmllcyh0b2tlbi5wYXJzZWQucGVybXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtyZXNvdXJjZSwgc2NvcGVzXSBvZiBPYmplY3QuZW50cmllcyh0b2tlbi5wYXJzZWQucGVybXMpKSB7XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZS5pbmNsdWRlcyhcIipcIikgJiYgaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhyZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0ZWRTY29wZSwgc2NvcGVzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZS5pbmNsdWRlcyhcIipcIikgJiYgcmVxdWVzdE9wdGlvbnMucm9vbUlkLnN0YXJ0c1dpdGgocmVzb3VyY2UucmVwbGFjZShcIipcIiwgXCJcIikpIHx8IHJlcXVlc3RPcHRpb25zLnJvb21JZCA9PT0gcmVzb3VyY2UgJiYgaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhyZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0ZWRTY29wZSwgc2NvcGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1ha2VBdXRoUmVxdWVzdChvcHRpb25zKSB7XG4gICAgY29uc3QgZmV0Y2hlciA9IGF1dGhPcHRpb25zLnBvbHlmaWxscz8uZmV0Y2ggPz8gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiB3aW5kb3cuZmV0Y2gpO1xuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcInByaXZhdGVcIikge1xuICAgICAgaWYgKGZldGNoZXIgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCB3aXRoIGEgdXJsIGFzIGF1dGggZW5kcG9pbnQsIHlvdSBuZWVkIHRvIHByb3ZpZGUgYSBmZXRjaCBwb2x5ZmlsbC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEF1dGhFbmRwb2ludChmZXRjaGVyLCBhdXRoZW50aWNhdGlvbi51cmwsIHtcbiAgICAgICAgcm9vbTogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VBdXRoVG9rZW4ocmVzcG9uc2UudG9rZW4pO1xuICAgICAgaWYgKHNlZW5Ub2tlbnMuaGFzKHBhcnNlZC5yYXcpKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUaGUgc2FtZSBMaXZlYmxvY2tzIGF1dGggdG9rZW4gd2FzIGlzc3VlZCBmcm9tIHRoZSBiYWNrZW5kIGJlZm9yZS4gQ2FjaGluZyBMaXZlYmxvY2tzIHRva2VucyBpcyBub3Qgc3VwcG9ydGVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBvbkF1dGhlbnRpY2F0ZT8uKHBhcnNlZC5wYXJzZWQpO1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRpb24uY2FsbGJhY2sob3B0aW9ucy5yb29tSWQpO1xuICAgICAgaWYgKHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VBdXRoVG9rZW4ocmVzcG9uc2UudG9rZW4pO1xuICAgICAgICAgIG9uQXV0aGVudGljYXRlPy4ocGFyc2VkLnBhcnNlZCk7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2UuZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke1wicmVhc29uXCIgaW4gcmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlLnJlYXNvbiA9PT0gXCJzdHJpbmdcIiA/IHJlc3BvbnNlLnJlYXNvbiA6IFwiRm9yYmlkZGVuXCJ9YDtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IgPT09IFwiZm9yYmlkZGVuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcocmVhc29uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdZb3VyIGF1dGhlbnRpY2F0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSB0b2tlbiwgYnV0IGl0IGRpZCBub3QuIEhpbnQ6IHRoZSByZXR1cm4gdmFsdWUgc2hvdWxkIGxvb2sgbGlrZTogeyB0b2tlbjogXCIuLi5cIiB9J1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJVbmV4cGVjdGVkIGF1dGhlbnRpY2F0aW9uIHR5cGUuIE11c3QgYmUgcHJpdmF0ZSBvciBjdXN0b20uXCJcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEF1dGhWYWx1ZShyZXF1ZXN0T3B0aW9ucykge1xuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInB1YmxpY1wiLCBwdWJsaWNBcGlLZXk6IGF1dGhlbnRpY2F0aW9uLnB1YmxpY0FwaUtleSB9O1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRUb2tlbiA9IGdldENhY2hlZFRva2VuKHJlcXVlc3RPcHRpb25zKTtcbiAgICBpZiAoY2FjaGVkVG9rZW4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW46IGNhY2hlZFRva2VuIH07XG4gICAgfVxuICAgIGxldCBjdXJyZW50UHJvbWlzZTtcbiAgICBpZiAocmVxdWVzdE9wdGlvbnMucm9vbUlkKSB7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlcy5nZXQocmVxdWVzdE9wdGlvbnMucm9vbUlkKTtcbiAgICAgIGlmIChjdXJyZW50UHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGN1cnJlbnRQcm9taXNlID0gbWFrZUF1dGhSZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLnNldChyZXF1ZXN0T3B0aW9ucy5yb29tSWQsIGN1cnJlbnRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXF1ZXN0UHJvbWlzZXMuZ2V0KFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIpO1xuICAgICAgaWYgKGN1cnJlbnRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgY3VycmVudFByb21pc2UgPSBtYWtlQXV0aFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuc2V0KFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIsIGN1cnJlbnRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgY3VycmVudFByb21pc2U7XG4gICAgICBjb25zdCBCVUZGRVIgPSAzMDtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMykgKyAodG9rZW4ucGFyc2VkLmV4cCAtIHRva2VuLnBhcnNlZC5pYXQpIC0gQlVGRkVSO1xuICAgICAgc2VlblRva2Vucy5hZGQodG9rZW4ucmF3KTtcbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayAhPT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLykge1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGV4cGlyeVRpbWVzLnB1c2goZXhwaXJlc0F0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6IFwic2VjcmV0XCIsIHRva2VuIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLmRlbGV0ZShyZXF1ZXN0T3B0aW9ucy5yb29tSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLmRlbGV0ZShcImxpdmVibG9ja3MtdXNlci10b2tlblwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNldCxcbiAgICBnZXRBdXRoVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVBdXRoZW50aWNhdGlvbihhdXRoT3B0aW9ucykge1xuICBjb25zdCB7IHB1YmxpY0FwaUtleSwgYXV0aEVuZHBvaW50IH0gPSBhdXRoT3B0aW9ucztcbiAgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwICYmIHB1YmxpY0FwaUtleSAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2Fubm90IHNpbXVsdGFuZW91c2x5IHVzZSBgcHVibGljQXBpS2V5YCBhbmQgYGF1dGhFbmRwb2ludGAgb3B0aW9ucy4gUGxlYXNlIHBpY2sgb25lIGFuZCBsZWF2ZSB0aGUgb3RoZXIgb3B0aW9uIHVuc3BlY2lmaWVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwdWJsaWNBcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAocHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJza19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGBwdWJsaWNBcGlLZXlgIG9wdGlvbi4gVGhlIHZhbHVlIHlvdSBwYXNzZWQgaXMgYSBzZWNyZXQga2V5LCB3aGljaCBzaG91bGQgbm90IGJlIHVzZWQgZnJvbSB0aGUgY2xpZW50LiBQbGVhc2Ugb25seSBldmVyIHBhc3MgYSBwdWJsaWMga2V5IGhlcmUuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFB1YmxpY0tleVwiXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIXB1YmxpY0FwaUtleS5zdGFydHNXaXRoKFwicGtfXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBrZXkuIFBsZWFzZSB1c2UgdGhlIHB1YmxpYyBrZXkgZm9ybWF0OiBwa188cHVibGljIGtleT4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFB1YmxpY0tleVwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwdWJsaWNcIixcbiAgICAgIHB1YmxpY0FwaUtleVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBhdXRoRW5kcG9pbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwcml2YXRlXCIsXG4gICAgICB1cmw6IGF1dGhFbmRwb2ludFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgICBjYWxsYmFjazogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhdXRoRW5kcG9pbnQgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIGBhdXRoRW5kcG9pbnRgIG9wdGlvbiBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudEF1dGhFbmRwb2ludFwiXG4gICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJJbnZhbGlkIExpdmVibG9ja3MgY2xpZW50IG9wdGlvbnMuIFBsZWFzZSBwcm92aWRlIGVpdGhlciBhIGBwdWJsaWNBcGlLZXlgIG9yIGBhdXRoRW5kcG9pbnRgIG9wdGlvbi4gVGhleSBjYW5ub3QgYm90aCBiZSBlbXB0eS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50XCJcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQXV0aEVuZHBvaW50KGZldGNoLCBlbmRwb2ludCwgYm9keSkge1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9LFxuICAgIGJvZHk6IHN0cmluZ2lmeU9yTG9nKGJvZHkpXG4gIH0pO1xuICBpZiAoIXJlcy5vaykge1xuICAgIGNvbnN0IHJlYXNvbiA9IGAkeyhhd2FpdCByZXMudGV4dCgpKS50cmltKCkgfHwgXCJyZWFzb24gbm90IHByb3ZpZGVkIGluIGF1dGggcmVzcG9uc2VcIn0gKCR7cmVzLnN0YXR1c30gcmV0dXJuZWQgYnkgUE9TVCAke2VuZHBvaW50fSlgO1xuICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEgfHwgcmVzLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKGBVbmF1dGhvcml6ZWQ6ICR7cmVhc29ufWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhdXRoZW50aWNhdGU6ICR7cmVhc29ufWApO1xuICAgIH1cbiAgfVxuICBsZXQgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIHdoZW4gZG9pbmcgYSBQT1NUIHJlcXVlc3Qgb24gXCIke2VuZHBvaW50fVwiLiAke1N0cmluZyhcbiAgICAgICAgZXJcbiAgICAgICl9YFxuICAgICk7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpIHx8IHR5cGVvZiBkYXRhLnRva2VuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgSlNPTiByZXNwb25zZSBvZiB0aGUgZm9ybSBcXGB7IHRva2VuOiBcIi4uLlwiIH1cXGAgd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIsIGJ1dCBnb3QgJHtzdHJpbmdpZnlPckxvZyhcbiAgICAgICAgZGF0YVxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7IHRva2VuIH0gPSBkYXRhO1xuICByZXR1cm4geyB0b2tlbiB9O1xufVxuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgREVGQVVMVF9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9hcGkubGl2ZWJsb2Nrcy5pb1wiO1xuXG4vLyBzcmMvaW50ZXJuYWwudHNcbnZhciBrSW50ZXJuYWwgPSBTeW1ib2woKTtcblxuLy8gc3JjL2RldnRvb2xzL2JyaWRnZS50c1xudmFyIF9icmlkZ2VBY3RpdmUgPSBmYWxzZTtcbmZ1bmN0aW9uIGFjdGl2YXRlQnJpZGdlKGFsbG93ZWQpIHtcbiAgX2JyaWRnZUFjdGl2ZSA9IGFsbG93ZWQ7XG59XG5mdW5jdGlvbiBzZW5kVG9QYW5lbChtZXNzYWdlLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmdWxsTXNnID0ge1xuICAgIC4uLm1lc3NhZ2UsXG4gICAgc291cmNlOiBcImxpdmVibG9ja3MtZGV2dG9vbHMtY2xpZW50XCJcbiAgfTtcbiAgaWYgKCEob3B0aW9ucz8uZm9yY2UgfHwgX2JyaWRnZUFjdGl2ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LnBvc3RNZXNzYWdlKGZ1bGxNc2csIFwiKlwiKTtcbn1cbnZhciBldmVudFNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQuc291cmNlID09PSB3aW5kb3cgJiYgZXZlbnQuZGF0YT8uc291cmNlID09PSBcImxpdmVibG9ja3MtZGV2dG9vbHMtcGFuZWxcIikge1xuICAgICAgZXZlbnRTb3VyY2Uubm90aWZ5KGV2ZW50LmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgfVxuICB9KTtcbn1cbnZhciBvbk1lc3NhZ2VGcm9tUGFuZWwgPSBldmVudFNvdXJjZS5vYnNlcnZhYmxlO1xuXG4vLyBzcmMvZGV2dG9vbHMvaW5kZXgudHNcbnZhciBWRVJTSU9OID0gUEtHX1ZFUlNJT04gfHwgXCJkZXZcIjtcbnZhciBfZGV2dG9vbHNTZXR1cEhhc1J1biA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBEZXZUb29scyhnZXRBbGxSb29tcykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKF9kZXZ0b29sc1NldHVwSGFzUnVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gdHJ1ZTtcbiAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgc3dpdGNoIChtc2cubXNnKSB7XG4gICAgICAvLyBXaGVuIGEgZGV2dG9vbCBwYW5lbCBzZW5kcyBhbiBleHBsaWNpdCBcImNvbm5lY3RcIiBtZXNzYWdlIGJhY2sgdG8gdGhpc1xuICAgICAgLy8gbGl2ZSBydW5uaW5nIGNsaWVudCAoaW4gcmVzcG9uc2UgdG8gdGhlIFwid2FrZS11cC1kZXZ0b29sc1wiIG1lc3NhZ2UsXG4gICAgICAvLyBvciB3aGVuIHRoZSBkZXZ0b29sIHBhbmVsIGlzIG9wZW5lZCBmb3IgdGhlIGZpcnN0IHRpbWUpLCBpdCBtZWFucyB0aGF0IGl0J3Mgb2theSB0b1xuICAgICAgLy8gc3RhcnQgZW1pdHRpbmcgbWVzc2FnZXMuXG4gICAgICAvLyBCZWZvcmUgdGhpcyBleHBsaWNpdCBhY2tub3dsZWRnZW1lbnQsIGFueSBjYWxsIHRvIHNlbmRUb1BhbmVsKCkgd2lsbFxuICAgICAgLy8gYmUgYSBuby1vcC5cbiAgICAgIGNhc2UgXCJjb25uZWN0XCI6IHtcbiAgICAgICAgYWN0aXZhdGVCcmlkZ2UodHJ1ZSk7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbUlkIG9mIGdldEFsbFJvb21zKCkpIHtcbiAgICAgICAgICBzZW5kVG9QYW5lbCh7XG4gICAgICAgICAgICBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICBjbGllbnRWZXJzaW9uOiBWRVJTSU9OXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwid2FrZS11cC1kZXZ0b29sc1wiIH0sIHsgZm9yY2U6IHRydWUgfSk7XG59XG52YXIgdW5zdWJzQnlSb29tSWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFN5bmNTdHJlYW0ocm9vbUlkKSB7XG4gIGNvbnN0IHVuc3VicyA9IHVuc3Vic0J5Um9vbUlkLmdldChyb29tSWQpID8/IFtdO1xuICB1bnN1YnNCeVJvb21JZC5kZWxldGUocm9vbUlkKTtcbiAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICB1bnN1YigpO1xuICB9XG59XG5mdW5jdGlvbiBzdGFydFN5bmNTdHJlYW0ocm9vbSkge1xuICBzdG9wU3luY1N0cmVhbShyb29tLmlkKTtcbiAgZnVsbFN5bmMocm9vbSk7XG4gIHVuc3Vic0J5Um9vbUlkLnNldChyb29tLmlkLCBbXG4gICAgLy8gV2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlc1xuICAgIHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pKSxcbiAgICAvLyBXaGVuIHN0b3JhZ2UgaW5pdGlhbGl6ZXMsIHNlbmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2UoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBzdG9yYWdlIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyBzdG9yYWdlIHJvb3RcbiAgICByb29tLmV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSksXG4gICAgLy8gQW55IHRpbWUgXCJtZVwiIG9yIFwib3RoZXJzXCIgdXBkYXRlcywgc2VuZCB0aGUgbmV3IHZhbHVlcyBhY2NvcmRpbmdseVxuICAgIHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jTWUocm9vbSkpLFxuICAgIHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNPdGhlcnMocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIHlkb2MgaXMgdXBkYXRlZCwgZm9yd2FyZCB0aGUgdXBkYXRlXG4gICAgcm9vbS5ldmVudHMueWRvYy5zdWJzY3JpYmUoKHVwZGF0ZSkgPT4gc3luY1lkb2NVcGRhdGUocm9vbSwgdXBkYXRlKSksXG4gICAgLy8gQW55IHRpbWUgYSBjdXN0b20gcm9vbSBldmVudCBpcyByZWNlaXZlZCwgZm9yd2FyZCBpdFxuICAgIHJvb20uZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgIChldmVudERhdGEpID0+IGZvcndhcmRFdmVudChyb29tLCBldmVudERhdGEpXG4gICAgKVxuICBdKTtcbn1cbmZ1bmN0aW9uIHN5bmNZZG9jVXBkYXRlKHJvb20sIHVwZGF0ZSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6Onlkb2NcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgdXBkYXRlXG4gIH0pO1xufVxudmFyIGxvYWRlZEF0ID0gRGF0ZS5ub3coKTtcbnZhciBldmVudENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gbmV4dEV2ZW50SWQoKSB7XG4gIHJldHVybiBgZXZlbnQtJHtsb2FkZWRBdH0tJHtldmVudENvdW50ZXIrK31gO1xufVxuZnVuY3Rpb24gZm9yd2FyZEV2ZW50KHJvb20sIGV2ZW50RGF0YSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OmV2ZW50czo6Y3VzdG9tLWV2ZW50XCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBcIkN1c3RvbUV2ZW50XCIsXG4gICAgICBpZDogbmV4dEV2ZW50SWQoKSxcbiAgICAgIGtleTogXCJFdmVudFwiLFxuICAgICAgY29ubmVjdGlvbklkOiBldmVudERhdGEuY29ubmVjdGlvbklkLFxuICAgICAgcGF5bG9hZDogZXZlbnREYXRhLmV2ZW50XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jQ29ubmVjdGlvbihyb29tKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBzdGF0dXM6IHJvb20uZ2V0U3RhdHVzKClcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkge1xuICBjb25zdCByb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgaWYgKHJvb3QpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgc3RvcmFnZTogcm9vdC50b1RyZWVOb2RlKFwicm9vdFwiKS5wYXlsb2FkXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jTWUocm9vbSkge1xuICBjb25zdCBtZSA9IHJvb21ba0ludGVybmFsXS5nZXRTZWxmX2ZvckRldlRvb2xzKCk7XG4gIGlmIChtZSkge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBtZVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY090aGVycyhyb29tKSB7XG4gIGNvbnN0IG90aGVycyA9IHJvb21ba0ludGVybmFsXS5nZXRPdGhlcnNfZm9yRGV2VG9vbHMoKTtcbiAgaWYgKG90aGVycykge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBvdGhlcnNcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZnVsbFN5bmMocm9vbSkge1xuICBjb25zdCByb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgY29uc3QgbWUgPSByb29tW2tJbnRlcm5hbF0uZ2V0U2VsZl9mb3JEZXZUb29scygpO1xuICBjb25zdCBvdGhlcnMgPSByb29tW2tJbnRlcm5hbF0uZ2V0T3RoZXJzX2ZvckRldlRvb2xzKCk7XG4gIHJvb20uZmV0Y2hZRG9jKFwiXCIpO1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6OmZ1bGxcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgc3RhdHVzOiByb29tLmdldFN0YXR1cygpLFxuICAgIHN0b3JhZ2U6IHJvb3Q/LnRvVHJlZU5vZGUoXCJyb290XCIpLnBheWxvYWQgPz8gbnVsbCxcbiAgICBtZSxcbiAgICBvdGhlcnNcbiAgfSk7XG59XG52YXIgcm9vbUNoYW5uZWxMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKSB7XG4gIGNvbnN0IGxpc3RlbmVyID0gcm9vbUNoYW5uZWxMaXN0ZW5lcnMuZ2V0KHJvb21JZCk7XG4gIHJvb21DaGFubmVsTGlzdGVuZXJzLmRlbGV0ZShyb29tSWQpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcigpO1xuICB9XG59XG5mdW5jdGlvbiBsaW5rRGV2VG9vbHMocm9vbUlkLCByb29tKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBzZW5kVG9QYW5lbCh7IG1zZzogXCJyb29tOjphdmFpbGFibGVcIiwgcm9vbUlkLCBjbGllbnRWZXJzaW9uOiBWRVJTSU9OIH0pO1xuICBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpO1xuICByb29tQ2hhbm5lbExpc3RlbmVycy5zZXQoXG4gICAgcm9vbUlkLFxuICAgIC8vIFJldHVybnMgdGhlIHVuc3Vic2NyaWJlIGNhbGxiYWNrLCB0aGF0IHdlIHN0b3JlIGluIHRoZVxuICAgIC8vIHJvb21DaGFubmVsTGlzdGVuZXJzIHJlZ2lzdHJ5XG4gICAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgICAgLy8gU2VudCBieSB0aGUgZGV2dG9vbCBwYW5lbCB3aGVuIGl0IHdhbnRzIHRvIHJlY2VpdmUgdGhlIHN5bmMgc3RyZWFtXG4gICAgICAgIC8vIGZvciBhIHJvb21cbiAgICAgICAgY2FzZSBcInJvb206OnN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgaWYgKG1zZy5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgc3RhcnRTeW5jU3RyZWFtKHJvb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicm9vbTo6dW5zdWJzY3JpYmVcIjoge1xuICAgICAgICAgIGlmIChtc2cucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgIHN0b3BTeW5jU3RyZWFtKHJvb21JZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHVubGlua0RldlRvb2xzKHJvb21JZCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RvcFN5bmNTdHJlYW0ocm9vbUlkKTtcbiAgc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKTtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjp1bmF2YWlsYWJsZVwiLFxuICAgIHJvb21JZFxuICB9KTtcbn1cblxuLy8gc3JjL2xpYi9wb3NpdGlvbi50c1xudmFyIE1JTl9DT0RFID0gMzI7XG52YXIgTUFYX0NPREUgPSAxMjY7XG52YXIgTlVNX0RJR0lUUyA9IE1BWF9DT0RFIC0gTUlOX0NPREUgKyAxO1xudmFyIFpFUk8gPSBudGhEaWdpdCgwKTtcbnZhciBPTkUgPSBudGhEaWdpdCgxKTtcbnZhciBaRVJPX05JTkUgPSBaRVJPICsgbnRoRGlnaXQoLTEpO1xuZnVuY3Rpb24gbnRoRGlnaXQobikge1xuICBjb25zdCBjb2RlID0gTUlOX0NPREUgKyAobiA8IDAgPyBOVU1fRElHSVRTICsgbiA6IG4pO1xuICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuIHZhbHVlOiAke259YCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5mdW5jdGlvbiBtYWtlUG9zaXRpb24oeCwgeSkge1xuICBpZiAoeCAhPT0gdm9pZCAwICYmIHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZXR3ZWVuKHgsIHkpO1xuICB9IGVsc2UgaWYgKHggIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBhZnRlcih4KTtcbiAgfSBlbHNlIGlmICh5ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmVmb3JlKHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPTkU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJlZm9yZShwb3MpIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gcG9zLmxlbmd0aCAtIDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDw9IE1JTl9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IGxhc3RJbmRleCkge1xuICAgICAgaWYgKGNvZGUgPT09IE1JTl9DT0RFICsgMSkge1xuICAgICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFpFUk9fTklORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkgKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9ORTtcbn1cbmZ1bmN0aW9uIGFmdGVyKHBvcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwb3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IE1BWF9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAxKTtcbiAgfVxuICByZXR1cm4gcG9zICsgT05FO1xufVxuZnVuY3Rpb24gYmV0d2VlbihsbywgaGkpIHtcbiAgaWYgKGxvIDwgaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4obG8sIGhpKTtcbiAgfSBlbHNlIGlmIChsbyA+IGhpKSB7XG4gICAgcmV0dXJuIF9iZXR3ZWVuKGhpLCBsbyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgdmFsdWUgYmV0d2VlbiB0d28gZXF1YWwgcG9zaXRpb25zXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfYmV0d2VlbihsbywgaGkpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbG9MZW4gPSBsby5sZW5ndGg7XG4gIGNvbnN0IGhpTGVuID0gaGkubGVuZ3RoO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGxvQ29kZSA9IGluZGV4IDwgbG9MZW4gPyBsby5jaGFyQ29kZUF0KGluZGV4KSA6IE1JTl9DT0RFO1xuICAgIGNvbnN0IGhpQ29kZSA9IGluZGV4IDwgaGlMZW4gPyBoaS5jaGFyQ29kZUF0KGluZGV4KSA6IE1BWF9DT0RFO1xuICAgIGlmIChsb0NvZGUgPT09IGhpQ29kZSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaGlDb2RlIC0gbG9Db2RlID09PSAxKSB7XG4gICAgICBjb25zdCBzaXplID0gaW5kZXggKyAxO1xuICAgICAgbGV0IHByZWZpeCA9IGxvLnN1YnN0cmluZygwLCBzaXplKTtcbiAgICAgIGlmIChwcmVmaXgubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBwcmVmaXggKz0gWkVSTy5yZXBlYXQoc2l6ZSAtIHByZWZpeC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VmZml4ID0gbG8uc3Vic3RyaW5nKHNpemUpO1xuICAgICAgY29uc3QgbmluZXMgPSBcIlwiO1xuICAgICAgcmV0dXJuIHByZWZpeCArIF9iZXR3ZWVuKHN1ZmZpeCwgbmluZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFrZU4obG8sIGluZGV4KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlDb2RlICsgbG9Db2RlID4+IDEpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGFrZU4ocG9zLCBuKSB7XG4gIHJldHVybiBuIDwgcG9zLmxlbmd0aCA/IHBvcy5zdWJzdHJpbmcoMCwgbikgOiBwb3MgKyBaRVJPLnJlcGVhdChuIC0gcG9zLmxlbmd0aCk7XG59XG52YXIgTUlOX05PTl9aRVJPX0NPREUgPSBNSU5fQ09ERSArIDE7XG5mdW5jdGlvbiBpc1BvcyhzdHIpIHtcbiAgaWYgKHN0ciA9PT0gXCJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0SWR4ID0gc3RyLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGxhc3QgPSBzdHIuY2hhckNvZGVBdChsYXN0SWR4KTtcbiAgaWYgKGxhc3QgPCBNSU5fTk9OX1pFUk9fQ09ERSB8fCBsYXN0ID4gTUFYX0NPREUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SWR4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCBNSU5fQ09ERSB8fCBjb2RlID4gTUFYX0NPREUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Qb3Moc3RyKSB7XG4gIGNvbnN0IGNvZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGNvZGVzLnB1c2goY29kZSA8IE1JTl9DT0RFID8gTUlOX0NPREUgOiBjb2RlID4gTUFYX0NPREUgPyBNQVhfQ09ERSA6IGNvZGUpO1xuICB9XG4gIHdoaWxlIChjb2Rlcy5sZW5ndGggPiAwICYmIGNvZGVzW2NvZGVzLmxlbmd0aCAtIDFdID09PSBNSU5fQ09ERSkge1xuICAgIGNvZGVzLmxlbmd0aC0tO1xuICB9XG4gIHJldHVybiBjb2Rlcy5sZW5ndGggPiAwID8gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5jb2RlcykgOiAoXG4gICAgLy8gRWRnZSBjYXNlOiB0aGUgc3RyIHdhcyBhIDAtb25seSBzdHJpbmcsIHdoaWNoIGlzIGludmFsaWQuIERlZmF1bHQgYmFjayB0byAuMVxuICAgIE9ORVxuICApO1xufVxuZnVuY3Rpb24gYXNQb3Moc3RyKSB7XG4gIHJldHVybiBpc1BvcyhzdHIpID8gc3RyIDogY29udmVydFRvUG9zKHN0cik7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9PcC50c1xudmFyIE9wQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE9wQ29kZTIpID0+IHtcbiAgT3BDb2RlMltPcENvZGUyW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlNFVF9QQVJFTlRfS0VZXCJdID0gMV0gPSBcIlNFVF9QQVJFTlRfS0VZXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9MSVNUXCJdID0gMl0gPSBcIkNSRUFURV9MSVNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlVQREFURV9PQkpFQ1RcIl0gPSAzXSA9IFwiVVBEQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfT0JKRUNUXCJdID0gNF0gPSBcIkNSRUFURV9PQkpFQ1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX0NSRFRcIl0gPSA1XSA9IFwiREVMRVRFX0NSRFRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX09CSkVDVF9LRVlcIl0gPSA2XSA9IFwiREVMRVRFX09CSkVDVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX01BUFwiXSA9IDddID0gXCJDUkVBVEVfTUFQXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9SRUdJU1RFUlwiXSA9IDhdID0gXCJDUkVBVEVfUkVHSVNURVJcIjtcbiAgcmV0dXJuIE9wQ29kZTI7XG59KShPcENvZGUgfHwge30pO1xuZnVuY3Rpb24gYWNrT3Aob3BJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgaWQ6IFwiQUNLXCIsXG4gICAgLy8gKEgpQUNLXG4gICAgb3BJZFxuICB9O1xufVxuZnVuY3Rpb24gaXNBY2tPcChvcCkge1xuICByZXR1cm4gb3AudHlwZSA9PT0gNSAvKiBERUxFVEVfQ1JEVCAqLyAmJiBvcC5pZCA9PT0gXCJBQ0tcIjtcbn1cblxuLy8gc3JjL2NyZHRzL0Fic3RyYWN0Q3JkdC50c1xuZnVuY3Rpb24gY3JkdEFzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gSGFzUGFyZW50KG5vZGUsIGtleSwgcG9zID0gYXNQb3Moa2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiSGFzUGFyZW50XCIsIG5vZGUsIGtleSwgcG9zIH0pO1xufVxudmFyIE5vUGFyZW50ID0gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiTm9QYXJlbnRcIiB9KTtcbmZ1bmN0aW9uIE9ycGhhbmVkKG9sZEtleSwgb2xkUG9zID0gYXNQb3Mob2xkS2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiT3JwaGFuZWRcIiwgb2xkS2V5LCBvbGRQb3MgfSk7XG59XG52YXIgQWJzdHJhY3RDcmR0ID0gY2xhc3Mge1xuICAvLyAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5eXiBUT0RPOiBNYWtlIHRoaXMgYW4gaW50ZXJmYWNlXG4gICNwb29sO1xuICAjaWQ7XG4gICNwYXJlbnQgPSBOb1BhcmVudDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0UGFyZW50S2V5T3JUaHJvdygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQga2V5IGlzIG1pc3NpbmdcIik7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZEtleTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50UG9zKCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zO1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkUG9zO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wb29sKCkge1xuICAgIHJldHVybiB0aGlzLiNwb29sO1xuICB9XG4gIGdldCByb29tSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvb2wgPyB0aGlzLiNwb29sLnJvb21JZCA6IG51bGw7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX2lkKCkge1xuICAgIHJldHVybiB0aGlzLiNpZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BhcmVudDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50S2V5KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRLZXk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIF9pc0xvY2FsKSB7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDUgLyogREVMRVRFX0NSRFQgKi86IHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZS5fZGV0YWNoQ2hpbGQoY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRQYXJlbnRMaW5rKG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQubm9kZSAhPT0gbmV3UGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcGFyZW50OiBub2RlIGFscmVhZHkgaGFzIGEgcGFyZW50XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI3BhcmVudCA9IEhhc1BhcmVudChuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLiNwYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIGlmICh0aGlzLiNpZCB8fCB0aGlzLiNwb29sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXR0YWNoIG5vZGU6IGFscmVhZHkgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIHBvb2wuYWRkTm9kZShpZCwgY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgIHRoaXMuI2lkID0gaWQ7XG4gICAgdGhpcy4jcG9vbCA9IHBvb2w7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIGlmICh0aGlzLiNwb29sICYmIHRoaXMuI2lkKSB7XG4gICAgICB0aGlzLiNwb29sLmRlbGV0ZU5vZGUodGhpcy4jaWQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjoge1xuICAgICAgICB0aGlzLiNwYXJlbnQgPSBPcnBoYW5lZCh0aGlzLnBhcmVudC5rZXksIHRoaXMucGFyZW50LnBvcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gTm9QYXJlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6IHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgICB0aGlzLiNwb29sID0gdm9pZCAwO1xuICB9XG4gIC8qKiBUaGlzIGNhY2hlcyB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IC50b0ltbXV0YWJsZSgpIGNhbGwgZm9yIHRoaXMgTGl2ZSBub2RlLiAqL1xuICAjY2FjaGVkSW1tdXRhYmxlO1xuICAjY2FjaGVkVHJlZU5vZGVLZXk7XG4gIC8qKiBUaGlzIGNhY2hlcyB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IC50b1RyZWVOb2RlKCkgY2FsbCBmb3IgdGhpcyBMaXZlIG5vZGUuICovXG4gICNjYWNoZWRUcmVlTm9kZTtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBDbGVhciB0aGUgSW1tdXRhYmxlIGNhY2hlLCBzbyB0aGF0IHRoZSBuZXh0IGNhbGwgdG8gYC50b0ltbXV0YWJsZSgpYCB3aWxsXG4gICAqIHJlY29tcHV0ZSB0aGUgZXF1aXZhbGVudCBJbW11dGFibGUgdmFsdWUgYWdhaW4uICBDYWxsIHRoaXMgYWZ0ZXIgZXZlcnlcbiAgICogbXV0YXRpb24gdG8gdGhlIExpdmUgbm9kZS5cbiAgICovXG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZEltbXV0YWJsZSAhPT0gdm9pZCAwIHx8IHRoaXMuI2NhY2hlZFRyZWVOb2RlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuI2NhY2hlZEltbXV0YWJsZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuI2NhY2hlZFRyZWVOb2RlID0gdm9pZCAwO1xuICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm9kZS5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogUmV0dXJuIGFuIHNuYXBzaG90IG9mIHRoaXMgTGl2ZSB0cmVlIGZvciB1c2UgaW4gRGV2VG9vbHMuXG4gICAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIGlmICh0aGlzLiNjYWNoZWRUcmVlTm9kZSA9PT0gdm9pZCAwIHx8IHRoaXMuI2NhY2hlZFRyZWVOb2RlS2V5ICE9PSBrZXkpIHtcbiAgICAgIHRoaXMuI2NhY2hlZFRyZWVOb2RlS2V5ID0ga2V5O1xuICAgICAgdGhpcy4jY2FjaGVkVHJlZU5vZGUgPSB0aGlzLl90b1RyZWVOb2RlKGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjYWNoZWRUcmVlTm9kZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIGltbXV0YWJsZSBzbmFwc2hvdCBvZiB0aGlzIExpdmUgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKi9cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZEltbXV0YWJsZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLiNjYWNoZWRJbW11dGFibGUgPSB0aGlzLl90b0ltbXV0YWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVkSW1tdXRhYmxlO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvU2VyaWFsaXplZENyZHQudHNcbnZhciBDcmR0VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENyZHRUeXBlMikgPT4ge1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiT0JKRUNUXCJdID0gMF0gPSBcIk9CSkVDVFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiTElTVFwiXSA9IDFdID0gXCJMSVNUXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJNQVBcIl0gPSAyXSA9IFwiTUFQXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJSRUdJU1RFUlwiXSA9IDNdID0gXCJSRUdJU1RFUlwiO1xuICByZXR1cm4gQ3JkdFR5cGUyO1xufSkoQ3JkdFR5cGUgfHwge30pO1xuZnVuY3Rpb24gaXNSb290Q3JkdChjcmR0KSB7XG4gIHJldHVybiBjcmR0LnR5cGUgPT09IDAgLyogT0JKRUNUICovICYmICFpc0NoaWxkQ3JkdChjcmR0KTtcbn1cbmZ1bmN0aW9uIGlzQ2hpbGRDcmR0KGNyZHQpIHtcbiAgcmV0dXJuIGNyZHQucGFyZW50SWQgIT09IHZvaWQgMCAmJiBjcmR0LnBhcmVudEtleSAhPT0gdm9pZCAwO1xufVxuXG4vLyBzcmMvY3JkdHMvTGl2ZVJlZ2lzdGVyLnRzXG52YXIgTGl2ZVJlZ2lzdGVyID0gY2xhc3MgX0xpdmVSZWdpc3RlciBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gICNkYXRhO1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNkYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZGF0YTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgX3BhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCByZWdpc3RlciA9IG5ldyBfTGl2ZVJlZ2lzdGVyKGl0ZW0uZGF0YSk7XG4gICAgcmVnaXN0ZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHJlZ2lzdGVyO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCBzZXJpYWxpemUgcmVnaXN0ZXIgaWYgcGFyZW50SWQgb3IgcGFyZW50S2V5IGlzIHVuZGVmaW5lZFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgcGFyZW50SWQsXG4gICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZVJlZ2lzdGVyIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMyAvKiBSRUdJU1RFUiAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKF9vcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKF9jcmR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkpzb25cIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuI2RhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5kYXRhKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVMaXN0LnRzXG5mdW5jdGlvbiBjb21wYXJlTm9kZVBvc2l0aW9uKGl0ZW1BLCBpdGVtQikge1xuICBjb25zdCBwb3NBID0gaXRlbUEuX3BhcmVudFBvcztcbiAgY29uc3QgcG9zQiA9IGl0ZW1CLl9wYXJlbnRQb3M7XG4gIHJldHVybiBwb3NBID09PSBwb3NCID8gMCA6IHBvc0EgPCBwb3NCID8gLTEgOiAxO1xufVxudmFyIExpdmVMaXN0ID0gY2xhc3MgX0xpdmVMaXN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgLy8gVE9ETzogTmFpdmUgYXJyYXkgYXQgZmlyc3QsIGZpbmQgYSBiZXR0ZXIgZGF0YSBzdHJ1Y3R1cmUuIE1heWJlIGFuIE9yZGVyIHN0YXRpc3RpY3MgdHJlZT9cbiAgI2l0ZW1zO1xuICAjaW1wbGljaXRseURlbGV0ZWRJdGVtcztcbiAgI3VuYWNrbm93bGVkZ2VkU2V0cztcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI2l0ZW1zID0gW107XG4gICAgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHBvc2l0aW9uID0gdm9pZCAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBtYWtlUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgY29uc3Qgbm9kZSA9IGxzb25Ub0xpdmVOb2RlKGl0ZW0pO1xuICAgICAgbm9kZS5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdQb3NpdGlvbik7XG4gICAgICB0aGlzLiNpdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgcG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBsaXN0ID0gbmV3IF9MaXZlTGlzdChbXSk7XG4gICAgbGlzdC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobGlzdCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbGlzdC5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHJlc3VsdGluZyBvcHMgd2lsbCBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgaWYgdGhleSBoYXZlIGFuICdvcElkJ1xuICAgKiBzbyB3ZSBtdXRhdGUgX3VuYWNrbm93bGVkZ2VkU2V0cyB0byBhdm9pZCBwb3RlbnRpYWwgZmxpY2tlcmluZ1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWJsb2Nrcy9saXZlYmxvY2tzL3B1bGwvMTE3N1xuICAgKlxuICAgKiBUaGlzIGlzIHF1aXRlIHVuaW50dWl0aXZlIGFuZCBzaG91bGQgZGlzYXBwZWFyIGFzIHNvb24gYXNcbiAgICogd2UgaW50cm9kdWNlIGFuIGV4cGxpY2l0IExpdmVMaXN0LlNldCBvcGVyYXRpb25cbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXlcbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jaXRlbXMpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleTIgPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgICBjb25zdCBjaGlsZE9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwYXJlbnRLZXkyLCBwb29sKSxcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgY29uc3QgY2hpbGRPcElkID0gY2hpbGRPcHNbMF0ub3BJZDtcbiAgICAgIGlmIChjaGlsZE9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldHMuc2V0KHBhcmVudEtleTIsIGNoaWxkT3BJZCk7XG4gICAgICB9XG4gICAgICBvcHMucHVzaCguLi5jaGlsZE9wcyk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gaW50byB0aGUgc29ydGVkIGxpc3QsIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uLlxuICAgKi9cbiAgX2luc2VydEFuZFNvcnQoaXRlbSkge1xuICAgIHRoaXMuI2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc29ydEl0ZW1zKCkge1xuICAgIHRoaXMuI2l0ZW1zLnNvcnQoY29tcGFyZU5vZGVQb3NpdGlvbik7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5kZXhPZlBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuI2l0ZW1zLmZpbmRJbmRleChcbiAgICAgIChpdGVtKSA9PiBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkgPT09IHBvc2l0aW9uXG4gICAgKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jaXRlbXMpIHtcbiAgICAgIGl0ZW0uX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuI2l0ZW1zKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgI2FwcGx5U2V0UmVtb3RlKG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgZGVsZXRlZElkID0gb3AuZGVsZXRlZElkO1xuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICBjb25zdCBpdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuI2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl07XG4gICAgICBpZiAoaXRlbVdpdGhTYW1lUG9zaXRpb24uX2lkID09PSBkZWxldGVkSWQpIHtcbiAgICAgICAgaXRlbVdpdGhTYW1lUG9zaXRpb24uX2RldGFjaCgpO1xuICAgICAgICB0aGlzLiNpdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dID0gY2hpbGQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBjaGlsZClcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5hZGQoaXRlbVdpdGhTYW1lUG9zaXRpb24pO1xuICAgICAgICB0aGlzLiNpdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dID0gY2hpbGQ7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gW1xuICAgICAgICAgIHNldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgY2hpbGQpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGRlbGV0ZURlbHRhMiA9IHRoaXMuI2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oXG4gICAgICAgICAgb3AuZGVsZXRlZElkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChkZWxldGVEZWx0YTIpIHtcbiAgICAgICAgICBkZWx0YS5wdXNoKGRlbGV0ZURlbHRhMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgICAgY29uc3QgZGVsZXRlRGVsdGEyID0gdGhpcy4jZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgb3AuZGVsZXRlZElkXG4gICAgICApO1xuICAgICAgaWYgKGRlbGV0ZURlbHRhMikge1xuICAgICAgICB1cGRhdGVzLnB1c2goZGVsZXRlRGVsdGEyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgdXBkYXRlcy5wdXNoKGluc2VydERlbHRhKHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpLCBjaGlsZCkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmV2ZXJzZTogW10sXG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIHVwZGF0ZXMpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAjYXBwbHlTZXRBY2sob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YSA9IFtdO1xuICAgIGNvbnN0IGRlbGV0ZWREZWx0YSA9IHRoaXMuI2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24ob3AuZGVsZXRlZElkKTtcbiAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICBkZWx0YS5wdXNoKGRlbGV0ZWREZWx0YSk7XG4gICAgfVxuICAgIGNvbnN0IHVuYWNrbm93bGVkZ2VkT3BJZCA9IHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0cy5nZXQob3AucGFyZW50S2V5KTtcbiAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh1bmFja25vd2xlZGdlZE9wSWQgIT09IG9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhLmxlbmd0aCA9PT0gMCA/IHsgbW9kaWZpZWQ6IGZhbHNlIH0gOiB7IG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSwgcmV2ZXJzZTogW10gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0cy5kZWxldGUob3AucGFyZW50S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy4jaXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5faWQgPT09IG9wLmlkKTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0gb3AucGFyZW50S2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChcbiAgICAgICAgICB0aGlzLiNpdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IFtwcmV2Tm9kZV0gPSB0aGlzLiNpdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIHByZXZOb2RlKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBpZiAobmV3SW5kZXggIT09IHByZXZJbmRleCkge1xuICAgICAgICBkZWx0YS5wdXNoKG1vdmVEZWx0YShwcmV2SW5kZXgsIG5ld0luZGV4LCBleGlzdGluZ0l0ZW0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBkZWx0YS5sZW5ndGggPiAwID8gbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSkgOiBmYWxzZSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9ycGhhbiA9IHRoaXMuX3Bvb2wuZ2V0Tm9kZShvcC5pZCk7XG4gICAgICBpZiAob3JwaGFuICYmIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKG9ycGhhbikpIHtcbiAgICAgICAgb3JwaGFuLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG9wLnBhcmVudEtleSk7XG4gICAgICAgIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKG9ycGhhbik7XG4gICAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQob3JwaGFuKTtcbiAgICAgICAgY29uc3QgcmVjcmVhdGVkSXRlbUluZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihvcnBoYW4pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEocmVjcmVhdGVkSXRlbUluZGV4LCBvcnBoYW4pIDogc2V0RGVsdGEocmVjcmVhdGVkSXRlbUluZGV4LCBvcnBoYW4pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLiNpdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5ld0l0ZW0sIG5ld0luZGV4IH0gPSB0aGlzLiNjcmVhdGVBdHRhY2hJdGVtQW5kU29ydChcbiAgICAgICAgICBvcCxcbiAgICAgICAgICBvcC5wYXJlbnRLZXlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIGF0IHRoaXMgcG9zaXRpb24sIHVwZGF0ZSBpcyBhIHNldCwgZWxzZSBpdCdzIGFuIGluc2VydFxuICAgICAgICAgICAgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID09PSAtMSA/IGluc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKSA6IHNldERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKSxcbiAgICAgICAgICAgIC4uLmRlbHRhXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVwZGF0ZSBkZWx0YSBvZiB0aGUgZGVsZXRpb24gb3IgbnVsbFxuICAgKi9cbiAgI2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oZGVsZXRlZElkKSB7XG4gICAgaWYgKGRlbGV0ZWRJZCA9PT0gdm9pZCAwIHx8IHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRJdGVtID0gdGhpcy5fcG9vbC5nZXROb2RlKGRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWRJdGVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZXRhY2hDaGlsZChkZWxldGVkSXRlbSk7XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lm1vZGlmaWVkLnVwZGF0ZXNbMF07XG4gIH1cbiAgI2FwcGx5UmVtb3RlSW5zZXJ0KG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gYXNQb3Mob3AucGFyZW50S2V5KTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuI3NoaWZ0SXRlbVBvc2l0aW9uKGV4aXN0aW5nSXRlbUluZGV4LCBrZXkpO1xuICAgIH1cbiAgICBjb25zdCB7IG5ld0l0ZW0sIG5ld0luZGV4IH0gPSB0aGlzLiNjcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKV0pLFxuICAgICAgcmV2ZXJzZTogW11cbiAgICB9O1xuICB9XG4gICNhcHBseUluc2VydEFjayhvcCkge1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuI2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgY29uc3Qga2V5ID0gYXNQb3Mob3AucGFyZW50S2V5KTtcbiAgICBjb25zdCBpdGVtSW5kZXhBdFBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSkge1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbS5fcGFyZW50S2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uSW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICAgIGlmIChpdGVtSW5kZXhBdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuI3NoaWZ0SXRlbVBvc2l0aW9uKGl0ZW1JbmRleEF0UG9zaXRpb24sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhpc3RpbmdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICBpZiAobmV3SW5kZXggPT09IG9sZFBvc2l0aW9uSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIG1vdmVEZWx0YShvbGRQb3NpdGlvbkluZGV4LCBuZXdJbmRleCwgZXhpc3RpbmdJdGVtKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9ycGhhbiA9IG5uKHRoaXMuX3Bvb2wpLmdldE5vZGUob3AuaWQpO1xuICAgICAgaWYgKG9ycGhhbiAmJiB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhvcnBoYW4pKSB7XG4gICAgICAgIG9ycGhhbi5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShvcnBoYW4pO1xuICAgICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG9ycGhhbik7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBvcnBoYW4pXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpdGVtSW5kZXhBdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuI3NoaWZ0SXRlbVBvc2l0aW9uKGl0ZW1JbmRleEF0UG9zaXRpb24sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy4jY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQob3AsIGtleSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNhcHBseUluc2VydFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBsZXQgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGJlZm9yZTIgPSB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0/Ll9wYXJlbnRQb3M7XG4gICAgICBjb25zdCBhZnRlcjIgPSB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zO1xuICAgICAgbmV3S2V5ID0gbWFrZVBvc2l0aW9uKGJlZm9yZTIsIGFmdGVyMik7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV1cbiAgICB9O1xuICB9XG4gICNhcHBseVNldFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXRzLnNldChrZXksIG5uKG9wLm9wSWQpKTtcbiAgICBjb25zdCBpbmRleE9mSXRlbVdpdGhTYW1lS2V5ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lS2V5ICE9PSAtMSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy4jaXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZUtleV07XG4gICAgICBleGlzdGluZ0l0ZW0uX2RldGFjaCgpO1xuICAgICAgdGhpcy4jaXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZUtleV0gPSBjaGlsZDtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICBleGlzdGluZ0l0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb3AuaWRcbiAgICAgICk7XG4gICAgICBjb25zdCBkZWx0YSA9IFtzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lS2V5LCBjaGlsZCldO1xuICAgICAgY29uc3QgZGVsZXRlZERlbHRhID0gdGhpcy4jZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgb3AuZGVsZXRlZElkXG4gICAgICApO1xuICAgICAgaWYgKGRlbGV0ZWREZWx0YSkge1xuICAgICAgICBkZWx0YS5wdXNoKGRlbGV0ZWREZWx0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgdGhpcy4jZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihvcC5kZWxldGVkSWQpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJldmVyc2U6IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAob3AuaW50ZW50ID09PSBcInNldFwiKSB7XG4gICAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLiNhcHBseVNldFJlbW90ZShvcCk7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy4jYXBwbHlTZXRBY2sob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy4jYXBwbHlTZXRVbmRvUmVkbyhvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuI2FwcGx5UmVtb3RlSW5zZXJ0KG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLiNhcHBseUluc2VydEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLiNhcHBseUluc2VydFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMobm4odGhpcy5faWQpLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgICAgY29uc3QgaW5kZXhUb0RlbGV0ZSA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKGluZGV4VG9EZWxldGUgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBbcHJldmlvdXNOb2RlXSA9IHRoaXMuI2l0ZW1zLnNwbGljZShpbmRleFRvRGVsZXRlLCAxKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4VG9EZWxldGUsIHByZXZpb3VzTm9kZSldKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgI2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCkge1xuICAgIGlmICh0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBjaGlsZC5fcGFyZW50S2V5O1xuICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAjYXBwbHlTZXRDaGlsZEtleUFjayhuZXdLZXksIGNoaWxkKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBpZiAodGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMoY2hpbGQpKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUoY2hpbGQpO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV3S2V5ID09PSBwcmV2aW91c0tleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAocHJldmlvdXNJbmRleCA9PT0gbmV3SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZClcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICk7XG4gICAgfVxuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAocHJldmlvdXNJbmRleCA9PT0gbmV3SW5kZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICBpZDogbm4oY2hpbGQuX2lkKSxcbiAgICAgICAgICBwYXJlbnRLZXk6IHByZXZpb3VzS2V5XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NldENoaWxkS2V5KG5ld0tleSwgY2hpbGQsIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICByZXR1cm4gdGhpcy4jYXBwbHlTZXRDaGlsZEtleVJlbW90ZShuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLiNhcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy4jYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvKG5ld0tleSwgY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTGlzdCBpZiBwYXJlbnQgaXMgbWlzc2luZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMuXG4gICAqL1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiNpdGVtcy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb25lIGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBMaXZlTGlzdC5cbiAgICovXG4gIHB1c2goZWxlbWVudCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KGVsZW1lbnQsIHRoaXMubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBvbmUgZWxlbWVudCBhdCBhIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0LlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHlvdSB3YW50IHRvIGluc2VydCB0aGUgZWxlbWVudC5cbiAgICovXG4gIGluc2VydChlbGVtZW50LCBpbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuI2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGluc2VydCBsaXN0IGl0ZW0gYXQgaW5kZXggXCJcdTAwMWQke2luZGV4fVwiLiBpbmRleCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuI2l0ZW1zLmxlbmd0aH1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBiZWZvcmUyID0gdGhpcy4jaXRlbXNbaW5kZXggLSAxXSA/IHRoaXMuI2l0ZW1zW2luZGV4IC0gMV0uX3BhcmVudFBvcyA6IHZvaWQgMDtcbiAgICBjb25zdCBhZnRlcjIgPSB0aGlzLiNpdGVtc1tpbmRleF0gPyB0aGlzLiNpdGVtc1tpbmRleF0uX3BhcmVudFBvcyA6IHZvaWQgMDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmUyLCBhZnRlcjIpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoZWxlbWVudCk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2luc2VydEFuZFNvcnQodmFsdWUpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgICBbdGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKGluZGV4LCB2YWx1ZSldKV1cbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNb3ZlIG9uZSBlbGVtZW50IGZyb20gb25lIGluZGV4IHRvIGFub3RoZXIuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gbW92ZVxuICAgKiBAcGFyYW0gdGFyZ2V0SW5kZXggVGhlIGluZGV4IHdoZXJlIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhZnRlciBtb3ZpbmcuXG4gICAqL1xuICBtb3ZlKGluZGV4LCB0YXJnZXRJbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGhpcy4jaXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPj0gdGhpcy4jaXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBjYW5ub3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBsaXN0IGxlbmd0aFwiKTtcbiAgICB9XG4gICAgbGV0IGJlZm9yZVBvc2l0aW9uID0gbnVsbDtcbiAgICBsZXQgYWZ0ZXJQb3NpdGlvbiA9IG51bGw7XG4gICAgaWYgKGluZGV4IDwgdGFyZ2V0SW5kZXgpIHtcbiAgICAgIGFmdGVyUG9zaXRpb24gPSB0YXJnZXRJbmRleCA9PT0gdGhpcy4jaXRlbXMubGVuZ3RoIC0gMSA/IHZvaWQgMCA6IHRoaXMuI2l0ZW1zW3RhcmdldEluZGV4ICsgMV0uX3BhcmVudFBvcztcbiAgICAgIGJlZm9yZVBvc2l0aW9uID0gdGhpcy4jaXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyUG9zaXRpb24gPSB0aGlzLiNpdGVtc1t0YXJnZXRJbmRleF0uX3BhcmVudFBvcztcbiAgICAgIGJlZm9yZVBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IDAgPyB2b2lkIDAgOiB0aGlzLiNpdGVtc1t0YXJnZXRJbmRleCAtIDFdLl9wYXJlbnRQb3M7XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKGJlZm9yZVBvc2l0aW9uLCBhZnRlclBvc2l0aW9uKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy4jaXRlbXNbaW5kZXhdO1xuICAgIGNvbnN0IHByZXZpb3VzUG9zaXRpb24gPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbdGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShpbmRleCwgdGFyZ2V0SW5kZXgsIGl0ZW0pXSldXG4gICAgICBdKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgICAgaWQ6IG5uKGl0ZW0uX2lkKSxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHBvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHByZXZpb3VzUG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbiBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShpbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLiNpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBkZWxldGUgbGlzdCBpdGVtIGF0IGluZGV4IFwiJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLiNpdGVtcy5sZW5ndGggLSAxfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLiNpdGVtc1tpbmRleF07XG4gICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgY29uc3QgW3ByZXZdID0gdGhpcy4jaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCkge1xuICAgICAgY29uc3QgY2hpbGRSZWNvcmRJZCA9IGl0ZW0uX2lkO1xuICAgICAgaWYgKGNoaWxkUmVjb3JkSWQpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBzdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgbm4odGhpcy5faWQpLFxuICAgICAgICAgIG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4LCBwcmV2KV0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgICAgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZDogY2hpbGRSZWNvcmRJZCxcbiAgICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpLFxuICAgICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgY29uc3QgcmV2ZXJzZU9wcyA9IFtdO1xuICAgICAgY29uc3QgdXBkYXRlRGVsdGEgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNpdGVtcykge1xuICAgICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICAgICAgY29uc3QgY2hpbGRJZCA9IGl0ZW0uX2lkO1xuICAgICAgICBpZiAoY2hpbGRJZCkge1xuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgICAgICAgICBpZDogY2hpbGRJZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXZlcnNlT3BzLnB1c2goXG4gICAgICAgICAgICAuLi5pdGVtLl90b09wcyhubih0aGlzLl9pZCksIGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHVwZGF0ZURlbHRhLnB1c2goZGVsZXRlRGVsdGEoMCwgaXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLiNpdGVtcyA9IFtdO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQobm4odGhpcy5faWQpLCBtYWtlVXBkYXRlKHRoaXMsIHVwZGF0ZURlbHRhKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jaXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNpdGVtcyA9IFtdO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG4gIHNldChpbmRleCwgaXRlbSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLiNpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzZXQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLiNpdGVtcy5sZW5ndGggLSAxfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuI2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGV4aXN0aW5nSXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGNvbnN0IGV4aXN0aW5nSWQgPSBleGlzdGluZ0l0ZW0uX2lkO1xuICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgY29uc3QgdmFsdWUgPSBsc29uVG9MaXZlTm9kZShpdGVtKTtcbiAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy4jaXRlbXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCk7XG4gICAgICB2YWx1ZS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwgbWFrZVVwZGF0ZSh0aGlzLCBbc2V0RGVsdGEoaW5kZXgsIHZhbHVlKV0pKTtcbiAgICAgIGNvbnN0IG9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIHZhbHVlLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHRoaXMuX3Bvb2wpLFxuICAgICAgICBleGlzdGluZ0lkXG4gICAgICApO1xuICAgICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXRzLnNldChwb3NpdGlvbiwgbm4ob3BzWzBdLm9wSWQpKTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICBleGlzdGluZ0l0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdm9pZCAwKSxcbiAgICAgICAgaWRcbiAgICAgICk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBBcnJheSBvZiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBMaXZlTGlzdC5cbiAgICovXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2l0ZW1zLm1hcChcbiAgICAgIChlbnRyeSkgPT4gbGl2ZU5vZGVUb0xzb24oZW50cnkpXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXlxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRklYTUUhIFRoaXMgaXNuJ3Qgc2FmZS5cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGFsbCBlbGVtZW50cyBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGZvciBlYWNoIGVsZW1lbnQsIHRha2luZyB0d28gYXJndW1lbnRzICh0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4KS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yIGV2ZXJ5IGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBldmVyeShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZXZlcnkocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IG9mIHRoZSBMaXZlTGlzdC4gUmV0dXJuIGEgdmFsdWUgdGhhdCBjb2VyY2VzIHRvIHRydWUgdG8ga2VlcCB0aGUgZWxlbWVudCwgb3IgdG8gZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QuXG4gICAqL1xuICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbHRlcihwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZS5cbiAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBmaW5kKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maW5kKHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgdW50aWwgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSBzYXRpc2Z5aW5nIGVsZW1lbnQgd2FzIGZvdW5kLlxuICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHRoYXQgcGFzc2VzIHRoZSB0ZXN0LiBPdGhlcndpc2UsIC0xLlxuICAgKi9cbiAgZmluZEluZGV4KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maW5kSW5kZXgocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFja2ZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFja2ZuKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZvckVhY2goY2FsbGJhY2tmbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9uIHRoZSBlbGVtZW50IHRvIGdldC5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuI2l0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVOb2RlVG9Mc29uKHRoaXMuI2l0ZW1zW2luZGV4XSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIExpdmVMaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUuXG4gICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggYXQuXG4gICAqIEByZXR1cm5zIFRoZSBmaXJzdCBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3Q7IC0xIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuIFRoZSBMaXZlTHNpdCBpcyBzZWFyY2hlZCBiYWNrd2FyZHMsIHN0YXJ0aW5nIGF0IGZyb21JbmRleC5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUuXG4gICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZyBiYWNrd2FyZHMuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBwb3B1bGF0ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gZXZlcnkgZWxlbWVudC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvciBldmVyeSBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIGVhY2ggZWxlbWVudCBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIG1hcChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLiNpdGVtcy5tYXAoXG4gICAgICAoZW50cnksIGkpID0+IGNhbGxiYWNrKFxuICAgICAgICBsaXZlTm9kZVRvTHNvbihlbnRyeSksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXlxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgRklYTUUhIFRoaXMgaXNuJ3Qgc2FmZS5cbiAgICAgICAgaVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHBhc3NlcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBhdCBsZWFzdCBvbmUgZWxlbWVudC4gT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICovXG4gIHNvbWUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLnNvbWUocHJlZGljYXRlKTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gbmV3IExpdmVMaXN0SXRlcmF0b3IodGhpcy4jaXRlbXMpO1xuICB9XG4gICNjcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KSB7XG4gICAgY29uc3QgbmV3SXRlbSA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBuZXdJdGVtLl9hdHRhY2gob3AuaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBuZXdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydChuZXdJdGVtKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIHJldHVybiB7IG5ld0l0ZW0sIG5ld0luZGV4IH07XG4gIH1cbiAgI3NoaWZ0SXRlbVBvc2l0aW9uKGluZGV4LCBrZXkpIHtcbiAgICBjb25zdCBzaGlmdGVkUG9zaXRpb24gPSBtYWtlUG9zaXRpb24oXG4gICAgICBrZXksXG4gICAgICB0aGlzLiNpdGVtcy5sZW5ndGggPiBpbmRleCArIDEgPyB0aGlzLiNpdGVtc1tpbmRleCArIDFdPy5fcGFyZW50UG9zIDogdm9pZCAwXG4gICAgKTtcbiAgICB0aGlzLiNpdGVtc1tpbmRleF0uX3NldFBhcmVudExpbmsodGhpcywgc2hpZnRlZFBvc2l0aW9uKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkxpdmVMaXN0XCIsXG4gICAgICBpZDogdGhpcy5faWQgPz8gbmFub2lkKCksXG4gICAgICBrZXksXG4gICAgICBwYXlsb2FkOiB0aGlzLiNpdGVtcy5tYXAoXG4gICAgICAgIChpdGVtLCBpbmRleCkgPT4gaXRlbS50b1RyZWVOb2RlKGluZGV4LnRvU3RyaW5nKCkpXG4gICAgICApXG4gICAgfTtcbiAgfVxuICB0b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudG9JbW11dGFibGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNpdGVtcy5tYXAoKG5vZGUpID0+IG5vZGUudG9JbW11dGFibGUoKSk7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IHJlc3VsdCA6IE9iamVjdC5mcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTGlzdCh0aGlzLiNpdGVtcy5tYXAoKGl0ZW0pID0+IGl0ZW0uY2xvbmUoKSkpO1xuICB9XG59O1xudmFyIExpdmVMaXN0SXRlcmF0b3IgPSBjbGFzcyB7XG4gICNpbm5lckl0ZXJhdG9yO1xuICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgIHRoaXMuI2lubmVySXRlcmF0b3IgPSBpdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24ocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4geyB2YWx1ZSB9O1xuICB9XG59O1xuZnVuY3Rpb24gbWFrZVVwZGF0ZShsaXZlTGlzdCwgZGVsdGFVcGRhdGVzKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbGl2ZUxpc3QsXG4gICAgdHlwZTogXCJMaXZlTGlzdFwiLFxuICAgIHVwZGF0ZXM6IGRlbHRhVXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gc2V0RGVsdGEoaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcInNldFwiLFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtXG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVEZWx0YShpbmRleCwgZGVsZXRlZE5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgIGluZGV4LFxuICAgIGRlbGV0ZWRJdGVtOiBkZWxldGVkTm9kZSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGRlbGV0ZWROb2RlLmRhdGEgOiBkZWxldGVkTm9kZVxuICB9O1xufVxuZnVuY3Rpb24gaW5zZXJ0RGVsdGEoaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcImluc2VydFwiLFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtXG4gIH07XG59XG5mdW5jdGlvbiBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1vdmVcIixcbiAgICBpbmRleCxcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbSxcbiAgICBwcmV2aW91c0luZGV4XG4gIH07XG59XG5mdW5jdGlvbiBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKG9wcywgZGVsZXRlZElkKSB7XG4gIHJldHVybiBvcHMubWFwKChvcCwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0T3AgPSBvcDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmZpcnN0T3AsXG4gICAgICAgIGludGVudDogXCJzZXRcIixcbiAgICAgICAgZGVsZXRlZElkXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3A7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2NyZHRzL0xpdmVNYXAudHNcbnZhciBMaXZlTWFwID0gY2xhc3MgX0xpdmVNYXAgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICAjbWFwO1xuICAjdW5hY2tub3dsZWRnZWRTZXQ7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKGVudHJpZXMyKSB7XG4gICAgICBjb25zdCBtYXBwZWRFbnRyaWVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzMikge1xuICAgICAgICBjb25zdCBub2RlID0gbHNvblRvTGl2ZU5vZGUodmFsdWUpO1xuICAgICAgICBub2RlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG1hcHBlZEVudHJpZXMucHVzaChba2V5LCBub2RlXSk7XG4gICAgICB9XG4gICAgICB0aGlzLiNtYXAgPSBuZXcgTWFwKG1hcHBlZEVudHJpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBfaXRlbV0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgX0xpdmVNYXAoKTtcbiAgICBtYXAuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChpZCk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobWFwLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICBtYXAuI21hcC5zZXQoY3JkdC5wYXJlbnRLZXksIGNoaWxkKTtcbiAgICAgIG1hcC5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5LCBvcElkIH0gPSBvcDtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXk7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICBjb25zdCBsYXN0VXBkYXRlT3BJZCA9IHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0LmdldChrZXkpO1xuICAgICAgaWYgKGxhc3RVcGRhdGVPcElkID09PSBvcElkKSB7XG4gICAgICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH0gZWxzZSBpZiAobGFzdFVwZGF0ZU9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XTtcbiAgICB9XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICB0aGlzLiNtYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuI21hcC52YWx1ZXMoKSkge1xuICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKGNoaWxkKSB7XG4gICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgY29uc3QgcGFyZW50S2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhpZCwgcGFyZW50S2V5LCB0aGlzLl9wb29sKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLiNtYXApIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gY2hpbGQpIHtcbiAgICAgICAgdGhpcy4jbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hpbGQuX2RldGFjaCgpO1xuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGUgPSB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICB1cGRhdGVzOiB7IFtwYXJlbnRLZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfTtcbiAgICByZXR1cm4geyBtb2RpZmllZDogc3RvcmFnZVVwZGF0ZSwgcmV2ZXJzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTWFwIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMiAvKiBNQVAgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIExpdmVNYXAuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIHRoaXMuI21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIGl0ZW0uX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb3BzID0gaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldC5zZXQoa2V5LCBubihvcHNbMF0ub3BJZCkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCksXG4gICAgICAgIG9sZFZhbHVlID8gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpIDogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBMaXZlTWFwLlxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5zaXplO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBvciBub3QuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byB0ZXN0IGZvciBwcmVzZW5jZS5cbiAgICovXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmhhcyhrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBieSBrZXkuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgYW4gZWxlbWVudCBleGlzdGVkIGFuZCBoYXMgYmVlbiByZW1vdmVkLCBvciBmYWxzZSBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgaWYgKGl0ZW0gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB0aGlzLiNtYXAuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgaXRlbS5faWQpIHtcbiAgICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzSWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgICAgICAgICBpZDogaXRlbS5faWQsXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzSWQsIGtleSksXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgW2tleSwgdmFsdWVdIHBhaXJzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICBlbnRyaWVzKCkge1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0aGlzLiNtYXAuZW50cmllcygpO1xuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3JWYWx1ZSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoaXRlcmF0b3JWYWx1ZS5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyeSA9IGl0ZXJhdG9yVmFsdWUudmFsdWU7XG4gICAgICAgIGNvbnN0IGtleSA9IGVudHJ5WzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKGl0ZXJhdG9yVmFsdWUudmFsdWVbMV0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBba2V5LCB2YWx1ZV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTYW1lIGZ1bmN0aW9uIG9iamVjdCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgZW50cmllcyBtZXRob2QuXG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGtleXMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5rZXlzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHZhbHVlcyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgdmFsdWVzKCkge1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0aGlzLiNtYXAudmFsdWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIHBlciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIHRoZSBNYXAgb2JqZWN0LCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVudHJ5IGluIHRoZSBtYXAuXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzKSB7XG4gICAgICBjYWxsYmFjayhlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IEFycmF5LmZyb20odGhpcy4jbWFwLmVudHJpZXMoKSkubWFwKFxuICAgICAgICAoW2tleTIsIHZhbF0pID0+IHZhbC50b1RyZWVOb2RlKGtleTIpXG4gICAgICApXG4gICAgfTtcbiAgfVxuICB0b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudG9JbW11dGFibGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlLnRvSW1tdXRhYmxlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU1hcChcbiAgICAgIEFycmF5LmZyb20odGhpcy4jbWFwKS5tYXAoKFtrZXksIG5vZGVdKSA9PiBba2V5LCBub2RlLmNsb25lKCldKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9MaXZlT2JqZWN0LnRzXG52YXIgTGl2ZU9iamVjdCA9IGNsYXNzIF9MaXZlT2JqZWN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgI21hcDtcbiAgI3Byb3BUb0xhc3RVcGRhdGU7XG4gIHN0YXRpYyAjYnVpbGRSb290QW5kUGFyZW50VG9DaGlsZHJlbihpdGVtcykge1xuICAgIGNvbnN0IHBhcmVudFRvQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCByb290ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgaXRlbXMpIHtcbiAgICAgIGlmIChpc1Jvb3RDcmR0KGNyZHQpKSB7XG4gICAgICAgIHJvb3QgPSBbaWQsIGNyZHRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHVwbGUgPSBbaWQsIGNyZHRdO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGNyZHQucGFyZW50SWQpO1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2godHVwbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFRvQ2hpbGRyZW4uc2V0KGNyZHQucGFyZW50SWQsIFt0dXBsZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IGNhbid0IGJlIG51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiBbcm9vdCwgcGFyZW50VG9DaGlsZHJlbl07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21JdGVtcyhpdGVtcywgcG9vbCkge1xuICAgIGNvbnN0IFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXSA9IF9MaXZlT2JqZWN0LiNidWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKTtcbiAgICByZXR1cm4gX0xpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudFRvQ2hpbGRyZW4sXG4gICAgICBwb29sXG4gICAgKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvYmogPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgbyA9IGNvbXBhY3RPYmplY3Qob2JqKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvW2tleV07XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhvKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcElkID0gcG9vbD8uZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXksXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpdmVPYmogPSBuZXcgX0xpdmVPYmplY3QoaXRlbS5kYXRhKTtcbiAgICBsaXZlT2JqLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KG5uKGxpdmVPYmouX2lkKSk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXZlT2JqO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXZlT2JqLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgICBsaXZlT2JqLiNtYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBsaXZlT2JqLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVPYmo7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgb3BJZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTHNvbihvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLykge1xuICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcElkKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNwcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpc0lkLCBrZXkgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQ6IHRoaXNJZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBwcmV2aW91c1ZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy4jbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLiNtYXApIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNtYXAudmFsdWVzKCkpIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBpc0xvY2FsKSB7XG4gICAgaWYgKG9wLnR5cGUgPT09IDMgLyogVVBEQVRFX09CSkVDVCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKTtcbiAgICB9IGVsc2UgaWYgKG9wLnR5cGUgPT09IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLiNhcHBseURlbGV0ZU9iamVjdEtleShvcCwgaXNMb2NhbCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICBpZiAoIWlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIiAmJiB0aGlzLnBhcmVudC5ub2RlLl9pZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIHBhcmVudElkOiB0aGlzLnBhcmVudC5ub2RlLl9pZCxcbiAgICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDAgLyogT0JKRUNUICovLFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAjYXBwbHlVcGRhdGUob3AsIGlzTG9jYWwpIHtcbiAgICBsZXQgaXNNb2RpZmllZCA9IGZhbHNlO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHJldmVyc2UgPSBbXTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlID0ge1xuICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgaWQsXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgcmV2ZXJzZS5wdXNoKC4uLm9sZFZhbHVlLl90b09wcyhpZCwga2V5KSk7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlVXBkYXRlLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkLCBrZXkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZURlbHRhID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcC5kYXRhW2tleV07XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLiNwcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wLm9wSWQpIHtcbiAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdXBkYXRlRGVsdGFba2V5XSA9IHsgdHlwZTogXCJ1cGRhdGVcIiB9O1xuICAgICAgdGhpcy4jbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMocmV2ZXJzZVVwZGF0ZS5kYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldmVyc2UudW5zaGlmdChyZXZlcnNlVXBkYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTW9kaWZpZWQgPyB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczogdXBkYXRlRGVsdGFcbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfSA6IHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgI2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qga2V5ID0gb3Aua2V5O1xuICAgIGlmICh0aGlzLiNtYXAuaGFzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKCFpc0xvY2FsICYmIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGxldCByZXZlcnNlID0gW107XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKGlkLCBvcC5rZXkpO1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBvbGRWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW29wLmtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBMaXZlT2JqZWN0IGludG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLiNtYXApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSBwcm9wZXJ0eSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgdGhpcy51cGRhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSB0aGUgTGl2ZU9iamVjdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGZyb20gdGhlIExpdmVPYmplY3RcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5O1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXlBc1N0cmluZyk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXlBc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgZGF0YTogeyBba2V5QXNTdHJpbmddOiBvbGRWYWx1ZSB9LFxuICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLiNtYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sXG4gICAgICAgICAga2V5OiBrZXlBc1N0cmluZyxcbiAgICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZSB3aXRoIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHBhdGNoIFRoZSBvYmplY3QgdXNlZCB0byBvdmVycmlkZXMgcHJvcGVydGllc1xuICAgKi9cbiAgdXBkYXRlKHBhdGNoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICBjb25zdCBvcElkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCB1cGRhdGVkUHJvcHMgPSB7fTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlT3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzLl9pZCwga2V5IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZU9wLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG5ld1ZhbHVlLl9hdHRhY2godGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBuZXdBdHRhY2hDaGlsZE9wcyA9IG5ld1ZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgY3JlYXRlQ3JkdE9wID0gbmV3QXR0YWNoQ2hpbGRPcHMuZmluZChcbiAgICAgICAgICAob3ApID0+IG9wLnBhcmVudElkID09PSB0aGlzLl9pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoY3JlYXRlQ3JkdE9wKSB7XG4gICAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihjcmVhdGVDcmR0T3Aub3BJZCkpO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKC4uLm5ld0F0dGFjaENoaWxkT3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRQcm9wc1trZXldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgb3BJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNtYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlT3AuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlT3BzLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZU9wKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQcm9wcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBvcHMudW5zaGlmdCh7XG4gICAgICAgIG9wSWQsXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICBkYXRhOiB1cGRhdGVkUHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiBzdXBlci50b1RyZWVOb2RlKGtleSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICBjb25zdCBub2RlSWQgPSB0aGlzLl9pZCA/PyBuYW5vaWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBpZDogbm9kZUlkLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLiNtYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsdWVdKSA9PiBpc0xpdmVOb2RlKHZhbHVlKSA/IHZhbHVlLnRvVHJlZU5vZGUoa2V5MikgOiB7IHR5cGU6IFwiSnNvblwiLCBpZDogYCR7bm9kZUlkfToke2tleTJ9YCwga2V5OiBrZXkyLCBwYXlsb2FkOiB2YWx1ZSB9XG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGlzTGl2ZVN0cnVjdHVyZSh2YWwpID8gdmFsLnRvSW1tdXRhYmxlKCkgOiB2YWw7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU9iamVjdChcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLiNtYXApLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9saXZlYmxvY2tzLWhlbHBlcnMudHNcbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKSB7XG4gIHJldHVybiBsc29uVG9MaXZlTm9kZShjcmVhdGlvbk9wVG9Mc29uKG9wKSk7XG59XG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9Mc29uKG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86XG4gICAgICByZXR1cm4gb3AuZGF0YTtcbiAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChvcC5kYXRhKTtcbiAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU1hcCgpO1xuICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZUxpc3QoW10pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob3AsIFwiVW5rbm93biBjcmVhdGlvbiBPcFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTYW1lTm9kZU9yQ2hpbGRPZihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgcmV0dXJuIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZS5wYXJlbnQubm9kZSwgcGFyZW50KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBMaXZlUmVnaXN0ZXIuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIENSRFQgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9Mc29uKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICBjYXNlIDAgLyogT0JKRUNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMSAvKiBMSVNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZUxpc3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDIgLyogTUFQICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU1hcC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzoge1xuICAgICAgcmV0dXJuIGNyZHQuZGF0YTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZUxpc3QodmFsdWUpIHx8IGlzTGl2ZU1hcCh2YWx1ZSkgfHwgaXNMaXZlT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgfHwgaXNMaXZlUmVnaXN0ZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNMaXZlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU1hcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwO1xufVxuZnVuY3Rpb24gaXNMaXZlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVSZWdpc3Rlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXI7XG59XG5mdW5jdGlvbiBjbG9uZUxzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBsaXZlTm9kZVRvTHNvbihvYmopIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlTGlzdCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlTWFwIHx8IG9iaiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NlcnROZXZlcihvYmosIFwiVW5rbm93biBBYnN0cmFjdENyZHRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxzb25Ub0xpdmVOb2RlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlUmVnaXN0ZXIodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3SXRlbXMpIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIGN1cnJlbnRJdGVtcy5mb3JFYWNoKChfLCBpZCkgPT4ge1xuICAgIGlmICghbmV3SXRlbXMuZ2V0KGlkKSkge1xuICAgICAgb3BzLnB1c2goe1xuICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbmV3SXRlbXMuZm9yRWFjaCgoY3JkdCwgaWQpID0+IHtcbiAgICBjb25zdCBjdXJyZW50Q3JkdCA9IGN1cnJlbnRJdGVtcy5nZXQoaWQpO1xuICAgIGlmIChjdXJyZW50Q3JkdCkge1xuICAgICAgaWYgKGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8pIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDcmR0LnR5cGUgIT09IDAgLyogT0JKRUNUICovIHx8IHN0cmluZ2lmeU9yTG9nKGNyZHQuZGF0YSkgIT09IHN0cmluZ2lmeU9yTG9nKGN1cnJlbnRDcmR0LmRhdGEpKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNyZHQucGFyZW50S2V5ICE9PSBjdXJyZW50Q3JkdC5wYXJlbnRLZXkpIHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGFyZW50S2V5OiBubihjcmR0LnBhcmVudEtleSwgXCJQYXJlbnQga2V5IG11c3Qgbm90IGJlIG1pc3NpbmdcIilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5LFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMSVNUICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDAgLyogT0JKRUNUICovOlxuICAgICAgICAgIGlmIChjcmR0LnBhcmVudElkID09PSB2b2lkIDAgfHwgY3JkdC5wYXJlbnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIkludGVybmFsIGVycm9yLiBDYW5ub3Qgc2VyaWFsaXplIHN0b3JhZ2Ugcm9vdCBpbnRvIGFuIG9wZXJhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogTUFQICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhzZWNvbmQudXBkYXRlcykpIHtcbiAgICB1cGRhdGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlczogdXBkYXRlcy5jb25jYXQoc2Vjb25kLnVwZGF0ZXMpXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc2Vjb25kO1xuICB9XG4gIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVPYmplY3RcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVNYXBcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlTWFwXCIpIHtcbiAgICByZXR1cm4gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVMaXN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZUxpc3RcIikge1xuICAgIHJldHVybiBtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIHtcbiAgfVxuICByZXR1cm4gc2Vjb25kO1xufVxuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNQbGFpbikge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoIHx8IFwicm9vdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKCFpc1BsYWluKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcbiAgICAgICAgbmVzdGVkVmFsdWUsXG4gICAgICAgIG5lc3RlZFBhdGhcbiAgICAgICk7XG4gICAgICBpZiAobm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9saWIvZGVidWcudHNcbmZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKG1zZywgdHJhY2VSb290KSB7XG4gIGNvbnN0IGVycm9yTGlrZSA9IHsgbmFtZTogbXNnIH07XG4gIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3JMaWtlLCB0cmFjZVJvb3QpO1xuICByZXR1cm4gZXJyb3JMaWtlLnN0YWNrO1xufVxuXG4vLyBzcmMvbGliL0RlcXVlLnRzXG52YXIgRGVxdWUgPSBjbGFzcyB7XG4gICNkYXRhO1xuICAjZnJvbnQ7XG4gICNiYWNrO1xuICAjc2l6ZTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy4jZGF0YSA9IHt9O1xuICAgIHRoaXMuI2Zyb250ID0gMDtcbiAgICB0aGlzLiNiYWNrID0gMTtcbiAgICB0aGlzLiNzaXplID0gMDtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiNzaXplO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy4jc2l6ZTtcbiAgICBjb25zdCBmcm9udCA9IHRoaXMuI2Zyb250O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB5aWVsZCB0aGlzLiNkYXRhW2Zyb250ICsgaV07XG4gICAgfVxuICB9XG4gIHB1c2godmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZXMyID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgaWYgKHRoaXMuI2JhY2sgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAtIHZhbHVlczIubGVuZ3RoIC0gMSlcbiAgICAgIHJhaXNlKFwiRGVxdWUgZnVsbFwiKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlMiBvZiB2YWx1ZXMyKSB7XG4gICAgICB0aGlzLiNkYXRhW3RoaXMuI2JhY2srKyAtIDFdID0gdmFsdWUyO1xuICAgIH1cbiAgICB0aGlzLiNzaXplICs9IHZhbHVlczIubGVuZ3RoO1xuICB9XG4gIHBvcCgpIHtcbiAgICBpZiAodGhpcy4jc2l6ZSA8IDEpIHJldHVybiB2b2lkIDA7XG4gICAgdGhpcy4jYmFjay0tO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZGF0YVt0aGlzLiNiYWNrIC0gMV07XG4gICAgZGVsZXRlIHRoaXMuI2RhdGFbdGhpcy4jYmFjayAtIDFdO1xuICAgIHRoaXMuI3NpemUtLTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcHVzaExlZnQodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZXMyID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgaWYgKHRoaXMuI2Zyb250IDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgKyB2YWx1ZXMyLmxlbmd0aClcbiAgICAgIHJhaXNlKFwiRGVxdWUgZnVsbFwiKTtcbiAgICBmb3IgKGxldCBpID0gdmFsdWVzMi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy4jZGF0YVstLXRoaXMuI2Zyb250XSA9IHZhbHVlczJbaV07XG4gICAgfVxuICAgIHRoaXMuI3NpemUgKz0gdmFsdWVzMi5sZW5ndGg7XG4gIH1cbiAgcG9wTGVmdCgpIHtcbiAgICBpZiAodGhpcy4jc2l6ZSA8IDEpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNkYXRhW3RoaXMuI2Zyb250XTtcbiAgICBkZWxldGUgdGhpcy4jZGF0YVt0aGlzLiNmcm9udF07XG4gICAgdGhpcy4jZnJvbnQrKztcbiAgICB0aGlzLiNzaXplLS07XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL0pzb24udHNcbmZ1bmN0aW9uIGlzSnNvblNjYWxhcihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBkYXRhID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzSnNvbkFycmF5KGRhdGEpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoZGF0YSkge1xuICByZXR1cm4gIWlzSnNvblNjYWxhcihkYXRhKSAmJiAhaXNKc29uQXJyYXkoZGF0YSk7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9DbGllbnRNc2cudHNcbnZhciBDbGllbnRNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoQ2xpZW50TXNnQ29kZTIpID0+IHtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJCUk9BRENBU1RfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RfRVZFTlRcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9TVE9SQUdFXCJdID0gMjAwXSA9IFwiRkVUQ0hfU1RPUkFHRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9ZRE9DXCJdID0gMzAwXSA9IFwiRkVUQ0hfWURPQ1wiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAxXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgcmV0dXJuIENsaWVudE1zZ0NvZGUyO1xufSkoQ2xpZW50TXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy9yZWZzL01hbmFnZWRPdGhlcnMudHNcbmZ1bmN0aW9uIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKSB7XG4gIGNvbnN0IHsgY29ubmVjdGlvbklkLCBpZCwgaW5mbyB9ID0gY29ubjtcbiAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoY29ubi5zY29wZXMpO1xuICByZXR1cm4gZnJlZXplKFxuICAgIGNvbXBhY3RPYmplY3Qoe1xuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgaWQsXG4gICAgICBpbmZvLFxuICAgICAgY2FuV3JpdGUsXG4gICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGNvbm4uc2NvcGVzKSxcbiAgICAgIGlzUmVhZE9ubHk6ICFjYW5Xcml0ZSxcbiAgICAgIC8vIERlcHJlY2F0ZWQsIGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcbiAgICAgIHByZXNlbmNlXG4gICAgfSlcbiAgKTtcbn1cbnZhciBNYW5hZ2VkT3RoZXJzID0gY2xhc3Mge1xuICAvLyBUcmFjayBtdXRhYmxlIHN0YXRlIGludGVybmFsbHksIGJ1dCBzaWduYWwgdG8gdGhlIG91dHNpZGUgd2hlbiB0aGVcbiAgLy8gb2JzZXJ2YWJsZSBkZXJpdmVkIHN0YXRlIGNoYW5nZXMgb25seVxuICAjaW50ZXJuYWw7XG4gICN1c2VyQ2FjaGU7XG4gIC8vIFRoZSBcImNsZWFuXCIgc2lnbmFsIHRoYXQgaXMgZXhwb3NlZCB0byB0aGUgb3V0c2lkZSB3b3JsZFxuICBzaWduYWw7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuI2ludGVybmFsID0gbmV3IE11dGFibGVTaWduYWwoe1xuICAgICAgY29ubmVjdGlvbnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBwcmVzZW5jZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICB9KTtcbiAgICB0aGlzLnNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICAgIHRoaXMuI2ludGVybmFsLFxuICAgICAgKF9pZ25vcmUpID0+IGNvbXBhY3QoXG4gICAgICAgIEFycmF5LmZyb20odGhpcy4jaW50ZXJuYWwuZ2V0KCkucHJlc2VuY2VzLmtleXMoKSkubWFwKFxuICAgICAgICAgIChjb25uZWN0aW9uSWQpID0+IHRoaXMuZ2V0VXNlcihOdW1iZXIoY29ubmVjdGlvbklkKSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy4jdXNlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvLyBTaG9ydGhhbmQgZm9yIC5zaWduYWwuZ2V0KClcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnNpZ25hbC5nZXQoKTtcbiAgfVxuICBjb25uZWN0aW9uSWRzKCkge1xuICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbC5nZXQoKS5jb25uZWN0aW9ucy5rZXlzKCk7XG4gIH1cbiAgY2xlYXJPdGhlcnMoKSB7XG4gICAgdGhpcy4jaW50ZXJuYWwubXV0YXRlKChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUuY29ubmVjdGlvbnMuY2xlYXIoKTtcbiAgICAgIHN0YXRlLnByZXNlbmNlcy5jbGVhcigpO1xuICAgICAgdGhpcy4jdXNlckNhY2hlLmNsZWFyKCk7XG4gICAgfSk7XG4gIH1cbiAgI19nZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jaW50ZXJuYWwuZ2V0KCk7XG4gICAgY29uc3QgY29ubiA9IHN0YXRlLmNvbm5lY3Rpb25zLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGNvbnN0IHByZXNlbmNlID0gc3RhdGUucHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb25uICE9PSB2b2lkIDAgJiYgcHJlc2VuY2UgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNhY2hlZFVzZXIgPSB0aGlzLiN1c2VyQ2FjaGUuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNhY2hlZFVzZXIpIHtcbiAgICAgIHJldHVybiBjYWNoZWRVc2VyO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZFVzZXIgPSB0aGlzLiNfZ2V0VXNlcihjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb21wdXRlZFVzZXIpIHtcbiAgICAgIHRoaXMuI3VzZXJDYWNoZS5zZXQoY29ubmVjdGlvbklkLCBjb21wdXRlZFVzZXIpO1xuICAgICAgcmV0dXJuIGNvbXB1dGVkVXNlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAjaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgdGhpcy4jdXNlckNhY2hlLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNvcmRzIGEga25vd24gY29ubmVjdGlvbi4gVGhpcyByZWNvcmRzIHRoZSBjb25uZWN0aW9uIElEIGFuZCB0aGVcbiAgICogYXNzb2NpYXRlZCBtZXRhZGF0YS5cbiAgICovXG4gIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBtZXRhVXNlcklkLCBtZXRhVXNlckluZm8sIHNjb3Blcykge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNvbm5lY3Rpb25zLnNldChcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICBmcmVlemUoe1xuICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICBpZDogbWV0YVVzZXJJZCxcbiAgICAgICAgICBpbmZvOiBtZXRhVXNlckluZm8sXG4gICAgICAgICAgc2NvcGVzXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgaWYgKCFzdGF0ZS5wcmVzZW5jZXMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBrbm93biBjb25uZWN0aW9uSWQuIFJlbW92ZXMgYm90aCB0aGUgY29ubmVjdGlvbidzIG1ldGFkYXRhIGFuZFxuICAgKiB0aGUgcHJlc2VuY2UgaW5mb3JtYXRpb24uXG4gICAqL1xuICByZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCkge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNvbm5lY3Rpb25zLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgc3RhdGUucHJlc2VuY2VzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RvcmVzIGEgbmV3IHVzZXIgZnJvbSBhIGZ1bGwgcHJlc2VuY2UgdXBkYXRlLiBJZiB0aGUgdXNlciBhbHJlYWR5IGV4aXN0cyxcbiAgICogaXRzIGtub3duIHByZXNlbmNlIGRhdGEgaXMgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBzZXRPdGhlcihjb25uZWN0aW9uSWQsIHByZXNlbmNlKSB7XG4gICAgdGhpcy4jaW50ZXJuYWwubXV0YXRlKChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUucHJlc2VuY2VzLnNldChjb25uZWN0aW9uSWQsIGZyZWV6ZShjb21wYWN0T2JqZWN0KHByZXNlbmNlKSkpO1xuICAgICAgaWYgKCFzdGF0ZS5jb25uZWN0aW9ucy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgcHJlc2VuY2UgZGF0YSBmb3IgYW4gZXhpc3RpbmcgXCJvdGhlclwiLiBJZiB3ZSBkb24ndCBrbm93IHRoZVxuICAgKiBpbml0aWFsIHByZXNlbmNlIGRhdGEgZm9yIHRoaXMgdXNlciB5ZXQsIGRpc2NhcmQgdGhpcyBwYXRjaCBhbmQgYXdhaXQgdGhlXG4gICAqIGZ1bGwgLnNldE90aGVyKCkgY2FsbCBmaXJzdC5cbiAgICovXG4gIHBhdGNoT3RoZXIoY29ubmVjdGlvbklkLCBwYXRjaCkge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IG9sZFByZXNlbmNlID0gc3RhdGUucHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgaWYgKG9sZFByZXNlbmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3UHJlc2VuY2UgPSBtZXJnZShvbGRQcmVzZW5jZSwgcGF0Y2gpO1xuICAgICAgaWYgKG9sZFByZXNlbmNlID09PSBuZXdQcmVzZW5jZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKG5ld1ByZXNlbmNlKSk7XG4gICAgICByZXR1cm4gdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3R5cGVzL0xpdmVibG9ja3NFcnJvci50c1xudmFyIExpdmVibG9ja3NFcnJvciA9IGNsYXNzIF9MaXZlYmxvY2tzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnRleHQ7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvbnRleHQsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZSB9KTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiTGl2ZWJsb2Nrc0Vycm9yXCI7XG4gIH1cbiAgLyoqIENvbnZlbmllbmNlIGFjY2Vzc29yIGZvciBlcnJvci5jb250ZXh0LnJvb21JZCAoaWYgYXZhaWxhYmxlKSAqL1xuICBnZXQgcm9vbUlkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucm9vbUlkO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBQcmVmZXIgdXNpbmcgYGNvbnRleHQuY29kZWAgaW5zdGVhZCwgdG8gZW5hYmxlIHR5cGUgbmFycm93aW5nICovXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29kZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIExpdmVibG9ja3NFcnJvciBmcm9tIGEgZ2VuZXJpYyBlcnJvciwgYnkgYXR0YWNoaW5nIExpdmVibG9ja3NcbiAgICogY29udGV4dHVhbCBpbmZvcm1hdGlvbiBsaWtlIHJvb20gSUQsIHRocmVhZCBJRCwgZXRjLlxuICAgKi9cbiAgc3RhdGljIGZyb20oY29udGV4dCwgY2F1c2UpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlYmxvY2tzRXJyb3IoXG4gICAgICBkZWZhdWx0TWVzc2FnZUZyb21Db250ZXh0KGNvbnRleHQpLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNhdXNlXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGRlZmF1bHRNZXNzYWdlRnJvbUNvbnRleHQoY29udGV4dCkge1xuICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgIGNhc2UgXCJST09NX0NPTk5FQ1RJT05fRVJST1JcIjoge1xuICAgICAgc3dpdGNoIChjb250ZXh0LmNvZGUpIHtcbiAgICAgICAgY2FzZSA0MDAxOlxuICAgICAgICAgIHJldHVybiBcIk5vdCBhbGxvd2VkIHRvIGNvbm5lY3QgdG8gdGhlIHJvb21cIjtcbiAgICAgICAgY2FzZSA0MDA1OlxuICAgICAgICAgIHJldHVybiBcIlJvb20gaXMgYWxyZWFkeSBmdWxsXCI7XG4gICAgICAgIGNhc2UgNDAwNjpcbiAgICAgICAgICByZXR1cm4gXCJLaWNrZWQgb3V0IG9mIHRoZSByb29tLCBiZWNhdXNlIHRoZSByb29tIElEIGNoYW5nZWRcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gXCJDb3VsZCBub3QgY29ubmVjdCB0byB0aGUgcm9vbVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXNlIFwiQ1JFQVRFX1RIUkVBRF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGNyZWF0ZSBuZXcgdGhyZWFkXCI7XG4gICAgY2FzZSBcIkRFTEVURV9USFJFQURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgdGhyZWFkXCI7XG4gICAgY2FzZSBcIkVESVRfVEhSRUFEX01FVEFEQVRBX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgZWRpdCB0aHJlYWQgbWV0YWRhdGFcIjtcbiAgICBjYXNlIFwiTUFSS19USFJFQURfQVNfUkVTT0xWRURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBtYXJrIHRocmVhZCBhcyByZXNvbHZlZFwiO1xuICAgIGNhc2UgXCJNQVJLX1RIUkVBRF9BU19VTlJFU09MVkVEX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgbWFyayB0aHJlYWQgYXMgdW5yZXNvbHZlZFwiO1xuICAgIGNhc2UgXCJDUkVBVEVfQ09NTUVOVF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGNyZWF0ZSBuZXcgY29tbWVudFwiO1xuICAgIGNhc2UgXCJFRElUX0NPTU1FTlRfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBlZGl0IGNvbW1lbnRcIjtcbiAgICBjYXNlIFwiREVMRVRFX0NPTU1FTlRfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgY29tbWVudFwiO1xuICAgIGNhc2UgXCJBRERfUkVBQ1RJT05fRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBhZGQgcmVhY3Rpb25cIjtcbiAgICBjYXNlIFwiUkVNT1ZFX1JFQUNUSU9OX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgcmVtb3ZlIHJlYWN0aW9uXCI7XG4gICAgY2FzZSBcIk1BUktfSU5CT1hfTk9USUZJQ0FUSU9OX0FTX1JFQURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBtYXJrIGluYm94IG5vdGlmaWNhdGlvbiBhcyByZWFkXCI7XG4gICAgY2FzZSBcIkRFTEVURV9JTkJPWF9OT1RJRklDQVRJT05fRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgaW5ib3ggbm90aWZpY2F0aW9uXCI7XG4gICAgY2FzZSBcIk1BUktfQUxMX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IG1hcmsgYWxsIGluYm94IG5vdGlmaWNhdGlvbnMgYXMgcmVhZFwiO1xuICAgIGNhc2UgXCJERUxFVEVfQUxMX0lOQk9YX05PVElGSUNBVElPTlNfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgYWxsIGluYm94IG5vdGlmaWNhdGlvbnNcIjtcbiAgICBjYXNlIFwiVVBEQVRFX05PVElGSUNBVElPTl9TRVRUSU5HU19FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IHVwZGF0ZSBub3RpZmljYXRpb24gc2V0dGluZ3NcIjtcbiAgICBjYXNlIFwiVVBEQVRFX1VTRVJfTk9USUZJQ0FUSU9OX1NFVFRJTkdTX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgdXBkYXRlIHVzZXIgbm90aWZpY2F0aW9uIHNldHRpbmdzXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihjb250ZXh0LCBcIlVuaGFuZGxlZCBjYXNlXCIpO1xuICB9XG59XG5cbi8vIHNyYy9yb29tLnRzXG52YXIgTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUgPSAxMDI0ICogMTAyNCAtIDUxMjtcbmZ1bmN0aW9uIG1ha2VJZEZhY3RvcnkoY29ubmVjdGlvbklkKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIHJldHVybiAoKSA9PiBgJHtjb25uZWN0aW9uSWR9OiR7Y291bnQrK31gO1xufVxuZnVuY3Rpb24gdXNlclRvVHJlZU5vZGUoa2V5LCB1c2VyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJVc2VyXCIsXG4gICAgaWQ6IGAke3VzZXIuY29ubmVjdGlvbklkfWAsXG4gICAga2V5LFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIGNvbm5lY3Rpb25JZDogdXNlci5jb25uZWN0aW9uSWQsXG4gICAgICBpZDogdXNlci5pZCxcbiAgICAgIGluZm86IHVzZXIuaW5mbyxcbiAgICAgIHByZXNlbmNlOiB1c2VyLnByZXNlbmNlLFxuICAgICAgaXNSZWFkT25seTogIXVzZXIuY2FuV3JpdGVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpIHtcbiAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gIGNvbnN0IGluQmFja2dyb3VuZFNpbmNlID0geyBjdXJyZW50OiBudWxsIH07XG4gIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID8/IERhdGUubm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgIGRvYz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgfTtcbiAgcmV0dXJuIFtpbkJhY2tncm91bmRTaW5jZSwgdW5zdWJdO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbShvcHRpb25zLCBjb25maWcpIHtcbiAgY29uc3QgaW5pdGlhbFByZXNlbmNlID0gb3B0aW9ucy5pbml0aWFsUHJlc2VuY2U7XG4gIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gb3B0aW9ucy5pbml0aWFsU3RvcmFnZTtcbiAgY29uc3QgaHR0cENsaWVudCA9IGNvbmZpZy5yb29tSHR0cENsaWVudDtcbiAgY29uc3QgW2luQmFja2dyb3VuZFNpbmNlLCB1bmluc3RhbGxCZ1RhYlNweV0gPSBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpO1xuICBjb25zdCBkZWxlZ2F0ZXMgPSB7XG4gICAgLi4uY29uZmlnLmRlbGVnYXRlcyxcbiAgICAvLyBBIGNvbm5lY3Rpb24gaXMgYWxsb3dlZCB0byBnbyBpbnRvIFwiem9tYmllIHN0YXRlXCIgb25seSBpZiBhbGwgb2YgdGhlXG4gICAgLy8gZm9sbG93aW5nIGNvbmRpdGlvbnMgYXBwbHk6XG4gICAgLy9cbiAgICAvLyAtIFRoZSBgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRgIGNsaWVudCBvcHRpb24gaXMgY29uZmlndXJlZFxuICAgIC8vIC0gVGhlIGJyb3dzZXIgd2luZG93IGhhcyBiZWVuIGluIHRoZSBiYWNrZ3JvdW5kIGZvciBhdCBsZWFzdFxuICAgIC8vICAgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBtaWxsaXNlY29uZHNcbiAgICAvLyAtIFRoZXJlIGFyZSBubyBwZW5kaW5nIGNoYW5nZXNcbiAgICAvL1xuICAgIGNhblpvbWJpZSgpIHtcbiAgICAgIHJldHVybiBjb25maWcuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgIT09IHZvaWQgMCAmJiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICE9PSBudWxsICYmIERhdGUubm93KCkgPiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICsgY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICYmIGdldFN0b3JhZ2VTdGF0dXMoKSAhPT0gXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9O1xuICBjb25zdCBtYW5hZ2VkU29ja2V0ID0gbmV3IE1hbmFnZWRTb2NrZXQoXG4gICAgZGVsZWdhdGVzLFxuICAgIGNvbmZpZy5lbmFibGVEZWJ1Z0xvZ2dpbmdcbiAgKTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBidWZmZXI6IHtcbiAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgbGFzdEZsdXNoZWRBdDogMCxcbiAgICAgIHByZXNlbmNlVXBkYXRlczogKFxuICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgaW5pdGlhbCBwcmVzZW5jZSBtZXNzYWdlIGFzIGEgRnVsbCBQcmVzZW5jZeKEoiB1cGRhdGVcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgICAgIGRhdGE6IGluaXRpYWxQcmVzZW5jZVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgc3RvcmFnZU9wZXJhdGlvbnM6IFtdXG4gICAgfSxcbiAgICBzdGF0aWNTZXNzaW9uSW5mb1NpZzogbmV3IFNpZ25hbChudWxsKSxcbiAgICBkeW5hbWljU2Vzc2lvbkluZm9TaWc6IG5ldyBTaWduYWwobnVsbCksXG4gICAgbXlQcmVzZW5jZTogbmV3IFBhdGNoYWJsZVNpZ25hbChpbml0aWFsUHJlc2VuY2UpLFxuICAgIG90aGVyczogbmV3IE1hbmFnZWRPdGhlcnMoKSxcbiAgICBpbml0aWFsU3RvcmFnZSxcbiAgICBpZEZhY3Rvcnk6IG51bGwsXG4gICAgLy8gVGhlIFlqcyBwcm92aWRlciBhc3NvY2lhdGVkIHRvIHRoaXMgcm9vbVxuICAgIHlqc1Byb3ZpZGVyOiB2b2lkIDAsXG4gICAgeWpzUHJvdmlkZXJEaWRDaGFuZ2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIFN0b3JhZ2VcbiAgICBjbG9jazogMCxcbiAgICBvcENsb2NrOiAwLFxuICAgIG5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICB1bmRvU3RhY2s6IFtdLFxuICAgIHJlZG9TdGFjazogW10sXG4gICAgcGF1c2VkSGlzdG9yeTogbnVsbCxcbiAgICBhY3RpdmVCYXRjaDogbnVsbCxcbiAgICB1bmFja25vd2xlZGdlZE9wczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAvLyBEZWJ1Z1xuICAgIG9wU3RhY2tUcmFjZXM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkgOiB2b2lkIDBcbiAgfTtcbiAgbGV0IGxhc3RUb2tlbktleTtcbiAgZnVuY3Rpb24gb25TdGF0dXNEaWRDaGFuZ2UobmV3U3RhdHVzKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gbWFuYWdlZFNvY2tldC5hdXRoVmFsdWU7XG4gICAgaWYgKGF1dGhWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdG9rZW5LZXkgPSBnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKTtcbiAgICAgIGlmICh0b2tlbktleSAhPT0gbGFzdFRva2VuS2V5KSB7XG4gICAgICAgIGxhc3RUb2tlbktleSA9IHRva2VuS2V5O1xuICAgICAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIpIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQ7XG4gICAgICAgICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mb1NpZy5zZXQoe1xuICAgICAgICAgICAgdXNlcklkOiB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaWQgOiB0b2tlbi51aWQsXG4gICAgICAgICAgICB1c2VySW5mbzogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmluZm8gOiB0b2tlbi51aVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm9TaWcuc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdm9pZCAwLFxuICAgICAgICAgICAgdXNlckluZm86IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50SHViLnN0YXR1cy5ub3RpZnkobmV3U3RhdHVzKTtcbiAgICBub3RpZnlTZWxmQ2hhbmdlZCgpO1xuICB9XG4gIGxldCBfY29ubmVjdGlvbkxvc3NUaW1lcklkO1xuICBsZXQgX2hhc0xvc3RDb25uZWN0aW9uID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGhhbmRsZUNvbm5lY3Rpb25Mb3NzRXZlbnQobmV3U3RhdHVzKSB7XG4gICAgaWYgKG5ld1N0YXR1cyA9PT0gXCJyZWNvbm5lY3RpbmdcIikge1xuICAgICAgX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJsb3N0XCIpO1xuICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250ZXh0Lm90aGVycy5jbGVhck90aGVycygpO1xuICAgICAgICBub3RpZnkoeyBvdGhlcnM6IFt7IHR5cGU6IFwicmVzZXRcIiB9XSB9KTtcbiAgICAgIH0sIGNvbmZpZy5sb3N0Q29ubmVjdGlvblRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCk7XG4gICAgICBpZiAoX2hhc0xvc3RDb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChuZXdTdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJmYWlsZWRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwicmVzdG9yZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgX2hhc0xvc3RDb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uRGlkQ29ubmVjdCgpIHtcbiAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7XG4gICAgICB0eXBlOiBcImZ1bGxcIixcbiAgICAgIGRhdGE6IChcbiAgICAgICAgLy8gQmVjYXVzZSBjb250ZXh0Lm1lLmN1cnJlbnQgaXMgYSByZWFkb25seSBvYmplY3QsIHdlJ2xsIGhhdmUgdG9cbiAgICAgICAgLy8gbWFrZSBhIGNvcHkgaGVyZS4gT3RoZXJ3aXNlLCB0eXBlIGVycm9ycyBoYXBwZW4gbGF0ZXIgd2hlblxuICAgICAgICAvLyBcInBhdGNoaW5nXCIgbXkgcHJlc2VuY2UuXG4gICAgICAgIHsgLi4uY29udGV4dC5teVByZXNlbmNlLmdldCgpIH1cbiAgICAgIClcbiAgICB9O1xuICAgIGlmIChfZ2V0U3RvcmFnZSQgIT09IG51bGwpIHtcbiAgICAgIHJlZnJlc2hTdG9yYWdlKHsgZmx1c2g6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIG9uRGlkRGlzY29ubmVjdCgpIHtcbiAgICBjbGVhclRpbWVvdXQoY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEKTtcbiAgfVxuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5vbk1lc3NhZ2Uuc3Vic2NyaWJlKGhhbmRsZVNlcnZlck1lc3NhZ2UpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5zdGF0dXNEaWRDaGFuZ2Uuc3Vic2NyaWJlKG9uU3RhdHVzRGlkQ2hhbmdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShoYW5kbGVDb25uZWN0aW9uTG9zc0V2ZW50KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuZGlkQ29ubmVjdC5zdWJzY3JpYmUob25EaWRDb25uZWN0KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuZGlkRGlzY29ubmVjdC5zdWJzY3JpYmUob25EaWREaXNjb25uZWN0KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25Db25uZWN0aW9uRXJyb3Iuc3Vic2NyaWJlKCh7IG1lc3NhZ2UsIGNvZGUgfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBcIlJPT01fQ09OTkVDVElPTl9FUlJPUlwiO1xuICAgIGNvbnN0IGVyciA9IG5ldyBMaXZlYmxvY2tzRXJyb3IobWVzc2FnZSwgeyB0eXBlLCBjb2RlLCByb29tSWQgfSk7XG4gICAgY29uc3QgZGlkTm90aWZ5ID0gY29uZmlnLmVycm9yRXZlbnRTb3VyY2Uubm90aWZ5KGVycik7XG4gICAgaWYgKCFkaWROb3RpZnkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZXJyb3IyKFxuICAgICAgICAgIGBDb25uZWN0aW9uIHRvIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkLiBSZWFzb246ICR7bWVzc2FnZX0gKGNvZGU6ICR7Y29kZX0pLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBwb29sID0ge1xuICAgIHJvb21JZDogY29uZmlnLnJvb21JZCxcbiAgICBnZXROb2RlOiAoaWQpID0+IGNvbnRleHQubm9kZXMuZ2V0KGlkKSxcbiAgICBhZGROb2RlOiAoaWQsIG5vZGUpID0+IHZvaWQgY29udGV4dC5ub2Rlcy5zZXQoaWQsIG5vZGUpLFxuICAgIGRlbGV0ZU5vZGU6IChpZCkgPT4gdm9pZCBjb250ZXh0Lm5vZGVzLmRlbGV0ZShpZCksXG4gICAgZ2VuZXJhdGVJZDogKCkgPT4gYCR7Z2V0Q29ubmVjdGlvbklkKCl9OiR7Y29udGV4dC5jbG9jaysrfWAsXG4gICAgZ2VuZXJhdGVPcElkOiAoKSA9PiBgJHtnZXRDb25uZWN0aW9uSWQoKX06JHtjb250ZXh0Lm9wQ2xvY2srK31gLFxuICAgIGRpc3BhdGNoKG9wcywgcmV2ZXJzZSwgc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhY2tUcmFjZSA9IGNhcHR1cmVTdGFja1RyYWNlKFwiU3RvcmFnZSBtdXRhdGlvblwiLCB0aGlzLmRpc3BhdGNoKTtcbiAgICAgICAgaWYgKHN0YWNrVHJhY2UpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICAgICAgaWYgKG9wLm9wSWQpIHtcbiAgICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5zZXQob3Aub3BJZCwgc3RhY2tUcmFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlQmF0Y2gpIHtcbiAgICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC5vcHMucHVzaChvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgIGFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnB1c2hMZWZ0KHJldmVyc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVG9VbmRvU3RhY2socmV2ZXJzZSk7XG4gICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIGRpc3BhdGNoT3BzKG9wcyk7XG4gICAgICAgIG5vdGlmeSh7IHN0b3JhZ2VVcGRhdGVzIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGU6ICgpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvU2lnLmdldCgpPy5zY29wZXM7XG4gICAgICBpZiAoc2NvcGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKTtcbiAgICAgIGlmICghY2FuV3JpdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IHdyaXRlIHRvIHN0b3JhZ2Ugd2l0aCBhIHJlYWQgb25seSB1c2VyLCBwbGVhc2UgZW5zdXJlIHRoZSB1c2VyIGhhcyB3cml0ZSBwZXJtaXNzaW9uc1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBldmVudEh1YiA9IHtcbiAgICBzdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIE5ldy9yZWNvbW1lbmRlZCBBUElcbiAgICBsb3N0Q29ubmVjdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgY3VzdG9tRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHNlbGY6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG15UHJlc2VuY2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG90aGVyczogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZUJhdGNoOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBoaXN0b3J5OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlRGlkTG9hZDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZVN0YXR1czogbWFrZUV2ZW50U291cmNlKCksXG4gICAgeWRvYzogbWFrZUV2ZW50U291cmNlKCksXG4gICAgY29tbWVudHM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHJvb21XaWxsRGVzdHJveTogbWFrZUV2ZW50U291cmNlKClcbiAgfTtcbiAgY29uc3Qgcm9vbUlkID0gY29uZmlnLnJvb21JZDtcbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGV4dE1lbnRpb24odXNlcklkLCBtZW50aW9uSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5jcmVhdGVUZXh0TWVudGlvbih7IHJvb21JZCwgdXNlcklkLCBtZW50aW9uSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGV4dE1lbnRpb24obWVudGlvbklkKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZGVsZXRlVGV4dE1lbnRpb24oeyByb29tSWQsIG1lbnRpb25JZCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZXBvcnRUZXh0RWRpdG9yKHR5cGUsIHJvb3RLZXkpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnJlcG9ydFRleHRFZGl0b3IoeyByb29tSWQsIHR5cGUsIHJvb3RLZXkgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbGlzdFRleHRWZXJzaW9ucygpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5saXN0VGV4dFZlcnNpb25zKHsgcm9vbUlkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnNTaW5jZShvcHRpb25zMikge1xuICAgIHJldHVybiBodHRwQ2xpZW50Lmxpc3RUZXh0VmVyc2lvbnNTaW5jZSh7XG4gICAgICByb29tSWQsXG4gICAgICBzaW5jZTogb3B0aW9uczIuc2luY2UsXG4gICAgICBzaWduYWw6IG9wdGlvbnMyLnNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRleHRWZXJzaW9uKHZlcnNpb25JZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmdldFRleHRWZXJzaW9uKHsgcm9vbUlkLCB2ZXJzaW9uSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGV4dFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuY3JlYXRlVGV4dFZlcnNpb24oeyByb29tSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUNvbnRleHR1YWxQcm9tcHQob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5leGVjdXRlQ29udGV4dHVhbFByb21wdCh7XG4gICAgICByb29tSWQsXG4gICAgICAuLi5vcHRpb25zMlxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uKiBjaHVua09wcyhtc2cpIHtcbiAgICBjb25zdCB7IG9wcywgLi4ucmVzdCB9ID0gbXNnO1xuICAgIGlmIChvcHMubGVuZ3RoIDwgMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNwbGl0IG9wcyBpbnRvIHNtYWxsZXIgY2h1bmtzXCIpO1xuICAgIH1cbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKG9wcy5sZW5ndGggLyAyKTtcbiAgICBjb25zdCBmaXJzdEhhbGYgPSBvcHMuc2xpY2UoMCwgbWlkKTtcbiAgICBjb25zdCBzZWNvbmRIYWxmID0gb3BzLnNsaWNlKG1pZCk7XG4gICAgZm9yIChjb25zdCBoYWxmT3BzIG9mIFtmaXJzdEhhbGYsIHNlY29uZEhhbGZdKSB7XG4gICAgICBjb25zdCBoYWxmID0geyBvcHM6IGhhbGZPcHMsIC4uLnJlc3QgfTtcbiAgICAgIGNvbnN0IHRleHQgPSBzdHJpbmdpZnlPckxvZyhbaGFsZl0pO1xuICAgICAgaWYgKCFpc1Rvb0JpZ0ZvcldlYlNvY2tldCh0ZXh0KSkge1xuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQqIGNodW5rT3BzKGhhbGYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiogY2h1bmtNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPCAyKSB7XG4gICAgICBpZiAobWVzc2FnZXNbMF0udHlwZSA9PT0gMjAxIC8qIFVQREFURV9TVE9SQUdFICovKSB7XG4gICAgICAgIHlpZWxkKiBjaHVua09wcyhtZXNzYWdlc1swXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCBzcGxpdCBpbnRvIGNodW5rcyBzbWFsbGVyIHRoYW4gdGhlIGFsbG93ZWQgbWVzc2FnZSBzaXplXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcihtZXNzYWdlcy5sZW5ndGggLyAyKTtcbiAgICBjb25zdCBmaXJzdEhhbGYgPSBtZXNzYWdlcy5zbGljZSgwLCBtaWQpO1xuICAgIGNvbnN0IHNlY29uZEhhbGYgPSBtZXNzYWdlcy5zbGljZShtaWQpO1xuICAgIGZvciAoY29uc3QgaGFsZiBvZiBbZmlyc3RIYWxmLCBzZWNvbmRIYWxmXSkge1xuICAgICAgY29uc3QgdGV4dCA9IHN0cmluZ2lmeU9yTG9nKGhhbGYpO1xuICAgICAgaWYgKCFpc1Rvb0JpZ0ZvcldlYlNvY2tldCh0ZXh0KSkge1xuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQqIGNodW5rTWVzc2FnZXMoaGFsZik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzVG9vQmlnRm9yV2ViU29ja2V0KHRleHQpIHtcbiAgICBpZiAodGV4dC5sZW5ndGggKiA0IDwgTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXh0KS5sZW5ndGggPj0gTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkU7XG4gIH1cbiAgZnVuY3Rpb24gc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgY29uc3Qgc3RyYXRlZ3kgPSBjb25maWcubGFyZ2VNZXNzYWdlU3RyYXRlZ3kgPz8gXCJkZWZhdWx0XCI7XG4gICAgY29uc3QgdGV4dCA9IHN0cmluZ2lmeU9yTG9nKG1lc3NhZ2VzKTtcbiAgICBpZiAoIWlzVG9vQmlnRm9yV2ViU29ja2V0KHRleHQpKSB7XG4gICAgICByZXR1cm4gbWFuYWdlZFNvY2tldC5zZW5kKHRleHQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICBjYXNlIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgIGVycm9yMihcIk1lc3NhZ2UgaXMgdG9vIGxhcmdlIGZvciB3ZWJzb2NrZXRzLCBub3Qgc2VuZGluZy4gQ29uZmlndXJlIGxhcmdlTWVzc2FnZVN0cmF0ZWd5IG9wdGlvbiB0byBkZWFsIHdpdGggdGhpcy5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJzcGxpdFwiOiB7XG4gICAgICAgIHdhcm4oXCJNZXNzYWdlIGlzIHRvbyBsYXJnZSBmb3Igd2Vic29ja2V0cywgc3BsaXR0aW5nIGludG8gc21hbGxlciBjaHVua3NcIik7XG4gICAgICAgIGZvciAoY29uc3QgY2h1bmsyIG9mIGNodW5rTWVzc2FnZXMobWVzc2FnZXMpKSB7XG4gICAgICAgICAgbWFuYWdlZFNvY2tldC5zZW5kKGNodW5rMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FzZSBcImV4cGVyaW1lbnRhbC1mYWxsYmFjay10by1odHRwXCI6IHtcbiAgICAgICAgd2FybihcIk1lc3NhZ2UgaXMgdG9vIGxhcmdlIGZvciB3ZWJzb2NrZXRzLCBzbyBzZW5kaW5nIG92ZXIgSFRUUCBpbnN0ZWFkXCIpO1xuICAgICAgICBjb25zdCBub25jZSA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvU2lnLmdldCgpPy5ub25jZSA/PyByYWlzZShcIlNlc3Npb24gaXMgbm90IGF1dGhvcml6ZWQgdG8gc2VuZCBtZXNzYWdlIG92ZXIgSFRUUFwiKTtcbiAgICAgICAgdm9pZCBodHRwQ2xpZW50LnNlbmRNZXNzYWdlcyh7IHJvb21JZCwgbm9uY2UsIG1lc3NhZ2VzIH0pLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICBpZiAoIXJlc3Aub2sgJiYgcmVzcC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgICAgbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGYgPSBEZXJpdmVkU2lnbmFsLmZyb20oXG4gICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mb1NpZyxcbiAgICBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mb1NpZyxcbiAgICBjb250ZXh0Lm15UHJlc2VuY2UsXG4gICAgKHN0YXRpY1Nlc3Npb24sIGR5bmFtaWNTZXNzaW9uLCBteVByZXNlbmNlKSA9PiB7XG4gICAgICBpZiAoc3RhdGljU2Vzc2lvbiA9PT0gbnVsbCB8fCBkeW5hbWljU2Vzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNhbldyaXRlID0gY2FuV3JpdGVTdG9yYWdlKGR5bmFtaWNTZXNzaW9uLnNjb3Blcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29ubmVjdGlvbklkOiBkeW5hbWljU2Vzc2lvbi5hY3RvcixcbiAgICAgICAgICBpZDogc3RhdGljU2Vzc2lvbi51c2VySWQsXG4gICAgICAgICAgaW5mbzogc3RhdGljU2Vzc2lvbi51c2VySW5mbyxcbiAgICAgICAgICBwcmVzZW5jZTogbXlQcmVzZW5jZSxcbiAgICAgICAgICBjYW5Xcml0ZSxcbiAgICAgICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGR5bmFtaWNTZXNzaW9uLnNjb3BlcylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGxldCBfbGFzdFNlbGY7XG4gIGZ1bmN0aW9uIG5vdGlmeVNlbGZDaGFuZ2VkKCkge1xuICAgIGNvbnN0IGN1cnJTZWxmID0gc2VsZi5nZXQoKTtcbiAgICBpZiAoY3VyclNlbGYgIT09IG51bGwgJiYgY3VyclNlbGYgIT09IF9sYXN0U2VsZikge1xuICAgICAgZXZlbnRIdWIuc2VsZi5ub3RpZnkoY3VyclNlbGYpO1xuICAgICAgX2xhc3RTZWxmID0gY3VyclNlbGY7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGZBc1RyZWVOb2RlID0gRGVyaXZlZFNpZ25hbC5mcm9tKFxuICAgIHNlbGYsXG4gICAgKG1lKSA9PiBtZSAhPT0gbnVsbCA/IHVzZXJUb1RyZWVOb2RlKFwiTWVcIiwgbWUpIDogbnVsbFxuICApO1xuICBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVJvb3RGcm9tTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogY2Fubm90IGxvYWQgc3RvcmFnZSB3aXRob3V0IGl0ZW1zXCIpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHVwZGF0ZVJvb3QobWVzc2FnZS5pdGVtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQucm9vdCA9IExpdmVPYmplY3QuX2Zyb21JdGVtcyhtZXNzYWdlLml0ZW1zLCBwb29sKTtcbiAgICB9XG4gICAgY29uc3QgY2FuV3JpdGUgPSBzZWxmLmdldCgpPy5jYW5Xcml0ZSA/PyB0cnVlO1xuICAgIGNvbnN0IHN0YWNrU2l6ZUJlZm9yZSA9IGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0LmluaXRpYWxTdG9yYWdlKSB7XG4gICAgICBpZiAoY29udGV4dC5yb290LmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGNhbldyaXRlKSB7XG4gICAgICAgICAgY29udGV4dC5yb290LnNldChrZXksIGNsb25lTHNvbihjb250ZXh0LmluaXRpYWxTdG9yYWdlW2tleV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEF0dGVtcHRlZCB0byBwb3B1bGF0ZSBtaXNzaW5nIHN0b3JhZ2Uga2V5ICcke2tleX0nLCBidXQgY3VycmVudCB1c2VyIGhhcyBubyB3cml0ZSBhY2Nlc3NgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSBzdGFja1NpemVCZWZvcmU7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUm9vdChpdGVtcykge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50SXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBub2RlXSBvZiBjb250ZXh0Lm5vZGVzKSB7XG4gICAgICBjdXJyZW50SXRlbXMuc2V0KGlkLCBub2RlLl9zZXJpYWxpemUoKSk7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IGdldFRyZWVzRGlmZk9wZXJhdGlvbnMoY3VycmVudEl0ZW1zLCBuZXcgTWFwKGl0ZW1zKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMob3BzLCBmYWxzZSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzKTtcbiAgfVxuICBmdW5jdGlvbiBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMpIHtcbiAgICBpZiAoY29udGV4dC51bmRvU3RhY2subGVuZ3RoID49IDUwKSB7XG4gICAgICBjb250ZXh0LnVuZG9TdGFjay5zaGlmdCgpO1xuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5wdXNoKGhpc3RvcnlPcHMpO1xuICAgIG9uSGlzdG9yeUNoYW5nZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFRvVW5kb1N0YWNrKGhpc3RvcnlPcHMpIHtcbiAgICBpZiAoY29udGV4dC5wYXVzZWRIaXN0b3J5ICE9PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkucHVzaExlZnQoaGlzdG9yeU9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeSh1cGRhdGVzKSB7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSB1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzO1xuICAgIGNvbnN0IG90aGVyc1VwZGF0ZXMgPSB1cGRhdGVzLm90aGVycztcbiAgICBpZiAob3RoZXJzVXBkYXRlcyAhPT0gdm9pZCAwICYmIG90aGVyc1VwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuZ2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIG90aGVyc1VwZGF0ZXMpIHtcbiAgICAgICAgZXZlbnRIdWIub3RoZXJzLm5vdGlmeSh7IC4uLmV2ZW50LCBvdGhlcnMgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGVzLnByZXNlbmNlID8/IGZhbHNlKSB7XG4gICAgICBub3RpZnlTZWxmQ2hhbmdlZCgpO1xuICAgICAgZXZlbnRIdWIubXlQcmVzZW5jZS5ub3RpZnkoY29udGV4dC5teVByZXNlbmNlLmdldCgpKTtcbiAgICB9XG4gICAgaWYgKHN0b3JhZ2VVcGRhdGVzICE9PSB2b2lkIDAgJiYgc3RvcmFnZVVwZGF0ZXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IHVwZGF0ZXMyID0gQXJyYXkuZnJvbShzdG9yYWdlVXBkYXRlcy52YWx1ZXMoKSk7XG4gICAgICBldmVudEh1Yi5zdG9yYWdlQmF0Y2gubm90aWZ5KHVwZGF0ZXMyKTtcbiAgICB9XG4gICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICB9XG4gIGZ1bmN0aW9uIGdldENvbm5lY3Rpb25JZCgpIHtcbiAgICBjb25zdCBpbmZvID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm9TaWcuZ2V0KCk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmFjdG9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludGVybmFsLiBUcmllZCB0byBnZXQgY29ubmVjdGlvbiBpZCBidXQgY29ubmVjdGlvbiB3YXMgbmV2ZXIgb3BlblwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wcyhyYXdPcHMsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICByZXZlcnNlOiBuZXcgRGVxdWUoKSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgcHJlc2VuY2U6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVkTm9kZUlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgb3BzID0gcmF3T3BzLm1hcCgob3ApID0+IHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIgJiYgIW9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ub3AsIG9wSWQ6IHBvb2wuZ2VuZXJhdGVPcElkKCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgPT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb25zdCByZXZlcnNlID0ge1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgcmV2ZXJzZS5kYXRhW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuZ2V0KClba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Lm15UHJlc2VuY2UucGF0Y2gob3AuZGF0YSk7XG4gICAgICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7IHR5cGU6IFwicGFydGlhbFwiLCBkYXRhOiBvcC5kYXRhIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFba2V5XSA9IG9wLmRhdGFba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnJldmVyc2UucHVzaExlZnQocmV2ZXJzZSk7XG4gICAgICAgIG91dHB1dC5wcmVzZW5jZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc291cmNlO1xuICAgICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICAgIHNvdXJjZSA9IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9wSWQgPSBubihvcC5vcElkKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBubihjb250ZXh0Lm9wU3RhY2tUcmFjZXMpLmRlbGV0ZShvcElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGVsZXRlZCA9IGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuZGVsZXRlKG9wSWQpO1xuICAgICAgICAgIHNvdXJjZSA9IGRlbGV0ZWQgPyAyIC8qIEFDSyAqLyA6IDEgLyogUkVNT1RFICovO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGx5T3BSZXN1bHQgPSBhcHBseU9wKG9wLCBzb3VyY2UpO1xuICAgICAgICBpZiAoYXBwbHlPcFJlc3VsdC5tb2RpZmllZCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVJZCA9IGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQ7XG4gICAgICAgICAgaWYgKCEobm9kZUlkICYmIGNyZWF0ZWROb2RlSWRzLmhhcyhub2RlSWQpKSkge1xuICAgICAgICAgICAgb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgICAgbm4oYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZCksXG4gICAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgICAgb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLmdldChubihhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkKSksXG4gICAgICAgICAgICAgICAgYXBwbHlPcFJlc3VsdC5tb2RpZmllZFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3V0cHV0LnJldmVyc2UucHVzaExlZnQoYXBwbHlPcFJlc3VsdC5yZXZlcnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wLnR5cGUgPT09IDIgLyogQ1JFQVRFX0xJU1QgKi8gfHwgb3AudHlwZSA9PT0gNyAvKiBDUkVBVEVfTUFQICovIHx8IG9wLnR5cGUgPT09IDQgLyogQ1JFQVRFX09CSkVDVCAqLykge1xuICAgICAgICAgICAgY3JlYXRlZE5vZGVJZHMuYWRkKG5uKG9wLmlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvcHMsXG4gICAgICByZXZlcnNlOiBBcnJheS5mcm9tKG91dHB1dC5yZXZlcnNlKSxcbiAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXM6IG91dHB1dC5zdG9yYWdlVXBkYXRlcyxcbiAgICAgICAgcHJlc2VuY2U6IG91dHB1dC5wcmVzZW5jZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlPcChvcCwgc291cmNlKSB7XG4gICAgaWYgKGlzQWNrT3Aob3ApKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi86XG4gICAgICBjYXNlIDMgLyogVVBEQVRFX09CSkVDVCAqLzpcbiAgICAgIGNhc2UgNSAvKiBERUxFVEVfQ1JEVCAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuX2FwcGx5KG9wLCBzb3VyY2UgPT09IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgMSAvKiBTRVRfUEFSRU5UX0tFWSAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudC5ub2RlLl9zZXRDaGlsZEtleShcbiAgICAgICAgICAgIGFzUG9zKG9wLnBhcmVudEtleSksXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOiB7XG4gICAgICAgIGlmIChvcC5wYXJlbnRJZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLnBhcmVudElkKTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnROb2RlLl9hdHRhY2hDaGlsZChvcCwgc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUHJlc2VuY2UocGF0Y2gsIG9wdGlvbnMyKSB7XG4gICAgY29uc3Qgb2xkVmFsdWVzID0ge307XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0ge1xuICAgICAgICB0eXBlOiBcInBhcnRpYWxcIixcbiAgICAgICAgZGF0YToge31cbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICBjb25zdCBvdmVycmlkZVZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgIGlmIChvdmVycmlkZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3ZlcnJpZGVWYWx1ZTtcbiAgICAgIG9sZFZhbHVlc1trZXldID0gY29udGV4dC5teVByZXNlbmNlLmdldCgpW2tleV07XG4gICAgfVxuICAgIGNvbnRleHQubXlQcmVzZW5jZS5wYXRjaChwYXRjaCk7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIGlmIChvcHRpb25zMj8uYWRkVG9IaXN0b3J5KSB7XG4gICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gucmV2ZXJzZU9wcy5wdXNoTGVmdCh7XG4gICAgICAgICAgdHlwZTogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgIGRhdGE6IG9sZFZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gudXBkYXRlcy5wcmVzZW5jZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgICBpZiAob3B0aW9uczI/LmFkZFRvSGlzdG9yeSkge1xuICAgICAgICBhZGRUb1VuZG9TdGFjayhbeyB0eXBlOiBcInByZXNlbmNlXCIsIGRhdGE6IG9sZFZhbHVlcyB9XSk7XG4gICAgICB9XG4gICAgICBub3RpZnkoeyBwcmVzZW5jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLnRhcmdldEFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IG9sZFVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgY29udGV4dC5vdGhlcnMuc2V0T3RoZXIobWVzc2FnZS5hY3RvciwgbWVzc2FnZS5kYXRhKTtcbiAgICAgIGNvbnN0IG5ld1VzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgaWYgKG9sZFVzZXIgPT09IHZvaWQgMCAmJiBuZXdVc2VyICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlbnRlclwiLCB1c2VyOiBuZXdVc2VyIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnBhdGNoT3RoZXIobWVzc2FnZS5hY3RvciwgbWVzc2FnZS5kYXRhKSwgbWVzc2FnZTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgIHVwZGF0ZXM6IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgdXNlclxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VyTGVmdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICBjb250ZXh0Lm90aGVycy5yZW1vdmVDb25uZWN0aW9uKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJsZWF2ZVwiLCB1c2VyIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIG9uUm9vbVN0YXRlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm9TaWcuc2V0KHtcbiAgICAgIGFjdG9yOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgbm9uY2U6IG1lc3NhZ2Uubm9uY2UsXG4gICAgICBzY29wZXM6IG1lc3NhZ2Uuc2NvcGVzXG4gICAgfSk7XG4gICAgY29udGV4dC5pZEZhY3RvcnkgPSBtYWtlSWRGYWN0b3J5KG1lc3NhZ2UuYWN0b3IpO1xuICAgIG5vdGlmeVNlbGZDaGFuZ2VkKCk7XG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uSWQgb2YgY29udGV4dC5vdGhlcnMuY29ubmVjdGlvbklkcygpKSB7XG4gICAgICBjb25zdCB1c2VyID0gbWVzc2FnZS51c2Vyc1tjb25uZWN0aW9uSWRdO1xuICAgICAgaWYgKHVzZXIgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250ZXh0Lm90aGVycy5yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG1lc3NhZ2UudXNlcnMpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2tleV07XG4gICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSBOdW1iZXIoa2V5KTtcbiAgICAgIGNvbnRleHQub3RoZXJzLnNldENvbm5lY3Rpb24oXG4gICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgdXNlci5pZCxcbiAgICAgICAgdXNlci5pbmZvLFxuICAgICAgICB1c2VyLnNjb3Blc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyZXNldFwiIH07XG4gIH1cbiAgZnVuY3Rpb24gY2FuVW5kbygpIHtcbiAgICByZXR1cm4gY29udGV4dC51bmRvU3RhY2subGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBjYW5SZWRvKCkge1xuICAgIHJldHVybiBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIG9uSGlzdG9yeUNoYW5nZSgpIHtcbiAgICBldmVudEh1Yi5oaXN0b3J5Lm5vdGlmeSh7IGNhblVuZG86IGNhblVuZG8oKSwgY2FuUmVkbzogY2FuUmVkbygpIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnRleHQub3RoZXJzLnNldENvbm5lY3Rpb24oXG4gICAgICBtZXNzYWdlLmFjdG9yLFxuICAgICAgbWVzc2FnZS5pZCxcbiAgICAgIG1lc3NhZ2UuaW5mbyxcbiAgICAgIG1lc3NhZ2Uuc2NvcGVzXG4gICAgKTtcbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICBkYXRhOiBjb250ZXh0Lm15UHJlc2VuY2UuZ2V0KCksXG4gICAgICB0YXJnZXRBY3RvcjogbWVzc2FnZS5hY3RvclxuICAgIH0pO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgcmV0dXJuIHVzZXIgPyB7IHR5cGU6IFwiZW50ZXJcIiwgdXNlciB9IDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VydmVyTWVzc2FnZShkYXRhKSB7XG4gICAgaWYgKCFpc0pzb25PYmplY3QoZGF0YSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2VzKHRleHQpIHtcbiAgICBjb25zdCBkYXRhID0gdHJ5UGFyc2VKc29uKHRleHQpO1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoaXNKc29uQXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybiBjb21wYWN0KGRhdGEubWFwKChpdGVtKSA9PiBwYXJzZVNlcnZlck1lc3NhZ2UoaXRlbSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoW3BhcnNlU2VydmVyTWVzc2FnZShkYXRhKV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhcHBseUFuZFNlbmRPcHMob2ZmbGluZU9wcykge1xuICAgIGlmIChvZmZsaW5lT3BzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBjb25zdCBpbk9wcyA9IEFycmF5LmZyb20ob2ZmbGluZU9wcy52YWx1ZXMoKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaW5PcHMsIHRydWUpO1xuICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMjAxIC8qIFVQREFURV9TVE9SQUdFICovLFxuICAgICAgb3BzOiByZXN1bHQub3BzXG4gICAgfSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzKTtcbiAgICBzZW5kTWVzc2FnZXMobWVzc2FnZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVNlcnZlck1lc3NhZ2UoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBwYXJzZVNlcnZlck1lc3NhZ2VzKGV2ZW50LmRhdGEpO1xuICAgIGlmIChtZXNzYWdlcyA9PT0gbnVsbCB8fCBtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlcyA9IHtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgb3RoZXJzOiBbXVxuICAgIH07XG4gICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICBjYXNlIDEwMSAvKiBVU0VSX0pPSU5FRCAqLzoge1xuICAgICAgICAgIGNvbnN0IHVzZXJKb2luZWRVcGRhdGUgPSBvblVzZXJKb2luZWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIGlmICh1c2VySm9pbmVkVXBkYXRlKSB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKHVzZXJKb2luZWRVcGRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi86IHtcbiAgICAgICAgICBjb25zdCBvdGhlcnNQcmVzZW5jZVVwZGF0ZSA9IG9uVXBkYXRlUHJlc2VuY2VNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIGlmIChvdGhlcnNQcmVzZW5jZVVwZGF0ZSkge1xuICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChvdGhlcnNQcmVzZW5jZVVwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTAzIC8qIEJST0FEQ0FTVEVEX0VWRU5UICovOiB7XG4gICAgICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuZ2V0KCk7XG4gICAgICAgICAgZXZlbnRIdWIuY3VzdG9tRXZlbnQubm90aWZ5KHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogbWVzc2FnZS5hY3RvcixcbiAgICAgICAgICAgIHVzZXI6IG1lc3NhZ2UuYWN0b3IgPCAwID8gbnVsbCA6IG90aGVycy5maW5kKCh1KSA9PiB1LmNvbm5lY3Rpb25JZCA9PT0gbWVzc2FnZS5hY3RvcikgPz8gbnVsbCxcbiAgICAgICAgICAgIGV2ZW50OiBtZXNzYWdlLmV2ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxMDIgLyogVVNFUl9MRUZUICovOiB7XG4gICAgICAgICAgY29uc3QgZXZlbnQyID0gb25Vc2VyTGVmdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgaWYgKGV2ZW50Mikge1xuICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChldmVudDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMwMCAvKiBVUERBVEVfWURPQyAqLzoge1xuICAgICAgICAgIGV2ZW50SHViLnlkb2Mubm90aWZ5KG1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTA0IC8qIFJPT01fU1RBVEUgKi86IHtcbiAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG9uUm9vbVN0YXRlTWVzc2FnZShtZXNzYWdlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyMDAgLyogSU5JVElBTF9TVE9SQUdFX1NUQVRFICovOiB7XG4gICAgICAgICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyaXRlIGV2ZW50XG4gICAgICAgIGNhc2UgMjAxIC8qIFVQREFURV9TVE9SQUdFICovOiB7XG4gICAgICAgICAgY29uc3QgYXBwbHlSZXN1bHQgPSBhcHBseU9wcyhtZXNzYWdlLm9wcywgZmFsc2UpO1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFwcGx5UmVzdWx0LnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXModXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5nZXQoa2V5KSwgdmFsdWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWNlaXZpbmcgYSBSZWplY3RlZE9wcyBtZXNzYWdlIGluIHRoZSBjbGllbnQgbWVhbnMgdGhhdCB0aGUgc2VydmVyIGlzIG5vXG4gICAgICAgIC8vIGxvbmdlciBpbiBzeW5jIHdpdGggdGhlIGNsaWVudC4gVHJ5aW5nIHRvIHN5bmNocm9uaXplIHRoZSBjbGllbnQgYWdhaW4gYnlcbiAgICAgICAgLy8gcm9sbGluZyBiYWNrIHBhcnRpY3VsYXIgT3BzIG1heSBiZSBoYXJkL2ltcG9zc2libGUuIEl0J3MgZmluZSB0byBub3QgdHJ5IGFuZFxuICAgICAgICAvLyBhY2NlcHQgdGhlIG91dC1vZi1zeW5jIHJlYWxpdHkgYW5kIHRocm93IGFuIGVycm9yLiBXZSBsb29rIGF0IHRoaXMga2luZCBvZiBidWdcbiAgICAgICAgLy8gYXMgYSBkZXZlbG9wZXItb3duZWQgYnVnLiBJbiBwcm9kdWN0aW9uLCB0aGVzZSBlcnJvcnMgYXJlIG5vdCBleHBlY3RlZCB0byBoYXBwZW4uXG4gICAgICAgIGNhc2UgMjk5IC8qIFJFSkVDVF9TVE9SQUdFX09QICovOiB7XG4gICAgICAgICAgZXJyb3JXaXRoVGl0bGUoXG4gICAgICAgICAgICBcIlN0b3JhZ2UgbXV0YXRpb24gcmVqZWN0aW9uIGVycm9yXCIsXG4gICAgICAgICAgICBtZXNzYWdlLnJlYXNvblxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgdHJhY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3BJZCBvZiBtZXNzYWdlLm9wSWRzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyYWNlID0gY29udGV4dC5vcFN0YWNrVHJhY2VzPy5nZXQob3BJZCk7XG4gICAgICAgICAgICAgIGlmICh0cmFjZSkge1xuICAgICAgICAgICAgICAgIHRyYWNlcy5hZGQodHJhY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2VzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgIHdhcm5XaXRoVGl0bGUoXG4gICAgICAgICAgICAgICAgXCJUaGUgZm9sbG93aW5nIGZ1bmN0aW9uIGNhbGxzIGNhdXNlZCB0aGUgcmVqZWN0ZWQgc3RvcmFnZSBtdXRhdGlvbnM6XCIsXG4gICAgICAgICAgICAgICAgYFxuXG4ke0FycmF5LmZyb20odHJhY2VzKS5qb2luKFwiXFxuXFxuXCIpfWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYFN0b3JhZ2UgbXV0YXRpb25zIHJlamVjdGVkIGJ5IHNlcnZlcjogJHttZXNzYWdlLnJlYXNvbn1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDQwMCAvKiBUSFJFQURfQ1JFQVRFRCAqLzpcbiAgICAgICAgY2FzZSA0MDcgLyogVEhSRUFEX0RFTEVURUQgKi86XG4gICAgICAgIGNhc2UgNDAxIC8qIFRIUkVBRF9NRVRBREFUQV9VUERBVEVEICovOlxuICAgICAgICBjYXNlIDQwOCAvKiBUSFJFQURfVVBEQVRFRCAqLzpcbiAgICAgICAgY2FzZSA0MDUgLyogQ09NTUVOVF9SRUFDVElPTl9BRERFRCAqLzpcbiAgICAgICAgY2FzZSA0MDYgLyogQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEICovOlxuICAgICAgICBjYXNlIDQwMiAvKiBDT01NRU5UX0NSRUFURUQgKi86XG4gICAgICAgIGNhc2UgNDAzIC8qIENPTU1FTlRfRURJVEVEICovOlxuICAgICAgICBjYXNlIDQwNCAvKiBDT01NRU5UX0RFTEVURUQgKi86IHtcbiAgICAgICAgICBldmVudEh1Yi5jb21tZW50cy5ub3RpZnkobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbm90aWZ5KHVwZGF0ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGZsdXNoTm93T3JTb29uKCkge1xuICAgIGNvbnN0IHN0b3JhZ2VPcHMgPSBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucztcbiAgICBpZiAoc3RvcmFnZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIHN0b3JhZ2VPcHMpIHtcbiAgICAgICAgY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5zZXQobm4ob3Aub3BJZCksIG9wKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zID0gW107XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZE1pbGxpcyA9IG5vdyAtIGNvbnRleHQuYnVmZmVyLmxhc3RGbHVzaGVkQXQ7XG4gICAgaWYgKGVsYXBzZWRNaWxsaXMgPj0gY29uZmlnLnRocm90dGxlRGVsYXkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzVG9GbHVzaCA9IHNlcmlhbGl6ZUJ1ZmZlcigpO1xuICAgICAgaWYgKG1lc3NhZ2VzVG9GbHVzaC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzVG9GbHVzaCk7XG4gICAgICBjb250ZXh0LmJ1ZmZlciA9IHtcbiAgICAgICAgZmx1c2hUaW1lcklEOiB2b2lkIDAsXG4gICAgICAgIGxhc3RGbHVzaGVkQXQ6IG5vdyxcbiAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICBzdG9yYWdlT3BlcmF0aW9uczogW10sXG4gICAgICAgIHByZXNlbmNlVXBkYXRlczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgICBmbHVzaE5vd09yU29vbixcbiAgICAgICAgY29uZmlnLnRocm90dGxlRGVsYXkgLSBlbGFwc2VkTWlsbGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXJpYWxpemVCdWZmZXIoKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKFxuICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMudHlwZSA9PT0gXCJmdWxsXCIgPyB7XG4gICAgICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgICAgICAvLyBQb3B1bGF0aW5nIHRoZSBgdGFyZ2V0QWN0b3JgIGZpZWxkIHR1cm5zIHRoaXMgbWVzc2FnZSBpbnRvXG4gICAgICAgICAgLy8gYSBGdWxsIFByZXNlbmNl4oSiIHVwZGF0ZSBtZXNzYWdlIChub3QgYSBwYXRjaCksIHdoaWNoIHdpbGwgZ2V0XG4gICAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYnkgb3RoZXIgY2xpZW50cyBhcyBzdWNoLlxuICAgICAgICAgIHRhcmdldEFjdG9yOiAtMSxcbiAgICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVxuICAgICAgICB9IDoge1xuICAgICAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcykge1xuICAgICAgbWVzc2FnZXMucHVzaChldmVudCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogMjAxIC8qIFVQREFURV9TVE9SQUdFICovLFxuICAgICAgICBvcHM6IGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVlEb2ModXBkYXRlLCBndWlkLCBpc1YyKSB7XG4gICAgY29uc3QgY2xpZW50TXNnID0ge1xuICAgICAgdHlwZTogMzAxIC8qIFVQREFURV9ZRE9DICovLFxuICAgICAgdXBkYXRlLFxuICAgICAgZ3VpZCxcbiAgICAgIHYyOiBpc1YyXG4gICAgfTtcbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKGNsaWVudE1zZyk7XG4gICAgZXZlbnRIdWIueWRvYy5ub3RpZnkoY2xpZW50TXNnKTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGJyb2FkY2FzdEV2ZW50KGV2ZW50LCBvcHRpb25zMiA9IHtcbiAgICBzaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeTogZmFsc2VcbiAgfSkge1xuICAgIGlmIChtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpICE9PSBcImNvbm5lY3RlZFwiICYmICFvcHRpb25zMi5zaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDEwMyAvKiBCUk9BRENBU1RfRVZFTlQgKi8sXG4gICAgICBldmVudFxuICAgIH0pO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcGF0Y2hPcHMob3BzKSB7XG4gICAgY29uc3QgeyBzdG9yYWdlT3BlcmF0aW9ucyB9ID0gY29udGV4dC5idWZmZXI7XG4gICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgIHN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGxldCBfZ2V0U3RvcmFnZSQgPSBudWxsO1xuICBsZXQgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IG51bGw7XG4gIGZ1bmN0aW9uIHByb2Nlc3NJbml0aWFsU3RvcmFnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdW5hY2tub3dsZWRnZWRPcHMgPSBuZXcgTWFwKGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMpO1xuICAgIGNyZWF0ZU9yVXBkYXRlUm9vdEZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuICAgIGFwcGx5QW5kU2VuZE9wcyh1bmFja25vd2xlZGdlZE9wcyk7XG4gICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZT8uKCk7XG4gICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIGV2ZW50SHViLnN0b3JhZ2VEaWRMb2FkLm5vdGlmeSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0b3JhZ2UoKSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkgcmV0dXJuO1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgaHR0cENsaWVudC5zdHJlYW1TdG9yYWdlKHsgcm9vbUlkIH0pO1xuICAgIHByb2Nlc3NJbml0aWFsU3RvcmFnZSh7IHR5cGU6IDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi8sIGl0ZW1zIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2hTdG9yYWdlKG9wdGlvbnMyKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcztcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX3N0cmVhbURhdGEpIHtcbiAgICAgIHZvaWQgc3RyZWFtU3RvcmFnZSgpO1xuICAgIH0gZWxzZSBpZiAoIW1lc3NhZ2VzLnNvbWUoKG1zZykgPT4gbXNnLnR5cGUgPT09IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovKSkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7IHR5cGU6IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9uczIuZmx1c2gpIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0TG9hZGluZ1N0b3JhZ2UoKSB7XG4gICAgaWYgKF9nZXRTdG9yYWdlJCA9PT0gbnVsbCkge1xuICAgICAgcmVmcmVzaFN0b3JhZ2UoeyBmbHVzaDogdHJ1ZSB9KTtcbiAgICAgIF9nZXRTdG9yYWdlJCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIHJldHVybiBfZ2V0U3RvcmFnZSQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVNuYXBzaG90KCkge1xuICAgIGNvbnN0IHJvb3QgPSBjb250ZXh0LnJvb3Q7XG4gICAgaWYgKHJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2UoKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgcm9vdDogY29udGV4dC5yb290XG4gICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgIHJldHVybiB7XG4gICAgICByb290OiBubihjb250ZXh0LnJvb3QpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmZXRjaFlEb2ModmVjdG9yLCBndWlkLCBpc1YyKSB7XG4gICAgaWYgKCFjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5maW5kKChtKSA9PiB7XG4gICAgICByZXR1cm4gbS50eXBlID09PSAzMDAgLyogRkVUQ0hfWURPQyAqLyAmJiBtLnZlY3RvciA9PT0gdmVjdG9yICYmIG0uZ3VpZCA9PT0gZ3VpZCAmJiBtLnYyID09PSBpc1YyO1xuICAgIH0pKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogMzAwIC8qIEZFVENIX1lET0MgKi8sXG4gICAgICAgIHZlY3RvcixcbiAgICAgICAgZ3VpZCxcbiAgICAgICAgdjI6IGlzVjJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGEgYmF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnVuZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoaGlzdG9yeU9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaGlzdG9yeU9wcywgdHJ1ZSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzKTtcbiAgICBjb250ZXh0LnJlZG9TdGFjay5wdXNoKHJlc3VsdC5yZXZlcnNlKTtcbiAgICBvbkhpc3RvcnlDaGFuZ2UoKTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHJlc3VsdC5vcHMpIHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVkbygpIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVkbyBpcyBub3QgYWxsb3dlZCBkdXJpbmcgYSBiYXRjaFwiKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucmVkb1N0YWNrLnBvcCgpO1xuICAgIGlmIChoaXN0b3J5T3BzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhoaXN0b3J5T3BzLCB0cnVlKTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMpO1xuICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgIG9uSGlzdG9yeUNoYW5nZSgpO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSAwO1xuICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gYmF0Y2gyKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBsZXQgcmV0dXJuVmFsdWUgPSB2b2lkIDA7XG4gICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IHtcbiAgICAgIG9wczogW10sXG4gICAgICB1cGRhdGVzOiB7XG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICBwcmVzZW5jZTogZmFsc2UsXG4gICAgICAgIG90aGVyczogW11cbiAgICAgIH0sXG4gICAgICByZXZlcnNlT3BzOiBuZXcgRGVxdWUoKVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY29uc3QgY3VycmVudEJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSBudWxsO1xuICAgICAgaWYgKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWRkVG9VbmRvU3RhY2soQXJyYXkuZnJvbShjdXJyZW50QmF0Y2gucmV2ZXJzZU9wcykpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBkaXNwYXRjaE9wcyhjdXJyZW50QmF0Y2gub3BzKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeShjdXJyZW50QmF0Y2gudXBkYXRlcyk7XG4gICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcGF1c2VIaXN0b3J5KCkge1xuICAgIGlmIChjb250ZXh0LnBhdXNlZEhpc3RvcnkgPT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG5ldyBEZXF1ZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXN1bWVIaXN0b3J5KCkge1xuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnBhdXNlZEhpc3Rvcnk7XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBpZiAoaGlzdG9yeU9wcyAhPT0gbnVsbCAmJiBoaXN0b3J5T3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIF9hZGRUb1JlYWxVbmRvU3RhY2soQXJyYXkuZnJvbShoaXN0b3J5T3BzKSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHN5bmNTb3VyY2VGb3JTdG9yYWdlID0gY29uZmlnLmNyZWF0ZVN5bmNTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVN0YXR1cygpIHtcbiAgICBpZiAoY29udGV4dC5yb290ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBfZ2V0U3RvcmFnZSQgPT09IG51bGwgPyBcIm5vdC1sb2FkZWRcIiA6IFwibG9hZGluZ1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5zaXplID09PSAwID8gXCJzeW5jaHJvbml6ZWRcIiA6IFwic3luY2hyb25pemluZ1wiO1xuICAgIH1cbiAgfVxuICBsZXQgX2xhc3RTdG9yYWdlU3RhdHVzID0gZ2V0U3RvcmFnZVN0YXR1cygpO1xuICBmdW5jdGlvbiBub3RpZnlTdG9yYWdlU3RhdHVzKCkge1xuICAgIGNvbnN0IHN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gICAgaWYgKF9sYXN0U3RvcmFnZVN0YXR1cyAhPT0gc3RvcmFnZVN0YXR1cykge1xuICAgICAgX2xhc3RTdG9yYWdlU3RhdHVzID0gc3RvcmFnZVN0YXR1cztcbiAgICAgIGV2ZW50SHViLnN0b3JhZ2VTdGF0dXMubm90aWZ5KHN0b3JhZ2VTdGF0dXMpO1xuICAgIH1cbiAgICBzeW5jU291cmNlRm9yU3RvcmFnZS5zZXRTeW5jU3RhdHVzKFxuICAgICAgc3RvcmFnZVN0YXR1cyA9PT0gXCJzeW5jaHJvbml6aW5nXCIgPyBcInN5bmNocm9uaXppbmdcIiA6IFwic3luY2hyb25pemVkXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGlzUHJlc2VuY2VSZWFkeSgpIHtcbiAgICByZXR1cm4gc2VsZi5nZXQoKSAhPT0gbnVsbDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWxQcmVzZW5jZVJlYWR5KCkge1xuICAgIHdoaWxlICghaXNQcmVzZW5jZVJlYWR5KCkpIHtcbiAgICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSB9ID0gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCk7XG4gICAgICBjb25zdCB1bnN1YjEgPSBldmVudHMuc2VsZi5zdWJzY3JpYmVPbmNlKHJlc29sdmUpO1xuICAgICAgY29uc3QgdW5zdWIyID0gZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmVPbmNlKHJlc29sdmUpO1xuICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIHVuc3ViMSgpO1xuICAgICAgdW5zdWIyKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzU3RvcmFnZVJlYWR5KCkge1xuICAgIHJldHVybiBnZXRTdG9yYWdlU25hcHNob3QoKSAhPT0gbnVsbDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3YWl0VW50aWxTdG9yYWdlUmVhZHkoKSB7XG4gICAgd2hpbGUgKCFpc1N0b3JhZ2VSZWFkeSgpKSB7XG4gICAgICBhd2FpdCBnZXRTdG9yYWdlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG90aGVyc19mb3JEZXZUb29scyA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICBjb250ZXh0Lm90aGVycy5zaWduYWwsXG4gICAgKG90aGVycykgPT4gb3RoZXJzLm1hcCgob3RoZXIsIGluZGV4KSA9PiB1c2VyVG9UcmVlTm9kZShgT3RoZXIgJHtpbmRleH1gLCBvdGhlcikpXG4gICk7XG4gIGNvbnN0IGV2ZW50cyA9IHtcbiAgICBzdGF0dXM6IGV2ZW50SHViLnN0YXR1cy5vYnNlcnZhYmxlLFxuICAgIGxvc3RDb25uZWN0aW9uOiBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5vYnNlcnZhYmxlLFxuICAgIGN1c3RvbUV2ZW50OiBldmVudEh1Yi5jdXN0b21FdmVudC5vYnNlcnZhYmxlLFxuICAgIG90aGVyczogZXZlbnRIdWIub3RoZXJzLm9ic2VydmFibGUsXG4gICAgc2VsZjogZXZlbnRIdWIuc2VsZi5vYnNlcnZhYmxlLFxuICAgIG15UHJlc2VuY2U6IGV2ZW50SHViLm15UHJlc2VuY2Uub2JzZXJ2YWJsZSxcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBzdG9yYWdlOiBldmVudEh1Yi5zdG9yYWdlQmF0Y2gub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlQmF0Y2g6IGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5vYnNlcnZhYmxlLFxuICAgIGhpc3Rvcnk6IGV2ZW50SHViLmhpc3Rvcnkub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlRGlkTG9hZDogZXZlbnRIdWIuc3RvcmFnZURpZExvYWQub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlU3RhdHVzOiBldmVudEh1Yi5zdG9yYWdlU3RhdHVzLm9ic2VydmFibGUsXG4gICAgeWRvYzogZXZlbnRIdWIueWRvYy5vYnNlcnZhYmxlLFxuICAgIGNvbW1lbnRzOiBldmVudEh1Yi5jb21tZW50cy5vYnNlcnZhYmxlLFxuICAgIHJvb21XaWxsRGVzdHJveTogZXZlbnRIdWIucm9vbVdpbGxEZXN0cm95Lm9ic2VydmFibGVcbiAgfTtcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkc1NpbmNlKG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0VGhyZWFkc1NpbmNlKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHNpbmNlOiBvcHRpb25zMi5zaW5jZSxcbiAgICAgIHNpZ25hbDogb3B0aW9uczIuc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkcyhvcHRpb25zMikge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmdldFRocmVhZHMoe1xuICAgICAgcm9vbUlkLFxuICAgICAgcXVlcnk6IG9wdGlvbnMyPy5xdWVyeSxcbiAgICAgIGN1cnNvcjogb3B0aW9uczI/LmN1cnNvclxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZCh0aHJlYWRJZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmdldFRocmVhZCh7IHJvb21JZCwgdGhyZWFkSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGhyZWFkKG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuY3JlYXRlVGhyZWFkKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHRocmVhZElkOiBvcHRpb25zMi50aHJlYWRJZCxcbiAgICAgIGNvbW1lbnRJZDogb3B0aW9uczIuY29tbWVudElkLFxuICAgICAgbWV0YWRhdGE6IG9wdGlvbnMyLm1ldGFkYXRhLFxuICAgICAgYm9keTogb3B0aW9uczIuYm9keSxcbiAgICAgIGF0dGFjaG1lbnRJZHM6IG9wdGlvbnMyLmF0dGFjaG1lbnRJZHNcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVUaHJlYWQodGhyZWFkSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5kZWxldGVUaHJlYWQoeyByb29tSWQsIHRocmVhZElkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRUaHJlYWRNZXRhZGF0YSh7XG4gICAgbWV0YWRhdGEsXG4gICAgdGhyZWFkSWRcbiAgfSkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmVkaXRUaHJlYWRNZXRhZGF0YSh7IHJvb21JZCwgdGhyZWFkSWQsIG1ldGFkYXRhIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtUaHJlYWRBc1Jlc29sdmVkKHRocmVhZElkKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQubWFya1RocmVhZEFzUmVzb2x2ZWQoeyByb29tSWQsIHRocmVhZElkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtUaHJlYWRBc1VucmVzb2x2ZWQodGhyZWFkSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5tYXJrVGhyZWFkQXNVbnJlc29sdmVkKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHRocmVhZElkXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tbWVudChvcHRpb25zMikge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmNyZWF0ZUNvbW1lbnQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgdGhyZWFkSWQ6IG9wdGlvbnMyLnRocmVhZElkLFxuICAgICAgY29tbWVudElkOiBvcHRpb25zMi5jb21tZW50SWQsXG4gICAgICBib2R5OiBvcHRpb25zMi5ib2R5LFxuICAgICAgYXR0YWNobWVudElkczogb3B0aW9uczIuYXR0YWNobWVudElkc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRDb21tZW50KG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZWRpdENvbW1lbnQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgdGhyZWFkSWQ6IG9wdGlvbnMyLnRocmVhZElkLFxuICAgICAgY29tbWVudElkOiBvcHRpb25zMi5jb21tZW50SWQsXG4gICAgICBib2R5OiBvcHRpb25zMi5ib2R5LFxuICAgICAgYXR0YWNobWVudElkczogb3B0aW9uczIuYXR0YWNobWVudElkc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNvbW1lbnQoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZFxuICB9KSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZGVsZXRlQ29tbWVudCh7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBhZGRSZWFjdGlvbih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGVtb2ppXG4gIH0pIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5hZGRSZWFjdGlvbih7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlUmVhY3Rpb24oe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBlbW9qaVxuICB9KSB7XG4gICAgcmV0dXJuIGF3YWl0IGh0dHBDbGllbnQucmVtb3ZlUmVhY3Rpb24oe1xuICAgICAgcm9vbUlkLFxuICAgICAgdGhyZWFkSWQsXG4gICAgICBjb21tZW50SWQsXG4gICAgICBlbW9qaVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHByZXBhcmVBdHRhY2htZW50KGZpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsb2NhbEF0dGFjaG1lbnRcIixcbiAgICAgIHN0YXR1czogXCJpZGxlXCIsXG4gICAgICBpZDogY3JlYXRlQ29tbWVudEF0dGFjaG1lbnRJZCgpLFxuICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgbWltZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgIGZpbGVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZEF0dGFjaG1lbnQoYXR0YWNobWVudCwgb3B0aW9uczIgPSB7fSkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnVwbG9hZEF0dGFjaG1lbnQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgYXR0YWNobWVudCxcbiAgICAgIHNpZ25hbDogb3B0aW9uczIuc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QXR0YWNobWVudFVybChhdHRhY2htZW50SWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXRBdHRhY2htZW50VXJsKHsgcm9vbUlkLCBhdHRhY2htZW50SWQgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3Mob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXROb3RpZmljYXRpb25TZXR0aW5ncyh7XG4gICAgICByb29tSWQsXG4gICAgICBzaWduYWw6IG9wdGlvbnMyPy5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzKHsgcm9vbUlkLCBzZXR0aW5ncyB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICAgIGF3YWl0IGh0dHBDbGllbnQubWFya1Jvb21JbmJveE5vdGlmaWNhdGlvbkFzUmVhZCh7XG4gICAgICByb29tSWQsXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbklkXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc3luY1NvdXJjZUZvcllqcyA9IGNvbmZpZy5jcmVhdGVTeW5jU291cmNlKCk7XG4gIGZ1bmN0aW9uIHlqc1N0YXR1c0RpZENoYW5nZShzdGF0dXMpIHtcbiAgICByZXR1cm4gc3luY1NvdXJjZUZvcllqcy5zZXRTeW5jU3RhdHVzKFxuICAgICAgc3RhdHVzID09PSBcInN5bmNocm9uaXppbmdcIiA/IFwic3luY2hyb25pemluZ1wiIDogXCJzeW5jaHJvbml6ZWRcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICBba0ludGVybmFsXToge1xuICAgICAgICBnZXQgcHJlc2VuY2VCdWZmZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXM/LmRhdGEgPz8gbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgdW5kb1N0YWNrKCkge1xuICAgICAgICAgIHJldHVybiBkZWVwQ2xvbmUoY29udGV4dC51bmRvU3RhY2spO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0IG5vZGVDb3VudCgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5ub2Rlcy5zaXplO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0WWpzUHJvdmlkZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQueWpzUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFlqc1Byb3ZpZGVyKG5ld1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC55anNQcm92aWRlcj8ub2ZmKFwic3RhdHVzXCIsIHlqc1N0YXR1c0RpZENoYW5nZSk7XG4gICAgICAgICAgY29udGV4dC55anNQcm92aWRlciA9IG5ld1Byb3ZpZGVyO1xuICAgICAgICAgIG5ld1Byb3ZpZGVyPy5vbihcInN0YXR1c1wiLCB5anNTdGF0dXNEaWRDaGFuZ2UpO1xuICAgICAgICAgIGNvbnRleHQueWpzUHJvdmlkZXJEaWRDaGFuZ2Uubm90aWZ5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHlqc1Byb3ZpZGVyRGlkQ2hhbmdlOiBjb250ZXh0Lnlqc1Byb3ZpZGVyRGlkQ2hhbmdlLm9ic2VydmFibGUsXG4gICAgICAgIC8vIHNlbmQgbWV0YWRhdGEgd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIHJlcG9ydFRleHRFZGl0b3IsXG4gICAgICAgIC8vIGNyZWF0ZSBhIHRleHQgbWVudGlvbiB3aGVuIHVzaW5nIGEgdGV4dCBlZGl0b3JcbiAgICAgICAgY3JlYXRlVGV4dE1lbnRpb24sXG4gICAgICAgIC8vIGRlbGV0ZSBhIHRleHQgbWVudGlvbiB3aGVuIHVzaW5nIGEgdGV4dCBlZGl0b3JcbiAgICAgICAgZGVsZXRlVGV4dE1lbnRpb24sXG4gICAgICAgIC8vIGxpc3QgdmVyc2lvbnMgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIGxpc3RUZXh0VmVyc2lvbnMsXG4gICAgICAgIC8vIExpc3QgdmVyc2lvbnMgb2YgdGhlIGRvY3VtZW50IHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZVxuICAgICAgICBsaXN0VGV4dFZlcnNpb25zU2luY2UsXG4gICAgICAgIC8vIGdldCBhIHNwZWNpZmljIHZlcnNpb25cbiAgICAgICAgZ2V0VGV4dFZlcnNpb24sXG4gICAgICAgIC8vIGNyZWF0ZSBhIHZlcnNpb25cbiAgICAgICAgY3JlYXRlVGV4dFZlcnNpb24sXG4gICAgICAgIC8vIGV4ZWN1dGUgYSBjb250ZXh0dWFsIHByb21wdFxuICAgICAgICBleGVjdXRlQ29udGV4dHVhbFByb21wdCxcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgdGhlIExpdmVibG9ja3MgYnJvd3NlciBleHRlbnNpb25cbiAgICAgICAgZ2V0U2VsZl9mb3JEZXZUb29sczogKCkgPT4gc2VsZkFzVHJlZU5vZGUuZ2V0KCksXG4gICAgICAgIGdldE90aGVyc19mb3JEZXZUb29sczogKCkgPT4gb3RoZXJzX2ZvckRldlRvb2xzLmdldCgpLFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgc2ltdWxhdGU6IHtcbiAgICAgICAgICAvLyBUaGVzZSBleGlzdCBvbmx5IGZvciBvdXIgRTJFIHRlc3RpbmcgYXBwXG4gICAgICAgICAgZXhwbGljaXRDbG9zZTogKGV2ZW50KSA9PiBtYW5hZ2VkU29ja2V0Ll9wcml2YXRlU2VuZE1hY2hpbmVFdmVudCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pLFxuICAgICAgICAgIHJhd1NlbmQ6IChkYXRhKSA9PiBtYW5hZ2VkU29ja2V0LnNlbmQoZGF0YSlcbiAgICAgICAgfSxcbiAgICAgICAgYXR0YWNobWVudFVybHNTdG9yZTogaHR0cENsaWVudC5nZXRPckNyZWF0ZUF0dGFjaG1lbnRVcmxzU3RvcmUocm9vbUlkKVxuICAgICAgfSxcbiAgICAgIGlkOiBjb25maWcucm9vbUlkLFxuICAgICAgc3Vic2NyaWJlOiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKFxuICAgICAgICBjb25maWcucm9vbUlkLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIGNvbmZpZy5lcnJvckV2ZW50U291cmNlXG4gICAgICApLFxuICAgICAgY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5jb25uZWN0KCksXG4gICAgICByZWNvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCksXG4gICAgICBkaXNjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmRpc2Nvbm5lY3QoKSxcbiAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByb29tV2lsbERlc3Ryb3ksIC4uLmV2ZW50c0V4Y2VwdERlc3Ryb3kgfSA9IGV2ZW50SHViO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBPYmplY3QudmFsdWVzKGV2ZW50c0V4Y2VwdERlc3Ryb3kpKSB7XG4gICAgICAgICAgc291cmNlW1N5bWJvbC5kaXNwb3NlXSgpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50SHViLnJvb21XaWxsRGVzdHJveS5ub3RpZnkoKTtcbiAgICAgICAgY29udGV4dC55anNQcm92aWRlcj8ub2ZmKFwic3RhdHVzXCIsIHlqc1N0YXR1c0RpZENoYW5nZSk7XG4gICAgICAgIHN5bmNTb3VyY2VGb3JTdG9yYWdlLmRlc3Ryb3koKTtcbiAgICAgICAgc3luY1NvdXJjZUZvcllqcy5kZXN0cm95KCk7XG4gICAgICAgIHVuaW5zdGFsbEJnVGFiU3B5KCk7XG4gICAgICAgIG1hbmFnZWRTb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICByb29tV2lsbERlc3Ryb3lbU3ltYm9sLmRpc3Bvc2VdKCk7XG4gICAgICB9LFxuICAgICAgLy8gUHJlc2VuY2VcbiAgICAgIHVwZGF0ZVByZXNlbmNlLFxuICAgICAgdXBkYXRlWURvYyxcbiAgICAgIGJyb2FkY2FzdEV2ZW50LFxuICAgICAgLy8gU3RvcmFnZVxuICAgICAgYmF0Y2g6IGJhdGNoMixcbiAgICAgIGhpc3Rvcnk6IHtcbiAgICAgICAgdW5kbyxcbiAgICAgICAgcmVkbyxcbiAgICAgICAgY2FuVW5kbyxcbiAgICAgICAgY2FuUmVkbyxcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIHBhdXNlOiBwYXVzZUhpc3RvcnksXG4gICAgICAgIHJlc3VtZTogcmVzdW1lSGlzdG9yeVxuICAgICAgfSxcbiAgICAgIGZldGNoWURvYyxcbiAgICAgIGdldFN0b3JhZ2UsXG4gICAgICBnZXRTdG9yYWdlU25hcHNob3QsXG4gICAgICBnZXRTdG9yYWdlU3RhdHVzLFxuICAgICAgaXNQcmVzZW5jZVJlYWR5LFxuICAgICAgaXNTdG9yYWdlUmVhZHksXG4gICAgICB3YWl0VW50aWxQcmVzZW5jZVJlYWR5OiBtZW1vaXplT25TdWNjZXNzKHdhaXRVbnRpbFByZXNlbmNlUmVhZHkpLFxuICAgICAgd2FpdFVudGlsU3RvcmFnZVJlYWR5OiBtZW1vaXplT25TdWNjZXNzKHdhaXRVbnRpbFN0b3JhZ2VSZWFkeSksXG4gICAgICBldmVudHMsXG4gICAgICAvLyBDb3JlXG4gICAgICBnZXRTdGF0dXM6ICgpID0+IG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCksXG4gICAgICBnZXRTZWxmOiAoKSA9PiBzZWxmLmdldCgpLFxuICAgICAgLy8gUHJlc2VuY2VcbiAgICAgIGdldFByZXNlbmNlOiAoKSA9PiBjb250ZXh0Lm15UHJlc2VuY2UuZ2V0KCksXG4gICAgICBnZXRPdGhlcnM6ICgpID0+IGNvbnRleHQub3RoZXJzLmdldCgpLFxuICAgICAgLy8gQ29tbWVudHNcbiAgICAgIGdldFRocmVhZHMsXG4gICAgICBnZXRUaHJlYWRzU2luY2UsXG4gICAgICBnZXRUaHJlYWQsXG4gICAgICBjcmVhdGVUaHJlYWQsXG4gICAgICBkZWxldGVUaHJlYWQsXG4gICAgICBlZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgICBtYXJrVGhyZWFkQXNSZXNvbHZlZCxcbiAgICAgIG1hcmtUaHJlYWRBc1VucmVzb2x2ZWQsXG4gICAgICBjcmVhdGVDb21tZW50LFxuICAgICAgZWRpdENvbW1lbnQsXG4gICAgICBkZWxldGVDb21tZW50LFxuICAgICAgYWRkUmVhY3Rpb24sXG4gICAgICByZW1vdmVSZWFjdGlvbixcbiAgICAgIHByZXBhcmVBdHRhY2htZW50LFxuICAgICAgdXBsb2FkQXR0YWNobWVudCxcbiAgICAgIGdldEF0dGFjaG1lbnRVcmwsXG4gICAgICAvLyBOb3RpZmljYXRpb25zXG4gICAgICBnZXROb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkXG4gICAgfSxcbiAgICAvLyBFeHBsaWN0bHkgbWFrZSB0aGUgaW50ZXJuYWwgZmllbGQgbm9uLWVudW1lcmFibGUsIHRvIGF2b2lkIGFnZ3Jlc3NpdmVcbiAgICAvLyBmcmVlemluZyB3aGVuIHVzZWQgd2l0aCBJbW1lclxuICAgIGtJbnRlcm5hbCxcbiAgICB7IGVudW1lcmFibGU6IGZhbHNlIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIG1ha2VDbGFzc2ljU3Vic2NyaWJlRm4ocm9vbUlkLCBldmVudHMsIGVycm9yRXZlbnRzKSB7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBldmVudHMuc3RvcmFnZUJhdGNoLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgY29uc3QgcmVsYXRlZFVwZGF0ZXMgPSB1cGRhdGVzLmZpbHRlcihcbiAgICAgICAgKHVwZGF0ZSkgPT4gaXNTYW1lTm9kZU9yQ2hpbGRPZih1cGRhdGUubm9kZSwgbm9kZSlcbiAgICAgICk7XG4gICAgICBpZiAocmVsYXRlZFVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjYWxsYmFjayhyZWxhdGVkVXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICAgIGlmICh1cGRhdGUubm9kZS5faWQgPT09IG5vZGUuX2lkKSB7XG4gICAgICAgICAgY2FsbGJhY2sodXBkYXRlLm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZpcnN0LCBzZWNvbmQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIGlzUm9vbUV2ZW50TmFtZShmaXJzdCkpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBjYWxsYmFjayBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm15LXByZXNlbmNlXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5teVByZXNlbmNlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJvdGhlcnNcIjoge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvdGhlcnMsIC4uLmludGVybmFsRXZlbnQgfSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNiKG90aGVycywgaW50ZXJuYWxFdmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICByZXR1cm4gZXJyb3JFdmVudHMuc3Vic2NyaWJlKChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInN0YXR1c1wiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuc3RhdHVzLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJsb3N0LWNvbm5lY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmxvc3RDb25uZWN0aW9uLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImhpc3RvcnlcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmhpc3Rvcnkuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcInN0b3JhZ2Utc3RhdHVzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlU3RhdHVzLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImNvbW1lbnRzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5jb21tZW50cy5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKFxuICAgICAgICAgICAgZmlyc3QsXG4gICAgICAgICAgICBgXCIke1N0cmluZyhmaXJzdCl9XCIgaXMgbm90IGEgdmFsaWQgZXZlbnQgbmFtZWBcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Vjb25kID09PSB2b2lkIDAgfHwgdHlwZW9mIGZpcnN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2FsbGJhY2sgPSBmaXJzdDtcbiAgICAgICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKHN0b3JhZ2VDYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc3BlY2lmeSBhIGxpc3RlbmVyIGNhbGxiYWNrXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNMaXZlTm9kZShmaXJzdCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBmaXJzdDtcbiAgICAgIGlmIChvcHRpb25zPy5pc0RlZXApIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5KG5vZGUsIHN0b3JhZ2VDYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlQ2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVTaGFsbG93bHkobm9kZSwgbm9kZUNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCR7U3RyaW5nKGZpcnN0KX0gaXMgbm90IGEgdmFsdWUgdGhhdCBjYW4gYmUgc3Vic2NyaWJlZCB0by5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3Vic2NyaWJlO1xufVxuZnVuY3Rpb24gaXNSb29tRXZlbnROYW1lKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gXCJteS1wcmVzZW5jZVwiIHx8IHZhbHVlID09PSBcIm90aGVyc1wiIHx8IHZhbHVlID09PSBcImV2ZW50XCIgfHwgdmFsdWUgPT09IFwiZXJyb3JcIiB8fCB2YWx1ZSA9PT0gXCJoaXN0b3J5XCIgfHwgdmFsdWUgPT09IFwic3RhdHVzXCIgfHwgdmFsdWUgPT09IFwic3RvcmFnZS1zdGF0dXNcIiB8fCB2YWx1ZSA9PT0gXCJsb3N0LWNvbm5lY3Rpb25cIiB8fCB2YWx1ZSA9PT0gXCJjb25uZWN0aW9uXCIgfHwgdmFsdWUgPT09IFwiY29tbWVudHNcIjtcbn1cbmZ1bmN0aW9uIG1ha2VBdXRoRGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYXV0aE1hbmFnZXIpIHtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICByZXR1cm4gYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwicm9vbTpyZWFkXCIsIHJvb21JZCB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VDcmVhdGVTb2NrZXREZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBiYXNlVXJsLCBXZWJTb2NrZXRQb2x5ZmlsbCkge1xuICByZXR1cm4gKGF1dGhWYWx1ZSkgPT4ge1xuICAgIGNvbnN0IHdzID0gV2ViU29ja2V0UG9seWZpbGwgPz8gKHR5cGVvZiBXZWJTb2NrZXQgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiBXZWJTb2NrZXQpO1xuICAgIGlmICh3cyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICBcIlRvIHVzZSBMaXZlYmxvY2tzIGNsaWVudCBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQsIHlvdSBuZWVkIHRvIHByb3ZpZGUgYSBXZWJTb2NrZXQgcG9seWZpbGwuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHVybDIgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgIHVybDIucHJvdG9jb2wgPSB1cmwyLnByb3RvY29sID09PSBcImh0dHA6XCIgPyBcIndzXCIgOiBcIndzc1wiO1xuICAgIHVybDIucGF0aG5hbWUgPSBcIi92N1wiO1xuICAgIHVybDIuc2VhcmNoUGFyYW1zLnNldChcInJvb21JZFwiLCByb29tSWQpO1xuICAgIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJzZWNyZXRcIikge1xuICAgICAgdXJsMi5zZWFyY2hQYXJhbXMuc2V0KFwidG9rXCIsIGF1dGhWYWx1ZS50b2tlbi5yYXcpO1xuICAgIH0gZWxzZSBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICAgIHVybDIuc2VhcmNoUGFyYW1zLnNldChcInB1YmtleVwiLCBhdXRoVmFsdWUucHVibGljQXBpS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKGF1dGhWYWx1ZSwgXCJVbmhhbmRsZWQgY2FzZVwiKTtcbiAgICB9XG4gICAgdXJsMi5zZWFyY2hQYXJhbXMuc2V0KFwidmVyc2lvblwiLCBQS0dfVkVSU0lPTiB8fCBcImRldlwiKTtcbiAgICByZXR1cm4gbmV3IHdzKHVybDIudG9TdHJpbmcoKSk7XG4gIH07XG59XG5cbi8vIHNyYy9jbGllbnQudHNcbnZhciBNSU5fVEhST1RUTEUgPSAxNjtcbnZhciBNQVhfVEhST1RUTEUgPSAxZTM7XG52YXIgREVGQVVMVF9USFJPVFRMRSA9IDEwMDtcbnZhciBNSU5fQkFDS0dST1VORF9LRUVQX0FMSVZFX1RJTUVPVVQgPSAxNWUzO1xudmFyIE1JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDIwMDtcbnZhciBSRUNPTU1FTkRFRF9NSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAxZTM7XG52YXIgTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gM2U0O1xudmFyIERFRkFVTFRfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSA1ZTM7XG52YXIgUkVTT0xWRV9VU0VSU19CQVRDSF9ERUxBWSA9IDUwO1xudmFyIFJFU09MVkVfUk9PTVNfSU5GT19CQVRDSF9ERUxBWSA9IDUwO1xuZnVuY3Rpb24gZ2V0QmFzZVVybChiYXNlVXJsKSB7XG4gIGlmICh0eXBlb2YgYmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiBiYXNlVXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgcmV0dXJuIGJhc2VVcmw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQkFTRV9VUkw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChvcHRpb25zKSB7XG4gIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBvcHRpb25zO1xuICBjb25zdCB0aHJvdHRsZURlbGF5ID0gZ2V0VGhyb3R0bGUoY2xpZW50T3B0aW9ucy50aHJvdHRsZSA/PyBERUZBVUxUX1RIUk9UVExFKTtcbiAgY29uc3QgbG9zdENvbm5lY3Rpb25UaW1lb3V0ID0gZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0KFxuICAgIGNsaWVudE9wdGlvbnMubG9zdENvbm5lY3Rpb25UaW1lb3V0ID8/IERFRkFVTFRfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVRcbiAgKTtcbiAgY29uc3QgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgPSBnZXRCYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dChcbiAgICBjbGllbnRPcHRpb25zLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XG4gICk7XG4gIGNvbnN0IGJhc2VVcmwgPSBnZXRCYXNlVXJsKGNsaWVudE9wdGlvbnMuYmFzZVVybCk7XG4gIGNvbnN0IGN1cnJlbnRVc2VySWQgPSBuZXcgU2lnbmFsKHZvaWQgMCk7XG4gIGNvbnN0IGF1dGhNYW5hZ2VyID0gY3JlYXRlQXV0aE1hbmFnZXIob3B0aW9ucywgKHRva2VuKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmlkIDogdG9rZW4udWlkO1xuICAgIGN1cnJlbnRVc2VySWQuc2V0KCgpID0+IHVzZXJJZCk7XG4gIH0pO1xuICBjb25zdCBmZXRjaFBvbHlmaWxsID0gY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmZldGNoIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdsb2JhbFRoaXMuZmV0Y2g/LmJpbmQoZ2xvYmFsVGhpcyk7XG4gIGNvbnN0IGh0dHBDbGllbnQgPSBjcmVhdGVBcGlDbGllbnQoe1xuICAgIGJhc2VVcmwsXG4gICAgZmV0Y2hQb2x5ZmlsbCxcbiAgICBhdXRoTWFuYWdlclxuICB9KTtcbiAgY29uc3Qgcm9vbXNCeUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gdGVhcmRvd25Sb29tKHJvb20pIHtcbiAgICB1bmxpbmtEZXZUb29scyhyb29tLmlkKTtcbiAgICByb29tc0J5SWQuZGVsZXRlKHJvb20uaWQpO1xuICAgIHJvb20uZGVzdHJveSgpO1xuICB9XG4gIGZ1bmN0aW9uIGxlYXNlUm9vbShkZXRhaWxzKSB7XG4gICAgY29uc3QgbGVhdmUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzZWxmID0gbGVhdmU7XG4gICAgICBpZiAoIWRldGFpbHMudW5zdWJzLmRlbGV0ZShzZWxmKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiVGhpcyBsZWF2ZSBmdW5jdGlvbiB3YXMgYWxyZWFkeSBjYWxsZWQuIENhbGxpbmcgaXQgbW9yZSB0aGFuIG9uY2UgaGFzIG5vIGVmZmVjdC5cIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRldGFpbHMudW5zdWJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0ZWFyZG93blJvb20oZGV0YWlscy5yb29tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZGV0YWlscy51bnN1YnMuYWRkKGxlYXZlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vbTogZGV0YWlscy5yb29tLFxuICAgICAgbGVhdmVcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGVudGVyUm9vbShyb29tSWQsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHJvb21zQnlJZC5nZXQocm9vbUlkKTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxlYXNlUm9vbShleGlzdGluZyk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMyID0gYXJnc1swXSA/PyB7fTtcbiAgICBjb25zdCBpbml0aWFsUHJlc2VuY2UgPSAodHlwZW9mIG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlKHJvb21JZCkgOiBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2UpID8/IHt9O1xuICAgIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gKHR5cGVvZiBvcHRpb25zMi5pbml0aWFsU3RvcmFnZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2Uocm9vbUlkKSA6IG9wdGlvbnMyLmluaXRpYWxTdG9yYWdlKSA/PyB7fTtcbiAgICBjb25zdCBuZXdSb29tID0gY3JlYXRlUm9vbShcbiAgICAgIHsgaW5pdGlhbFByZXNlbmNlLCBpbml0aWFsU3RvcmFnZSB9LFxuICAgICAge1xuICAgICAgICByb29tSWQsXG4gICAgICAgIHRocm90dGxlRGVsYXksXG4gICAgICAgIGxvc3RDb25uZWN0aW9uVGltZW91dCxcbiAgICAgICAgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQsXG4gICAgICAgIHBvbHlmaWxsczogY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHMsXG4gICAgICAgIGRlbGVnYXRlczogY2xpZW50T3B0aW9ucy5tb2NrZWREZWxlZ2F0ZXMgPz8ge1xuICAgICAgICAgIGNyZWF0ZVNvY2tldDogbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIGJhc2VVcmwsXG4gICAgICAgICAgICBjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uV2ViU29ja2V0XG4gICAgICAgICAgKSxcbiAgICAgICAgICBhdXRoZW50aWNhdGU6IG1ha2VBdXRoRGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYXV0aE1hbmFnZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGVuYWJsZURlYnVnTG9nZ2luZzogY2xpZW50T3B0aW9ucy5lbmFibGVEZWJ1Z0xvZ2dpbmcsXG4gICAgICAgIGJhc2VVcmwsXG4gICAgICAgIGVycm9yRXZlbnRTb3VyY2U6IGxpdmVibG9ja3NFcnJvclNvdXJjZSxcbiAgICAgICAgbGFyZ2VNZXNzYWdlU3RyYXRlZ3k6IGNsaWVudE9wdGlvbnMubGFyZ2VNZXNzYWdlU3RyYXRlZ3kgPz8gKGNsaWVudE9wdGlvbnMudW5zdGFibGVfZmFsbGJhY2tUb0hUVFAgPyBcImV4cGVyaW1lbnRhbC1mYWxsYmFjay10by1odHRwXCIgOiB2b2lkIDApLFxuICAgICAgICB1bnN0YWJsZV9zdHJlYW1EYXRhOiAhIWNsaWVudE9wdGlvbnMudW5zdGFibGVfc3RyZWFtRGF0YSxcbiAgICAgICAgcm9vbUh0dHBDbGllbnQ6IGh0dHBDbGllbnQsXG4gICAgICAgIGNyZWF0ZVN5bmNTb3VyY2VcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IG5ld1Jvb21EZXRhaWxzID0ge1xuICAgICAgcm9vbTogbmV3Um9vbSxcbiAgICAgIHVuc3ViczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgcm9vbXNCeUlkLnNldChyb29tSWQsIG5ld1Jvb21EZXRhaWxzKTtcbiAgICBzZXR1cERldlRvb2xzKCgpID0+IEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSkpO1xuICAgIGxpbmtEZXZUb29scyhyb29tSWQsIG5ld1Jvb20pO1xuICAgIGNvbnN0IHNob3VsZENvbm5lY3QgPSBvcHRpb25zMi5hdXRvQ29ubmVjdCA/PyB0cnVlO1xuICAgIGlmIChzaG91bGRDb25uZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIGF0b2IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5hdG9iID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIllvdSBuZWVkIHRvIHBvbHlmaWxsIGF0b2IgdG8gdXNlIHRoZSBjbGllbnQgaW4geW91ciBlbnZpcm9ubWVudC4gUGxlYXNlIGZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGF0IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9saXZlYmxvY2tzLWNsaWVudC9hdG9iLXBvbHlmaWxsXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbC5hdG9iID0gY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHMuYXRvYjtcbiAgICAgIH1cbiAgICAgIG5ld1Jvb20uY29ubmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gbGVhc2VSb29tKG5ld1Jvb21EZXRhaWxzKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSb29tKHJvb21JZCkge1xuICAgIGNvbnN0IHJvb20gPSByb29tc0J5SWQuZ2V0KHJvb21JZCk/LnJvb207XG4gICAgcmV0dXJuIHJvb20gPyByb29tIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgYXV0aE1hbmFnZXIucmVzZXQoKTtcbiAgICBjdXJyZW50VXNlcklkLnNldCgoKSA9PiB2b2lkIDApO1xuICAgIGZvciAoY29uc3QgeyByb29tIH0gb2Ygcm9vbXNCeUlkLnZhbHVlcygpKSB7XG4gICAgICBpZiAoIWlzSWRsZShyb29tLmdldFN0YXR1cygpKSkge1xuICAgICAgICByb29tLnJlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCByZXNvbHZlVXNlcnMgPSBjbGllbnRPcHRpb25zLnJlc29sdmVVc2VycztcbiAgY29uc3Qgd2FybklmTm9SZXNvbHZlVXNlcnMgPSBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoXG4gICAgKCkgPT4gIXJlc29sdmVVc2VycyxcbiAgICBcIlNldCB0aGUgcmVzb2x2ZVVzZXJzIG9wdGlvbiBpbiBjcmVhdGVDbGllbnQgdG8gc3BlY2lmeSB1c2VyIGluZm8uXCJcbiAgKTtcbiAgY29uc3QgYmF0Y2hlZFJlc29sdmVVc2VycyA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZFVzZXJJZHMpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZHMgPSBiYXRjaGVkVXNlcklkcy5mbGF0KCk7XG4gICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc29sdmVVc2Vycz8uKHsgdXNlcklkcyB9KTtcbiAgICAgIHdhcm5JZk5vUmVzb2x2ZVVzZXJzKCk7XG4gICAgICByZXR1cm4gdXNlcnMgPz8gdXNlcklkcy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICB9LFxuICAgIHsgZGVsYXk6IFJFU09MVkVfVVNFUlNfQkFUQ0hfREVMQVkgfVxuICApO1xuICBjb25zdCB1c2Vyc1N0b3JlID0gY3JlYXRlQmF0Y2hTdG9yZShiYXRjaGVkUmVzb2x2ZVVzZXJzKTtcbiAgZnVuY3Rpb24gaW52YWxpZGF0ZVJlc29sdmVkVXNlcnModXNlcklkcykge1xuICAgIHVzZXJzU3RvcmUuaW52YWxpZGF0ZSh1c2VySWRzKTtcbiAgfVxuICBjb25zdCByZXNvbHZlUm9vbXNJbmZvID0gY2xpZW50T3B0aW9ucy5yZXNvbHZlUm9vbXNJbmZvO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVSb29tc0luZm8gPSBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoXG4gICAgKCkgPT4gIXJlc29sdmVSb29tc0luZm8sXG4gICAgXCJTZXQgdGhlIHJlc29sdmVSb29tc0luZm8gb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHJvb20gaW5mby5cIlxuICApO1xuICBjb25zdCBiYXRjaGVkUmVzb2x2ZVJvb21zSW5mbyA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZFJvb21JZHMpID0+IHtcbiAgICAgIGNvbnN0IHJvb21JZHMgPSBiYXRjaGVkUm9vbUlkcy5mbGF0KCk7XG4gICAgICBjb25zdCByb29tc0luZm8gPSBhd2FpdCByZXNvbHZlUm9vbXNJbmZvPy4oeyByb29tSWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlUm9vbXNJbmZvKCk7XG4gICAgICByZXR1cm4gcm9vbXNJbmZvID8/IHJvb21JZHMubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgfVxuICApO1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2hlZFJlc29sdmVSb29tc0luZm8pO1xuICBmdW5jdGlvbiBpbnZhbGlkYXRlUmVzb2x2ZWRSb29tc0luZm8ocm9vbUlkcykge1xuICAgIHJvb21zSW5mb1N0b3JlLmludmFsaWRhdGUocm9vbUlkcyk7XG4gIH1cbiAgY29uc3QgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBpbnZhbGlkYXRlUmVzb2x2ZWRNZW50aW9uU3VnZ2VzdGlvbnMoKSB7XG4gICAgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUuY2xlYXIoKTtcbiAgfVxuICBjb25zdCBzeW5jU3RhdHVzU291cmNlcyA9IFtdO1xuICBjb25zdCBzeW5jU3RhdHVzU2lnbmFsID0gbmV3IFNpZ25hbChcInN5bmNocm9uaXplZFwiKTtcbiAgY29uc3QgbGl2ZWJsb2Nrc0Vycm9yU291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGZ1bmN0aW9uIGdldFN5bmNTdGF0dXMoKSB7XG4gICAgY29uc3Qgc3RhdHVzID0gc3luY1N0YXR1c1NpZ25hbC5nZXQoKTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBcInN5bmNocm9uaXppbmdcIiA/IHN0YXR1cyA6IFwic3luY2hyb25pemVkXCI7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb21wdXRlKCkge1xuICAgIHN5bmNTdGF0dXNTaWduYWwuc2V0KFxuICAgICAgc3luY1N0YXR1c1NvdXJjZXMuc29tZSgoc3JjKSA9PiBzcmMuZ2V0KCkgPT09IFwic3luY2hyb25pemluZ1wiKSA/IFwic3luY2hyb25pemluZ1wiIDogc3luY1N0YXR1c1NvdXJjZXMuc29tZSgoc3JjKSA9PiBzcmMuZ2V0KCkgPT09IFwiaGFzLWxvY2FsLWNoYW5nZXNcIikgPyBcImhhcy1sb2NhbC1jaGFuZ2VzXCIgOiBcInN5bmNocm9uaXplZFwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVTeW5jU291cmNlKCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBTaWduYWwoXCJzeW5jaHJvbml6ZWRcIik7XG4gICAgc3luY1N0YXR1c1NvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIGNvbnN0IHVuc3ViID0gc291cmNlLnN1YnNjcmliZSgoKSA9PiByZWNvbXB1dGUoKSk7XG4gICAgZnVuY3Rpb24gc2V0U3luY1N0YXR1cyhzdGF0dXMpIHtcbiAgICAgIHNvdXJjZS5zZXQoc3RhdHVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHVuc3ViKCk7XG4gICAgICBjb25zdCBpbmRleCA9IHN5bmNTdGF0dXNTb3VyY2VzLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbSA9PT0gc291cmNlKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGNvbnN0IFtyZWZdID0gc3luY1N0YXR1c1NvdXJjZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgY29uc3Qgd2FzU3RpbGxQZW5kaW5nID0gcmVmLmdldCgpICE9PSBcInN5bmNocm9uaXplZFwiO1xuICAgICAgICBpZiAod2FzU3RpbGxQZW5kaW5nKSB7XG4gICAgICAgICAgcmVjb21wdXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc2V0U3luY1N0YXR1cywgZGVzdHJveSB9O1xuICB9XG4gIHtcbiAgICBjb25zdCBtYXliZVByZXZlbnRDbG9zZSA9IChlKSA9PiB7XG4gICAgICBpZiAoY2xpZW50T3B0aW9ucy5wcmV2ZW50VW5zYXZlZENoYW5nZXMgJiYgc3luY1N0YXR1c1NpZ25hbC5nZXQoKSAhPT0gXCJzeW5jaHJvbml6ZWRcIikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdm9pZCAwO1xuICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBtYXliZVByZXZlbnRDbG9zZSk7XG4gIH1cbiAgY29uc3QgY2xpZW50ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIGVudGVyUm9vbSxcbiAgICAgIGdldFJvb20sXG4gICAgICBsb2dvdXQsXG4gICAgICAvLyBQdWJsaWMgaW5ib3ggbm90aWZpY2F0aW9ucyBBUElcbiAgICAgIGdldEluYm94Tm90aWZpY2F0aW9uczogaHR0cENsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZTogaHR0cENsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZSxcbiAgICAgIGdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiBodHRwQ2xpZW50LmdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICAgICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDogaHR0cENsaWVudC5tYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkOiBodHRwQ2xpZW50Lm1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICAgIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczogaHR0cENsaWVudC5kZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICBkZWxldGVJbmJveE5vdGlmaWNhdGlvbjogaHR0cENsaWVudC5kZWxldGVJbmJveE5vdGlmaWNhdGlvbixcbiAgICAgIC8vIFB1YmxpYyBjaGFubmVsIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBBUElcbiAgICAgIGdldE5vdGlmaWNhdGlvblNldHRpbmdzOiBodHRwQ2xpZW50LmdldFVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzOiBodHRwQ2xpZW50LnVwZGF0ZVVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgIC8vIEFkdmFuY2VkIHJlc29sdmVycyBBUElzXG4gICAgICByZXNvbHZlcnM6IHtcbiAgICAgICAgaW52YWxpZGF0ZVVzZXJzOiBpbnZhbGlkYXRlUmVzb2x2ZWRVc2VycyxcbiAgICAgICAgaW52YWxpZGF0ZVJvb21zSW5mbzogaW52YWxpZGF0ZVJlc29sdmVkUm9vbXNJbmZvLFxuICAgICAgICBpbnZhbGlkYXRlTWVudGlvblN1Z2dlc3Rpb25zOiBpbnZhbGlkYXRlUmVzb2x2ZWRNZW50aW9uU3VnZ2VzdGlvbnNcbiAgICAgIH0sXG4gICAgICBnZXRTeW5jU3RhdHVzLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGVycm9yOiBsaXZlYmxvY2tzRXJyb3JTb3VyY2UsXG4gICAgICAgIHN5bmNTdGF0dXM6IHN5bmNTdGF0dXNTaWduYWxcbiAgICAgIH0sXG4gICAgICAvLyBJbnRlcm5hbFxuICAgICAgW2tJbnRlcm5hbF06IHtcbiAgICAgICAgY3VycmVudFVzZXJJZCxcbiAgICAgICAgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUsXG4gICAgICAgIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnM6IGNsaWVudE9wdGlvbnMucmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyxcbiAgICAgICAgdXNlcnNTdG9yZSxcbiAgICAgICAgcm9vbXNJbmZvU3RvcmUsXG4gICAgICAgIGdldFJvb21JZHMoKSB7XG4gICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGh0dHBDbGllbnQsXG4gICAgICAgIC8vIFR5cGUtbGV2ZWwgaGVscGVyIG9ubHksIGl0J3MgZWZmZWN0aXZlbHkgb25seSBhbiBpZGVudGl0eS1mdW5jdGlvbiBhdCBydW50aW1lXG4gICAgICAgIGFzOiAoKSA9PiBjbGllbnQsXG4gICAgICAgIGNyZWF0ZVN5bmNTb3VyY2UsXG4gICAgICAgIGVtaXRFcnJvcjogKGNvbnRleHQsIGNhdXNlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXJyb3IzID0gTGl2ZWJsb2Nrc0Vycm9yLmZyb20oY29udGV4dCwgY2F1c2UpO1xuICAgICAgICAgIGNvbnN0IGRpZE5vdGlmeSA9IGxpdmVibG9ja3NFcnJvclNvdXJjZS5ub3RpZnkoZXJyb3IzKTtcbiAgICAgICAgICBpZiAoIWRpZE5vdGlmeSkge1xuICAgICAgICAgICAgZXJyb3IyKGVycm9yMy5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGtJbnRlcm5hbCxcbiAgICB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIGNsaWVudDtcbn1cbmZ1bmN0aW9uIGNoZWNrQm91bmRzKG9wdGlvbiwgdmFsdWUsIG1pbiwgbWF4LCByZWNvbW1lbmRlZE1pbikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDwgbWluIHx8IG1heCAhPT0gdm9pZCAwICYmIHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbWF4ICE9PSB2b2lkIDAgPyBgJHtvcHRpb259IHNob3VsZCBiZSBiZXR3ZWVuICR7cmVjb21tZW5kZWRNaW4gPz8gbWlufSBhbmQgJHttYXh9LmAgOiBgJHtvcHRpb259IHNob3VsZCBiZSBhdCBsZWFzdCAke3JlY29tbWVuZGVkTWluID8/IG1pbn0uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcbiAgICBcImJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XCIsXG4gICAgdmFsdWUsXG4gICAgTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUXG4gICk7XG59XG5mdW5jdGlvbiBnZXRUaHJvdHRsZSh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXCJ0aHJvdHRsZVwiLCB2YWx1ZSwgTUlOX1RIUk9UVExFLCBNQVhfVEhST1RUTEUpO1xufVxuZnVuY3Rpb24gZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcbiAgICBcImxvc3RDb25uZWN0aW9uVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCxcbiAgICBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoY29uZGl0aW9uLCAuLi5hcmdzKSB7XG4gIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIWhhc1dhcm5lZCAmJiAodHlwZW9mIGNvbmRpdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gY29uZGl0aW9uKCkgOiBjb25kaXRpb24pKSB7XG4gICAgICAgIHdhcm4oLi4uYXJncyk7XG4gICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2NvbW1lbnRzL2NvbW1lbnQtYm9keS50c1xuZnVuY3Rpb24gaXNDb21tZW50Qm9keVBhcmFncmFwaChlbGVtZW50KSB7XG4gIHJldHVybiBcInR5cGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQudHlwZSA9PT0gXCJwYXJhZ3JhcGhcIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlUZXh0KGVsZW1lbnQpIHtcbiAgcmV0dXJuICEoXCJ0eXBlXCIgaW4gZWxlbWVudCkgJiYgXCJ0ZXh0XCIgaW4gZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC50ZXh0ID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keU1lbnRpb24oZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibWVudGlvblwiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keUxpbmsoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibGlua1wiO1xufVxudmFyIGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHMgPSB7XG4gIHBhcmFncmFwaDogaXNDb21tZW50Qm9keVBhcmFncmFwaCxcbiAgdGV4dDogaXNDb21tZW50Qm9keVRleHQsXG4gIGxpbms6IGlzQ29tbWVudEJvZHlMaW5rLFxuICBtZW50aW9uOiBpc0NvbW1lbnRCb2R5TWVudGlvblxufTtcbnZhciBjb21tZW50Qm9keUVsZW1lbnRzVHlwZXMgPSB7XG4gIHBhcmFncmFwaDogXCJibG9ja1wiLFxuICB0ZXh0OiBcImlubGluZVwiLFxuICBsaW5rOiBcImlubGluZVwiLFxuICBtZW50aW9uOiBcImlubGluZVwiXG59O1xuZnVuY3Rpb24gdHJhdmVyc2VDb21tZW50Qm9keShib2R5LCBlbGVtZW50T3JWaXNpdG9yLCBwb3NzaWJseVZpc2l0b3IpIHtcbiAgaWYgKCFib2R5IHx8ICFib2R5Py5jb250ZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSB0eXBlb2YgZWxlbWVudE9yVmlzaXRvciA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnRPclZpc2l0b3IgOiB2b2lkIDA7XG4gIGNvbnN0IHR5cGUgPSBlbGVtZW50ID8gY29tbWVudEJvZHlFbGVtZW50c1R5cGVzW2VsZW1lbnRdIDogXCJhbGxcIjtcbiAgY29uc3QgZ3VhcmQgPSBlbGVtZW50ID8gY29tbWVudEJvZHlFbGVtZW50c0d1YXJkc1tlbGVtZW50XSA6ICgpID0+IHRydWU7XG4gIGNvbnN0IHZpc2l0b3IgPSB0eXBlb2YgZWxlbWVudE9yVmlzaXRvciA9PT0gXCJmdW5jdGlvblwiID8gZWxlbWVudE9yVmlzaXRvciA6IHBvc3NpYmx5VmlzaXRvcjtcbiAgZm9yIChjb25zdCBibG9jayBvZiBib2R5LmNvbnRlbnQpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJhbGxcIiB8fCB0eXBlID09PSBcImJsb2NrXCIpIHtcbiAgICAgIGlmIChndWFyZChibG9jaykpIHtcbiAgICAgICAgdmlzaXRvcj8uKGJsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJpbmxpbmVcIikge1xuICAgICAgZm9yIChjb25zdCBpbmxpbmUgb2YgYmxvY2suY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGd1YXJkKGlubGluZSkpIHtcbiAgICAgICAgICB2aXNpdG9yPy4oaW5saW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5KGJvZHkpIHtcbiAgY29uc3QgbWVudGlvbmVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgdHJhdmVyc2VDb21tZW50Qm9keShcbiAgICBib2R5LFxuICAgIFwibWVudGlvblwiLFxuICAgIChtZW50aW9uKSA9PiBtZW50aW9uZWRJZHMuYWRkKG1lbnRpb24uaWQpXG4gICk7XG4gIHJldHVybiBBcnJheS5mcm9tKG1lbnRpb25lZElkcyk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KGJvZHksIHJlc29sdmVVc2Vycykge1xuICBjb25zdCByZXNvbHZlZFVzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgaWYgKCFyZXNvbHZlVXNlcnMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRVc2VycztcbiAgfVxuICBjb25zdCB1c2VySWRzID0gZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5KGJvZHkpO1xuICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc29sdmVVc2Vycyh7XG4gICAgdXNlcklkc1xuICB9KTtcbiAgZm9yIChjb25zdCBbaW5kZXgsIHVzZXJJZF0gb2YgdXNlcklkcy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCB1c2VyID0gdXNlcnM/LltpbmRleF07XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHJlc29sdmVkVXNlcnMuc2V0KHVzZXJJZCwgdXNlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNvbHZlZFVzZXJzO1xufVxudmFyIGh0bWxFc2NhcGFibGVzID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiMzOTtcIlxufTtcbnZhciBodG1sRXNjYXBhYmxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgT2JqZWN0LmtleXMoaHRtbEVzY2FwYWJsZXMpLm1hcCgoZW50aXR5KSA9PiBgXFxcXCR7ZW50aXR5fWApLmpvaW4oXCJ8XCIpLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIGh0bWxTYWZlKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1N0cmluZyh2YWx1ZSldLCBbXSk7XG59XG5mdW5jdGlvbiBqb2luSHRtbChzdHJpbmdzKSB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhbXCJcIl0sIFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFxuICAgIFtcIlwiLCAuLi5BcnJheShzdHJpbmdzLmxlbmd0aCAtIDEpLmZpbGwoXCJcIiksIFwiXCJdLFxuICAgIHN0cmluZ3NcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZUh0bWwodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSHRtbFNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gam9pbkh0bWwodmFsdWUpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkucmVwbGFjZShcbiAgICBodG1sRXNjYXBhYmxlc1JlZ2V4LFxuICAgIChjaGFyYWN0ZXIpID0+IGh0bWxFc2NhcGFibGVzW2NoYXJhY3Rlcl1cbiAgKTtcbn1cbnZhciBIdG1sU2FmZVN0cmluZyA9IGNsYXNzIHtcbiAgI3N0cmluZ3M7XG4gICN2YWx1ZXM7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlczIpIHtcbiAgICB0aGlzLiNzdHJpbmdzID0gc3RyaW5ncztcbiAgICB0aGlzLiN2YWx1ZXMgPSB2YWx1ZXMyO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNzdHJpbmdzLnJlZHVjZSgocmVzdWx0LCBzdHIsIGkpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVIdG1sKG5uKHRoaXMuI3ZhbHVlc1tpIC0gMV0pKSArIHN0cjtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGh0bWwoc3RyaW5ncywgLi4udmFsdWVzMikge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlczIpO1xufVxudmFyIG1hcmtkb3duRXNjYXBhYmxlcyA9IHtcbiAgXzogXCJcXFxcX1wiLFxuICBcIipcIjogXCJcXFxcKlwiLFxuICBcIiNcIjogXCJcXFxcI1wiLFxuICBcImBcIjogXCJcXFxcYFwiLFxuICBcIn5cIjogXCJcXFxcflwiLFxuICBcIiFcIjogXCJcXFxcIVwiLFxuICBcInxcIjogXCJcXFxcfFwiLFxuICBcIihcIjogXCJcXFxcKFwiLFxuICBcIilcIjogXCJcXFxcKVwiLFxuICBcIntcIjogXCJcXFxce1wiLFxuICBcIn1cIjogXCJcXFxcfVwiLFxuICBcIltcIjogXCJcXFxcW1wiLFxuICBcIl1cIjogXCJcXFxcXVwiXG59O1xudmFyIG1hcmtkb3duRXNjYXBhYmxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgT2JqZWN0LmtleXMobWFya2Rvd25Fc2NhcGFibGVzKS5tYXAoKGVudGl0eSkgPT4gYFxcXFwke2VudGl0eX1gKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBqb2luTWFya2Rvd24oc3RyaW5ncykge1xuICBpZiAoc3RyaW5ncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKFtcIlwiXSwgW10pO1xuICB9XG4gIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKFxuICAgIFtcIlwiLCAuLi5BcnJheShzdHJpbmdzLmxlbmd0aCAtIDEpLmZpbGwoXCJcIiksIFwiXCJdLFxuICAgIHN0cmluZ3NcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZU1hcmtkb3duKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcmtkb3duU2FmZVN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBqb2luTWFya2Rvd24odmFsdWUpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkucmVwbGFjZShcbiAgICBtYXJrZG93bkVzY2FwYWJsZXNSZWdleCxcbiAgICAoY2hhcmFjdGVyKSA9PiBtYXJrZG93bkVzY2FwYWJsZXNbY2hhcmFjdGVyXVxuICApO1xufVxudmFyIE1hcmtkb3duU2FmZVN0cmluZyA9IGNsYXNzIHtcbiAgI3N0cmluZ3M7XG4gICN2YWx1ZXM7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlczIpIHtcbiAgICB0aGlzLiNzdHJpbmdzID0gc3RyaW5ncztcbiAgICB0aGlzLiN2YWx1ZXMgPSB2YWx1ZXMyO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNzdHJpbmdzLnJlZHVjZSgocmVzdWx0LCBzdHIsIGkpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVNYXJrZG93bihubih0aGlzLiN2YWx1ZXNbaSAtIDFdKSkgKyBzdHI7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBtYXJrZG93bihzdHJpbmdzLCAuLi52YWx1ZXMyKSB7XG4gIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlczIpO1xufVxuZnVuY3Rpb24gdG9BYnNvbHV0ZVVybCh1cmwyKSB7XG4gIGlmICh1cmwyLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHVybDIuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgcmV0dXJuIHVybDI7XG4gIH0gZWxzZSBpZiAodXJsMi5zdGFydHNXaXRoKFwid3d3LlwiKSkge1xuICAgIHJldHVybiBcImh0dHBzOi8vXCIgKyB1cmwyO1xuICB9XG4gIHJldHVybjtcbn1cbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4gY2hpbGRyZW4sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC50ZXh0LFxuICBsaW5rOiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudGV4dCA/PyBlbGVtZW50LnVybCxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIGBAJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9YDtcbiAgfVxufTtcbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuID8gaHRtbGA8cD4ke2h0bWxTYWZlKGNoaWxkcmVuKX08L3A+YCA6IGNoaWxkcmVuO1xuICB9LFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LnRleHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGh0bWxgJHtjaGlsZHJlbn1gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ib2xkKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPHN0cm9uZz4ke2NoaWxkcmVufTwvc3Ryb25nPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lml0YWxpYykge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxlbT4ke2NoaWxkcmVufTwvZW0+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc3RyaWtldGhyb3VnaCkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxzPiR7Y2hpbGRyZW59PC9zPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmNvZGUpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8Y29kZT4ke2NoaWxkcmVufTwvY29kZT5gO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbGAke2NoaWxkcmVufWA7XG4gIH0sXG4gIGxpbms6ICh7IGVsZW1lbnQsIGhyZWYgfSkgPT4ge1xuICAgIHJldHVybiBodG1sYDxhIGhyZWY9XCIke2hyZWZ9XCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiPiR7ZWxlbWVudC50ZXh0ID8gaHRtbGAke2VsZW1lbnQudGV4dH1gIDogZWxlbWVudC51cmx9PC9hPmA7XG4gIH0sXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBodG1sYDxzcGFuIGRhdGEtbWVudGlvbj5AJHt1c2VyPy5uYW1lID8gaHRtbGAke3VzZXI/Lm5hbWV9YCA6IGVsZW1lbnQuaWR9PC9zcGFuPmA7XG4gIH1cbn07XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4ge1xuICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmJvbGQpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gKioke2NoaWxkcmVufSoqYDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaXRhbGljKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYF8ke2NoaWxkcmVufV9gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zdHJpa2V0aHJvdWdoKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYH5+JHtjaGlsZHJlbn1+fmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmNvZGUpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gXFxgJHtjaGlsZHJlbn1cXGBgO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG4gIGxpbms6ICh7IGVsZW1lbnQsIGhyZWYgfSkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bmBbJHtlbGVtZW50LnRleHQgPz8gZWxlbWVudC51cmx9XSgke2hyZWZ9KWA7XG4gIH0sXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bmBAJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9YDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHN0cmluZ2lmeUNvbW1lbnRCb2R5KGJvZHksIG9wdGlvbnMpIHtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucz8uZm9ybWF0ID8/IFwicGxhaW5cIjtcbiAgY29uc3Qgc2VwYXJhdG9yID0gb3B0aW9ucz8uc2VwYXJhdG9yID8/IChmb3JtYXQgPT09IFwibWFya2Rvd25cIiA/IFwiXFxuXFxuXCIgOiBcIlxcblwiKTtcbiAgY29uc3QgZWxlbWVudHMgPSB7XG4gICAgLi4uZm9ybWF0ID09PSBcImh0bWxcIiA/IHN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzIDogZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keU1hcmtkb3duRWxlbWVudHMgOiBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMsXG4gICAgLi4ub3B0aW9ucz8uZWxlbWVudHNcbiAgfTtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IGF3YWl0IHJlc29sdmVVc2Vyc0luQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBvcHRpb25zPy5yZXNvbHZlVXNlcnNcbiAgKTtcbiAgY29uc3QgYmxvY2tzID0gYm9keS5jb250ZW50LmZsYXRNYXAoKGJsb2NrLCBibG9ja0luZGV4KSA9PiB7XG4gICAgc3dpdGNoIChibG9jay50eXBlKSB7XG4gICAgICBjYXNlIFwicGFyYWdyYXBoXCI6IHtcbiAgICAgICAgY29uc3QgaW5saW5lcyA9IGJsb2NrLmNoaWxkcmVuLmZsYXRNYXAoKGlubGluZSwgaW5saW5lSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keU1lbnRpb24oaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlubGluZS5pZCA/IFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubWVudGlvbihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICB1c2VyOiByZXNvbHZlZFVzZXJzLmdldChpbmxpbmUuaWQpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmxpbmVJbmRleFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdIDogW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5TGluayhpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBlbGVtZW50cy5saW5rKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGlubGluZSxcbiAgICAgICAgICAgICAgICAgIGhyZWY6IHRvQWJzb2x1dGVVcmwoaW5saW5lLnVybCkgPz8gaW5saW5lLnVybFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlUZXh0KGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWxlbWVudHMudGV4dCh7IGVsZW1lbnQ6IGlubGluZSB9LCBpbmxpbmVJbmRleCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGVsZW1lbnRzLnBhcmFncmFwaChcbiAgICAgICAgICAgIHsgZWxlbWVudDogYmxvY2ssIGNoaWxkcmVuOiBpbmxpbmVzLmpvaW4oXCJcIikgfSxcbiAgICAgICAgICAgIGJsb2NrSW5kZXhcbiAgICAgICAgICApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGJsb2Nrcy5qb2luKHNlcGFyYXRvcik7XG59XG5cbi8vIHNyYy9jb21tZW50cy9jb21tZW50LXVybC50c1xudmFyIFBMQUNFSE9MREVSX0JBU0VfVVJMID0gXCJodHRwczovL2xvY2FsaG9zdDo5OTk5XCI7XG52YXIgQUJTT0xVVEVfVVJMX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVpcXGQrXFwtLl0qPzovO1xuZnVuY3Rpb24gZ2VuZXJhdGVDb21tZW50VXJsKHtcbiAgcm9vbVVybCxcbiAgY29tbWVudElkXG59KSB7XG4gIGNvbnN0IGlzQWJzb2x1dGUgPSBBQlNPTFVURV9VUkxfUkVHRVgudGVzdChyb29tVXJsKTtcbiAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTChcbiAgICByb29tVXJsLFxuICAgIGlzQWJzb2x1dGUgPyB2b2lkIDAgOiBQTEFDRUhPTERFUl9CQVNFX1VSTFxuICApO1xuICB1cmxPYmplY3QuaGFzaCA9IGAjJHtjb21tZW50SWR9YDtcbiAgcmV0dXJuIGlzQWJzb2x1dGUgPyB1cmxPYmplY3QuaHJlZiA6IHVybE9iamVjdC5ocmVmLnJlcGxhY2UoUExBQ0VIT0xERVJfQkFTRV9VUkwsIFwiXCIpO1xufVxuXG4vLyBzcmMvY3JkdHMvdXRpbHMudHNcbmZ1bmN0aW9uIHRvUGxhaW5Mc29uKGxzb24pIHtcbiAgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIGRhdGE6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMobHNvbi50b09iamVjdCgpKS5mbGF0TWFwKFxuICAgICAgICAgIChba2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDAgPyBbW2tleSwgdG9QbGFpbkxzb24odmFsdWUpXV0gOiBbXVxuICAgICAgICApXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIFsuLi5sc29uXS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgdG9QbGFpbkxzb24odmFsdWUpXSlcbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlTGlzdFwiLFxuICAgICAgZGF0YTogWy4uLmxzb25dLm1hcCgoaXRlbSkgPT4gdG9QbGFpbkxzb24oaXRlbSkpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbHNvbjtcbiAgfVxufVxuXG4vLyBzcmMvaW1tdXRhYmxlLnRzXG5mdW5jdGlvbiBsc29uT2JqZWN0VG9Kc29uKG9iaikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgY29uc3QgdmFsID0gb2JqW2tleV07XG4gICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxpdmVPYmplY3RUb0pzb24obGl2ZU9iamVjdCkge1xuICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbihsaXZlT2JqZWN0LnRvT2JqZWN0KCkpO1xufVxuZnVuY3Rpb24gbGl2ZU1hcFRvSnNvbihtYXApIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICByZXN1bHRba2V5XSA9IGxzb25Ub0pzb24odmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsc29uTGlzdFRvSnNvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUubWFwKGxzb25Ub0pzb24pO1xufVxuZnVuY3Rpb24gbGl2ZUxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIGxzb25MaXN0VG9Kc29uKHZhbHVlLnRvQXJyYXkoKSk7XG59XG5mdW5jdGlvbiBsc29uVG9Kc29uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gbGl2ZU9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiBsaXZlTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwKSB7XG4gICAgcmV0dXJuIGxpdmVNYXBUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlLmRhdGE7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGxzb25MaXN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uT2JqZWN0VG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBkZWVwTGl2ZWlmeSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IExpdmVMaXN0KHZhbHVlLm1hcChkZWVwTGl2ZWlmeSkpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgY29uc3QgaW5pdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICBjb25zdCB2YWwgPSB2YWx1ZVtrZXldO1xuICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaW5pdFtrZXldID0gZGVlcExpdmVpZnkodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaXZlT2JqZWN0KGluaXQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlTGlzdChsaXZlTGlzdCwgcHJldiwgbmV4dCkge1xuICBsZXQgaSA9IDA7XG4gIGxldCBwcmV2RW5kID0gcHJldi5sZW5ndGggLSAxO1xuICBsZXQgbmV4dEVuZCA9IG5leHQubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZOb2RlID0gcHJldlswXTtcbiAgbGV0IG5leHROb2RlID0gbmV4dFswXTtcbiAgb3V0ZXI6IHtcbiAgICB3aGlsZSAocHJldk5vZGUgPT09IG5leHROb2RlKSB7XG4gICAgICArK2k7XG4gICAgICBpZiAoaSA+IHByZXZFbmQgfHwgaSA+IG5leHRFbmQpIHtcbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbaV07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbaV07XG4gICAgfVxuICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICBuZXh0Tm9kZSA9IG5leHRbbmV4dEVuZF07XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgcHJldkVuZC0tO1xuICAgICAgbmV4dEVuZC0tO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W3ByZXZFbmRdO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIH1cbiAgfVxuICBpZiAoaSA+IHByZXZFbmQpIHtcbiAgICBpZiAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICB3aGlsZSAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaSA+IG5leHRFbmQpIHtcbiAgICBsZXQgbG9jYWxJID0gaTtcbiAgICB3aGlsZSAobG9jYWxJIDw9IHByZXZFbmQpIHtcbiAgICAgIGxpdmVMaXN0LmRlbGV0ZShpKTtcbiAgICAgIGxvY2FsSSsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoaSA8PSBwcmV2RW5kICYmIGkgPD0gbmV4dEVuZCkge1xuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgICAgY29uc3QgbGl2ZUxpc3ROb2RlID0gbGl2ZUxpc3QuZ2V0KGkpO1xuICAgICAgaWYgKGlzTGl2ZU9iamVjdChsaXZlTGlzdE5vZGUpICYmIGlzUGxhaW5PYmplY3QocHJldk5vZGUpICYmIGlzUGxhaW5PYmplY3QobmV4dE5vZGUpKSB7XG4gICAgICAgIHBhdGNoTGl2ZU9iamVjdChsaXZlTGlzdE5vZGUsIHByZXZOb2RlLCBuZXh0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXZlTGlzdC5zZXQoaSwgZGVlcExpdmVpZnkobmV4dE5vZGUpKTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgbGl2ZUxpc3QuaW5zZXJ0KGRlZXBMaXZlaWZ5KG5leHRbaV0pLCBpKTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZU9iamVjdEtleShsaXZlT2JqZWN0LCBrZXksIHByZXYsIG5leHQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IG5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5leHQpO1xuICAgIGlmIChub25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgZXJyb3IyKFxuICAgICAgICBgTmV3IHN0YXRlIHBhdGg6ICcke25vblNlcmlhbGl6YWJsZVZhbHVlLnBhdGh9JyB2YWx1ZTogJyR7U3RyaW5nKFxuICAgICAgICAgIG5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlXG4gICAgICAgICl9JyBpcyBub3Qgc2VyaWFsaXphYmxlLlxuT25seSBzZXJpYWxpemFibGUgdmFsdWUgY2FuIGJlIHN5bmNlZCB3aXRoIExpdmVibG9ja3MuYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBsaXZlT2JqZWN0LmdldChrZXkpO1xuICBpZiAobmV4dCA9PT0gdm9pZCAwKSB7XG4gICAgbGl2ZU9iamVjdC5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgbGl2ZU9iamVjdC5zZXQoa2V5LCBkZWVwTGl2ZWlmeShuZXh0KSk7XG4gIH0gZWxzZSBpZiAocHJldiA9PT0gbmV4dCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpc0xpdmVMaXN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHByZXYpICYmIEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICBwYXRjaExpdmVMaXN0KHZhbHVlLCBwcmV2LCBuZXh0KTtcbiAgfSBlbHNlIGlmIChpc0xpdmVPYmplY3QodmFsdWUpICYmIGlzUGxhaW5PYmplY3QocHJldikgJiYgaXNQbGFpbk9iamVjdChuZXh0KSkge1xuICAgIHBhdGNoTGl2ZU9iamVjdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgbGl2ZU9iamVjdC5zZXQoa2V5LCBkZWVwTGl2ZWlmeShuZXh0KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZU9iamVjdChyb290LCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgIHBhdGNoTGl2ZU9iamVjdEtleShyb290LCBrZXksIHByZXZba2V5XSwgbmV4dFtrZXldKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgaWYgKG5leHRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICByb290LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LmtleXModXBkYXRlcykubGVuZ3RoID4gMCkge1xuICAgIHJvb3QudXBkYXRlKHVwZGF0ZXMpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRzUGF0aChub2RlKSB7XG4gIGNvbnN0IHBhdGggPSBbXTtcbiAgd2hpbGUgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICBpZiAoaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgcGF0aC5wdXNoKG5vZGUucGFyZW50Lm5vZGUuX2luZGV4T2ZQb3NpdGlvbihub2RlLnBhcmVudC5rZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5wdXNoKG5vZGUucGFyZW50LmtleSk7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudC5ub2RlO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0KHN0YXRlLCB1cGRhdGVzKSB7XG4gIHJldHVybiB1cGRhdGVzLnJlZHVjZShcbiAgICAoc3RhdGUyLCB1cGRhdGUpID0+IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdFdpdGhVcGRhdGUoc3RhdGUyLCB1cGRhdGUpLFxuICAgIHN0YXRlXG4gICk7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlLCB1cGRhdGUpIHtcbiAgY29uc3QgcGF0aCA9IGdldFBhcmVudHNQYXRoKHVwZGF0ZS5ub2RlKTtcbiAgcmV0dXJuIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoc3RhdGUsIHBhdGgsIHVwZGF0ZSk7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpIHtcbiAgY29uc3QgcGF0aEl0ZW0gPSBwYXRoLnBvcCgpO1xuICBpZiAocGF0aEl0ZW0gPT09IHZvaWQgMCkge1xuICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJMaXZlT2JqZWN0XCI6IHtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVPYmplY3QgYnV0IHN0YXRlIHdhcyBub3QgYW4gb2JqZWN0XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSB1cGRhdGUubm9kZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJMaXZlTGlzdFwiOiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZUxpc3QgYnV0IHN0YXRlIHdhcyBub3QgYW4gYXJyYXlcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1N0YXRlID0gc3RhdGUubWFwKCh4KSA9PiB4KTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0VXBkYXRlIG9mIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXdTdGF0ZS5tYXAoXG4gICAgICAgICAgICAgIChpdGVtLCBpbmRleCkgPT4gaW5kZXggPT09IGxpc3RVcGRhdGUuaW5kZXggPyBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSkgOiBpdGVtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcImluc2VydFwiKSB7XG4gICAgICAgICAgICBpZiAobGlzdFVwZGF0ZS5pbmRleCA9PT0gbmV3U3RhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlLnB1c2gobHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUuaW5kZXgpLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4KVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZS5zcGxpY2UobGlzdFVwZGF0ZS5pbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwibW92ZVwiKSB7XG4gICAgICAgICAgICBpZiAobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ID4gbGlzdFVwZGF0ZS5pbmRleCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleCwgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShcbiAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLmluZGV4ICsgMVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXggKyAxKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZU1hcFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlTWFwIGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB1cGRhdGUubm9kZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnN0YXRlXTtcbiAgICBuZXdBcnJheVtwYXRoSXRlbV0gPSBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKFxuICAgICAgc3RhdGVbcGF0aEl0ZW1dLFxuICAgICAgcGF0aCxcbiAgICAgIHVwZGF0ZVxuICAgICk7XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9IGVsc2UgaWYgKGlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICBjb25zdCBub2RlID0gc3RhdGVbcGF0aEl0ZW1dO1xuICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhdGVBc09iaiA9IHN0YXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGVBc09iaixcbiAgICAgICAgW3BhdGhJdGVtXTogbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShub2RlLCBwYXRoLCB1cGRhdGUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9kZXByZWNhdGlvbi50c1xudmFyIF9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5mdW5jdGlvbiBkZXByZWNhdGUobWVzc2FnZSwga2V5ID0gbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MuaGFzKGtleSkpIHtcbiAgICAgIF9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncy5hZGQoa2V5KTtcbiAgICAgIGVycm9yV2l0aFRpdGxlKFwiRGVwcmVjYXRpb24gd2FybmluZ1wiLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZUlmKGNvbmRpdGlvbiwgbWVzc2FnZSwga2V5ID0gbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgZGVwcmVjYXRlKG1lc3NhZ2UsIGtleSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0aHJvd1VzYWdlRXJyb3IobWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgdXNhZ2VFcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB1c2FnZUVycm9yLm5hbWUgPSBcIlVzYWdlIGVycm9yXCI7XG4gICAgZXJyb3JXaXRoVGl0bGUoXCJVc2FnZSBlcnJvclwiLCBtZXNzYWdlKTtcbiAgICB0aHJvdyB1c2FnZUVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcklmKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgdGhyb3dVc2FnZUVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvbGliL1BvbGxlci50c1xudmFyIEJBQ0tPRkZfREVMQVlTMiA9IFsxZTMsIDJlMywgNGUzLCA4ZTMsIDFlNF07XG5mdW5jdGlvbiBtYWtlUG9sbGVyKGNhbGxiYWNrLCBpbnRlcnZhbE1zLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHZvaWQgMDtcbiAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHZvaWQgMDtcbiAgY29uc3QgbWF4U3RhbGVUaW1lTXMgPSBvcHRpb25zPy5tYXhTdGFsZVRpbWVNcyA/PyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgaW5Gb3JlZ3JvdW5kOiBkb2M/LnZpc2liaWxpdHlTdGF0ZSAhPT0gXCJoaWRkZW5cIixcbiAgICBsYXN0U3VjY2Vzc2Z1bFBvbGxBdDogc3RhcnRUaW1lLFxuICAgIGNvdW50OiAwLFxuICAgIGJhY2tvZmY6IDBcbiAgfTtcbiAgZnVuY3Rpb24gbWF5UG9sbCgpIHtcbiAgICByZXR1cm4gY29udGV4dC5jb3VudCA+IDAgJiYgY29udGV4dC5pbkZvcmVncm91bmQ7XG4gIH1cbiAgY29uc3QgZnNtID0gbmV3IEZTTSh7fSkuYWRkU3RhdGUoXCJAaWRsZVwiKS5hZGRTdGF0ZShcIkBlbmFibGVkXCIpLmFkZFN0YXRlKFwiQHBvbGxpbmdcIik7XG4gIGZzbS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlXCIsIHsgU1RBUlQ6IFwiQGVuYWJsZWRcIiB9KTtcbiAgZnNtLmFkZFRyYW5zaXRpb25zKFwiQGVuYWJsZWRcIiwgeyBTVE9QOiBcIkBpZGxlXCIsIFBPTEw6IFwiQHBvbGxpbmdcIiB9KTtcbiAgZnNtLmFkZFRpbWVkVHJhbnNpdGlvbihcbiAgICBcIkBlbmFibGVkXCIsXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgbGFzdFBvbGwgPSBjb250ZXh0Lmxhc3RTdWNjZXNzZnVsUG9sbEF0O1xuICAgICAgY29uc3QgbmV4dFBvbGwgPSBsYXN0UG9sbCArIGludGVydmFsTXM7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgbmV4dFBvbGwgLSBwZXJmb3JtYW5jZS5ub3coKSkgKyBjb250ZXh0LmJhY2tvZmY7XG4gICAgfSxcbiAgICBcIkBwb2xsaW5nXCJcbiAgKTtcbiAgZnNtLm9uRW50ZXJBc3luYyhcbiAgICBcIkBwb2xsaW5nXCIsXG4gICAgYXN5bmMgKF9jdHgsIHNpZ25hbCkgPT4ge1xuICAgICAgYXdhaXQgY2FsbGJhY2soc2lnbmFsKTtcbiAgICAgIGlmICghc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgY29udGV4dC5sYXN0U3VjY2Vzc2Z1bFBvbGxBdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gV2hlbiBPS1xuICAgICgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogbWF5UG9sbCgpID8gXCJAZW5hYmxlZFwiIDogXCJAaWRsZVwiLFxuICAgICAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgICAgICBjb250ZXh0LmJhY2tvZmYgPSAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gV2hlbiBlcnJvclxuICAgICgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogbWF5UG9sbCgpID8gXCJAZW5hYmxlZFwiIDogXCJAaWRsZVwiLFxuICAgICAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgICAgICBjb250ZXh0LmJhY2tvZmYgPSBCQUNLT0ZGX0RFTEFZUzIuZmluZCgoZGVsYXkpID0+IGRlbGF5ID4gY29udGV4dC5iYWNrb2ZmKSA/PyBCQUNLT0ZGX0RFTEFZUzJbQkFDS09GRl9ERUxBWVMyLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgM2U0XG4gICAgLy8gQWJvcnQgdGhlIHBvbGwgaWYgdGhlIGNhbGxiYWNrIHRha2VzIG1vcmUgdGhhbiAzMCBzZWNvbmRzIHRvIGNvbXBsZXRlXG4gICk7XG4gIGZ1bmN0aW9uIHN0YXJ0T3JTdG9wKCkge1xuICAgIGlmIChtYXlQb2xsKCkpIHtcbiAgICAgIGZzbS5zZW5kKHsgdHlwZTogXCJTVEFSVFwiIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmc20uc2VuZCh7IHR5cGU6IFwiU1RPUFwiIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbmMoKSB7XG4gICAgY29udGV4dC5jb3VudCsrO1xuICAgIHN0YXJ0T3JTdG9wKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVjKCkge1xuICAgIGNvbnRleHQuY291bnQtLTtcbiAgICBpZiAoY29udGV4dC5jb3VudCA8IDApIHtcbiAgICAgIGNvbnRleHQuY291bnQgPSAwO1xuICAgIH1cbiAgICBzdGFydE9yU3RvcCgpO1xuICB9XG4gIGZ1bmN0aW9uIHBvbGxOb3dJZlN0YWxlKCkge1xuICAgIGlmIChwZXJmb3JtYW5jZS5ub3coKSAtIGNvbnRleHQubGFzdFN1Y2Nlc3NmdWxQb2xsQXQgPiBtYXhTdGFsZVRpbWVNcykge1xuICAgICAgZnNtLnNlbmQoeyB0eXBlOiBcIlBPTExcIiB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0SW5Gb3JlZ3JvdW5kKGluRm9yZWdyb3VuZCkge1xuICAgIGNvbnRleHQuaW5Gb3JlZ3JvdW5kID0gaW5Gb3JlZ3JvdW5kO1xuICAgIHN0YXJ0T3JTdG9wKCk7XG4gICAgcG9sbE5vd0lmU3RhbGUoKTtcbiAgfVxuICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgc2V0SW5Gb3JlZ3JvdW5kKGRvYz8udmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiKTtcbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBwb2xsTm93SWZTdGFsZSk7XG4gIGZzbS5zdGFydCgpO1xuICByZXR1cm4ge1xuICAgIGluYyxcbiAgICBkZWMsXG4gICAgcG9sbE5vd0lmU3RhbGUsXG4gICAgLy8gSW50ZXJuYWwgQVBJLCB1c2VkIGJ5IHVuaXQgdGVzdHMgb25seSB0byBzaW11bGF0ZSB2aXNpYmlsaXR5IGV2ZW50c1xuICAgIHNldEluRm9yZWdyb3VuZFxuICB9O1xufVxuXG4vLyBzcmMvbGliL3NoYWxsb3cudHNcbmZ1bmN0aW9uIHNoYWxsb3dBcnJheSh4cywgeXMpIHtcbiAgaWYgKHhzLmxlbmd0aCAhPT0geXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5pcyh4c1tpXSwgeXNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2hhbGxvd09iaihvYmpBLCBvYmpCKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChvYmpBKSB8fCAhaXNQbGFpbk9iamVjdChvYmpCKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmpCKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGtleXNBLmV2ZXJ5KFxuICAgIChrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXkpICYmIE9iamVjdC5pcyhvYmpBW2tleV0sIG9iakJba2V5XSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3coYSwgYikge1xuICBpZiAoT2JqZWN0LmlzKGEsIGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICBjb25zdCBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gIGlmIChpc0FycmF5QSB8fCBpc0FycmF5Qikge1xuICAgIGlmICghaXNBcnJheUEgfHwgIWlzQXJyYXlCKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzaGFsbG93QXJyYXkoYSwgYik7XG4gIH1cbiAgcmV0dXJuIHNoYWxsb3dPYmooYSwgYik7XG59XG5cbi8vIHNyYy9saWIvU29ydGVkTGlzdC50c1xuZnVuY3Rpb24gYmlzZWN0UmlnaHQoYXJyLCB4LCBsdCkge1xuICBsZXQgbG8gPSAwO1xuICBsZXQgaGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIGNvbnN0IG1pZCA9IGxvICsgKGhpIC0gbG8gPj4gMSk7XG4gICAgaWYgKGx0KHgsIGFyclttaWRdKSkge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvID0gbWlkICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvO1xufVxudmFyIFNvcnRlZExpc3QgPSBjbGFzcyBfU29ydGVkTGlzdCB7XG4gICNkYXRhO1xuICAjbHQ7XG4gIGNvbnN0cnVjdG9yKGFscmVhZHlTb3J0ZWRMaXN0LCBsdCkge1xuICAgIHRoaXMuI2x0ID0gbHQ7XG4gICAgdGhpcy4jZGF0YSA9IGFscmVhZHlTb3J0ZWRMaXN0O1xuICB9XG4gIHN0YXRpYyBmcm9tKGFyciwgbHQpIHtcbiAgICBjb25zdCBzb3J0ZWQgPSBuZXcgX1NvcnRlZExpc3QoW10sIGx0KTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBzb3J0ZWQuYWRkKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gc29ydGVkO1xuICB9XG4gIHN0YXRpYyBmcm9tQWxyZWFkeVNvcnRlZChhbHJlYWR5U29ydGVkLCBsdCkge1xuICAgIHJldHVybiBuZXcgX1NvcnRlZExpc3QoYWxyZWFkeVNvcnRlZCwgbHQpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHNvcnRlZCBsaXN0IHRvIGEgbmV3IGluc3RhbmNlLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfU29ydGVkTGlzdCh0aGlzLiNkYXRhLnNsaWNlKCksIHRoaXMuI2x0KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRoZSBzb3J0ZWQgbGlzdCwgc3VjaCB0aGF0IGl0IHJlbWFpbnMgc29ydGVkLlxuICAgKi9cbiAgYWRkKHZhbHVlKSB7XG4gICAgY29uc3QgaWR4ID0gYmlzZWN0UmlnaHQodGhpcy4jZGF0YSwgdmFsdWUsIHRoaXMuI2x0KTtcbiAgICB0aGlzLiNkYXRhLnNwbGljZShpZHgsIDAsIHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gdmFsdWUgZnJvbSB0aGUgc29ydGVkIGxpc3QsIGlmIGl0IGV4aXN0cy4gVGhlIGdpdmVuXG4gICAqIHZhbHVlIG11c3QgYmUgYD09PWAgdG8gb25lIG9mIHRoZSBsaXN0IGl0ZW1zLiBPbmx5IHRoZSBmaXJzdCBlbnRyeSB3aWxsIGJlXG4gICAqIHJlbW92ZWQgaWYgdGhlIGVsZW1lbnQgZXhpc3RzIGluIHRoZSBzb3J0ZWQgbGlzdCBtdWx0aXBsZSB0aW1lcy5cbiAgICovXG4gIHJlbW92ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuI2RhdGEuaW5kZXhPZih2YWx1ZSk7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLiNkYXRhLnNwbGljZShpZHgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhLmxlbmd0aDtcbiAgfVxuICAqZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNkYXRhKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGl0ZW0pKSB7XG4gICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3RvY29sL1VzZXJOb3RpZmljYXRpb25TZXR0aW5ncy50c1xuZnVuY3Rpb24gaXNOb3RpZmljYXRpb25DaGFubmVsRW5hYmxlZChzZXR0aW5ncykge1xuICByZXR1cm4gdmFsdWVzKHNldHRpbmdzKS5ldmVyeSgoZW5hYmxlZCkgPT4gZW5hYmxlZCA9PT0gdHJ1ZSk7XG59XG5cbi8vIHNyYy90eXBlcy9PdGhlcnMudHNcbnZhciBUZXh0RWRpdG9yVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFRleHRFZGl0b3JUeXBlMikgPT4ge1xuICBUZXh0RWRpdG9yVHlwZTJbXCJMZXhpY2FsXCJdID0gXCJsZXhpY2FsXCI7XG4gIFRleHRFZGl0b3JUeXBlMltcIlRpcFRhcFwiXSA9IFwidGlwdGFwXCI7XG4gIHJldHVybiBUZXh0RWRpdG9yVHlwZTI7XG59KShUZXh0RWRpdG9yVHlwZSB8fCB7fSk7XG5cbi8vIHNyYy9pbmRleC50c1xuZGV0ZWN0RHVwZXMoUEtHX05BTUUsIFBLR19WRVJTSU9OLCBQS0dfRk9STUFUKTtcbnZhciBDb21tZW50c0FwaUVycm9yID0gSHR0cEVycm9yO1xudmFyIE5vdGlmaWNhdGlvbnNBcGlFcnJvciA9IEh0dHBFcnJvcjtcbmV4cG9ydCB7XG4gIENsaWVudE1zZ0NvZGUsXG4gIENvbW1lbnRzQXBpRXJyb3IsXG4gIENyZHRUeXBlLFxuICBEZWZhdWx0TWFwLFxuICBEZXJpdmVkU2lnbmFsLFxuICBIdHRwRXJyb3IsXG4gIExpdmVMaXN0LFxuICBMaXZlTWFwLFxuICBMaXZlT2JqZWN0LFxuICBMaXZlYmxvY2tzRXJyb3IsXG4gIE11dGFibGVTaWduYWwsXG4gIE5vdGlmaWNhdGlvbnNBcGlFcnJvcixcbiAgT3BDb2RlLFxuICBQZXJtaXNzaW9uLFxuICBQcm9taXNlX3dpdGhSZXNvbHZlcnMsXG4gIFNlcnZlck1zZ0NvZGUsXG4gIFNpZ25hbCxcbiAgU29ydGVkTGlzdCxcbiAgVGV4dEVkaXRvclR5cGUsXG4gIFdlYnNvY2tldENsb3NlQ29kZXMsXG4gIGFja09wLFxuICBhc1BvcyxcbiAgYXNzZXJ0LFxuICBhc3NlcnROZXZlcixcbiAgYXV0b1JldHJ5LFxuICBiNjRkZWNvZGUsXG4gIGJhdGNoLFxuICBjaHVuayxcbiAgY2xvbmVMc29uLFxuICBjb21wYWN0T2JqZWN0LFxuICBmYW5jeV9jb25zb2xlX2V4cG9ydHMgYXMgY29uc29sZSxcbiAgY29udmVydFRvQ29tbWVudERhdGEsXG4gIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24sXG4gIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YSxcbiAgY29udmVydFRvVGhyZWFkRGF0YSxcbiAgY3JlYXRlQ2xpZW50LFxuICBjcmVhdGVDb21tZW50QXR0YWNobWVudElkLFxuICBjcmVhdGVDb21tZW50SWQsXG4gIGNyZWF0ZUluYm94Tm90aWZpY2F0aW9uSWQsXG4gIGNyZWF0ZVRocmVhZElkLFxuICBkZXByZWNhdGUsXG4gIGRlcHJlY2F0ZUlmLFxuICBkZXRlY3REdXBlcyxcbiAgZW50cmllcyxcbiAgZXJyb3JJZixcbiAgZnJlZXplLFxuICBnZW5lcmF0ZUNvbW1lbnRVcmwsXG4gIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keSxcbiAgaHRtbCxcbiAgaHRtbFNhZmUsXG4gIGlzQ2hpbGRDcmR0LFxuICBpc0NvbW1lbnRCb2R5TGluayxcbiAgaXNDb21tZW50Qm9keU1lbnRpb24sXG4gIGlzQ29tbWVudEJvZHlUZXh0LFxuICBpc0pzb25BcnJheSxcbiAgaXNKc29uT2JqZWN0LFxuICBpc0pzb25TY2FsYXIsXG4gIGlzTGl2ZU5vZGUsXG4gIGlzTm90aWZpY2F0aW9uQ2hhbm5lbEVuYWJsZWQsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzUm9vdENyZHQsXG4gIGlzU3RhcnRzV2l0aE9wZXJhdG9yLFxuICBrSW50ZXJuYWwsXG4gIGtleXMsXG4gIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdCxcbiAgbHNvblRvSnNvbixcbiAgbWFrZUV2ZW50U291cmNlLFxuICBtYWtlUG9sbGVyLFxuICBtYWtlUG9zaXRpb24sXG4gIG1hcFZhbHVlcyxcbiAgbWVtb2l6ZU9uU3VjY2VzcyxcbiAgbmFub2lkLFxuICBubixcbiAgb2JqZWN0VG9RdWVyeSxcbiAgcGF0Y2hMaXZlT2JqZWN0S2V5LFxuICByYWlzZSxcbiAgcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keSxcbiAgc2hhbGxvdyxcbiAgc3RhYmxlU3RyaW5naWZ5LFxuICBzdHJpbmdpZnlDb21tZW50Qm9keSxcbiAgdGhyb3dVc2FnZUVycm9yLFxuICB0b0Fic29sdXRlVXJsLFxuICB0b1BsYWluTHNvbixcbiAgdHJ5UGFyc2VKc29uLFxuICB1cmwsXG4gIHVybGpvaW4sXG4gIHdhaXQsXG4gIHdpdGhUaW1lb3V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@liveblocks/core/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@liveblocks/node/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@liveblocks/node/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Liveblocks: () => (/* binding */ Liveblocks),\n/* harmony export */   LiveblocksError: () => (/* binding */ LiveblocksError),\n/* harmony export */   WebhookHandler: () => (/* binding */ WebhookHandler),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.getMentionedIdsFromCommentBody),\n/* harmony export */   isCustomNotificationEvent: () => (/* binding */ isCustomNotificationEvent),\n/* harmony export */   isNotificationChannelEnabled: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.isNotificationChannelEnabled),\n/* harmony export */   isTextMentionNotificationEvent: () => (/* binding */ isTextMentionNotificationEvent),\n/* harmony export */   isThreadNotificationEvent: () => (/* binding */ isThreadNotificationEvent),\n/* harmony export */   stringifyCommentBody: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.stringifyCommentBody)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liveblocks/core */ \"(rsc)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var _stablelib_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stablelib/base64 */ \"(rsc)/./node_modules/@stablelib/base64/lib/base64.js\");\n/* harmony import */ var fast_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-sha256 */ \"(rsc)/./node_modules/fast-sha256/sha256.js\");\n// src/index.ts\n\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/node\";\nvar PKG_VERSION = \"2.19.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/client.ts\n\n\n// src/Session.ts\n\n\n// src/utils.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\nvar VALID_KEY_CHARS_REGEX = /^[\\w-]+$/;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nasync function fetchPolyfill() {\n  return typeof globalThis.fetch !== \"undefined\" ? globalThis.fetch : (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/whatwg-url\"), __webpack_require__.e(\"vendor-chunks/tr46\"), __webpack_require__.e(\"vendor-chunks/node-fetch\"), __webpack_require__.e(\"vendor-chunks/webidl-conversions\")]).then(__webpack_require__.bind(__webpack_require__, /*! node-fetch */ \"(rsc)/./node_modules/node-fetch/lib/index.mjs\"))).default;\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction startsWith(value, prefix) {\n  return isString(value) && value.startsWith(prefix);\n}\nfunction isNonEmpty(value) {\n  return isString(value) && value.length > 0;\n}\nfunction assertNonEmpty(value, field) {\n  if (!isNonEmpty(value)) {\n    throw new Error(\n      `Invalid value for field '${field}'. Please provide a non-empty string. For more information: https://liveblocks.io/docs/api-reference/liveblocks-node#authorize`\n    );\n  }\n}\nfunction assertSecretKey(value, field) {\n  if (!startsWith(value, \"sk_\")) {\n    throw new Error(\n      `Invalid value for field '${field}'. Secret keys must start with 'sk_'. Please provide the secret key from your Liveblocks dashboard at https://liveblocks.io/dashboard/apikeys.`\n    );\n  }\n  if (!VALID_KEY_CHARS_REGEX.test(value)) {\n    throw new Error(\n      `Invalid chars found in field '${field}'. Please check that you correctly copied the secret key from your Liveblocks dashboard at https://liveblocks.io/dashboard/apikeys.`\n    );\n  }\n}\nfunction normalizeStatusCode(statusCode) {\n  if (statusCode >= 200 && statusCode < 300) {\n    return 200;\n  } else if (statusCode >= 500) {\n    return 503;\n  } else {\n    return 403;\n  }\n}\n\n// src/Session.ts\nvar ALL_PERMISSIONS = Object.freeze([\n  \"room:write\",\n  \"room:read\",\n  \"room:presence:write\",\n  \"comments:write\",\n  \"comments:read\"\n]);\nfunction isPermission(value) {\n  return ALL_PERMISSIONS.includes(value);\n}\nvar MAX_PERMS_PER_SET = 10;\nvar READ_ACCESS = Object.freeze([\n  \"room:read\",\n  \"room:presence:write\",\n  \"comments:read\"\n]);\nvar FULL_ACCESS = Object.freeze([\"room:write\", \"comments:write\"]);\nvar roomPatternRegex = /^([*]|[^*]{1,128}[*]?)$/;\nvar Session = class {\n  FULL_ACCESS = FULL_ACCESS;\n  READ_ACCESS = READ_ACCESS;\n  #postFn;\n  #userId;\n  #userInfo;\n  #sealed = false;\n  #permissions = /* @__PURE__ */ new Map();\n  /** @internal */\n  constructor(postFn, userId, userInfo) {\n    assertNonEmpty(userId, \"userId\");\n    this.#postFn = postFn;\n    this.#userId = userId;\n    this.#userInfo = userInfo;\n  }\n  #getOrCreate(roomId) {\n    if (this.#sealed) {\n      throw new Error(\"You can no longer change these permissions.\");\n    }\n    let perms = this.#permissions.get(roomId);\n    if (perms) {\n      return perms;\n    } else {\n      if (this.#permissions.size >= MAX_PERMS_PER_SET) {\n        throw new Error(\n          \"You cannot add permissions for more than 10 rooms in a single token\"\n        );\n      }\n      perms = /* @__PURE__ */ new Set();\n      this.#permissions.set(roomId, perms);\n      return perms;\n    }\n  }\n  allow(roomIdOrPattern, newPerms) {\n    if (typeof roomIdOrPattern !== \"string\") {\n      throw new Error(\"Room name or pattern must be a string\");\n    }\n    if (!roomPatternRegex.test(roomIdOrPattern)) {\n      throw new Error(\"Invalid room name or pattern\");\n    }\n    if (newPerms.length === 0) {\n      throw new Error(\"Permission list cannot be empty\");\n    }\n    const existingPerms = this.#getOrCreate(roomIdOrPattern);\n    for (const perm of newPerms) {\n      if (!isPermission(perm)) {\n        throw new Error(`Not a valid permission: ${perm}`);\n      }\n      existingPerms.add(perm);\n    }\n    return this;\n  }\n  /** @internal - For unit tests only */\n  hasPermissions() {\n    return this.#permissions.size > 0;\n  }\n  /** @internal - For unit tests only */\n  seal() {\n    if (this.#sealed) {\n      throw new Error(\n        \"You cannot reuse Session instances. Please create a new session every time.\"\n      );\n    }\n    this.#sealed = true;\n  }\n  /** @internal - For unit tests only */\n  serializePermissions() {\n    return Object.fromEntries(\n      Array.from(this.#permissions.entries()).map(([pat, perms]) => [\n        pat,\n        Array.from(perms)\n      ])\n    );\n  }\n  /**\n   * Call this to authorize the session to access Liveblocks. Note that this\n   * will return a Liveblocks \"access token\". Anyone that obtains such access\n   * token will have access to the allowed resources.\n   */\n  async authorize() {\n    this.seal();\n    if (!this.hasPermissions()) {\n      console.warn(\n        \"Access tokens without any permission will not be supported soon, you should use wildcards when the client requests a token for resources outside a room. See https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions\"\n      );\n    }\n    try {\n      const resp = await this.#postFn((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/authorize-user`, {\n        // Required\n        userId: this.#userId,\n        permissions: this.serializePermissions(),\n        // Optional metadata\n        userInfo: this.#userInfo\n      });\n      return {\n        status: normalizeStatusCode(resp.status),\n        body: await resp.text()\n      };\n    } catch (er) {\n      return {\n        status: 503,\n        body: 'Call to /v2/authorize-user failed. See \"error\" for more information.',\n        error: er\n      };\n    }\n  }\n};\n\n// src/client.ts\nvar Liveblocks = class {\n  #secret;\n  #baseUrl;\n  /**\n   * Interact with the Liveblocks API from your Node.js backend.\n   */\n  constructor(options) {\n    const options_ = options;\n    const secret = options_.secret;\n    assertSecretKey(secret, \"secret\");\n    this.#secret = secret;\n    this.#baseUrl = new URL(getBaseUrl(options.baseUrl));\n  }\n  async #post(path, json, options) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this.#baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`,\n      \"Content-Type\": \"application/json\"\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(json),\n      signal: options?.signal\n    });\n    return res;\n  }\n  async #put(path, json, options) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this.#baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`,\n      \"Content-Type\": \"application/json\"\n    };\n    const fetch = await fetchPolyfill();\n    return await fetch(url3, {\n      method: \"PUT\",\n      headers,\n      body: JSON.stringify(json),\n      signal: options?.signal\n    });\n  }\n  async #putBinary(path, body, params, options) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this.#baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`,\n      \"Content-Type\": \"application/octet-stream\"\n    };\n    const fetch = await fetchPolyfill();\n    return await fetch(url3, {\n      method: \"PUT\",\n      headers,\n      body,\n      signal: options?.signal\n    });\n  }\n  async #delete(path, options) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this.#baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, {\n      method: \"DELETE\",\n      headers,\n      signal: options?.signal\n    });\n    return res;\n  }\n  async #get(path, params, options) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this.#baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, {\n      method: \"GET\",\n      headers,\n      signal: options?.signal\n    });\n    return res;\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Authentication\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Prepares a new session to authorize a user to access Liveblocks.\n   *\n   * IMPORTANT:\n   * Always make sure that you trust the user making the request to your\n   * backend before calling .prepareSession()!\n   *\n   * @param userId Tell Liveblocks the user ID of the user to authorize. Must\n   * uniquely identify the user account in your system. The uniqueness of this\n   * value will determine how many MAUs will be counted/billed.\n   *\n   * @param options.userInfo Custom metadata to attach to this user. Data you\n   * add here will be visible to all other clients in the room, through the\n   * `other.info` property.\n   *\n   */\n  prepareSession(userId, ...rest) {\n    const options = rest[0];\n    return new Session(this.#post.bind(this), userId, options?.userInfo);\n  }\n  /**\n   * Call this to authenticate the user as an actor you want to allow to use\n   * Liveblocks.\n   *\n   * You should use this method only if you want to manage your permissions\n   * through the Liveblocks Permissions API. This method is more complicated to\n   * set up, but allows for finer-grained specification of permissions.\n   *\n   * Calling `.identifyUser()` only lets you securely identify a user (and what\n   * groups they belong to). What permissions this user will end up having is\n   * determined by whatever permissions you assign the user/group in your\n   * Liveblocks account, through the Permissions API:\n   * https://liveblocks.io/docs/rooms/permissions\n   *\n   * IMPORTANT:\n   * Always verify that you trust the user making the request before calling\n   * .identifyUser()!\n   *\n   * @param identity Tell Liveblocks the user ID of the user to authenticate.\n   * Must uniquely identify the user account in your system. The uniqueness of\n   * this value will determine how many MAUs will be counted/billed.\n   *\n   * If you also want to assign which groups this user belongs to, use the\n   * object form and specify the `groupIds` property. Those `groupIds` should\n   * match the groupIds you assigned permissions to via the Liveblocks\n   * Permissions API, see\n   * https://liveblocks.io/docs/rooms/permissions#permissions-levels-groups-accesses-example\n   *\n   * @param options.userInfo Custom metadata to attach to this user. Data you\n   * add here will be visible to all other clients in the room, through the\n   * `other.info` property.\n   */\n  // These fields define the security identity of the user. Whatever you pass in here will define which\n  async identifyUser(identity, ...rest) {\n    const options = rest[0];\n    const path = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/identify-user`;\n    const userId = typeof identity === \"string\" ? identity : identity.userId;\n    const groupIds = typeof identity === \"string\" ? void 0 : identity.groupIds;\n    assertNonEmpty(userId, \"userId\");\n    try {\n      const resp = await this.#post(path, {\n        userId,\n        groupIds,\n        // Optional metadata\n        userInfo: options?.userInfo\n      });\n      return {\n        status: normalizeStatusCode(resp.status),\n        body: await resp.text()\n      };\n    } catch (er) {\n      return {\n        status: 503,\n        body: `Call to ${(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(\n          this.#baseUrl,\n          path\n        )} failed. See \"error\" for more information.`,\n        error: er\n      };\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Room\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Returns a list of your rooms. The rooms are returned sorted by creation date, from newest to oldest. You can filter rooms by metadata, users accesses and groups accesses.\n   * @param params.limit (optional) A limit on the number of rooms to be returned. The limit can range between 1 and 100, and defaults to 20.\n   * @param params.startingAfter (optional) A cursor used for pagination. You get the value from the response of the previous page.\n   * @param params.userId (optional) A filter on users accesses.\n   * @param params.metadata (optional) A filter on metadata. Multiple metadata keys can be used to filter rooms.\n   * @param params.groupIds (optional) A filter on groups accesses. Multiple groups can be used.\n   * @param params.query (optional) A query to filter rooms by. It is based on our query language. You can filter by metadata and room ID.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A list of rooms.\n   */\n  async getRooms(params = {}, options) {\n    const path = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms`;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const queryParams = {\n      limit: params.limit,\n      startingAfter: params.startingAfter,\n      userId: params.userId,\n      groupIds: params.groupIds ? params.groupIds.join(\",\") : void 0,\n      // \"Flatten\" {metadata: {foo: \"bar\"}} to {\"metadata.foo\": \"bar\"}\n      ...Object.fromEntries(\n        Object.entries(params.metadata ?? {}).map(([key, val]) => [\n          `metadata.${key}`,\n          val\n        ])\n      ),\n      query\n    };\n    const res = await this.#get(path, queryParams, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const rooms = data.data.map((room) => {\n      const lastConnectionAt = room.lastConnectionAt ? new Date(room.lastConnectionAt) : void 0;\n      const createdAt = new Date(room.createdAt);\n      return {\n        ...room,\n        createdAt,\n        lastConnectionAt\n      };\n    });\n    return {\n      ...data,\n      data: rooms\n    };\n  }\n  /**\n   * Creates a new room with the given id.\n   * @param roomId The id of the room to create.\n   * @param params.defaultAccesses The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created room.\n   */\n  async createRoom(roomId, params, options) {\n    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms`,\n      {\n        id: roomId,\n        defaultAccesses,\n        groupsAccesses,\n        usersAccesses,\n        metadata\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      lastConnectionAt,\n      createdAt\n    };\n  }\n  /**\n   * Returns a room with the given id.\n   * @param roomId The id of the room to return.\n   * @returns The room with the given id.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getRoom(roomId, options) {\n    const res = await this.#get((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}`, void 0, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      createdAt,\n      lastConnectionAt\n    };\n  }\n  /**\n   * Updates specific properties of a room. It’s not necessary to provide the entire room’s information.\n   * Setting a property to `null` means to delete this property.\n   * @param roomId The id of the room to update.\n   * @param params.defaultAccesses (optional) The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The updated room.\n   */\n  async updateRoom(roomId, params, options) {\n    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}`,\n      {\n        defaultAccesses,\n        groupsAccesses,\n        usersAccesses,\n        metadata\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      lastConnectionAt,\n      createdAt\n    };\n  }\n  /**\n   * Deletes a room with the given id. A deleted room is no longer accessible from the API or the dashboard and it cannot be restored.\n   * @param roomId The id of the room to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteRoom(roomId, options) {\n    const res = await this.#delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}`, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns a list of users currently present in the requested room. For better performance, we recommand to call this endpoint every 10 seconds maximum. Duplicates can happen if a user is in the requested room with multiple browser tabs opened.\n   * @param roomId The id of the room to get the users from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A list of users currently present in the requested room.\n   */\n  async getActiveUsers(roomId, options) {\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/active_users`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Boadcasts an event to a room without having to connect to it via the client from @liveblocks/client. The connectionId passed to event listeners is -1 when using this API.\n   * @param roomId The id of the room to broadcast the event to.\n   * @param message The message to broadcast. It can be any JSON serializable value.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async broadcastEvent(roomId, message, options) {\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/broadcast_event`,\n      message,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  async getStorageDocument(roomId, format = \"plain-lson\", options) {\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/storage`,\n      { format },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Initializes a room’s Storage. The room must already exist and have an empty Storage.\n   * Calling this endpoint will disconnect all users from the room if there are any.\n   *\n   * @param roomId The id of the room to initialize the storage from.\n   * @param document The document to initialize the storage with.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The initialized storage document. It is of the same format as the one passed in.\n   */\n  async initializeStorageDocument(roomId, document, options) {\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/storage`,\n      document,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Deletes all of the room’s Storage data and disconnect all users from the room if there are any. Note that this does not delete the Yjs document in the room if one exists.\n   * @param roomId The id of the room to delete the storage from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteStorageDocument(roomId, options) {\n    const res = await this.#delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/storage`, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Yjs\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Returns a JSON representation of the room’s Yjs document.\n   * @param roomId The id of the room to get the Yjs document from.\n   * @param params.format (optional) If true, YText will return formatting.\n   * @param params.key (optional) If provided, returns only a single key’s value, e.g. doc.get(key).toJSON().\n   * @param params.type (optional) Used with key to override the inferred type, i.e. \"ymap\" will return doc.get(key, Y.Map).\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A JSON representation of the room’s Yjs document.\n   */\n  async getYjsDocument(roomId, params = {}, options) {\n    const { format, key, type } = params;\n    const path = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`v2/rooms/${roomId}/ydoc`;\n    const res = await this.#get(\n      path,\n      { formatting: format ? \"true\" : void 0, key, type },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Send a Yjs binary update to the room’s Yjs document. You can use this endpoint to initialize Yjs data for the room or to update the room’s Yjs document.\n   * @param roomId The id of the room to send the Yjs binary update to.\n   * @param update The Yjs update to send. Typically the result of calling `Yjs.encodeStateAsUpdate(doc)`. Read the [Yjs documentation](https://docs.yjs.dev/api/document-updates) to learn how to create a binary update.\n   * @param params.guid (optional) If provided, the binary update will be applied to the Yjs subdocument with the given guid. If not provided, the binary update will be applied to the root Yjs document.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async sendYjsBinaryUpdate(roomId, update, params = {}, options) {\n    const res = await this.#putBinary(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/ydoc`,\n      update,\n      { guid: params.guid },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns the room’s Yjs document encoded as a single binary update. This can be used by Y.applyUpdate(responseBody) to get a copy of the document in your backend.\n   * See [Yjs documentation](https://docs.yjs.dev/api/document-updates) for more information on working with updates.\n   * @param roomId The id of the room to get the Yjs document from.\n   * @param params.guid (optional) If provided, returns the binary update of the Yjs subdocument with the given guid. If not provided, returns the binary update of the root Yjs document.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The room’s Yjs document encoded as a single binary update.\n   */\n  async getYjsDocumentAsBinaryUpdate(roomId, params = {}, options) {\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/ydoc-binary`,\n      { guid: params.guid },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return res.arrayBuffer();\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Schema Validation\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Creates a new schema which can be referenced later to enforce a room’s Storage data structure.\n   * @param name The name used to reference the schema. Must be a non-empty string with less than 65 characters and only contain lowercase letters, numbers and dashes\n   * @param body The exact allowed shape of data in the room. It is a multi-line string written in the [Liveblocks schema syntax](https://liveblocks.io/docs/platform/schema-validation/syntax).\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created schema.\n   */\n  async createSchema(name, body, options) {\n    const res = await this.#post((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/schemas`, { name, body }, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Returns a schema by its id.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The schema with the given id.\n   */\n  async getSchema(schemaId, options) {\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/schemas/${schemaId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Updates the body for the schema. A schema can only be updated if it is not used by any room.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @param body The exact allowed shape of data in the room. It is a multi-line string written in the [Liveblocks schema syntax](https://liveblocks.io/docs/platform/schema-validation/syntax).\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The updated schema. The version of the schema will be incremented.\n   */\n  async updateSchema(schemaId, body, options) {\n    const res = await this.#put(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/schemas/${schemaId}`,\n      { body },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Deletes a schema by its id. A schema can only be deleted if it is not used by any room.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteSchema(schemaId, options) {\n    const res = await this.#delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/schemas/${schemaId}`, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns the schema attached to a room.\n   * @param roomId The id of the room to get the schema from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns\n   */\n  async getSchemaByRoomId(roomId, options) {\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/schema`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Attaches a schema to a room, and instantly enables runtime schema validation for the room.\n   * If the current contents of the room’s Storage do not match the schema, attaching will fail and the error message will give details on why the schema failed to attach.\n   * @param roomId The id of the room to attach the schema to.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The schema id as JSON.\n   */\n  async attachSchemaToRoom(roomId, schemaId, options) {\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/schema`,\n      { schema: schemaId },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Detaches a schema from a room, and disables runtime schema validation for the room.\n   * @param roomId The id of the room to detach the schema from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async detachSchemaFromRoom(roomId, options) {\n    const res = await this.#delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/schema`, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Comments\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Gets all the threads in a room.\n   *\n   * @param params.roomId The room ID to get the threads from.\n   * @param params.query The query to filter threads by. It is based on our query language and can filter by metadata.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A list of threads.\n   */\n  async getThreads(params, options) {\n    const { roomId } = params;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads`,\n      { query },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const { data } = await res.json();\n    return {\n      data: data.map((thread) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(thread))\n    };\n  }\n  /**\n   * Gets a thread.\n   *\n   * @param params.roomId The room ID to get the thread from.\n   * @param params.threadId The thread ID.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A thread.\n   */\n  async getThread(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Gets a thread's participants.\n   *\n   * Participants are users who have commented on the thread\n   * or users and groups that have been mentioned in a comment.\n   *\n   * @param params.roomId The room ID to get the thread participants from.\n   * @param params.threadId The thread ID to get the participants from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns An object containing an array of participant IDs.\n   */\n  async getThreadParticipants(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/participants`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Gets a thread's comment.\n   *\n   * @param params.roomId The room ID to get the comment from.\n   * @param params.threadId The thread ID to get the comment from.\n   * @param params.commentId The comment ID.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A comment.\n   */\n  async getComment(params, options) {\n    const { roomId, threadId, commentId } = params;\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Creates a comment.\n   *\n   * @param params.roomId The room ID to create the comment in.\n   * @param params.threadId The thread ID to create the comment in.\n   * @param params.data.userId The user ID of the user who is set to create the comment.\n   * @param params.data.createdAt (optional) The date the comment is set to be created.\n   * @param params.data.body The body of the comment.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created comment.\n   */\n  async createComment(params, options) {\n    const { roomId, threadId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments`,\n      {\n        ...data,\n        createdAt: data.createdAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Edits a comment.\n   * @param params.roomId The room ID to edit the comment in.\n   * @param params.threadId The thread ID to edit the comment in.\n   * @param params.commentId The comment ID to edit.\n   * @param params.data.body The body of the comment.\n   * @param params.data.editedAt (optional) The date the comment was edited.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The edited comment.\n   */\n  async editComment(params, options) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,\n      { ...data, editedAt: data.editedAt?.toISOString() },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Deletes a comment. Deletes a comment. If there are no remaining comments in the thread, the thread is also deleted.\n   * @param params.roomId The room ID to delete the comment in.\n   * @param params.threadId The thread ID to delete the comment in.\n   * @param params.commentId The comment ID to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteComment(params, options) {\n    const { roomId, threadId, commentId } = params;\n    const res = await this.#delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Creates a new thread. The thread will be created with the specified comment as its first comment.\n   * If the thread already exists, a `LiveblocksError` will be thrown with status code 409.\n   * @param params.roomId The room ID to create the thread in.\n   * @param params.thread.metadata (optional) The metadata for the thread. Supports upto a maximum of 10 entries. Value must be a string, boolean or number\n   * @param params.thread.comment.userId The user ID of the user who created the comment.\n   * @param params.thread.comment.createdAt (optional) The date the comment was created.\n   * @param params.thread.comment.body The body of the comment.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created thread. The thread will be created with the specified comment as its first comment.\n   */\n  async createThread(params, options) {\n    const { roomId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads`,\n      {\n        ...data,\n        comment: {\n          ...data.comment,\n          createdAt: data.comment.createdAt?.toISOString()\n        }\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Deletes a thread and all of its comments.\n   * @param params.roomId The room ID to delete the thread in.\n   * @param params.threadId The thread ID to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteThread(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}`,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Mark a thread as resolved.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to mark as resolved.\n   * @param params.data.userId The user ID of the user who marked the thread as resolved.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The thread marked as resolved.\n   */\n  async markThreadAsResolved(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/mark-as-resolved`,\n      {},\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Mark a thread as unresolved.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to mark as unresolved.\n   * @param params.data.userId The user ID of the user who marked the thread as unresolved.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The thread marked as unresolved.\n   */\n  async markThreadAsUnresolved(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/mark-as-unresolved`,\n      {},\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Updates the metadata of the specified thread in a room.\n   * @param params.roomId The room ID to update the thread in.\n   * @param params.threadId The thread ID to update.\n   * @param params.data.metadata The metadata for the thread. Value must be a string, boolean or number\n   * @param params.data.userId The user ID of the user who updated the thread.\n   * @param params.data.updatedAt (optional) The date the thread is set to be updated.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The updated thread metadata.\n   */\n  async editThreadMetadata(params, options) {\n    const { roomId, threadId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/metadata`,\n      {\n        ...data,\n        updatedAt: data.updatedAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Adds a new comment reaction to a comment.\n   * @param params.roomId The room ID to add the comment reaction in.\n   * @param params.threadId The thread ID to add the comment reaction in.\n   * @param params.commentId The comment ID to add the reaction in.\n   * @param params.data.emoji The (emoji) reaction to add.\n   * @param params.data.userId The user ID of the user associated with the reaction.\n   * @param params.data.createdAt (optional) The date the reaction is set to be created.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created comment reaction.\n   */\n  async addCommentReaction(params, options) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}/add-reaction`,\n      {\n        ...data,\n        createdAt: data.createdAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const reaction = await res.json();\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentUserReaction)(reaction);\n  }\n  /**\n   * Removes a reaction from a comment.\n   * @param params.roomId The room ID to remove the comment reaction from.\n   * @param params.threadId The thread ID to remove the comment reaction from.\n   * @param params.commentId The comment ID to remove the reaction from.\n   * @param params.data.emoji The (emoji) reaction to remove.\n   * @param params.data.userId The user ID of the user associated with the reaction.\n   * @param params.data.removedAt (optional) The date the reaction is set to be removed.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async removeCommentReaction(params, options) {\n    const { roomId, threadId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${params.commentId}/remove-reaction`,\n      {\n        ...data,\n        removedAt: data.removedAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns the inbox notifications for a user.\n   * @param params.userId The user ID to get the inbox notifications from.\n   * @param params.inboxNotificationId The ID of the inbox notification to get.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getInboxNotification(params, options) {\n    const { userId, inboxNotificationId } = params;\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToInboxNotificationData)(\n      await res.json()\n    );\n  }\n  /**\n   * Returns the inbox notifications for a user.\n   * @param params.userId The user ID to get the inbox notifications from.\n   * @param params.query The query to filter inbox notifications by. It is based on our query language and can filter by unread.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getInboxNotifications(params, options) {\n    const { userId } = params;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/inbox-notifications`,\n      { query },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const { data } = await res.json();\n    return {\n      data: data.map(_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToInboxNotificationData)\n    };\n  }\n  /**\n   * Gets the user's room notification settings.\n   * @param params.userId The user ID to get the room notifications from.\n   * @param params.roomId The room ID to get the room notification settings from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getRoomNotificationSettings(params, options) {\n    const { userId, roomId } = params;\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/users/${userId}/notification-settings`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Updates the user's room notification settings.\n   * @param params.userId The user ID to update the room notification settings for.\n   * @param params.roomId The room ID to update the room notification settings for.\n   * @param params.data The new room notification settings for the user.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async updateRoomNotificationSettings(params, options) {\n    const { userId, roomId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/users/${userId}/notification-settings`,\n      data,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Delete the user's room notification settings.\n   * @param params.userId The user ID to delete the room notification settings from.\n   * @param params.roomId The room ID to delete the room notification settings from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteRoomNotificationSettings(params, options) {\n    const { userId, roomId } = params;\n    const res = await this.#delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/users/${userId}/notification-settings`,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Update a room ID.\n   * @param params.roomId The current ID of the room.\n   * @param params.newRoomId The new room ID.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async updateRoomId(params, options) {\n    const { currentRoomId, newRoomId } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${currentRoomId}/update-room-id`,\n      { newRoomId },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n      lastConnectionAt: data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0\n    };\n  }\n  async triggerInboxNotification(params, options) {\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/inbox-notifications/trigger`,\n      params,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Deletes an inbox notification for a user.\n   * @param params.userId The user ID for which to delete the inbox notification.\n   * @param params.inboxNotificationId The ID of the inbox notification to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteInboxNotification(params, options) {\n    const { userId, inboxNotificationId } = params;\n    const res = await this.#delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Deletes all inbox notifications for a user.\n   * @param params.userId The user ID for which to delete all the inbox notifications.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteAllInboxNotifications(params, options) {\n    const { userId } = params;\n    const res = await this.#delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/inbox-notifications`,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Get notification settings for a user for a project.\n   * @param params.userId The user ID to get the notifications settings for.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getNotificationSettings(params, options) {\n    const { userId } = params;\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/notification-settings`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Update the user's notification settings.\n   * @param params.userId The user ID to update the notification settings for.\n   * @param params.data The new notification settings for the user.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async updateNotificationSettings(params, options) {\n    const { userId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/notification-settings`,\n      data,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Delete the user's notification settings\n   * @param params.userId The user ID to update the notification settings for.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteNotificationSettings(params, options) {\n    const { userId } = params;\n    const res = await this.#delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/notification-settings`,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n};\nvar LiveblocksError = class _LiveblocksError extends Error {\n  status;\n  details;\n  constructor(message, status, details) {\n    super(message);\n    this.name = \"LiveblocksError\";\n    this.status = status;\n    this.details = details;\n  }\n  toString() {\n    let msg = `${this.name}: ${this.message} (status ${this.status})`;\n    if (this.details) {\n      msg += `\n${this.details}`;\n    }\n    return msg;\n  }\n  static async from(res) {\n    const FALLBACK = \"An error happened without an error message\";\n    let text;\n    try {\n      text = await res.text();\n    } catch {\n      text = FALLBACK;\n    }\n    const obj = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.tryParseJson)(text) ?? { message: text };\n    const message = obj.message || FALLBACK;\n    const details = [\n      obj.suggestion ? `Suggestion: ${String(obj.suggestion)}` : void 0,\n      obj.docs ? `See also: ${String(obj.docs)}` : void 0\n    ].filter(Boolean).join(\"\\n\") || void 0;\n    return new _LiveblocksError(message, res.status, details);\n  }\n};\n\n// src/webhooks.ts\n\n\nvar WebhookHandler = class _WebhookHandler {\n  #secretBuffer;\n  static #secretPrefix = \"whsec_\";\n  constructor(secret) {\n    if (!secret) throw new Error(\"Secret is required\");\n    if (typeof secret !== \"string\") throw new Error(\"Secret must be a string\");\n    if (secret.startsWith(_WebhookHandler.#secretPrefix) === false)\n      throw new Error(\"Invalid secret, must start with whsec_\");\n    const secretKey = secret.slice(_WebhookHandler.#secretPrefix.length);\n    this.#secretBuffer = Buffer.from(secretKey, \"base64\");\n  }\n  /**\n   * Verifies a webhook request and returns the event\n   */\n  verifyRequest(request) {\n    const { headers, rawBody } = request;\n    const { webhookId, timestamp, rawSignatures } = this.#verifyHeaders(headers);\n    if (typeof rawBody !== \"string\") {\n      throw new Error(\n        `Invalid rawBody field, must be a string, got \"${typeof rawBody}\" instead. It is likely that you need to JSON.stringify the body before passing it.`\n      );\n    }\n    this.#verifyTimestamp(timestamp);\n    const signature = this.#sign(`${webhookId}.${timestamp}.${rawBody}`);\n    const expectedSignatures = rawSignatures.split(\" \").map((rawSignature) => {\n      const [, parsedSignature] = rawSignature.split(\",\");\n      return parsedSignature;\n    }).filter(isNotUndefined);\n    if (expectedSignatures.includes(signature) === false)\n      throw new Error(\n        `Invalid signature, expected one of ${expectedSignatures.join(\n          \", \"\n        )}, got ${signature}`\n      );\n    const event = JSON.parse(rawBody);\n    this.#verifyWebhookEventType(event);\n    return event;\n  }\n  /**\n   * Verifies the headers and returns the webhookId, timestamp and rawSignatures\n   */\n  #verifyHeaders(headers) {\n    const usingNativeHeaders = typeof Headers !== \"undefined\" && headers instanceof Headers;\n    const normalizedHeaders = usingNativeHeaders ? Object.fromEntries(headers) : headers;\n    const sanitizedHeaders = {};\n    Object.keys(normalizedHeaders).forEach((key) => {\n      sanitizedHeaders[key.toLowerCase()] = normalizedHeaders[key];\n    });\n    const webhookId = sanitizedHeaders[\"webhook-id\"];\n    if (typeof webhookId !== \"string\")\n      throw new Error(\"Invalid webhook-id header\");\n    const timestamp = sanitizedHeaders[\"webhook-timestamp\"];\n    if (typeof timestamp !== \"string\")\n      throw new Error(\"Invalid webhook-timestamp header\");\n    const rawSignatures = sanitizedHeaders[\"webhook-signature\"];\n    if (typeof rawSignatures !== \"string\")\n      throw new Error(\"Invalid webhook-signature header\");\n    return { webhookId, timestamp, rawSignatures };\n  }\n  /**\n   * Signs the content with the secret\n   * @param content\n   * @returns `string`\n   */\n  #sign(content) {\n    const encoder = new TextEncoder();\n    const toSign = encoder.encode(content);\n    return _stablelib_base64__WEBPACK_IMPORTED_MODULE_1__.encode(fast_sha256__WEBPACK_IMPORTED_MODULE_2__.hmac(this.#secretBuffer, toSign));\n  }\n  /**\n   * Verifies that the timestamp is not too old or in the future\n   */\n  #verifyTimestamp(timestampHeader) {\n    const now = Math.floor(Date.now() / 1e3);\n    const timestamp = parseInt(timestampHeader, 10);\n    if (isNaN(timestamp)) {\n      throw new Error(\"Invalid timestamp\");\n    }\n    if (timestamp < now - WEBHOOK_TOLERANCE_IN_SECONDS) {\n      throw new Error(\"Timestamp too old\");\n    }\n    if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {\n      throw new Error(\"Timestamp in the future\");\n    }\n  }\n  /**\n   * Ensures that the event is a known event type\n   * or throws and prompts the user to upgrade to a higher version of @liveblocks/node\n   */\n  #verifyWebhookEventType(event) {\n    if (event && event.type && [\n      \"storageUpdated\",\n      \"userEntered\",\n      \"userLeft\",\n      \"roomCreated\",\n      \"roomDeleted\",\n      \"commentCreated\",\n      \"commentEdited\",\n      \"commentDeleted\",\n      \"commentReactionAdded\",\n      \"commentReactionRemoved\",\n      \"threadMetadataUpdated\",\n      \"threadCreated\",\n      \"threadDeleted\",\n      \"ydocUpdated\",\n      \"notification\",\n      \"threadMarkedAsResolved\",\n      \"threadMarkedAsUnresolved\"\n    ].includes(event.type)) {\n      if (event.type === \"notification\") {\n        const notification = event;\n        if (notification.data.kind === \"thread\" || notification.data.kind === \"textMention\" || isCustomKind(notification.data.kind)) {\n          return;\n        } else {\n          throw new Error(\n            `Unknown notification kind: ${JSON.stringify(notification.data.kind)}`\n          );\n        }\n      }\n      return;\n    }\n    throw new Error(\n      \"Unknown event type, please upgrade to a higher version of @liveblocks/node\"\n    );\n  }\n};\nvar WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;\nvar isNotUndefined = (value) => value !== void 0;\nvar isCustomKind = (value) => {\n  return isString(value) && value.startsWith(\"$\");\n};\nfunction isThreadNotificationEvent(event) {\n  return event.type === \"notification\" && event.data.kind === \"thread\";\n}\nfunction isTextMentionNotificationEvent(event) {\n  return event.type === \"notification\" && event.data.kind === \"textMention\";\n}\nfunction isCustomNotificationEvent(event) {\n  return event.type === \"notification\" && isCustomKind(event.data.kind);\n}\n\n// src/index.ts\n\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3Mvbm9kZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQytDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQVUwQjs7QUFFMUI7QUFDdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxpV0FBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSzBCO0FBQzFCLDZEQUFXO0FBV1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dyaXRldG9nZXRoZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3Mvbm9kZS9kaXN0L2luZGV4LmpzPzE3MzIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBkZXRlY3REdXBlcyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL25vZGVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi4xOS4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9jbGllbnQudHNcbmltcG9ydCB7XG4gIGNvbnZlcnRUb0NvbW1lbnREYXRhLFxuICBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uLFxuICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEsXG4gIGNvbnZlcnRUb1RocmVhZERhdGEsXG4gIG9iamVjdFRvUXVlcnksXG4gIHRyeVBhcnNlSnNvbixcbiAgdXJsIGFzIHVybDIsXG4gIHVybGpvaW5cbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcblxuLy8gc3JjL1Nlc3Npb24udHNcbmltcG9ydCB7IHVybCB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5cbi8vIHNyYy91dGlscy50c1xudmFyIERFRkFVTFRfQkFTRV9VUkwgPSBcImh0dHBzOi8vYXBpLmxpdmVibG9ja3MuaW9cIjtcbnZhciBWQUxJRF9LRVlfQ0hBUlNfUkVHRVggPSAvXltcXHctXSskLztcbmZ1bmN0aW9uIGdldEJhc2VVcmwoYmFzZVVybCkge1xuICBpZiAodHlwZW9mIGJhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgYmFzZVVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHJldHVybiBiYXNlVXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBERUZBVUxUX0JBU0VfVVJMO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFBvbHlmaWxsKCkge1xuICByZXR1cm4gdHlwZW9mIGdsb2JhbFRoaXMuZmV0Y2ggIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzLmZldGNoIDogKGF3YWl0IGltcG9ydChcIm5vZGUtZmV0Y2hcIikpLmRlZmF1bHQ7XG59XG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gc3RhcnRzV2l0aCh2YWx1ZSwgcHJlZml4KSB7XG4gIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuc3RhcnRzV2l0aChwcmVmaXgpO1xufVxuZnVuY3Rpb24gaXNOb25FbXB0eSh2YWx1ZSkge1xuICByZXR1cm4gaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiBhc3NlcnROb25FbXB0eSh2YWx1ZSwgZmllbGQpIHtcbiAgaWYgKCFpc05vbkVtcHR5KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBmaWVsZCAnJHtmaWVsZH0nLiBQbGVhc2UgcHJvdmlkZSBhIG5vbi1lbXB0eSBzdHJpbmcuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3Mtbm9kZSNhdXRob3JpemVgXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U2VjcmV0S2V5KHZhbHVlLCBmaWVsZCkge1xuICBpZiAoIXN0YXJ0c1dpdGgodmFsdWUsIFwic2tfXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIGZpZWxkICcke2ZpZWxkfScuIFNlY3JldCBrZXlzIG11c3Qgc3RhcnQgd2l0aCAnc2tfJy4gUGxlYXNlIHByb3ZpZGUgdGhlIHNlY3JldCBrZXkgZnJvbSB5b3VyIExpdmVibG9ja3MgZGFzaGJvYXJkIGF0IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kYXNoYm9hcmQvYXBpa2V5cy5gXG4gICAgKTtcbiAgfVxuICBpZiAoIVZBTElEX0tFWV9DSEFSU19SRUdFWC50ZXN0KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGNoYXJzIGZvdW5kIGluIGZpZWxkICcke2ZpZWxkfScuIFBsZWFzZSBjaGVjayB0aGF0IHlvdSBjb3JyZWN0bHkgY29waWVkIHRoZSBzZWNyZXQga2V5IGZyb20geW91ciBMaXZlYmxvY2tzIGRhc2hib2FyZCBhdCBodHRwczovL2xpdmVibG9ja3MuaW8vZGFzaGJvYXJkL2FwaWtleXMuYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0YXR1c0NvZGUoc3RhdHVzQ29kZSkge1xuICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgIHJldHVybiAyMDA7XG4gIH0gZWxzZSBpZiAoc3RhdHVzQ29kZSA+PSA1MDApIHtcbiAgICByZXR1cm4gNTAzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiA0MDM7XG4gIH1cbn1cblxuLy8gc3JjL1Nlc3Npb24udHNcbnZhciBBTExfUEVSTUlTU0lPTlMgPSBPYmplY3QuZnJlZXplKFtcbiAgXCJyb29tOndyaXRlXCIsXG4gIFwicm9vbTpyZWFkXCIsXG4gIFwicm9vbTpwcmVzZW5jZTp3cml0ZVwiLFxuICBcImNvbW1lbnRzOndyaXRlXCIsXG4gIFwiY29tbWVudHM6cmVhZFwiXG5dKTtcbmZ1bmN0aW9uIGlzUGVybWlzc2lvbih2YWx1ZSkge1xuICByZXR1cm4gQUxMX1BFUk1JU1NJT05TLmluY2x1ZGVzKHZhbHVlKTtcbn1cbnZhciBNQVhfUEVSTVNfUEVSX1NFVCA9IDEwO1xudmFyIFJFQURfQUNDRVNTID0gT2JqZWN0LmZyZWV6ZShbXG4gIFwicm9vbTpyZWFkXCIsXG4gIFwicm9vbTpwcmVzZW5jZTp3cml0ZVwiLFxuICBcImNvbW1lbnRzOnJlYWRcIlxuXSk7XG52YXIgRlVMTF9BQ0NFU1MgPSBPYmplY3QuZnJlZXplKFtcInJvb206d3JpdGVcIiwgXCJjb21tZW50czp3cml0ZVwiXSk7XG52YXIgcm9vbVBhdHRlcm5SZWdleCA9IC9eKFsqXXxbXipdezEsMTI4fVsqXT8pJC87XG52YXIgU2Vzc2lvbiA9IGNsYXNzIHtcbiAgRlVMTF9BQ0NFU1MgPSBGVUxMX0FDQ0VTUztcbiAgUkVBRF9BQ0NFU1MgPSBSRUFEX0FDQ0VTUztcbiAgI3Bvc3RGbjtcbiAgI3VzZXJJZDtcbiAgI3VzZXJJbmZvO1xuICAjc2VhbGVkID0gZmFsc2U7XG4gICNwZXJtaXNzaW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IocG9zdEZuLCB1c2VySWQsIHVzZXJJbmZvKSB7XG4gICAgYXNzZXJ0Tm9uRW1wdHkodXNlcklkLCBcInVzZXJJZFwiKTtcbiAgICB0aGlzLiNwb3N0Rm4gPSBwb3N0Rm47XG4gICAgdGhpcy4jdXNlcklkID0gdXNlcklkO1xuICAgIHRoaXMuI3VzZXJJbmZvID0gdXNlckluZm87XG4gIH1cbiAgI2dldE9yQ3JlYXRlKHJvb21JZCkge1xuICAgIGlmICh0aGlzLiNzZWFsZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4gbm8gbG9uZ2VyIGNoYW5nZSB0aGVzZSBwZXJtaXNzaW9ucy5cIik7XG4gICAgfVxuICAgIGxldCBwZXJtcyA9IHRoaXMuI3Blcm1pc3Npb25zLmdldChyb29tSWQpO1xuICAgIGlmIChwZXJtcykge1xuICAgICAgcmV0dXJuIHBlcm1zO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy4jcGVybWlzc2lvbnMuc2l6ZSA+PSBNQVhfUEVSTVNfUEVSX1NFVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJZb3UgY2Fubm90IGFkZCBwZXJtaXNzaW9ucyBmb3IgbW9yZSB0aGFuIDEwIHJvb21zIGluIGEgc2luZ2xlIHRva2VuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHBlcm1zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuI3Blcm1pc3Npb25zLnNldChyb29tSWQsIHBlcm1zKTtcbiAgICAgIHJldHVybiBwZXJtcztcbiAgICB9XG4gIH1cbiAgYWxsb3cocm9vbUlkT3JQYXR0ZXJuLCBuZXdQZXJtcykge1xuICAgIGlmICh0eXBlb2Ygcm9vbUlkT3JQYXR0ZXJuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tIG5hbWUgb3IgcGF0dGVybiBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBpZiAoIXJvb21QYXR0ZXJuUmVnZXgudGVzdChyb29tSWRPclBhdHRlcm4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvb20gbmFtZSBvciBwYXR0ZXJuXCIpO1xuICAgIH1cbiAgICBpZiAobmV3UGVybXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJtaXNzaW9uIGxpc3QgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1Blcm1zID0gdGhpcy4jZ2V0T3JDcmVhdGUocm9vbUlkT3JQYXR0ZXJuKTtcbiAgICBmb3IgKGNvbnN0IHBlcm0gb2YgbmV3UGVybXMpIHtcbiAgICAgIGlmICghaXNQZXJtaXNzaW9uKHBlcm0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgdmFsaWQgcGVybWlzc2lvbjogJHtwZXJtfWApO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdQZXJtcy5hZGQocGVybSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgLSBGb3IgdW5pdCB0ZXN0cyBvbmx5ICovXG4gIGhhc1Blcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNwZXJtaXNzaW9ucy5zaXplID4gMDtcbiAgfVxuICAvKiogQGludGVybmFsIC0gRm9yIHVuaXQgdGVzdHMgb25seSAqL1xuICBzZWFsKCkge1xuICAgIGlmICh0aGlzLiNzZWFsZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJZb3UgY2Fubm90IHJldXNlIFNlc3Npb24gaW5zdGFuY2VzLiBQbGVhc2UgY3JlYXRlIGEgbmV3IHNlc3Npb24gZXZlcnkgdGltZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy4jc2VhbGVkID0gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsIC0gRm9yIHVuaXQgdGVzdHMgb25seSAqL1xuICBzZXJpYWxpemVQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLiNwZXJtaXNzaW9ucy5lbnRyaWVzKCkpLm1hcCgoW3BhdCwgcGVybXNdKSA9PiBbXG4gICAgICAgIHBhdCxcbiAgICAgICAgQXJyYXkuZnJvbShwZXJtcylcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIGF1dGhvcml6ZSB0aGUgc2Vzc2lvbiB0byBhY2Nlc3MgTGl2ZWJsb2Nrcy4gTm90ZSB0aGF0IHRoaXNcbiAgICogd2lsbCByZXR1cm4gYSBMaXZlYmxvY2tzIFwiYWNjZXNzIHRva2VuXCIuIEFueW9uZSB0aGF0IG9idGFpbnMgc3VjaCBhY2Nlc3NcbiAgICogdG9rZW4gd2lsbCBoYXZlIGFjY2VzcyB0byB0aGUgYWxsb3dlZCByZXNvdXJjZXMuXG4gICAqL1xuICBhc3luYyBhdXRob3JpemUoKSB7XG4gICAgdGhpcy5zZWFsKCk7XG4gICAgaWYgKCF0aGlzLmhhc1Blcm1pc3Npb25zKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJBY2Nlc3MgdG9rZW5zIHdpdGhvdXQgYW55IHBlcm1pc3Npb24gd2lsbCBub3QgYmUgc3VwcG9ydGVkIHNvb24sIHlvdSBzaG91bGQgdXNlIHdpbGRjYXJkcyB3aGVuIHRoZSBjbGllbnQgcmVxdWVzdHMgYSB0b2tlbiBmb3IgcmVzb3VyY2VzIG91dHNpZGUgYSByb29tLiBTZWUgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtY2xpZW50L2FjY2Vzcy10b2tlbnMtbm90LWVub3VnaC1wZXJtaXNzaW9uc1wiXG4gICAgICApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuI3Bvc3RGbih1cmxgL3YyL2F1dGhvcml6ZS11c2VyYCwge1xuICAgICAgICAvLyBSZXF1aXJlZFxuICAgICAgICB1c2VySWQ6IHRoaXMuI3VzZXJJZCxcbiAgICAgICAgcGVybWlzc2lvbnM6IHRoaXMuc2VyaWFsaXplUGVybWlzc2lvbnMoKSxcbiAgICAgICAgLy8gT3B0aW9uYWwgbWV0YWRhdGFcbiAgICAgICAgdXNlckluZm86IHRoaXMuI3VzZXJJbmZvXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogbm9ybWFsaXplU3RhdHVzQ29kZShyZXNwLnN0YXR1cyksXG4gICAgICAgIGJvZHk6IGF3YWl0IHJlc3AudGV4dCgpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IDUwMyxcbiAgICAgICAgYm9keTogJ0NhbGwgdG8gL3YyL2F1dGhvcml6ZS11c2VyIGZhaWxlZC4gU2VlIFwiZXJyb3JcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLFxuICAgICAgICBlcnJvcjogZXJcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY2xpZW50LnRzXG52YXIgTGl2ZWJsb2NrcyA9IGNsYXNzIHtcbiAgI3NlY3JldDtcbiAgI2Jhc2VVcmw7XG4gIC8qKlxuICAgKiBJbnRlcmFjdCB3aXRoIHRoZSBMaXZlYmxvY2tzIEFQSSBmcm9tIHlvdXIgTm9kZS5qcyBiYWNrZW5kLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnNfID0gb3B0aW9ucztcbiAgICBjb25zdCBzZWNyZXQgPSBvcHRpb25zXy5zZWNyZXQ7XG4gICAgYXNzZXJ0U2VjcmV0S2V5KHNlY3JldCwgXCJzZWNyZXRcIik7XG4gICAgdGhpcy4jc2VjcmV0ID0gc2VjcmV0O1xuICAgIHRoaXMuI2Jhc2VVcmwgPSBuZXcgVVJMKGdldEJhc2VVcmwob3B0aW9ucy5iYXNlVXJsKSk7XG4gIH1cbiAgYXN5bmMgI3Bvc3QocGF0aCwganNvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHVybDMgPSB1cmxqb2luKHRoaXMuI2Jhc2VVcmwsIHBhdGgpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy4jc2VjcmV0fWAsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH07XG4gICAgY29uc3QgZmV0Y2ggPSBhd2FpdCBmZXRjaFBvbHlmaWxsKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsMywge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqc29uKSxcbiAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBhc3luYyAjcHV0KHBhdGgsIGpzb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB1cmwzID0gdXJsam9pbih0aGlzLiNiYXNlVXJsLCBwYXRoKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuI3NlY3JldH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9O1xuICAgIGNvbnN0IGZldGNoID0gYXdhaXQgZmV0Y2hQb2x5ZmlsbCgpO1xuICAgIHJldHVybiBhd2FpdCBmZXRjaCh1cmwzLCB7XG4gICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvbiksXG4gICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGFzeW5jICNwdXRCaW5hcnkocGF0aCwgYm9keSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdXJsMyA9IHVybGpvaW4odGhpcy4jYmFzZVVybCwgcGF0aCwgcGFyYW1zKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuI3NlY3JldH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgIH07XG4gICAgY29uc3QgZmV0Y2ggPSBhd2FpdCBmZXRjaFBvbHlmaWxsKCk7XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoKHVybDMsIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBhc3luYyAjZGVsZXRlKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB1cmwzID0gdXJsam9pbih0aGlzLiNiYXNlVXJsLCBwYXRoKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuI3NlY3JldH1gXG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGF3YWl0IGZldGNoUG9seWZpbGwoKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwzLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGFzeW5jICNnZXQocGF0aCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdXJsMyA9IHVybGpvaW4odGhpcy4jYmFzZVVybCwgcGF0aCwgcGFyYW1zKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuI3NlY3JldH1gXG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGF3YWl0IGZldGNoUG9seWZpbGwoKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwzLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQXV0aGVudGljYXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKipcbiAgICogUHJlcGFyZXMgYSBuZXcgc2Vzc2lvbiB0byBhdXRob3JpemUgYSB1c2VyIHRvIGFjY2VzcyBMaXZlYmxvY2tzLlxuICAgKlxuICAgKiBJTVBPUlRBTlQ6XG4gICAqIEFsd2F5cyBtYWtlIHN1cmUgdGhhdCB5b3UgdHJ1c3QgdGhlIHVzZXIgbWFraW5nIHRoZSByZXF1ZXN0IHRvIHlvdXJcbiAgICogYmFja2VuZCBiZWZvcmUgY2FsbGluZyAucHJlcGFyZVNlc3Npb24oKSFcbiAgICpcbiAgICogQHBhcmFtIHVzZXJJZCBUZWxsIExpdmVibG9ja3MgdGhlIHVzZXIgSUQgb2YgdGhlIHVzZXIgdG8gYXV0aG9yaXplLiBNdXN0XG4gICAqIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSB1c2VyIGFjY291bnQgaW4geW91ciBzeXN0ZW0uIFRoZSB1bmlxdWVuZXNzIG9mIHRoaXNcbiAgICogdmFsdWUgd2lsbCBkZXRlcm1pbmUgaG93IG1hbnkgTUFVcyB3aWxsIGJlIGNvdW50ZWQvYmlsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy51c2VySW5mbyBDdXN0b20gbWV0YWRhdGEgdG8gYXR0YWNoIHRvIHRoaXMgdXNlci4gRGF0YSB5b3VcbiAgICogYWRkIGhlcmUgd2lsbCBiZSB2aXNpYmxlIHRvIGFsbCBvdGhlciBjbGllbnRzIGluIHRoZSByb29tLCB0aHJvdWdoIHRoZVxuICAgKiBgb3RoZXIuaW5mb2AgcHJvcGVydHkuXG4gICAqXG4gICAqL1xuICBwcmVwYXJlU2Vzc2lvbih1c2VySWQsIC4uLnJlc3QpIHtcbiAgICBjb25zdCBvcHRpb25zID0gcmVzdFswXTtcbiAgICByZXR1cm4gbmV3IFNlc3Npb24odGhpcy4jcG9zdC5iaW5kKHRoaXMpLCB1c2VySWQsIG9wdGlvbnM/LnVzZXJJbmZvKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIGF1dGhlbnRpY2F0ZSB0aGUgdXNlciBhcyBhbiBhY3RvciB5b3Ugd2FudCB0byBhbGxvdyB0byB1c2VcbiAgICogTGl2ZWJsb2Nrcy5cbiAgICpcbiAgICogWW91IHNob3VsZCB1c2UgdGhpcyBtZXRob2Qgb25seSBpZiB5b3Ugd2FudCB0byBtYW5hZ2UgeW91ciBwZXJtaXNzaW9uc1xuICAgKiB0aHJvdWdoIHRoZSBMaXZlYmxvY2tzIFBlcm1pc3Npb25zIEFQSS4gVGhpcyBtZXRob2QgaXMgbW9yZSBjb21wbGljYXRlZCB0b1xuICAgKiBzZXQgdXAsIGJ1dCBhbGxvd3MgZm9yIGZpbmVyLWdyYWluZWQgc3BlY2lmaWNhdGlvbiBvZiBwZXJtaXNzaW9ucy5cbiAgICpcbiAgICogQ2FsbGluZyBgLmlkZW50aWZ5VXNlcigpYCBvbmx5IGxldHMgeW91IHNlY3VyZWx5IGlkZW50aWZ5IGEgdXNlciAoYW5kIHdoYXRcbiAgICogZ3JvdXBzIHRoZXkgYmVsb25nIHRvKS4gV2hhdCBwZXJtaXNzaW9ucyB0aGlzIHVzZXIgd2lsbCBlbmQgdXAgaGF2aW5nIGlzXG4gICAqIGRldGVybWluZWQgYnkgd2hhdGV2ZXIgcGVybWlzc2lvbnMgeW91IGFzc2lnbiB0aGUgdXNlci9ncm91cCBpbiB5b3VyXG4gICAqIExpdmVibG9ja3MgYWNjb3VudCwgdGhyb3VnaCB0aGUgUGVybWlzc2lvbnMgQVBJOlxuICAgKiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9yb29tcy9wZXJtaXNzaW9uc1xuICAgKlxuICAgKiBJTVBPUlRBTlQ6XG4gICAqIEFsd2F5cyB2ZXJpZnkgdGhhdCB5b3UgdHJ1c3QgdGhlIHVzZXIgbWFraW5nIHRoZSByZXF1ZXN0IGJlZm9yZSBjYWxsaW5nXG4gICAqIC5pZGVudGlmeVVzZXIoKSFcbiAgICpcbiAgICogQHBhcmFtIGlkZW50aXR5IFRlbGwgTGl2ZWJsb2NrcyB0aGUgdXNlciBJRCBvZiB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUuXG4gICAqIE11c3QgdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHVzZXIgYWNjb3VudCBpbiB5b3VyIHN5c3RlbS4gVGhlIHVuaXF1ZW5lc3Mgb2ZcbiAgICogdGhpcyB2YWx1ZSB3aWxsIGRldGVybWluZSBob3cgbWFueSBNQVVzIHdpbGwgYmUgY291bnRlZC9iaWxsZWQuXG4gICAqXG4gICAqIElmIHlvdSBhbHNvIHdhbnQgdG8gYXNzaWduIHdoaWNoIGdyb3VwcyB0aGlzIHVzZXIgYmVsb25ncyB0bywgdXNlIHRoZVxuICAgKiBvYmplY3QgZm9ybSBhbmQgc3BlY2lmeSB0aGUgYGdyb3VwSWRzYCBwcm9wZXJ0eS4gVGhvc2UgYGdyb3VwSWRzYCBzaG91bGRcbiAgICogbWF0Y2ggdGhlIGdyb3VwSWRzIHlvdSBhc3NpZ25lZCBwZXJtaXNzaW9ucyB0byB2aWEgdGhlIExpdmVibG9ja3NcbiAgICogUGVybWlzc2lvbnMgQVBJLCBzZWVcbiAgICogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3Mvcm9vbXMvcGVybWlzc2lvbnMjcGVybWlzc2lvbnMtbGV2ZWxzLWdyb3Vwcy1hY2Nlc3Nlcy1leGFtcGxlXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnVzZXJJbmZvIEN1c3RvbSBtZXRhZGF0YSB0byBhdHRhY2ggdG8gdGhpcyB1c2VyLiBEYXRhIHlvdVxuICAgKiBhZGQgaGVyZSB3aWxsIGJlIHZpc2libGUgdG8gYWxsIG90aGVyIGNsaWVudHMgaW4gdGhlIHJvb20sIHRocm91Z2ggdGhlXG4gICAqIGBvdGhlci5pbmZvYCBwcm9wZXJ0eS5cbiAgICovXG4gIC8vIFRoZXNlIGZpZWxkcyBkZWZpbmUgdGhlIHNlY3VyaXR5IGlkZW50aXR5IG9mIHRoZSB1c2VyLiBXaGF0ZXZlciB5b3UgcGFzcyBpbiBoZXJlIHdpbGwgZGVmaW5lIHdoaWNoXG4gIGFzeW5jIGlkZW50aWZ5VXNlcihpZGVudGl0eSwgLi4ucmVzdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXN0WzBdO1xuICAgIGNvbnN0IHBhdGggPSB1cmwyYC92Mi9pZGVudGlmeS11c2VyYDtcbiAgICBjb25zdCB1c2VySWQgPSB0eXBlb2YgaWRlbnRpdHkgPT09IFwic3RyaW5nXCIgPyBpZGVudGl0eSA6IGlkZW50aXR5LnVzZXJJZDtcbiAgICBjb25zdCBncm91cElkcyA9IHR5cGVvZiBpZGVudGl0eSA9PT0gXCJzdHJpbmdcIiA/IHZvaWQgMCA6IGlkZW50aXR5Lmdyb3VwSWRzO1xuICAgIGFzc2VydE5vbkVtcHR5KHVzZXJJZCwgXCJ1c2VySWRcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLiNwb3N0KHBhdGgsIHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBncm91cElkcyxcbiAgICAgICAgLy8gT3B0aW9uYWwgbWV0YWRhdGFcbiAgICAgICAgdXNlckluZm86IG9wdGlvbnM/LnVzZXJJbmZvXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogbm9ybWFsaXplU3RhdHVzQ29kZShyZXNwLnN0YXR1cyksXG4gICAgICAgIGJvZHk6IGF3YWl0IHJlc3AudGV4dCgpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IDUwMyxcbiAgICAgICAgYm9keTogYENhbGwgdG8gJHt1cmxqb2luKFxuICAgICAgICAgIHRoaXMuI2Jhc2VVcmwsXG4gICAgICAgICAgcGF0aFxuICAgICAgICApfSBmYWlsZWQuIFNlZSBcImVycm9yXCIgZm9yIG1vcmUgaW5mb3JtYXRpb24uYCxcbiAgICAgICAgZXJyb3I6IGVyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFJvb21cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgeW91ciByb29tcy4gVGhlIHJvb21zIGFyZSByZXR1cm5lZCBzb3J0ZWQgYnkgY3JlYXRpb24gZGF0ZSwgZnJvbSBuZXdlc3QgdG8gb2xkZXN0LiBZb3UgY2FuIGZpbHRlciByb29tcyBieSBtZXRhZGF0YSwgdXNlcnMgYWNjZXNzZXMgYW5kIGdyb3VwcyBhY2Nlc3Nlcy5cbiAgICogQHBhcmFtIHBhcmFtcy5saW1pdCAob3B0aW9uYWwpIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiByb29tcyB0byBiZSByZXR1cm5lZC4gVGhlIGxpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIGRlZmF1bHRzIHRvIDIwLlxuICAgKiBAcGFyYW0gcGFyYW1zLnN0YXJ0aW5nQWZ0ZXIgKG9wdGlvbmFsKSBBIGN1cnNvciB1c2VkIGZvciBwYWdpbmF0aW9uLiBZb3UgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSByZXNwb25zZSBvZiB0aGUgcHJldmlvdXMgcGFnZS5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgKG9wdGlvbmFsKSBBIGZpbHRlciBvbiB1c2VycyBhY2Nlc3Nlcy5cbiAgICogQHBhcmFtIHBhcmFtcy5tZXRhZGF0YSAob3B0aW9uYWwpIEEgZmlsdGVyIG9uIG1ldGFkYXRhLiBNdWx0aXBsZSBtZXRhZGF0YSBrZXlzIGNhbiBiZSB1c2VkIHRvIGZpbHRlciByb29tcy5cbiAgICogQHBhcmFtIHBhcmFtcy5ncm91cElkcyAob3B0aW9uYWwpIEEgZmlsdGVyIG9uIGdyb3VwcyBhY2Nlc3Nlcy4gTXVsdGlwbGUgZ3JvdXBzIGNhbiBiZSB1c2VkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnF1ZXJ5IChvcHRpb25hbCkgQSBxdWVyeSB0byBmaWx0ZXIgcm9vbXMgYnkuIEl0IGlzIGJhc2VkIG9uIG91ciBxdWVyeSBsYW5ndWFnZS4gWW91IGNhbiBmaWx0ZXIgYnkgbWV0YWRhdGEgYW5kIHJvb20gSUQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiByb29tcy5cbiAgICovXG4gIGFzeW5jIGdldFJvb21zKHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGF0aCA9IHVybDJgL3YyL3Jvb21zYDtcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMucXVlcnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHF1ZXJ5ID0gcGFyYW1zLnF1ZXJ5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcXVlcnkgPSBvYmplY3RUb1F1ZXJ5KHBhcmFtcy5xdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0ge1xuICAgICAgbGltaXQ6IHBhcmFtcy5saW1pdCxcbiAgICAgIHN0YXJ0aW5nQWZ0ZXI6IHBhcmFtcy5zdGFydGluZ0FmdGVyLFxuICAgICAgdXNlcklkOiBwYXJhbXMudXNlcklkLFxuICAgICAgZ3JvdXBJZHM6IHBhcmFtcy5ncm91cElkcyA/IHBhcmFtcy5ncm91cElkcy5qb2luKFwiLFwiKSA6IHZvaWQgMCxcbiAgICAgIC8vIFwiRmxhdHRlblwiIHttZXRhZGF0YToge2ZvbzogXCJiYXJcIn19IHRvIHtcIm1ldGFkYXRhLmZvb1wiOiBcImJhclwifVxuICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMubWV0YWRhdGEgPz8ge30pLm1hcCgoW2tleSwgdmFsXSkgPT4gW1xuICAgICAgICAgIGBtZXRhZGF0YS4ke2tleX1gLFxuICAgICAgICAgIHZhbFxuICAgICAgICBdKVxuICAgICAgKSxcbiAgICAgIHF1ZXJ5XG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQocGF0aCwgcXVlcnlQYXJhbXMsIG9wdGlvbnMpO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCByb29tcyA9IGRhdGEuZGF0YS5tYXAoKHJvb20pID0+IHtcbiAgICAgIGNvbnN0IGxhc3RDb25uZWN0aW9uQXQgPSByb29tLmxhc3RDb25uZWN0aW9uQXQgPyBuZXcgRGF0ZShyb29tLmxhc3RDb25uZWN0aW9uQXQpIDogdm9pZCAwO1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUocm9vbS5jcmVhdGVkQXQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucm9vbSxcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICBsYXN0Q29ubmVjdGlvbkF0XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgZGF0YTogcm9vbXNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHJvb20gd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGNyZWF0ZS5cbiAgICogQHBhcmFtIHBhcmFtcy5kZWZhdWx0QWNjZXNzZXMgVGhlIGRlZmF1bHQgYWNjZXNzZXMgZm9yIHRoZSByb29tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmdyb3Vwc0FjY2Vzc2VzIChvcHRpb25hbCkgVGhlIGdyb3VwIGFjY2Vzc2VzIGZvciB0aGUgcm9vbS4gQ2FuIGNvbnRhaW4gYSBtYXhpbXVtIG9mIDEwMCBlbnRyaWVzLiBLZXkgbGVuZ3RoIGhhcyBhIGxpbWl0IG9mIDQwIGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcnNBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSB1c2VyIGFjY2Vzc2VzIGZvciB0aGUgcm9vbS4gQ2FuIGNvbnRhaW4gYSBtYXhpbXVtIG9mIDEwMCBlbnRyaWVzLiBLZXkgbGVuZ3RoIGhhcyBhIGxpbWl0IG9mIDQwIGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBwYXJhbXMubWV0YWRhdGEgKG9wdGlvbmFsKSBUaGUgbWV0YWRhdGEgZm9yIHRoZSByb29tLiBTdXBwb3J0cyB1cHRvIGEgbWF4aW11bSBvZiA1MCBlbnRyaWVzLiBLZXkgbGVuZ3RoIGhhcyBhIGxpbWl0IG9mIDQwIGNoYXJhY3RlcnMuIFZhbHVlIGxlbmd0aCBoYXMgYSBsaW1pdCBvZiAyNTYgY2hhcmFjdGVycy5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgcm9vbS5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVJvb20ocm9vbUlkLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGRlZmF1bHRBY2Nlc3NlcywgZ3JvdXBzQWNjZXNzZXMsIHVzZXJzQWNjZXNzZXMsIG1ldGFkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zYCxcbiAgICAgIHtcbiAgICAgICAgaWQ6IHJvb21JZCxcbiAgICAgICAgZGVmYXVsdEFjY2Vzc2VzLFxuICAgICAgICBncm91cHNBY2Nlc3NlcyxcbiAgICAgICAgdXNlcnNBY2Nlc3NlcyxcbiAgICAgICAgbWV0YWRhdGFcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgbGFzdENvbm5lY3Rpb25BdCA9IGRhdGEubGFzdENvbm5lY3Rpb25BdCA/IG5ldyBEYXRlKGRhdGEubGFzdENvbm5lY3Rpb25BdCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgbGFzdENvbm5lY3Rpb25BdCxcbiAgICAgIGNyZWF0ZWRBdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSByb29tIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSByb29tIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZ2V0Um9vbShyb29tSWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQodXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9YCwgdm9pZCAwLCBvcHRpb25zKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgbGFzdENvbm5lY3Rpb25BdCA9IGRhdGEubGFzdENvbm5lY3Rpb25BdCA/IG5ldyBEYXRlKGRhdGEubGFzdENvbm5lY3Rpb25BdCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgbGFzdENvbm5lY3Rpb25BdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgc3BlY2lmaWMgcHJvcGVydGllcyBvZiBhIHJvb20uIEl04oCZcyBub3QgbmVjZXNzYXJ5IHRvIHByb3ZpZGUgdGhlIGVudGlyZSByb29t4oCZcyBpbmZvcm1hdGlvbi5cbiAgICogU2V0dGluZyBhIHByb3BlcnR5IHRvIGBudWxsYCBtZWFucyB0byBkZWxldGUgdGhpcyBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRlZmF1bHRBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSBkZWZhdWx0IGFjY2Vzc2VzIGZvciB0aGUgcm9vbS5cbiAgICogQHBhcmFtIHBhcmFtcy5ncm91cHNBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSBncm91cCBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJzQWNjZXNzZXMgKG9wdGlvbmFsKSBUaGUgdXNlciBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLm1ldGFkYXRhIChvcHRpb25hbCkgVGhlIG1ldGFkYXRhIGZvciB0aGUgcm9vbS4gU3VwcG9ydHMgdXB0byBhIG1heGltdW0gb2YgNTAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLiBWYWx1ZSBsZW5ndGggaGFzIGEgbGltaXQgb2YgMjU2IGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIHJvb20uXG4gICAqL1xuICBhc3luYyB1cGRhdGVSb29tKHJvb21JZCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBkZWZhdWx0QWNjZXNzZXMsIGdyb3Vwc0FjY2Vzc2VzLCB1c2Vyc0FjY2Vzc2VzLCBtZXRhZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH1gLFxuICAgICAge1xuICAgICAgICBkZWZhdWx0QWNjZXNzZXMsXG4gICAgICAgIGdyb3Vwc0FjY2Vzc2VzLFxuICAgICAgICB1c2Vyc0FjY2Vzc2VzLFxuICAgICAgICBtZXRhZGF0YVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCBsYXN0Q29ubmVjdGlvbkF0ID0gZGF0YS5sYXN0Q29ubmVjdGlvbkF0ID8gbmV3IERhdGUoZGF0YS5sYXN0Q29ubmVjdGlvbkF0KSA6IHZvaWQgMDtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBsYXN0Q29ubmVjdGlvbkF0LFxuICAgICAgY3JlYXRlZEF0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIHJvb20gd2l0aCB0aGUgZ2l2ZW4gaWQuIEEgZGVsZXRlZCByb29tIGlzIG5vIGxvbmdlciBhY2Nlc3NpYmxlIGZyb20gdGhlIEFQSSBvciB0aGUgZGFzaGJvYXJkIGFuZCBpdCBjYW5ub3QgYmUgcmVzdG9yZWQuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGRlbGV0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZVJvb20ocm9vbUlkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZGVsZXRlKHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfWAsIG9wdGlvbnMpO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdXNlcnMgY3VycmVudGx5IHByZXNlbnQgaW4gdGhlIHJlcXVlc3RlZCByb29tLiBGb3IgYmV0dGVyIHBlcmZvcm1hbmNlLCB3ZSByZWNvbW1hbmQgdG8gY2FsbCB0aGlzIGVuZHBvaW50IGV2ZXJ5IDEwIHNlY29uZHMgbWF4aW11bS4gRHVwbGljYXRlcyBjYW4gaGFwcGVuIGlmIGEgdXNlciBpcyBpbiB0aGUgcmVxdWVzdGVkIHJvb20gd2l0aCBtdWx0aXBsZSBicm93c2VyIHRhYnMgb3BlbmVkLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBnZXQgdGhlIHVzZXJzIGZyb20uXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiB1c2VycyBjdXJyZW50bHkgcHJlc2VudCBpbiB0aGUgcmVxdWVzdGVkIHJvb20uXG4gICAqL1xuICBhc3luYyBnZXRBY3RpdmVVc2Vycyhyb29tSWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vYWN0aXZlX3VzZXJzYCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogQm9hZGNhc3RzIGFuIGV2ZW50IHRvIGEgcm9vbSB3aXRob3V0IGhhdmluZyB0byBjb25uZWN0IHRvIGl0IHZpYSB0aGUgY2xpZW50IGZyb20gQGxpdmVibG9ja3MvY2xpZW50LiBUaGUgY29ubmVjdGlvbklkIHBhc3NlZCB0byBldmVudCBsaXN0ZW5lcnMgaXMgLTEgd2hlbiB1c2luZyB0aGlzIEFQSS5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gYnJvYWRjYXN0IHRoZSBldmVudCB0by5cbiAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYnJvYWRjYXN0LiBJdCBjYW4gYmUgYW55IEpTT04gc2VyaWFsaXphYmxlIHZhbHVlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgYnJvYWRjYXN0RXZlbnQocm9vbUlkLCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS9icm9hZGNhc3RfZXZlbnRgLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRTdG9yYWdlRG9jdW1lbnQocm9vbUlkLCBmb3JtYXQgPSBcInBsYWluLWxzb25cIiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2dldChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS9zdG9yYWdlYCxcbiAgICAgIHsgZm9ybWF0IH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgcm9vbeKAmXMgU3RvcmFnZS4gVGhlIHJvb20gbXVzdCBhbHJlYWR5IGV4aXN0IGFuZCBoYXZlIGFuIGVtcHR5IFN0b3JhZ2UuXG4gICAqIENhbGxpbmcgdGhpcyBlbmRwb2ludCB3aWxsIGRpc2Nvbm5lY3QgYWxsIHVzZXJzIGZyb20gdGhlIHJvb20gaWYgdGhlcmUgYXJlIGFueS5cbiAgICpcbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gaW5pdGlhbGl6ZSB0aGUgc3RvcmFnZSBmcm9tLlxuICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIGluaXRpYWxpemUgdGhlIHN0b3JhZ2Ugd2l0aC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIGluaXRpYWxpemVkIHN0b3JhZ2UgZG9jdW1lbnQuIEl0IGlzIG9mIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgb25lIHBhc3NlZCBpbi5cbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemVTdG9yYWdlRG9jdW1lbnQocm9vbUlkLCBkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vc3RvcmFnZWAsXG4gICAgICBkb2N1bWVudCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgb2YgdGhlIHJvb23igJlzIFN0b3JhZ2UgZGF0YSBhbmQgZGlzY29ubmVjdCBhbGwgdXNlcnMgZnJvbSB0aGUgcm9vbSBpZiB0aGVyZSBhcmUgYW55LiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBkZWxldGUgdGhlIFlqcyBkb2N1bWVudCBpbiB0aGUgcm9vbSBpZiBvbmUgZXhpc3RzLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBkZWxldGUgdGhlIHN0b3JhZ2UgZnJvbS5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZVN0b3JhZ2VEb2N1bWVudChyb29tSWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNkZWxldGUodXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3N0b3JhZ2VgLCBvcHRpb25zKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBZanNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKipcbiAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHJvb23igJlzIFlqcyBkb2N1bWVudC5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gZ2V0IHRoZSBZanMgZG9jdW1lbnQgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5mb3JtYXQgKG9wdGlvbmFsKSBJZiB0cnVlLCBZVGV4dCB3aWxsIHJldHVybiBmb3JtYXR0aW5nLlxuICAgKiBAcGFyYW0gcGFyYW1zLmtleSAob3B0aW9uYWwpIElmIHByb3ZpZGVkLCByZXR1cm5zIG9ubHkgYSBzaW5nbGUga2V54oCZcyB2YWx1ZSwgZS5nLiBkb2MuZ2V0KGtleSkudG9KU09OKCkuXG4gICAqIEBwYXJhbSBwYXJhbXMudHlwZSAob3B0aW9uYWwpIFVzZWQgd2l0aCBrZXkgdG8gb3ZlcnJpZGUgdGhlIGluZmVycmVkIHR5cGUsIGkuZS4gXCJ5bWFwXCIgd2lsbCByZXR1cm4gZG9jLmdldChrZXksIFkuTWFwKS5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByb29t4oCZcyBZanMgZG9jdW1lbnQuXG4gICAqL1xuICBhc3luYyBnZXRZanNEb2N1bWVudChyb29tSWQsIHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBmb3JtYXQsIGtleSwgdHlwZSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHBhdGggPSB1cmwyYHYyL3Jvb21zLyR7cm9vbUlkfS95ZG9jYDtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQoXG4gICAgICBwYXRoLFxuICAgICAgeyBmb3JtYXR0aW5nOiBmb3JtYXQgPyBcInRydWVcIiA6IHZvaWQgMCwga2V5LCB0eXBlIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYSBZanMgYmluYXJ5IHVwZGF0ZSB0byB0aGUgcm9vbeKAmXMgWWpzIGRvY3VtZW50LiBZb3UgY2FuIHVzZSB0aGlzIGVuZHBvaW50IHRvIGluaXRpYWxpemUgWWpzIGRhdGEgZm9yIHRoZSByb29tIG9yIHRvIHVwZGF0ZSB0aGUgcm9vbeKAmXMgWWpzIGRvY3VtZW50LlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBzZW5kIHRoZSBZanMgYmluYXJ5IHVwZGF0ZSB0by5cbiAgICogQHBhcmFtIHVwZGF0ZSBUaGUgWWpzIHVwZGF0ZSB0byBzZW5kLiBUeXBpY2FsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBZanMuZW5jb2RlU3RhdGVBc1VwZGF0ZShkb2MpYC4gUmVhZCB0aGUgW1lqcyBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MueWpzLmRldi9hcGkvZG9jdW1lbnQtdXBkYXRlcykgdG8gbGVhcm4gaG93IHRvIGNyZWF0ZSBhIGJpbmFyeSB1cGRhdGUuXG4gICAqIEBwYXJhbSBwYXJhbXMuZ3VpZCAob3B0aW9uYWwpIElmIHByb3ZpZGVkLCB0aGUgYmluYXJ5IHVwZGF0ZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIFlqcyBzdWJkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBndWlkLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBiaW5hcnkgdXBkYXRlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcm9vdCBZanMgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyBzZW5kWWpzQmluYXJ5VXBkYXRlKHJvb21JZCwgdXBkYXRlLCBwYXJhbXMgPSB7fSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3B1dEJpbmFyeShcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS95ZG9jYCxcbiAgICAgIHVwZGF0ZSxcbiAgICAgIHsgZ3VpZDogcGFyYW1zLmd1aWQgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm9vbeKAmXMgWWpzIGRvY3VtZW50IGVuY29kZWQgYXMgYSBzaW5nbGUgYmluYXJ5IHVwZGF0ZS4gVGhpcyBjYW4gYmUgdXNlZCBieSBZLmFwcGx5VXBkYXRlKHJlc3BvbnNlQm9keSkgdG8gZ2V0IGEgY29weSBvZiB0aGUgZG9jdW1lbnQgaW4geW91ciBiYWNrZW5kLlxuICAgKiBTZWUgW1lqcyBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MueWpzLmRldi9hcGkvZG9jdW1lbnQtdXBkYXRlcykgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gd29ya2luZyB3aXRoIHVwZGF0ZXMuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGdldCB0aGUgWWpzIGRvY3VtZW50IGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMuZ3VpZCAob3B0aW9uYWwpIElmIHByb3ZpZGVkLCByZXR1cm5zIHRoZSBiaW5hcnkgdXBkYXRlIG9mIHRoZSBZanMgc3ViZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gZ3VpZC4gSWYgbm90IHByb3ZpZGVkLCByZXR1cm5zIHRoZSBiaW5hcnkgdXBkYXRlIG9mIHRoZSByb290IFlqcyBkb2N1bWVudC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJvb23igJlzIFlqcyBkb2N1bWVudCBlbmNvZGVkIGFzIGEgc2luZ2xlIGJpbmFyeSB1cGRhdGUuXG4gICAqL1xuICBhc3luYyBnZXRZanNEb2N1bWVudEFzQmluYXJ5VXBkYXRlKHJvb21JZCwgcGFyYW1zID0ge30sIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0veWRvYy1iaW5hcnlgLFxuICAgICAgeyBndWlkOiBwYXJhbXMuZ3VpZCB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXMuYXJyYXlCdWZmZXIoKTtcbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFNjaGVtYSBWYWxpZGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc2NoZW1hIHdoaWNoIGNhbiBiZSByZWZlcmVuY2VkIGxhdGVyIHRvIGVuZm9yY2UgYSByb29t4oCZcyBTdG9yYWdlIGRhdGEgc3RydWN0dXJlLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGUgc2NoZW1hLiBNdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyB3aXRoIGxlc3MgdGhhbiA2NSBjaGFyYWN0ZXJzIGFuZCBvbmx5IGNvbnRhaW4gbG93ZXJjYXNlIGxldHRlcnMsIG51bWJlcnMgYW5kIGRhc2hlc1xuICAgKiBAcGFyYW0gYm9keSBUaGUgZXhhY3QgYWxsb3dlZCBzaGFwZSBvZiBkYXRhIGluIHRoZSByb29tLiBJdCBpcyBhIG11bHRpLWxpbmUgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIFtMaXZlYmxvY2tzIHNjaGVtYSBzeW50YXhdKGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL3NjaGVtYS12YWxpZGF0aW9uL3N5bnRheCkuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHNjaGVtYS5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNjaGVtYShuYW1lLCBib2R5LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdCh1cmwyYC92Mi9zY2hlbWFzYCwgeyBuYW1lLCBib2R5IH0sIG9wdGlvbnMpO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoZGF0YS51cGRhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgdXBkYXRlZEF0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNjaGVtYSBieSBpdHMgaWQuXG4gICAqIEBwYXJhbSBzY2hlbWFJZCBJZCBvZiB0aGUgc2NoZW1hIC0gdGhpcyBpcyB0aGUgY29tYmluYXRpb24gb2YgdGhlIHNjaGVtYSBuYW1lIGFuZCB2ZXJzaW9uIG9mIHRoZSBzY2hlbWEgdG8gdXBkYXRlLiBGb3IgZXhhbXBsZSwgYG15LXNjaGVtYUAxYC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHNjaGVtYSB3aXRoIHRoZSBnaXZlbiBpZC5cbiAgICovXG4gIGFzeW5jIGdldFNjaGVtYShzY2hlbWFJZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2dldChcbiAgICAgIHVybDJgL3YyL3NjaGVtYXMvJHtzY2hlbWFJZH1gLFxuICAgICAgdm9pZCAwLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICB1cGRhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBib2R5IGZvciB0aGUgc2NoZW1hLiBBIHNjaGVtYSBjYW4gb25seSBiZSB1cGRhdGVkIGlmIGl0IGlzIG5vdCB1c2VkIGJ5IGFueSByb29tLlxuICAgKiBAcGFyYW0gc2NoZW1hSWQgSWQgb2YgdGhlIHNjaGVtYSAtIHRoaXMgaXMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBzY2hlbWEgbmFtZSBhbmQgdmVyc2lvbiBvZiB0aGUgc2NoZW1hIHRvIHVwZGF0ZS4gRm9yIGV4YW1wbGUsIGBteS1zY2hlbWFAMWAuXG4gICAqIEBwYXJhbSBib2R5IFRoZSBleGFjdCBhbGxvd2VkIHNoYXBlIG9mIGRhdGEgaW4gdGhlIHJvb20uIEl0IGlzIGEgbXVsdGktbGluZSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgW0xpdmVibG9ja3Mgc2NoZW1hIHN5bnRheF0oaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvcGxhdGZvcm0vc2NoZW1hLXZhbGlkYXRpb24vc3ludGF4KS5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgc2NoZW1hLiBUaGUgdmVyc2lvbiBvZiB0aGUgc2NoZW1hIHdpbGwgYmUgaW5jcmVtZW50ZWQuXG4gICAqL1xuICBhc3luYyB1cGRhdGVTY2hlbWEoc2NoZW1hSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNwdXQoXG4gICAgICB1cmwyYC92Mi9zY2hlbWFzLyR7c2NoZW1hSWR9YCxcbiAgICAgIHsgYm9keSB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICB1cGRhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgc2NoZW1hIGJ5IGl0cyBpZC4gQSBzY2hlbWEgY2FuIG9ubHkgYmUgZGVsZXRlZCBpZiBpdCBpcyBub3QgdXNlZCBieSBhbnkgcm9vbS5cbiAgICogQHBhcmFtIHNjaGVtYUlkIElkIG9mIHRoZSBzY2hlbWEgLSB0aGlzIGlzIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgc2NoZW1hIG5hbWUgYW5kIHZlcnNpb24gb2YgdGhlIHNjaGVtYSB0byB1cGRhdGUuIEZvciBleGFtcGxlLCBgbXktc2NoZW1hQDFgLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlU2NoZW1hKHNjaGVtYUlkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZGVsZXRlKHVybDJgL3YyL3NjaGVtYXMvJHtzY2hlbWFJZH1gLCBvcHRpb25zKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjaGVtYSBhdHRhY2hlZCB0byBhIHJvb20uXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGdldCB0aGUgc2NoZW1hIGZyb20uXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRTY2hlbWFCeVJvb21JZChyb29tSWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vc2NoZW1hYCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoZGF0YS51cGRhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgdXBkYXRlZEF0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoZXMgYSBzY2hlbWEgdG8gYSByb29tLCBhbmQgaW5zdGFudGx5IGVuYWJsZXMgcnVudGltZSBzY2hlbWEgdmFsaWRhdGlvbiBmb3IgdGhlIHJvb20uXG4gICAqIElmIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoZSByb29t4oCZcyBTdG9yYWdlIGRvIG5vdCBtYXRjaCB0aGUgc2NoZW1hLCBhdHRhY2hpbmcgd2lsbCBmYWlsIGFuZCB0aGUgZXJyb3IgbWVzc2FnZSB3aWxsIGdpdmUgZGV0YWlscyBvbiB3aHkgdGhlIHNjaGVtYSBmYWlsZWQgdG8gYXR0YWNoLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBhdHRhY2ggdGhlIHNjaGVtYSB0by5cbiAgICogQHBhcmFtIHNjaGVtYUlkIElkIG9mIHRoZSBzY2hlbWEgLSB0aGlzIGlzIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgc2NoZW1hIG5hbWUgYW5kIHZlcnNpb24gb2YgdGhlIHNjaGVtYSB0byB1cGRhdGUuIEZvciBleGFtcGxlLCBgbXktc2NoZW1hQDFgLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgc2NoZW1hIGlkIGFzIEpTT04uXG4gICAqL1xuICBhc3luYyBhdHRhY2hTY2hlbWFUb1Jvb20ocm9vbUlkLCBzY2hlbWFJZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vc2NoZW1hYCxcbiAgICAgIHsgc2NoZW1hOiBzY2hlbWFJZCB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRhY2hlcyBhIHNjaGVtYSBmcm9tIGEgcm9vbSwgYW5kIGRpc2FibGVzIHJ1bnRpbWUgc2NoZW1hIHZhbGlkYXRpb24gZm9yIHRoZSByb29tLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBkZXRhY2ggdGhlIHNjaGVtYSBmcm9tLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZGV0YWNoU2NoZW1hRnJvbVJvb20ocm9vbUlkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZGVsZXRlKHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS9zY2hlbWFgLCBvcHRpb25zKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb21tZW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC8qKlxuICAgKiBHZXRzIGFsbCB0aGUgdGhyZWFkcyBpbiBhIHJvb20uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGdldCB0aGUgdGhyZWFkcyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnF1ZXJ5IFRoZSBxdWVyeSB0byBmaWx0ZXIgdGhyZWFkcyBieS4gSXQgaXMgYmFzZWQgb24gb3VyIHF1ZXJ5IGxhbmd1YWdlIGFuZCBjYW4gZmlsdGVyIGJ5IG1ldGFkYXRhLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBIGxpc3Qgb2YgdGhyZWFkcy5cbiAgICovXG4gIGFzeW5jIGdldFRocmVhZHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByb29tSWQgfSA9IHBhcmFtcztcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMucXVlcnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHF1ZXJ5ID0gcGFyYW1zLnF1ZXJ5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcXVlcnkgPSBvYmplY3RUb1F1ZXJ5KHBhcmFtcy5xdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2dldChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzYCxcbiAgICAgIHsgcXVlcnkgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGRhdGEubWFwKCh0aHJlYWQpID0+IGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgdGhyZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBnZXQgdGhlIHRocmVhZCBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIEEgdGhyZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0VGhyZWFkKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2dldChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9YCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIHRocmVhZCdzIHBhcnRpY2lwYW50cy5cbiAgICpcbiAgICogUGFydGljaXBhbnRzIGFyZSB1c2VycyB3aG8gaGF2ZSBjb21tZW50ZWQgb24gdGhlIHRocmVhZFxuICAgKiBvciB1c2VycyBhbmQgZ3JvdXBzIHRoYXQgaGF2ZSBiZWVuIG1lbnRpb25lZCBpbiBhIGNvbW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGdldCB0aGUgdGhyZWFkIHBhcnRpY2lwYW50cyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gZ2V0IHRoZSBwYXJ0aWNpcGFudHMgZnJvbS5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgcGFydGljaXBhbnQgSURzLlxuICAgKi9cbiAgYXN5bmMgZ2V0VGhyZWFkUGFydGljaXBhbnRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2dldChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L3BhcnRpY2lwYW50c2AsXG4gICAgICB2b2lkIDAsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSB0aHJlYWQncyBjb21tZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBnZXQgdGhlIGNvbW1lbnQgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGdldCB0aGUgY29tbWVudCBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmNvbW1lbnRJZCBUaGUgY29tbWVudCBJRC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQSBjb21tZW50LlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29tbWVudChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2dldChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfWAsXG4gICAgICB2b2lkIDAsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGF3YWl0IHJlcy5qc29uKCkpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gY3JlYXRlIHRoZSBjb21tZW50IGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gY3JlYXRlIHRoZSBjb21tZW50IGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXNlcklkIFRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIHdobyBpcyBzZXQgdG8gY3JlYXRlIHRoZSBjb21tZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuY3JlYXRlZEF0IChvcHRpb25hbCkgVGhlIGRhdGUgdGhlIGNvbW1lbnQgaXMgc2V0IHRvIGJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5ib2R5IFRoZSBib2R5IG9mIHRoZSBjb21tZW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBjb21tZW50LlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQ29tbWVudChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQsIGRhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNwb3N0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vY29tbWVudHNgLFxuICAgICAge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBjcmVhdGVkQXQ6IGRhdGEuY3JlYXRlZEF0Py50b0lTT1N0cmluZygpXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogRWRpdHMgYSBjb21tZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBlZGl0IHRoZSBjb21tZW50IGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gZWRpdCB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQgdG8gZWRpdC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLmJvZHkgVGhlIGJvZHkgb2YgdGhlIGNvbW1lbnQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5lZGl0ZWRBdCAob3B0aW9uYWwpIFRoZSBkYXRlIHRoZSBjb21tZW50IHdhcyBlZGl0ZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSBlZGl0ZWQgY29tbWVudC5cbiAgICovXG4gIGFzeW5jIGVkaXRDb21tZW50KHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfWAsXG4gICAgICB7IC4uLmRhdGEsIGVkaXRlZEF0OiBkYXRhLmVkaXRlZEF0Py50b0lTT1N0cmluZygpIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGF3YWl0IHJlcy5qc29uKCkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgY29tbWVudC4gRGVsZXRlcyBhIGNvbW1lbnQuIElmIHRoZXJlIGFyZSBubyByZW1haW5pbmcgY29tbWVudHMgaW4gdGhlIHRocmVhZCwgdGhlIHRocmVhZCBpcyBhbHNvIGRlbGV0ZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGRlbGV0ZSB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGRlbGV0ZSB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQgdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlQ29tbWVudChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2RlbGV0ZShcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfWAsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdGhyZWFkLiBUaGUgdGhyZWFkIHdpbGwgYmUgY3JlYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgY29tbWVudCBhcyBpdHMgZmlyc3QgY29tbWVudC5cbiAgICogSWYgdGhlIHRocmVhZCBhbHJlYWR5IGV4aXN0cywgYSBgTGl2ZWJsb2Nrc0Vycm9yYCB3aWxsIGJlIHRocm93biB3aXRoIHN0YXR1cyBjb2RlIDQwOS5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gY3JlYXRlIHRoZSB0aHJlYWQgaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkLm1ldGFkYXRhIChvcHRpb25hbCkgVGhlIG1ldGFkYXRhIGZvciB0aGUgdGhyZWFkLiBTdXBwb3J0cyB1cHRvIGEgbWF4aW11bSBvZiAxMCBlbnRyaWVzLiBWYWx1ZSBtdXN0IGJlIGEgc3RyaW5nLCBib29sZWFuIG9yIG51bWJlclxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZC5jb21tZW50LnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gY3JlYXRlZCB0aGUgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWQuY29tbWVudC5jcmVhdGVkQXQgKG9wdGlvbmFsKSBUaGUgZGF0ZSB0aGUgY29tbWVudCB3YXMgY3JlYXRlZC5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWQuY29tbWVudC5ib2R5IFRoZSBib2R5IG9mIHRoZSBjb21tZW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB0aHJlYWQuIFRoZSB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBjb21tZW50IGFzIGl0cyBmaXJzdCBjb21tZW50LlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVGhyZWFkKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzYCxcbiAgICAgIHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgY29tbWVudDoge1xuICAgICAgICAgIC4uLmRhdGEuY29tbWVudCxcbiAgICAgICAgICBjcmVhdGVkQXQ6IGRhdGEuY29tbWVudC5jcmVhdGVkQXQ/LnRvSVNPU3RyaW5nKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIHRocmVhZCBhbmQgYWxsIG9mIGl0cyBjb21tZW50cy5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZGVsZXRlIHRoZSB0aHJlYWQgaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byBkZWxldGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyBkZWxldGVUaHJlYWQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZGVsZXRlKFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH1gLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNYXJrIGEgdGhyZWFkIGFzIHJlc29sdmVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gbWFyayBhcyByZXNvbHZlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gbWFya2VkIHRoZSB0aHJlYWQgYXMgcmVzb2x2ZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSB0aHJlYWQgbWFya2VkIGFzIHJlc29sdmVkLlxuICAgKi9cbiAgYXN5bmMgbWFya1RocmVhZEFzUmVzb2x2ZWQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L21hcmstYXMtcmVzb2x2ZWRgLFxuICAgICAge30sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmsgYSB0aHJlYWQgYXMgdW5yZXNvbHZlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgb2YgdGhlIHRocmVhZC5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIG1hcmsgYXMgdW5yZXNvbHZlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gbWFya2VkIHRoZSB0aHJlYWQgYXMgdW5yZXNvbHZlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHRocmVhZCBtYXJrZWQgYXMgdW5yZXNvbHZlZC5cbiAgICovXG4gIGFzeW5jIG1hcmtUaHJlYWRBc1VucmVzb2x2ZWQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L21hcmstYXMtdW5yZXNvbHZlZGAsXG4gICAgICB7fSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbWV0YWRhdGEgb2YgdGhlIHNwZWNpZmllZCB0aHJlYWQgaW4gYSByb29tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byB1cGRhdGUgdGhlIHRocmVhZCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLm1ldGFkYXRhIFRoZSBtZXRhZGF0YSBmb3IgdGhlIHRocmVhZC4gVmFsdWUgbXVzdCBiZSBhIHN0cmluZywgYm9vbGVhbiBvciBudW1iZXJcbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gdXBkYXRlZCB0aGUgdGhyZWFkLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXBkYXRlZEF0IChvcHRpb25hbCkgVGhlIGRhdGUgdGhlIHRocmVhZCBpcyBzZXQgdG8gYmUgdXBkYXRlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgdGhyZWFkIG1ldGFkYXRhLlxuICAgKi9cbiAgYXN5bmMgZWRpdFRocmVhZE1ldGFkYXRhKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9tZXRhZGF0YWAsXG4gICAgICB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIHVwZGF0ZWRBdDogZGF0YS51cGRhdGVkQXQ/LnRvSVNPU3RyaW5nKClcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgY29tbWVudCByZWFjdGlvbiB0byBhIGNvbW1lbnQuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGFkZCB0aGUgY29tbWVudCByZWFjdGlvbiBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGFkZCB0aGUgY29tbWVudCByZWFjdGlvbiBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQgdG8gYWRkIHRoZSByZWFjdGlvbiBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLmVtb2ppIFRoZSAoZW1vamkpIHJlYWN0aW9uIHRvIGFkZC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciBhc3NvY2lhdGVkIHdpdGggdGhlIHJlYWN0aW9uLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuY3JlYXRlZEF0IChvcHRpb25hbCkgVGhlIGRhdGUgdGhlIHJlYWN0aW9uIGlzIHNldCB0byBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBjb21tZW50IHJlYWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgYWRkQ29tbWVudFJlYWN0aW9uKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfS9hZGQtcmVhY3Rpb25gLFxuICAgICAge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBjcmVhdGVkQXQ6IGRhdGEuY3JlYXRlZEF0Py50b0lTT1N0cmluZygpXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWN0aW9uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbihyZWFjdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSByZWFjdGlvbiBmcm9tIGEgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gcmVtb3ZlIHRoZSBjb21tZW50IHJlYWN0aW9uIGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byByZW1vdmUgdGhlIGNvbW1lbnQgcmVhY3Rpb24gZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQgdG8gcmVtb3ZlIHRoZSByZWFjdGlvbiBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuZW1vamkgVGhlIChlbW9qaSkgcmVhY3Rpb24gdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXNlcklkIFRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVhY3Rpb24uXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5yZW1vdmVkQXQgKG9wdGlvbmFsKSBUaGUgZGF0ZSB0aGUgcmVhY3Rpb24gaXMgc2V0IHRvIGJlIHJlbW92ZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyByZW1vdmVDb21tZW50UmVhY3Rpb24ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7cGFyYW1zLmNvbW1lbnRJZH0vcmVtb3ZlLXJlYWN0aW9uYCxcbiAgICAgIHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgcmVtb3ZlZEF0OiBkYXRhLnJlbW92ZWRBdD8udG9JU09TdHJpbmcoKVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5ib3ggbm90aWZpY2F0aW9ucyBmb3IgYSB1c2VyLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJJZCBUaGUgdXNlciBJRCB0byBnZXQgdGhlIGluYm94IG5vdGlmaWNhdGlvbnMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5pbmJveE5vdGlmaWNhdGlvbklkIFRoZSBJRCBvZiB0aGUgaW5ib3ggbm90aWZpY2F0aW9uIHRvIGdldC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGdldEluYm94Tm90aWZpY2F0aW9uKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdXNlcklkLCBpbmJveE5vdGlmaWNhdGlvbklkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZ2V0KFxuICAgICAgdXJsMmAvdjIvdXNlcnMvJHt1c2VySWR9L2luYm94LW5vdGlmaWNhdGlvbnMvJHtpbmJveE5vdGlmaWNhdGlvbklkfWAsXG4gICAgICB2b2lkIDAsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShcbiAgICAgIGF3YWl0IHJlcy5qc29uKClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmJveCBub3RpZmljYXRpb25zIGZvciBhIHVzZXIuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIFRoZSB1c2VyIElEIHRvIGdldCB0aGUgaW5ib3ggbm90aWZpY2F0aW9ucyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnF1ZXJ5IFRoZSBxdWVyeSB0byBmaWx0ZXIgaW5ib3ggbm90aWZpY2F0aW9ucyBieS4gSXQgaXMgYmFzZWQgb24gb3VyIHF1ZXJ5IGxhbmd1YWdlIGFuZCBjYW4gZmlsdGVyIGJ5IHVucmVhZC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGdldEluYm94Tm90aWZpY2F0aW9ucyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gcGFyYW1zO1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcXVlcnkgPSBwYXJhbXMucXVlcnk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zLnF1ZXJ5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBxdWVyeSA9IG9iamVjdFRvUXVlcnkocGFyYW1zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZ2V0KFxuICAgICAgdXJsMmAvdjIvdXNlcnMvJHt1c2VySWR9L2luYm94LW5vdGlmaWNhdGlvbnNgLFxuICAgICAgeyBxdWVyeSB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogZGF0YS5tYXAoY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVzZXIncyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgdG8gZ2V0IHRoZSByb29tIG5vdGlmaWNhdGlvbnMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZ2V0IHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmcm9tLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZ2V0Um9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdXNlcklkLCByb29tSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdXNlcnMvJHt1c2VySWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICB2b2lkIDAsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIncyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgdG8gdXBkYXRlIHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmb3IuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIHVwZGF0ZSB0aGUgcm9vbSBub3RpZmljYXRpb24gc2V0dGluZ3MgZm9yLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEgVGhlIG5ldyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmb3IgdGhlIHVzZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB1c2VySWQsIHJvb21JZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdXNlcnMvJHt1c2VySWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICBkYXRhLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIHVzZXIncyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgdG8gZGVsZXRlIHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBkZWxldGUgdGhlIHJvb20gbm90aWZpY2F0aW9uIHNldHRpbmdzIGZyb20uXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyBkZWxldGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB1c2VySWQsIHJvb21JZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2RlbGV0ZShcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS91c2Vycy8ke3VzZXJJZH0vbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIGEgcm9vbSBJRC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIGN1cnJlbnQgSUQgb2YgdGhlIHJvb20uXG4gICAqIEBwYXJhbSBwYXJhbXMubmV3Um9vbUlkIFRoZSBuZXcgcm9vbSBJRC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVJvb21JZChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRSb29tSWQsIG5ld1Jvb21JZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke2N1cnJlbnRSb29tSWR9L3VwZGF0ZS1yb29tLWlkYCxcbiAgICAgIHsgbmV3Um9vbUlkIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KSxcbiAgICAgIGxhc3RDb25uZWN0aW9uQXQ6IGRhdGEubGFzdENvbm5lY3Rpb25BdCA/IG5ldyBEYXRlKGRhdGEubGFzdENvbm5lY3Rpb25BdCkgOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGFzeW5jIHRyaWdnZXJJbmJveE5vdGlmaWNhdGlvbihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNwb3N0KFxuICAgICAgdXJsMmAvdjIvaW5ib3gtbm90aWZpY2F0aW9ucy90cmlnZ2VyYCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbiBpbmJveCBub3RpZmljYXRpb24gZm9yIGEgdXNlci5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgZm9yIHdoaWNoIHRvIGRlbGV0ZSB0aGUgaW5ib3ggbm90aWZpY2F0aW9uLlxuICAgKiBAcGFyYW0gcGFyYW1zLmluYm94Tm90aWZpY2F0aW9uSWQgVGhlIElEIG9mIHRoZSBpbmJveCBub3RpZmljYXRpb24gdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlSW5ib3hOb3RpZmljYXRpb24ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB1c2VySWQsIGluYm94Tm90aWZpY2F0aW9uSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNkZWxldGUoXG4gICAgICB1cmwyYC92Mi91c2Vycy8ke3VzZXJJZH0vaW5ib3gtbm90aWZpY2F0aW9ucy8ke2luYm94Tm90aWZpY2F0aW9uSWR9YCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgaW5ib3ggbm90aWZpY2F0aW9ucyBmb3IgYSB1c2VyLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJJZCBUaGUgdXNlciBJRCBmb3Igd2hpY2ggdG8gZGVsZXRlIGFsbCB0aGUgaW5ib3ggbm90aWZpY2F0aW9ucy5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2RlbGV0ZShcbiAgICAgIHVybDJgL3YyL3VzZXJzLyR7dXNlcklkfS9pbmJveC1ub3RpZmljYXRpb25zYCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmb3IgYSB1c2VyIGZvciBhIHByb2plY3QuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIFRoZSB1c2VyIElEIHRvIGdldCB0aGUgbm90aWZpY2F0aW9ucyBzZXR0aW5ncyBmb3IuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyBnZXROb3RpZmljYXRpb25TZXR0aW5ncyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2dldChcbiAgICAgIHVybDJgL3YyL3VzZXJzLyR7dXNlcklkfS9ub3RpZmljYXRpb24tc2V0dGluZ3NgLFxuICAgICAgdm9pZCAwLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHVzZXIncyBub3RpZmljYXRpb24gc2V0dGluZ3MuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIFRoZSB1c2VyIElEIHRvIHVwZGF0ZSB0aGUgbm90aWZpY2F0aW9uIHNldHRpbmdzIGZvci5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhIFRoZSBuZXcgbm90aWZpY2F0aW9uIHNldHRpbmdzIGZvciB0aGUgdXNlci5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdXNlcklkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3VzZXJzLyR7dXNlcklkfS9ub3RpZmljYXRpb24tc2V0dGluZ3NgLFxuICAgICAgZGF0YSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIHRoZSB1c2VyJ3Mgbm90aWZpY2F0aW9uIHNldHRpbmdzXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIFRoZSB1c2VyIElEIHRvIHVwZGF0ZSB0aGUgbm90aWZpY2F0aW9uIHNldHRpbmdzIGZvci5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZU5vdGlmaWNhdGlvblNldHRpbmdzKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdXNlcklkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZGVsZXRlKFxuICAgICAgdXJsMmAvdjIvdXNlcnMvJHt1c2VySWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgTGl2ZWJsb2Nrc0Vycm9yID0gY2xhc3MgX0xpdmVibG9ja3NFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgc3RhdHVzO1xuICBkZXRhaWxzO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkxpdmVibG9ja3NFcnJvclwiO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IG1zZyA9IGAke3RoaXMubmFtZX06ICR7dGhpcy5tZXNzYWdlfSAoc3RhdHVzICR7dGhpcy5zdGF0dXN9KWA7XG4gICAgaWYgKHRoaXMuZGV0YWlscykge1xuICAgICAgbXNnICs9IGBcbiR7dGhpcy5kZXRhaWxzfWA7XG4gICAgfVxuICAgIHJldHVybiBtc2c7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb20ocmVzKSB7XG4gICAgY29uc3QgRkFMTEJBQ0sgPSBcIkFuIGVycm9yIGhhcHBlbmVkIHdpdGhvdXQgYW4gZXJyb3IgbWVzc2FnZVwiO1xuICAgIGxldCB0ZXh0O1xuICAgIHRyeSB7XG4gICAgICB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRleHQgPSBGQUxMQkFDSztcbiAgICB9XG4gICAgY29uc3Qgb2JqID0gdHJ5UGFyc2VKc29uKHRleHQpID8/IHsgbWVzc2FnZTogdGV4dCB9O1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBvYmoubWVzc2FnZSB8fCBGQUxMQkFDSztcbiAgICBjb25zdCBkZXRhaWxzID0gW1xuICAgICAgb2JqLnN1Z2dlc3Rpb24gPyBgU3VnZ2VzdGlvbjogJHtTdHJpbmcob2JqLnN1Z2dlc3Rpb24pfWAgOiB2b2lkIDAsXG4gICAgICBvYmouZG9jcyA/IGBTZWUgYWxzbzogJHtTdHJpbmcob2JqLmRvY3MpfWAgOiB2b2lkIDBcbiAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXFxuXCIpIHx8IHZvaWQgMDtcbiAgICByZXR1cm4gbmV3IF9MaXZlYmxvY2tzRXJyb3IobWVzc2FnZSwgcmVzLnN0YXR1cywgZGV0YWlscyk7XG4gIH1cbn07XG5cbi8vIHNyYy93ZWJob29rcy50c1xuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gXCJAc3RhYmxlbGliL2Jhc2U2NFwiO1xuaW1wb3J0ICogYXMgc2hhMjU2IGZyb20gXCJmYXN0LXNoYTI1NlwiO1xudmFyIFdlYmhvb2tIYW5kbGVyID0gY2xhc3MgX1dlYmhvb2tIYW5kbGVyIHtcbiAgI3NlY3JldEJ1ZmZlcjtcbiAgc3RhdGljICNzZWNyZXRQcmVmaXggPSBcIndoc2VjX1wiO1xuICBjb25zdHJ1Y3RvcihzZWNyZXQpIHtcbiAgICBpZiAoIXNlY3JldCkgdGhyb3cgbmV3IEVycm9yKFwiU2VjcmV0IGlzIHJlcXVpcmVkXCIpO1xuICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSBcInN0cmluZ1wiKSB0aHJvdyBuZXcgRXJyb3IoXCJTZWNyZXQgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICBpZiAoc2VjcmV0LnN0YXJ0c1dpdGgoX1dlYmhvb2tIYW5kbGVyLiNzZWNyZXRQcmVmaXgpID09PSBmYWxzZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VjcmV0LCBtdXN0IHN0YXJ0IHdpdGggd2hzZWNfXCIpO1xuICAgIGNvbnN0IHNlY3JldEtleSA9IHNlY3JldC5zbGljZShfV2ViaG9va0hhbmRsZXIuI3NlY3JldFByZWZpeC5sZW5ndGgpO1xuICAgIHRoaXMuI3NlY3JldEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNlY3JldEtleSwgXCJiYXNlNjRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFZlcmlmaWVzIGEgd2ViaG9vayByZXF1ZXN0IGFuZCByZXR1cm5zIHRoZSBldmVudFxuICAgKi9cbiAgdmVyaWZ5UmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgY29uc3QgeyBoZWFkZXJzLCByYXdCb2R5IH0gPSByZXF1ZXN0O1xuICAgIGNvbnN0IHsgd2ViaG9va0lkLCB0aW1lc3RhbXAsIHJhd1NpZ25hdHVyZXMgfSA9IHRoaXMuI3ZlcmlmeUhlYWRlcnMoaGVhZGVycyk7XG4gICAgaWYgKHR5cGVvZiByYXdCb2R5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHJhd0JvZHkgZmllbGQsIG11c3QgYmUgYSBzdHJpbmcsIGdvdCBcIiR7dHlwZW9mIHJhd0JvZHl9XCIgaW5zdGVhZC4gSXQgaXMgbGlrZWx5IHRoYXQgeW91IG5lZWQgdG8gSlNPTi5zdHJpbmdpZnkgdGhlIGJvZHkgYmVmb3JlIHBhc3NpbmcgaXQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy4jdmVyaWZ5VGltZXN0YW1wKHRpbWVzdGFtcCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy4jc2lnbihgJHt3ZWJob29rSWR9LiR7dGltZXN0YW1wfS4ke3Jhd0JvZHl9YCk7XG4gICAgY29uc3QgZXhwZWN0ZWRTaWduYXR1cmVzID0gcmF3U2lnbmF0dXJlcy5zcGxpdChcIiBcIikubWFwKChyYXdTaWduYXR1cmUpID0+IHtcbiAgICAgIGNvbnN0IFssIHBhcnNlZFNpZ25hdHVyZV0gPSByYXdTaWduYXR1cmUuc3BsaXQoXCIsXCIpO1xuICAgICAgcmV0dXJuIHBhcnNlZFNpZ25hdHVyZTtcbiAgICB9KS5maWx0ZXIoaXNOb3RVbmRlZmluZWQpO1xuICAgIGlmIChleHBlY3RlZFNpZ25hdHVyZXMuaW5jbHVkZXMoc2lnbmF0dXJlKSA9PT0gZmFsc2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHNpZ25hdHVyZSwgZXhwZWN0ZWQgb25lIG9mICR7ZXhwZWN0ZWRTaWduYXR1cmVzLmpvaW4oXG4gICAgICAgICAgXCIsIFwiXG4gICAgICAgICl9LCBnb3QgJHtzaWduYXR1cmV9YFxuICAgICAgKTtcbiAgICBjb25zdCBldmVudCA9IEpTT04ucGFyc2UocmF3Qm9keSk7XG4gICAgdGhpcy4jdmVyaWZ5V2ViaG9va0V2ZW50VHlwZShldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgaGVhZGVycyBhbmQgcmV0dXJucyB0aGUgd2ViaG9va0lkLCB0aW1lc3RhbXAgYW5kIHJhd1NpZ25hdHVyZXNcbiAgICovXG4gICN2ZXJpZnlIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBjb25zdCB1c2luZ05hdGl2ZUhlYWRlcnMgPSB0eXBlb2YgSGVhZGVycyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycztcbiAgICBjb25zdCBub3JtYWxpemVkSGVhZGVycyA9IHVzaW5nTmF0aXZlSGVhZGVycyA/IE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzKSA6IGhlYWRlcnM7XG4gICAgY29uc3Qgc2FuaXRpemVkSGVhZGVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG5vcm1hbGl6ZWRIZWFkZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHNhbml0aXplZEhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gbm9ybWFsaXplZEhlYWRlcnNba2V5XTtcbiAgICB9KTtcbiAgICBjb25zdCB3ZWJob29rSWQgPSBzYW5pdGl6ZWRIZWFkZXJzW1wid2ViaG9vay1pZFwiXTtcbiAgICBpZiAodHlwZW9mIHdlYmhvb2tJZCAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2ViaG9vay1pZCBoZWFkZXJcIik7XG4gICAgY29uc3QgdGltZXN0YW1wID0gc2FuaXRpemVkSGVhZGVyc1tcIndlYmhvb2stdGltZXN0YW1wXCJdO1xuICAgIGlmICh0eXBlb2YgdGltZXN0YW1wICE9PSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3ZWJob29rLXRpbWVzdGFtcCBoZWFkZXJcIik7XG4gICAgY29uc3QgcmF3U2lnbmF0dXJlcyA9IHNhbml0aXplZEhlYWRlcnNbXCJ3ZWJob29rLXNpZ25hdHVyZVwiXTtcbiAgICBpZiAodHlwZW9mIHJhd1NpZ25hdHVyZXMgIT09IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdlYmhvb2stc2lnbmF0dXJlIGhlYWRlclwiKTtcbiAgICByZXR1cm4geyB3ZWJob29rSWQsIHRpbWVzdGFtcCwgcmF3U2lnbmF0dXJlcyB9O1xuICB9XG4gIC8qKlxuICAgKiBTaWducyB0aGUgY29udGVudCB3aXRoIHRoZSBzZWNyZXRcbiAgICogQHBhcmFtIGNvbnRlbnRcbiAgICogQHJldHVybnMgYHN0cmluZ2BcbiAgICovXG4gICNzaWduKGNvbnRlbnQpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgdG9TaWduID0gZW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG4gICAgcmV0dXJuIGJhc2U2NC5lbmNvZGUoc2hhMjU2LmhtYWModGhpcy4jc2VjcmV0QnVmZmVyLCB0b1NpZ24pKTtcbiAgfVxuICAvKipcbiAgICogVmVyaWZpZXMgdGhhdCB0aGUgdGltZXN0YW1wIGlzIG5vdCB0b28gb2xkIG9yIGluIHRoZSBmdXR1cmVcbiAgICovXG4gICN2ZXJpZnlUaW1lc3RhbXAodGltZXN0YW1wSGVhZGVyKSB7XG4gICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBwYXJzZUludCh0aW1lc3RhbXBIZWFkZXIsIDEwKTtcbiAgICBpZiAoaXNOYU4odGltZXN0YW1wKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0aW1lc3RhbXBcIik7XG4gICAgfVxuICAgIGlmICh0aW1lc3RhbXAgPCBub3cgLSBXRUJIT09LX1RPTEVSQU5DRV9JTl9TRUNPTkRTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaW1lc3RhbXAgdG9vIG9sZFwiKTtcbiAgICB9XG4gICAgaWYgKHRpbWVzdGFtcCA+IG5vdyArIFdFQkhPT0tfVE9MRVJBTkNFX0lOX1NFQ09ORFMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRpbWVzdGFtcCBpbiB0aGUgZnV0dXJlXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSBldmVudCBpcyBhIGtub3duIGV2ZW50IHR5cGVcbiAgICogb3IgdGhyb3dzIGFuZCBwcm9tcHRzIHRoZSB1c2VyIHRvIHVwZ3JhZGUgdG8gYSBoaWdoZXIgdmVyc2lvbiBvZiBAbGl2ZWJsb2Nrcy9ub2RlXG4gICAqL1xuICAjdmVyaWZ5V2ViaG9va0V2ZW50VHlwZShldmVudCkge1xuICAgIGlmIChldmVudCAmJiBldmVudC50eXBlICYmIFtcbiAgICAgIFwic3RvcmFnZVVwZGF0ZWRcIixcbiAgICAgIFwidXNlckVudGVyZWRcIixcbiAgICAgIFwidXNlckxlZnRcIixcbiAgICAgIFwicm9vbUNyZWF0ZWRcIixcbiAgICAgIFwicm9vbURlbGV0ZWRcIixcbiAgICAgIFwiY29tbWVudENyZWF0ZWRcIixcbiAgICAgIFwiY29tbWVudEVkaXRlZFwiLFxuICAgICAgXCJjb21tZW50RGVsZXRlZFwiLFxuICAgICAgXCJjb21tZW50UmVhY3Rpb25BZGRlZFwiLFxuICAgICAgXCJjb21tZW50UmVhY3Rpb25SZW1vdmVkXCIsXG4gICAgICBcInRocmVhZE1ldGFkYXRhVXBkYXRlZFwiLFxuICAgICAgXCJ0aHJlYWRDcmVhdGVkXCIsXG4gICAgICBcInRocmVhZERlbGV0ZWRcIixcbiAgICAgIFwieWRvY1VwZGF0ZWRcIixcbiAgICAgIFwibm90aWZpY2F0aW9uXCIsXG4gICAgICBcInRocmVhZE1hcmtlZEFzUmVzb2x2ZWRcIixcbiAgICAgIFwidGhyZWFkTWFya2VkQXNVbnJlc29sdmVkXCJcbiAgICBdLmluY2x1ZGVzKGV2ZW50LnR5cGUpKSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJub3RpZmljYXRpb25cIikge1xuICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBldmVudDtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi5kYXRhLmtpbmQgPT09IFwidGhyZWFkXCIgfHwgbm90aWZpY2F0aW9uLmRhdGEua2luZCA9PT0gXCJ0ZXh0TWVudGlvblwiIHx8IGlzQ3VzdG9tS2luZChub3RpZmljYXRpb24uZGF0YS5raW5kKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVW5rbm93biBub3RpZmljYXRpb24ga2luZDogJHtKU09OLnN0cmluZ2lmeShub3RpZmljYXRpb24uZGF0YS5raW5kKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlVua25vd24gZXZlbnQgdHlwZSwgcGxlYXNlIHVwZ3JhZGUgdG8gYSBoaWdoZXIgdmVyc2lvbiBvZiBAbGl2ZWJsb2Nrcy9ub2RlXCJcbiAgICApO1xuICB9XG59O1xudmFyIFdFQkhPT0tfVE9MRVJBTkNFX0lOX1NFQ09ORFMgPSA1ICogNjA7XG52YXIgaXNOb3RVbmRlZmluZWQgPSAodmFsdWUpID0+IHZhbHVlICE9PSB2b2lkIDA7XG52YXIgaXNDdXN0b21LaW5kID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuc3RhcnRzV2l0aChcIiRcIik7XG59O1xuZnVuY3Rpb24gaXNUaHJlYWROb3RpZmljYXRpb25FdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gXCJub3RpZmljYXRpb25cIiAmJiBldmVudC5kYXRhLmtpbmQgPT09IFwidGhyZWFkXCI7XG59XG5mdW5jdGlvbiBpc1RleHRNZW50aW9uTm90aWZpY2F0aW9uRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IFwibm90aWZpY2F0aW9uXCIgJiYgZXZlbnQuZGF0YS5raW5kID09PSBcInRleHRNZW50aW9uXCI7XG59XG5mdW5jdGlvbiBpc0N1c3RvbU5vdGlmaWNhdGlvbkV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSBcIm5vdGlmaWNhdGlvblwiICYmIGlzQ3VzdG9tS2luZChldmVudC5kYXRhLmtpbmQpO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7XG4gIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keSxcbiAgaXNOb3RpZmljYXRpb25DaGFubmVsRW5hYmxlZCxcbiAgc3RyaW5naWZ5Q29tbWVudEJvZHlcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG5leHBvcnQge1xuICBMaXZlYmxvY2tzLFxuICBMaXZlYmxvY2tzRXJyb3IsXG4gIFdlYmhvb2tIYW5kbGVyLFxuICBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHksXG4gIGlzQ3VzdG9tTm90aWZpY2F0aW9uRXZlbnQsXG4gIGlzTm90aWZpY2F0aW9uQ2hhbm5lbEVuYWJsZWQsXG4gIGlzVGV4dE1lbnRpb25Ob3RpZmljYXRpb25FdmVudCxcbiAgaXNUaHJlYWROb3RpZmljYXRpb25FdmVudCxcbiAgc3RyaW5naWZ5Q29tbWVudEJvZHlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@liveblocks/node/dist/index.js\n");

/***/ })

};
;